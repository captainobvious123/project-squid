squid_version = 4.69

AlertFrames = {}
BigAlertFrames = {}
soundplayed = {}

ewt_callbacks = {}
function AddEWTCallback(callback)
	table.insert(ewt_callbacks,callback)
end

local cfe
local sui
local sui_bold
local locale = GetLocale()

function round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end

function Squid_GUI_Update()

	local time = GetTime()

	--saved vars modified by gui
	SQUID.gui_coords = SQUID.gui_coords or {}
	SQUID.objects_to_draw = SQUID.objects_to_draw or {}
	SQUID.max_object_finder_dist = SQUID.max_object_finder_dist or 80
	SQUID.alert_after_reload = SQUID.alert_after_reload or {}

	if SQUID.alert_after_reload["segoeuib.ttf"] then
		C_Timer.After(3,function()
			Squid_Alert("Alerts font was updated.")
			Squid_Alert_Big("How do I look? ;)")
			SQUID.alert_after_reload["segoeuib.ttf"] = nil
		end)
	end

	local function same_file(table1,table2)
		if not table1 or not table2 then return false end
		if #table1 ~= #table2 then return false end
		for i=1,#table1 do
			if table1[i] ~= table2[i] then
				print(table1[i], table2[i])
				return false
			end
		end
		return true
	end

	-- cant do this any more ;(
	-- if not squid_media_updated then
	-- 	local dir = Squid_Directory() .. "/media/"
	-- 	if dir then
	-- 		--segoeuib (sui_bold)
	-- 		SendHTTPRequest("ewt://@395E9F176492D6F1B08EC37B37F6C89EB873EB94D90C78F87544ADD1FAB6F413F21160D1047A27166544F251063F0683DCC3CFF452433885E1D82E0DD76A045C",nil,
	-- 			function(x)
	-- 				if x then
	-- 					local current_file = ReadFile(dir .. "segoeuib.ttf", 0x1)
	-- 					if not same_file(current_file,x) then
	-- 						if WriteFile(dir .. "segoeuib.ttf",x) then
	-- 							SQUID.alert_after_reload["segoeuib.ttf"] = true
	-- 							ReloadUI()
	-- 						end
	-- 					end
	-- 				end
	-- 			end,
	-- 			nil,
	-- 			0x2
	-- 		)
	-- 	end
	-- 	squid_media_updated = true
	-- end

	-- if not squid_sounds_updated then
	-- 	local dir = Squid_Directory() .. "/media/"
	-- 	if dir then
	-- 		--sounds.zip
	-- 		SendHTTPRequest("https://www.projectsquid.com/wp-content/sounds.zip",nil,
	-- 			function(x)
	-- 				if x then
	-- 					local current_file = ReadFile(dir .. "sounds.zip", 0x1)
	-- 					if not same_file(current_file,x) then
	-- 						if WriteFile(dir .. "sounds.zip",x) then
	-- 							unzip_and_alert = true
	-- 						end
	-- 					end
	-- 				end
	-- 			end,
	-- 			nil,
	-- 			0x2
	-- 		)
	-- 	end
	-- 	squid_sounds_updated = true
	-- end

	if unzip_and_alert then
		local dir = Squid_Directory() .. "/media/"
		UnzipFile(dir .. "sounds.zip", dir)
		C_Timer.After(2,function() Squid_Alert("Sound Files Updated") end)
		unzip_and_alert = nil
	end

	if locale == "enUS" then
		sui = Squid_Directory() .. "/media/Segoe UI Light.ttf"
		cfe = Squid_Directory() .. "/media/Seguisym.ttf"
		-- cfe = "Fonts\\FRIZQT__.TTF"
	elseif locale == "zhCN" then
		sui = "Fonts\\ARHei.ttf"
		cfe = "Fonts\\ARHei.ttf"
	else
		sui = Squid_Directory() .. "/media/Segoe UI Light.ttf"
		cfe = Squid_Directory() .. "/media/Seguisym.ttf"
	end

	sui_bold = Squid_Directory() .. "/media/segoeuib.ttf"

	SquidFont = CreateFont("SquidFont")
	SquidFont:SetFont(cfe,12,'OUTLINE')

	SquidFontMedium = CreateFont("SquidFontMedium")
	SquidFontMedium:SetFont(cfe,22,'OUTLINE')

	local framerate = GetFramerate()

	--AlertFrames Anchor
	if not AlertFrames_Anchor then
		AlertFrames_Anchor = CreateFrame("Frame", nil, self, "BackdropTemplate")

		local backdrop = {
		bgFile = "Interface/Tooltips/UI-Tooltip-Background",
		tileSize = 256,
		edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
		tile = 1,
		edgeSize = 3,
		insets = {
			top = 0, --2
			right = 0, --2
			left = 0, --3
			bottom = 0, --3
		 	}
		}

		local f = AlertFrames_Anchor

		if SQUID.alerts_anchor_coords then
			local a1,a2,x,y = SQUID.alerts_anchor_coords.a1,SQUID.alerts_anchor_coords.a2,SQUID.alerts_anchor_coords.x,SQUID.alerts_anchor_coords.y
			f:SetPoint(a1,nil,a2,x,y)
		else
			f:SetPoint("CENTER",0,200)
		end

		f:SetHeight(12)
		f:SetWidth(150)
		f:SetBackdrop(backdrop)

		-- f.texture = f:CreateTexture(nil,"ARTWORK",nil)
		-- f.texture:SetTexture(GetSpellTexture(106898))
		-- f.texture:SetWidth(16)
		-- f.texture:SetHeight(16)
		-- f.texture:SetPoint("CENTER",f,"CENTER",-65,0)

		f.txt = f:CreateFontString(nil,"HIGH",nil)
		f.txt:SetFont(cfe,10,'OUTLINE')
		f.txt:SetText("Alerts Anchor")
		f.txt:SetPoint("CENTER",0,0)

		f:SetFrameStrata("HIGH")
		f:SetMovable(true)
		f:SetScript("OnMouseUp",function(self) self:StopMovingOrSizing() Squid_StopSpamming = false local a1,_,a2,x,y = self:GetPoint() SQUID.alerts_anchor_coords = {a1=a1,a2=a2,x=x,y=y} end)
		f:SetScript("OnMouseDown",function(self) self:StartMoving() Squid_StopSpamming = true end)
	end

	if not BigAlertFrames_Anchor then
		BigAlertFrames_Anchor = CreateFrame("Frame", nil, self, "BackdropTemplate")

		local backdrop = {
		bgFile = "Interface/Tooltips/UI-Tooltip-Background",
		tileSize = 256,
		edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
		tile = 1,
		edgeSize = 3,
		insets = {
			top = 0, --2
			right = 0, --2
			left = 0, --3
			bottom = 0, --3
		 	}
		}

		local f = BigAlertFrames_Anchor

		if SQUID.big_alerts_anchor_coords then
			local a1,a2,x,y = SQUID.big_alerts_anchor_coords.a1,SQUID.big_alerts_anchor_coords.a2,SQUID.big_alerts_anchor_coords.x,SQUID.big_alerts_anchor_coords.y
			f:SetPoint(a1,nil,a2,x,y)
		else
			f:SetPoint("CENTER",0,200)
		end

		f:SetHeight(12)
		f:SetWidth(150)
		f:SetBackdrop(backdrop)

		-- f.texture = f:CreateTexture(nil,"ARTWORK",nil)
		-- f.texture:SetTexture(GetSpellTexture(106898))
		-- f.texture:SetWidth(16)
		-- f.texture:SetHeight(16)
		-- f.texture:SetPoint("CENTER",f,"CENTER",-65,0)

		f.txt = f:CreateFontString(nil,"HIGH",nil)
		f.txt:SetFont(cfe,10,'OUTLINE')
		f.txt:SetText("Big Alerts Anchor")
		f.txt:SetPoint("CENTER",0,0)

		f:SetFrameStrata("HIGH")
		f:SetMovable(true)
		f:SetScript("OnMouseUp",function(self) self:StopMovingOrSizing() Squid_StopSpamming = false local a1,_,a2,x,y = self:GetPoint() SQUID.big_alerts_anchor_coords = {a1=a1,a2=a2,x=x,y=y} end)
		f:SetScript("OnMouseDown",function(self) self:StartMoving() Squid_StopSpamming = true end)
	end

	if #AlertFrames > 0 then

		table.sort(AlertFrames, function(x,y) return x.Start > y.Start or (x.Start == y.Start and x.index < y.index) end)

		for i=1,#AlertFrames do
			if AlertFrames[i] then
				AlertFrames[i].index = i
			end
			--delete invisible frames
			if AlertFrames[i] and AlertFrames[i].Alpha < 0 then
				AlertFrames[i]:Hide()
				table.remove(AlertFrames,i)
			end
		end

		-- local anchor,_,anchor2,x,y = AlertFrames_Anchor:GetPoint()
		if not Squid_StopSpamming then
			for i=1,#AlertFrames do
				--move new frames
				if i > 1 then
					local dist = 20
					AlertFrames[i]:SetPoint("CENTER",AlertFrames_Anchor,"CENTER",0,i*dist)
				end

			end
		end

	end

	if #BigAlertFrames > 0 then

		table.sort(BigAlertFrames, function(x,y) return x.Start > y.Start or (x.Start == y.Start and x.index < y.index) end)

		for i=1,#BigAlertFrames do
			if BigAlertFrames[i] then
				BigAlertFrames[i].index = i
			end
			--delete invisible frames
			if BigAlertFrames[i] and BigAlertFrames[i].Alpha < 0 then
				BigAlertFrames[i]:Hide()
				table.remove(BigAlertFrames,i)
			end
		end

		-- local anchor,_,anchor2,x,y = BigAlertFrames_Anchor:GetPoint()
		for i=1,#BigAlertFrames do

			--move new frames
			if i > 1 then
				local dist = -25
				BigAlertFrames[i]:SetPoint("CENTER",BigAlertFrames_Anchor,"CENTER",0,i*dist)
			end

		end

		if #BigAlertFrames > 3 then
			for i=4,#BigAlertFrames do 
				BigAlertFrames[i]:SetAlpha(0)
			end 
		end

	end

	if IsHackEnabled and LibDraw and not libdraw_init then
		
		--hook libdraw funcs
		-- LubDraw by docbrown on fh-wow.com
		local LibDraw
		local sin, cos, atan, atan2, sqrt, rad = math.sin, math.cos, math.atan, math.atan2, math.sqrt, math.rad
		local tinsert, tremove = tinsert, tremove

		local wf_top = WorldFrame:GetTop()

		local function WorldToScreen (wX, wY, wZ)
			if not wX or not wY or not wZ then return 0, 0 end
		    local sX, sY = _G.WorldToScreen(wX, wY, wZ);
		    if sX and sY then
		        return sX, -(WorldFrame:GetTop() - sY);
		    else
		        return sX, sY;
		    end
		end

		-- if LibStub then
		--     -- LibStub version control
		--     LibDraw = LibStub:NewLibrary("LibDraw-1.0", 3)
		--     if not LibDraw then return end
		-- else
		    -- Pretty much LibStub
		    LibDraw = {
		        version = 69.0
		    }
		    _G['LibDraw'] = LibDraw
		-- end

		LibDraw.line = LibDraw.line or { r = 0, g = 1, b = 0, a = 1, w = 1 }
		LibDraw.level = "BACKGROUND"
		LibDraw.callbacks = { }

		if not LibDraw.canvas then
		    LibDraw.canvas = CreateFrame("Frame", WorldFrame)
		    LibDraw.canvas:SetAllPoints(WorldFrame)
		    LibDraw.lines = { }
		    LibDraw.lines_used = { }
		    LibDraw.textures = { }
		    LibDraw.textures_used = { }
		    LibDraw.fontstrings = { }
		    LibDraw.fontstrings_used = { }
		end

		function LibDraw.SetColor(r, g, b, a)
		    LibDraw.line.r = r * 0.00390625
		    LibDraw.line.g = g * 0.00390625
		    LibDraw.line.b = b * 0.00390625
		    if a then
		        LibDraw.line.a = a * 0.01
		    else
		        LibDraw.line.a = 1
		    end
		end

		function LibDraw.SetColorRaw(r, g, b, a)
		    LibDraw.line.r = r
		    LibDraw.line.g = g
		    LibDraw.line.b = b
		    LibDraw.line.a = a
		end

		SQUID.line_scale = SQUID.line_scale or 1
		function LibDraw.SetWidth(w)
		    LibDraw.line.w = w * SQUID.line_scale
		end

		function LibDraw.Line(sx, sy, sz, ex, ey, ez)
		    if not WorldToScreen then return end

		    local sx, sy = WorldToScreen(sx, sy, sz)
		    local ex, ey = WorldToScreen(ex, ey, ez)

		    LibDraw.Draw2DLine(sx, sy, ex, ey)
		end

		function LibDraw.LineFromGround(sx, sy, sz, ex, ey, ez)
		    if not WorldToScreen then return end

		    sx, sy, sz = GroundZ(sx, sy, sz)

		    local sx, sy = WorldToScreen(sx, sy, sz)
		    local ex, ey = WorldToScreen(ex, ey, ez)

		    LibDraw.Draw2DLine(sx, sy, ex, ey)
		end

		function LibDraw.rotateX(cx, cy, cz, px, py, pz, r)
		    if r == nil then return px, py, pz end
		    local s = sin(r)
		    local c = cos(r)
		    -- center of rotation
		    px, py, pz = px - cx,  py - cy, pz - cz
		    local x = px + cx
		    local y = ((py * c - pz * s) + cy)
		    local z = ((py * s + pz * c) + cz)
		    return x, y, z
		end

		function LibDraw.rotateY(cx, cy, cz, px, py, pz, r)
		    if r == nil then return px, py, pz end
		    local s = sin(r)
		    local c = cos(r)
		    -- center of rotation
		    px, py, pz = px - cx,  py - cy, pz - cz
		    local x = ((pz * s + px * c) + cx)
		    local y = py + cy
		    local z = ((pz * c - px * s) + cz)
		    return x, y, z
		end

		function LibDraw.rotateZ(cx, cy, cz, px, py, pz, r)
		    if r == nil then return px, py, pz end
		    local s = sin(r)
		    local c = cos(r)
		    -- center of rotation
		    px, py, pz = px - cx,  py - cy, pz - cz
		    local x = ((px * c - py * s) + cx)
		    local y = ((px * s + py * c) + cy)
		    local z = pz + cz
		    return x, y, z
		end

		function LibDraw.Array(vectors, x, y, z, rotationX, rotationY, rotationZ)
		    for _, vector in ipairs(vectors) do
		        local sx, sy, sz = x+vector[1], y+vector[2], z+vector[3]
		        local ex, ey, ez = x+vector[4], y+vector[5], z+vector[6]

		        if rotationX then
		            sx, sy, sz = LibDraw.rotateX(x, y, z, sx, sy, sz, rotationX)
		            ex, ey, ez = LibDraw.rotateX(x, y, z, ex, ey, ez, rotationX)
		        end
		        if rotationY then
		            sx, sy, sz = LibDraw.rotateY(x, y, z, sx, sy, sz, rotationY)
		            ex, ey, ez = LibDraw.rotateY(x, y, z, ex, ey, ez, rotationY)
		        end
		        if rotationZ then
		            sx, sy, sz = LibDraw.rotateZ(x, y, z, sx, sy, sz, rotationZ)
		            ex, ey, ez = LibDraw.rotateZ(x, y, z, ex, ey, ez, rotationZ)
		        end

		        local sx, sy = WorldToScreen(sx, sy, sz)
		        local ex, ey = WorldToScreen(ex, ey, ez)
		        LibDraw.Draw2DLine(sx, sy, ex, ey)
		    end
		end

		function LibDraw.Draw2DLine(sx, sy, ex, ey, thickness)

		    if not WorldToScreen or not sx or not sy or not ex or not ey then return end

		    local L = tremove(LibDraw.lines) or false
		    if L == false then
		        L = CreateFrame("Frame", LibDraw.canvas)
		    L.line = L:CreateLine()
		        L.line:SetDrawLayer(LibDraw.level)
		    end
		    tinsert(LibDraw.lines_used, L)

		  	L:ClearAllPoints()

			  if sx > ex and sy > ey or sx < ex and sy < ey then
			    L:SetPoint("TOPRIGHT", LibDraw.canvas, "TOPLEFT", sx, sy)
			    L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", ex, ey)
			    L.line:SetStartPoint('TOPRIGHT')
			    L.line:SetEndPoint('BOTTOMLEFT')
			  elseif sx < ex and sy > ey then
			    L:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
			    L:SetPoint("BOTTOMRIGHT", LibDraw.canvas, "TOPLEFT", ex, ey)
			    L.line:SetStartPoint('TOPLEFT')
			    L.line:SetEndPoint('BOTTOMRIGHT')
			  elseif sx > ex and sy < ey then
			    L:SetPoint("TOPRIGHT", LibDraw.canvas, "TOPLEFT", sx, sy)
			    L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", ex, ey)
			    L.line:SetStartPoint('TOPLEFT')
			    L.line:SetEndPoint('BOTTOMRIGHT')
			  else
			    -- wat, I don't like this, not one bit
			    L:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
			    L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", sx, ey)
			    L.line:SetStartPoint('TOPLEFT')
			    L.line:SetEndPoint('BOTTOMLEFT')
			  end

		  	L.line:SetThickness(thickness or LibDraw.line.w)
		    L.line:SetColorTexture(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

		    L:Show()

		end

		local full_circle = rad(365)
		local small_circle_step = rad(3)

		function LibDraw.Circle(x, y, z, size)
			local step = small_circle_step * 2
		    local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
		    for v=0, full_circle, step do
		        nx, ny = WorldToScreen( (x+cos(v)*size), (y+sin(v)*size), z )
		        LibDraw.Draw2DLine(lx, ly, nx, ny)
		        lx, ly = nx, ny
		    end
		end

		local flags = bit.bor(0x100)

		function LibDraw.GroundCircle(x, y, z, size)
			local step = small_circle_step * 3
			size = size / 2
		    local lx, ly, nx, ny, fx, fy, fz = false, false, false, false, false, false, false
		    for v=0, full_circle, step do
		        fx, fy, fz = TraceLine(  (x+cos(v)*size), (y+sin(v)*size), z+100, (x+cos(v)*size), (y+sin(v)*size), z-100, flags )
		        if fx == nil then
		            fx, fy, fz = (x+cos(v)*size), (y+sin(v)*size), z
		        end
		        nx, ny = WorldToScreen( (fx+cos(v)*size), (fy+sin(v)*size), fz )
		        LibDraw.Draw2DLine(lx, ly, nx, ny)
		        lx, ly = nx, ny
		    end
		end

		function LibDraw.DeSync(index)
		  tremove(LibDraw.callbacks, index)
		end

		-- local function GetScreenPositionBetweenWorldAndScreenPosition(sx, sy, sz, ex, ey, dist)
		-- 	local wex, wey, wez = ScreenToWorld(ex, ey, 0x100111)
		-- 	if not wex or not wey or not wez then return end
		-- 	local x, y, z = GetPositionBetweenPositions(sx, sy, sz, wex, wey, wez, dist)
		-- 	return WorldToScreen( x, y, z )
		-- end

		function LibDraw.Arc(x, y, z, size, arc, rotation)
			if not x or not y or not z then return false end
		    local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
		    local half_arc = arc * 0.5
		    local ss = (arc/half_arc)
		    local as, ae = -half_arc, half_arc
		    for v = as, ae, ss do
		        nx, ny = WorldToScreen( (x+cos(rotation+rad(v))*size), (y+sin(rotation+rad(v))*size), z )
		        if lx and ly then
		            LibDraw.Draw2DLine(lx, ly, nx, ny)
		        else
		            fx, fy = nx, ny
		        end
		        lx, ly = nx, ny
		    end
		    local px, py = WorldToScreen(x, y, z)
		    if px and py then
			    LibDraw.Draw2DLine(px, py, lx, ly)
			    LibDraw.Draw2DLine(px, py, fx, fy)
			else
				--figure out some way to draw the lines
			end
		end

		local function Arc(x, y, z, size, arc, rotation,noline)
		    local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
		    local half_arc = arc * 0.5
		    local ss = (arc/half_arc)
		    local as, ae = -half_arc, half_arc
		    for v = as, ae, ss do
		        nx, ny = WorldToScreen( (x+cos(rotation+rad(v))*size), (y+sin(rotation+rad(v))*size), z )
		        if lx and ly then
		            LibDraw.Draw2DLine(lx, ly, nx, ny)
		        else
		            fx, fy = nx, ny
		        end
		        lx, ly = nx, ny
		    end
		    if not noline then
			    local px, py = WorldToScreen(x, y, z)
			    LibDraw.Draw2DLine(px, py, lx, ly)
			    LibDraw.Draw2DLine(px, py, fx, fy)
			end
		end

		function LibDraw.Crescent(x, y, z, size, arc, rotation, ground)
			if ground then
				x, y, z = GroundZ( x, y, z )
			end
			if not x or not y or not z then return false end
		    local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
		    local half_arc = arc * 0.5
		    local ss = (arc/half_arc)
		    local as, ae = -half_arc, half_arc
		    for v = as, ae, ss do
		    	if x and y and z then
			        nx, ny = WorldToScreen( (x+cos(rotation+rad(v))*size), (y+sin(rotation+rad(v))*size), z )
			        if lx and ly then
			            LibDraw.Draw2DLine(lx, ly, nx, ny)
			        else
			            fx, fy = nx, ny
			        end
			        lx, ly = nx, ny
			    end
		    end
		    local half = (as+ae)/ss
		    local mid_x,mid_y,mid_z = (x+cos(rotation+rad(half))*size), (y+sin(rotation+rad(half))*size), z
		    return mid_x,mid_y,mid_z
		end

		function LibDraw.Texture(config, x, y, z, alphaA)

		    local texture, width, height = config.texture, config.width, config.height
		    local left, right, top, bottom, scale =  config.left, config.right, config.top, config.bottom, config.scale
		    local alpha = config.alpha or alphaA

		    if not WorldToScreen or not texture or not width or not height or not x or not y or not z then return end
		    if not left or not right or not top or not bottom then
		        left = 0
		        right = 1
		        top = 0
		        bottom = 1
		    end
		    if not scale then
		        local cx, cy, cz = GetCameraPosition()
		        scale = width / LibDraw.Distance(x, y, z, cx, cy, cz)
		    end

		    local sx, sy = WorldToScreen(x, y, z)
		    if not sx or not sy then return end
		    local w = width * scale
		    local h = height * scale
		    sx = sx - w*0.5
		    sy = sy + h*0.5
		    local ex, ey = sx + w, sy - h

		    local T = tremove(LibDraw.textures) or false
		    if T == false then
		        T = LibDraw.canvas:CreateTexture(nil, "BACKGROUND")
		        T:SetDrawLayer(LibDraw.level)
		        T:SetTexture(LibDraw.texture)
		    end
		    tinsert(LibDraw.textures_used, T)
		    T:ClearAllPoints()
		    T:SetTexCoord(left, right, top, bottom)
		    T:SetTexture(texture)
		    T:SetWidth(width)
		    T:SetHeight(height)
		    T:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
		    T:SetPoint("BOTTOMRIGHT", LibDraw.canvas, "TOPLEFT", ex, ey)
		    T:SetVertexColor(1, 1, 1, 1)
		    if alpha then T:SetAlpha(alpha) else T:SetAlpha(1) end
		    T:Show()

		end

		function LibDraw.Text(text, font, x, y, z)

		    local sx, sy = WorldToScreen(x, y, z)

		    if sx and sy then

		        local F = tremove(LibDraw.fontstrings) or LibDraw.canvas:CreateFontString(nil, "BACKGROUND")

		        F:SetFontObject(font)
		        F:SetText(text)
		        F:SetTextColor(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

		        if p then
		            local width = F:GetStringWidth() - 4
		            local offsetX = width*0.5
		            local offsetY = F:GetStringHeight() + 3.5
		            local pwidth = width*p*0.01
		            FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX), sy-offsetY, 4, r, g, b, 0.25)
		            FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX)-(width-pwidth), sy-offsetY, 4, r, g, b, 1)
		        end

		        F:SetPoint("TOPLEFT", UIParent, "TOPLEFT", sx-(F:GetStringWidth()*0.5), sy)
		        F:Show()

		        tinsert(LibDraw.fontstrings_used, F)

		    end

		end

		local rad90 = math.rad(-90)

		function LibDraw.Box(x, y, z, width, height, rotation, offset_x, offset_y)

		    if not offset_x then offset_x = 0 end
		    if not offset_y then offset_y = 0 end

		    if rotation then rotation = rotation + rad90 end

		    local half_width = width * 0.5
		    local half_height = height * 0.5

		    local p1x, p1y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y - half_width + offset_y, z, rotation)
		    local p2x, p2y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y - half_width + offset_y, z, rotation)
		    local p3x, p3y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y + half_width + offset_y, z, rotation)
		    local p4x, p4y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y - half_width + offset_y, z, rotation)
		    local p5x, p5y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y + half_width + offset_y, z, rotation)
		    local p6x, p6y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y - half_width + offset_y, z, rotation)
		    local p7x, p7y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y + half_width + offset_y, z, rotation)
		    local p8x, p8y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y + half_width + offset_y, z, rotation)

		    LibDraw.Line(p1x, p1y, z, p2x, p2y, z)
		    LibDraw.Line(p3x, p3y, z, p4x, p4y, z)
		    LibDraw.Line(p5x, p5y, z, p6x, p6y, z)
		    LibDraw.Line(p7x, p7y, z, p8x, p8y, z)

		end

		local deg45 = math.rad(45)
		local arrowX = {
		    { 0  , 0, 0, 1.5,  0,    0   },
		    { 1.5, 0, 0, 1.2,  0.2, -0.2 },
		    { 1.5, 0, 0, 1.2, -0.2,  0.2 }
		}
		local arrowY = {
		    { 0, 0  , 0,  0  , 1.5,  0   },
		    { 0, 1.5, 0,  0.2, 1.2, -0.2 },
		    { 0, 1.5, 0, -0.2, 1.2,  0.2 }
		}
		local arrowZ = {
		    { 0, 0, 0  ,  0,    0,   1.5 },
		    { 0, 0, 1.5,  0.2, -0.2, 1.2 },
		    { 0, 0, 1.5, -0.2,  0.2, 1.2 }
		}

		function LibDraw.DrawHelper()
		    local playerX, playerY, playerZ = ObjectPosition("player")
		    local old_red, old_green, old_blue, old_alpha, old_width = LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a, LibDraw.line.w

		    -- X
		    LibDraw.SetColor(255, 0, 0, 100)
		    LibDraw.SetWidth(1)
		    LibDraw.Array(arrowX, playerX, playerY, playerZ, deg45, false, false)
		    LibDraw.Text('X', "GameFontNormal", playerX + 1.75, playerY, playerZ)
		    -- Y
		    LibDraw.SetColor(0, 255, 0, 100)
		    LibDraw.SetWidth(1)
		    LibDraw.Array(arrowY, playerX, playerY, playerZ, false, -deg45, false)
		    LibDraw.Text('Y', "GameFontNormal", playerX, playerY + 1.75, playerZ)
		    -- Z
		    LibDraw.SetColor(0, 0, 255, 100)
		    LibDraw.SetWidth(1)
		    LibDraw.Array(arrowZ, playerX, playerY, playerZ, false, false, false)
		    LibDraw.Text('Z', "GameFontNormal", playerX, playerY, playerZ + 1.75)

		    LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a, LibDraw.line.w = old_red, old_green, old_blue, old_alpha, old_width
		end

		function LibDraw.Distance(ax, ay, az, bx, by, bz)
		    return math.sqrt(((bx-ax)*(bx-ax)) + ((by-ay)*(by-ay)) + ((bz-az)*(bz-az)))
		end

		function LibDraw.Camera()
		    local fX, fY, fZ = ObjectPosition("player")
		    local sX, sY, sZ = GetCameraPosition()
		    return sX, sY, sZ, atan2(sY - fY, sX - fX), atan((sZ - fZ) / sqrt(((fX - sX) ^ 2) + ((fY - sY) ^ 2)))
		end

		function LibDraw.Sync(callback)
		    tinsert(LibDraw.callbacks, callback)
		end

		function LibDraw.clearCanvas()
		    -- LibDraw.stats = #LibDraw.textures_used
		    for i = #LibDraw.textures_used, 1, -1 do
		        LibDraw.textures_used[i]:Hide()
		        tinsert(LibDraw.textures, tremove(LibDraw.textures_used))
		    end
		    for i = #LibDraw.fontstrings_used, 1, -1 do
		        LibDraw.fontstrings_used[i]:Hide()
		        tinsert(LibDraw.fontstrings, tremove(LibDraw.fontstrings_used))
		    end
		  for i = #LibDraw.lines_used, 1, -1 do
		        LibDraw.lines_used[i]:Hide()
		        tinsert(LibDraw.lines, tremove(LibDraw.lines_used))
		    end
		end

		local function OnUpdate()
		    LibDraw.clearCanvas()
		    for _, callback in ipairs(LibDraw.callbacks) do
		        callback()
		        if LibDraw.helper then
		            LibDraw.DrawHelper()
		        end
		        LibDraw.helper = false
		    end
		end

		function LibDraw.Enable(interval)
		    local timer
		    if not interval then
		        timer = C_Timer.NewTicker(interval, OnUpdate)
		    else
		        timer = C_Timer.NewTicker(interval, OnUpdate)
		    end
		    return timer
		end

		local function Line(sx, sy, sz, ex, ey, ez)
			local function WorldToScreen (wX, wY, wZ)
		        local sX, sY = _G.WorldToScreen(wX, wY, wZ);
		        if sX and sY then
		            return sX, -(WorldFrame:GetTop() - sY);
		        else
		            return sX, sY;
		        end
		    end
		    local startx, starty = WorldToScreen(sx, sy, sz)
		    local endx, endy = WorldToScreen(ex, ey, ez)
		    if (endx == nil or endy == nil) and startx then
		        local i = 1
		        while (endx == nil or endy == nil) and i < 300 do
		        	local zdif = ez - sz
		        	if zdif > 0 then ez = ez - zdif end
		            endx, endy = WorldToScreen(GetPositionBetweenPositions(ex, ey, ez, sx, sy, sz, i))
		            i = i + 1 
		        end
		    end
		    if (startx == nil or starty == nil) and endx then
		        local i = 1
		        while (startx == nil or starty == nil) and i < 300 do
		        	local zdif = sz - ez
		        	if zdif > 0 then sz = sz - zdif end
		            startx, starty = WorldToScreen(GetPositionBetweenPositions(sx, sy, sz, ex, ey, ez, i))
		            i = i + 1 
		        end
		    end
		    LibDraw.Draw2DLine(startx, starty, endx, endy)
		end

		function LibDraw.Cone(x, y, z, size)
			local lx, ly, nx, ny, fx, fy = false, false, false, false, false
			for h=0, size, size/8 do
				h = size - h
				for v=0, full_circle, small_circle_step*6 do
					nx, ny = WorldToScreen( (x+cos(v)*h), (y+sin(v)*h), z+h )
					LibDraw.Draw2DLine(lx, ly, nx, ny)
					lx, ly = nx, ny
				end
			end
		end

		function LibDraw.Sphere(x, y, z, size)
			local lx, ly, nx, ny, fx, fy = false, false, false, false, false
			local step = small_circle_step*6
			for h=0, size, size/8 do
				h = size - h
				for v=0, full_circle, step do
					nx, ny = WorldToScreen( (x+cos(v)*h), (y+sin(v)*h), z+h )
					LibDraw.Draw2DLine(lx, ly, nx, ny)
					lx, ly = nx, ny
				end
			end
			for h=0, size, size/8 do
				h = size - h
				for v=0, full_circle, step do
					nx, ny = WorldToScreen( (x+cos(v)*h), (y+sin(v)*h), z+size+h )
					LibDraw.Draw2DLine(lx, ly, nx, ny)
					lx, ly = nx, ny
				end
			end
		end

		LibDraw.Sync(function()

			local time = GetTime()
			local px,py,pz = GetPlayerPosition()
			local player_name = UnitName("player")

			-- LibDraw.DrawHelper()

			-- local arrowX = {
			--     { 0  , 0, 0, 1.5,  0,    0   },
			--     { 1.5, 0, 0, 1.2,  0.2, -0.2 },
			--     { 1.5, 0, 0, 1.2, -0.2,  0.2 }
			-- }
			-- local arrowY = {
			--     { 0, 0  , 0,  0  , 1.5,  0   },
			--     { 0, 1.5, 0,  0.2, 1.2, -0.2 },
			--     { 0, 1.5, 0, -0.2, 1.2,  0.2 }
			-- }
			-- local arrowZ = {
			--     { 0, 0, 0  ,  0,    0,   1.5 },
			--     { 0, 0, 1.5,  0.2, -0.2, 1.2 },
			--     { 0, 0, 1.5, -0.2,  0.2, 1.2 }
			-- }

			if target_arrow and UnitIsVisible("target") then
				local angle = GetAnglesBetweenObjects("target","player")
				local arrow_size = 0.25
				local arrow_shape = {
				  {-arrow_size, -arrow_size, 0, 0, 0, 0},
				  {arrow_size, -arrow_size, 0, 0, 0, 0},
				}
			    -- target arrow
			    LibDraw.SetColor(255, 0, 0, 100)
			    LibDraw.SetWidth(2)
			    LibDraw.Array(arrow_shape, px - 3 * math.cos(angle), py - 3 * math.sin(angle), pz, nil, nil, math.rad(90) + angle)
			end

			--green / red line around corners of screen? animation for toggles?
			-- green_line_test = true
			if SQUID.toggle_flash then
				if green_line_test and ( not red_line_test or time - red_line_test > time - green_line_test ) then
					
					local max_x,max_y = LibDraw.canvas:GetWidth(),LibDraw.canvas:GetHeight()
					max_y = max_y - wf_top

					local min_y = -wf_top - 3.34
					local min_x = 0

					local w = 10

					max_x = max_x - .1

					-- min_x = min_x + w
					-- from cursor to top right of screen
					-- local cx,cy = GetCursorPosition()
					-- if cy then 
					-- 	cy = cy - wf_top
					-- 	LibDraw.SetColorRaw(.12, 1, .4, 1)
					-- 	LibDraw.SetWidth(15)
					-- 	LibDraw.Draw2DLine(cx, cy, max_x, max_y)
					-- 	print(cx,cy,max_x,max_y)
					-- end

					-- LibDraw.SetColorRaw(.12, 1, .4, 1)
					-- LibDraw.SetWidth(15)
					-- LibDraw.Draw2DLine(91.372,-3.34,1427.6695605469,-3.34)

					local function reset_shit ()
						--starting pos
						top_line_squid = { min_x + (max_x / 5), max_y, max_x, max_y-.01, a = .1 }

						right_line_squid = { max_x, max_y, max_x-.01, max_y-.01, a = .1 }

						bottom_line_squid = { max_x - (max_x / 5), min_y, min_x, min_y+.01, a = .1 }

						left_line_squid = { min_x, min_y, min_x+.01, min_y+.01, a = .1 }
					end

					if not top_line_squid or red_line_test then
						reset_shit()
						red_line_test = nil
					end

					local fps = GetFramerate()

					local done_here

					-- if not line_thing_update or time - line_thing_update > .00001 then
						local line_step = ( max_x / ( fps * .85) )
						local sx, sy, ex, ey = top_line_squid[1], top_line_squid[2], top_line_squid[3], top_line_squid[4]
						local dx, dy = ex - sx, ey - sy
		            	local l = sqrt((dx * dx) + (dy * dy))
		            	
		          		local animation_completion = 0

		          		animation_completion = ( max_x - l ) / max_x

		            	-- print(l)
		            	if l > 1 then
		            		if l < max_x then
		            			top_line_squid[1] = top_line_squid[1] + line_step
		            			top_line_squid.a = top_line_squid.a + animation_completion
								local rsx, rsy, rex, rey = right_line_squid[1], right_line_squid[2], right_line_squid[3], right_line_squid[4]
								local rdx, rdy = rex - rsx, rey - rsy
								local rl = sqrt((rdx * rdx) + (rdy * rdy))
								if rsy > min_y then
									right_line_squid[2] = right_line_squid[2] - line_step
									right_line_squid.a = right_line_squid.a + animation_completion
								end
		            		end
		            	end

		            	local sx, sy, ex, ey = bottom_line_squid[1], bottom_line_squid[2], bottom_line_squid[3], bottom_line_squid[4]
						local dx, dy = ex - sx, ey - sy
		            	local l = sqrt((dx * dx) + (dy * dy))
		            	-- print(l)
		            	if l > 1 then
		            		if l < max_x then
		            			bottom_line_squid[1] = bottom_line_squid[1] - line_step
		            			bottom_line_squid.a = bottom_line_squid.a + animation_completion
								local rsx, rsy, rex, rey = left_line_squid[1], left_line_squid[2], left_line_squid[3], left_line_squid[4]
								local rdx, rdy = rex - rsx, rey - rsy
								local rl = sqrt((rdx * rdx) + (rdy * rdy))
								if rsy < max_y then--+ (min_y - (min_y / 2)) then
									left_line_squid[2] = left_line_squid[2] + line_step
									left_line_squid.a = left_line_squid.a + animation_completion
								else
									done_here=true
								end
		            		end
		            	end

					-- 	line_thing_update = time

					-- end

					--top line ( x 1 )
					local sx, sy, ex, ey = top_line_squid[1], top_line_squid[2], top_line_squid[3], top_line_squid[4]
		            local dx, dy = ex - sx, ey - sy
		            local l = sqrt((dx * dx) + (dy * dy))
		            if l > 0 then
		            	local a = top_line_squid.a
						LibDraw.SetColorRaw(.12, 1, .4, a)
						LibDraw.SetWidth(15)
						LibDraw.Draw2DLine(sx, sy, ex, ey)
					end

					--right line ( y 1 )
					local sx, sy, ex, ey = right_line_squid[1], right_line_squid[2], right_line_squid[3], right_line_squid[4]
		            local dx, dy = ex - sx, ey - sy
		            local l = sqrt((dx * dx) + (dy * dy))
		            if l > 0 then
						local a = right_line_squid.a
						LibDraw.SetColorRaw(.12, 1, .4, a)
						LibDraw.SetWidth(15)
						LibDraw.Draw2DLine(sx, sy, ex, ey)
					end

					--bottom line ( x 2 )
					local sx, sy, ex, ey = bottom_line_squid[1], bottom_line_squid[2], bottom_line_squid[3], bottom_line_squid[4]
		            local dx, dy = ex - sx, ey - sy
		            local l = sqrt((dx * dx) + (dy * dy))
		            if l > 0 then
						local a = bottom_line_squid.a
						LibDraw.SetColorRaw(.12, 1, .4, a)
						LibDraw.SetWidth(15)
						LibDraw.Draw2DLine(sx, sy, ex, ey)
					end

					--left line ( y 2 )
					local sx, sy, ex, ey = left_line_squid[1], left_line_squid[2], left_line_squid[3], left_line_squid[4]
		            local dx, dy = ex - sx, ey - sy
		            local l = sqrt((dx * dx) + (dy * dy))
		            if l > 0 then
						local a = left_line_squid.a
						LibDraw.SetColorRaw(.12, 1, .4, a)
						LibDraw.SetWidth(15)
						LibDraw.Draw2DLine(sx, sy, ex, ey)
					end

					if done_here then reset_shit() green_line_test = nil red_line_test = nil end

				elseif red_line_test then

					local max_x,max_y = LibDraw.canvas:GetWidth(),LibDraw.canvas:GetHeight()
					max_y = max_y - wf_top

					local min_y = -wf_top - 3.34
					local min_x = 0

					local w = 10

					max_x = max_x - .1

					-- min_x = min_x + w
					-- from cursor to top right of screen
					-- local cx,cy = GetCursorPosition()
					-- if cy then 
					-- 	cy = cy - wf_top
					-- 	LibDraw.SetColorRaw(.12, 1, .4, 1)
					-- 	LibDraw.SetWidth(15)
					-- 	LibDraw.Draw2DLine(cx, cy, max_x, max_y)
					-- 	print(cx,cy,max_x,max_y)
					-- end

					-- LibDraw.SetColorRaw(.12, 1, .4, 1)
					-- LibDraw.SetWidth(15)
					-- LibDraw.Draw2DLine(91.372,-3.34,1427.6695605469,-3.34)

					local function reset_shit ()
						--starting pos
						top_line_squid = { min_x + (max_x / 5), max_y, max_x, max_y-.01, a = .1 }

						right_line_squid = { max_x, max_y, max_x-.01, max_y-.01, a = .1 }

						bottom_line_squid = { max_x - (max_x / 5), min_y, min_x, min_y+.01, a = .1 }

						left_line_squid = { min_x, min_y, min_x+.01, min_y+.01, a = .1 }
					end

					if not top_line_squid or green_line_test then
						reset_shit()
						green_line_test = nil
					end

					local fps = GetFramerate()

					local done_here

					-- if not line_thing_update or time - line_thing_update > .00001 then
						local line_step = ( max_x / ( fps * .85) )
						local sx, sy, ex, ey = top_line_squid[1], top_line_squid[2], top_line_squid[3], top_line_squid[4]
						local dx, dy = ex - sx, ey - sy
		            	local l = sqrt((dx * dx) + (dy * dy))
		            	
		          		local animation_completion = 0

		          		animation_completion = ( max_x - l ) / max_x

		            	-- print(l)
		            	if l > 1 then
		            		if l < max_x then
		            			top_line_squid[1] = top_line_squid[1] + line_step
		            			top_line_squid.a = top_line_squid.a + animation_completion
								local rsx, rsy, rex, rey = right_line_squid[1], right_line_squid[2], right_line_squid[3], right_line_squid[4]
								local rdx, rdy = rex - rsx, rey - rsy
								local rl = sqrt((rdx * rdx) + (rdy * rdy))
								if rsy > min_y then
									right_line_squid[2] = right_line_squid[2] - line_step
									right_line_squid.a = right_line_squid.a + animation_completion
								end
		            		end
		            	end

		            	local sx, sy, ex, ey = bottom_line_squid[1], bottom_line_squid[2], bottom_line_squid[3], bottom_line_squid[4]
						local dx, dy = ex - sx, ey - sy
		            	local l = sqrt((dx * dx) + (dy * dy))
		            	-- print(l)
		            	if l > 1 then
		            		if l < max_x then
		            			bottom_line_squid[1] = bottom_line_squid[1] - line_step
		            			bottom_line_squid.a = bottom_line_squid.a + animation_completion
								local rsx, rsy, rex, rey = left_line_squid[1], left_line_squid[2], left_line_squid[3], left_line_squid[4]
								local rdx, rdy = rex - rsx, rey - rsy
								local rl = sqrt((rdx * rdx) + (rdy * rdy))
								if rsy < max_y then--+ (min_y - (min_y / 2)) then
									left_line_squid[2] = left_line_squid[2] + line_step
									left_line_squid.a = left_line_squid.a + animation_completion
								else
									done_here=true
								end
		            		end
		            	end

					-- 	line_thing_update = time

					-- end

					--top line ( x 1 )
					local sx, sy, ex, ey = top_line_squid[1], top_line_squid[2], top_line_squid[3], top_line_squid[4]
		            local dx, dy = ex - sx, ey - sy
		            local l = sqrt((dx * dx) + (dy * dy))
		            if l > 0 then
		            	local a = top_line_squid.a
						LibDraw.SetColorRaw(1, .1, .4, a)
						LibDraw.SetWidth(15)
						LibDraw.Draw2DLine(sx, sy, ex, ey)
					end

					--right line ( y 1 )
					local sx, sy, ex, ey = right_line_squid[1], right_line_squid[2], right_line_squid[3], right_line_squid[4]
		            local dx, dy = ex - sx, ey - sy
		            local l = sqrt((dx * dx) + (dy * dy))
		            if l > 0 then
						local a = right_line_squid.a
						LibDraw.SetColorRaw(1, .1, .4, a)
						LibDraw.SetWidth(15)
						LibDraw.Draw2DLine(sx, sy, ex, ey)
					end

					--bottom line ( x 2 )
					local sx, sy, ex, ey = bottom_line_squid[1], bottom_line_squid[2], bottom_line_squid[3], bottom_line_squid[4]
		            local dx, dy = ex - sx, ey - sy
		            local l = sqrt((dx * dx) + (dy * dy))
		            if l > 0 then
						local a = bottom_line_squid.a
						LibDraw.SetColorRaw(1, .1, .4, a)
						LibDraw.SetWidth(15)
						LibDraw.Draw2DLine(sx, sy, ex, ey)
					end

					--left line ( y 2 )
					local sx, sy, ex, ey = left_line_squid[1], left_line_squid[2], left_line_squid[3], left_line_squid[4]
		            local dx, dy = ex - sx, ey - sy
		            local l = sqrt((dx * dx) + (dy * dy))
		            if l > 0 then
						local a = left_line_squid.a
						LibDraw.SetColorRaw(1, .1, .4, a)
						LibDraw.SetWidth(15)
						LibDraw.Draw2DLine(sx, sy, ex, ey)
					end

					if done_here then reset_shit() green_line_test = nil red_line_test = nil end

				end
			end

			local player_is_melee = _isMeleeDps("player")

			if player_is_melee then
				if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and _distance(current_target) < 7 then
					local unit = current_target
					if (UnitBuffID(unit,5277) or UnitBuffID(unit,118038) or UnitBuffID(unit,199754) or UnitBuffID(unit,198589) or UnitChannelInfo(unit) == "Fists of Fury") then
						LibDraw.SetColorRaw(1, 1, .1, .75)
						LibDraw.SetWidth(3)
						local x,y,z = ObjectPosition(current_target)
						local facing = ObjectFacing(current_target)
						local size = UnitDebuffID(current_target,6770) and UnitPower("player",4) > 0 and not UnitDebuffID(current_target,1943,"player") and 5.75 or 1.6
						-- multiple arcs?
						Arc(x,y,z,size,180,mod(facing + math.pi, math.pi * 2))
					end
				end
			end

			-- local countdown = max( _spellCooldown(408), _drRemains(current_focus,"stun") )
			-- if not countdown_val or countdown_val < time then countdown_val = time + 7 end

			-- cc_draw_line = cc_draw_line or {unit="focus", spellID=6770}
			-- cc_draw_line = {unit="focus", spellID=408}
			-- cc_draw_line = {unit="focus", spellID=2094}

			-- rogue back drawing function LibDraw.Arc(x, y, z, size, arc, rotation)
			if select(2,UnitClass("player")) == "ROGUE" and GetSpecialization() == 3 then
				if get_squid_var("Backstab Drawing") then
					if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and _distance(current_target) < 6 then
						LibDraw.SetColorRaw(1, 1, .1, .4+(UnitDebuffID(current_target,6770) and UnitPower("player",4) > 0 and not UnitDebuffID(current_target,1943,"player") and .5 or 0))
						LibDraw.SetWidth(3)
						local x,y,z = ObjectPosition(current_target)
						local facing = ObjectFacing(current_target)
						local size = UnitDebuffID(current_target,6770) and UnitPower("player",4) > 0 and not UnitDebuffID(current_target,1943,"player") and 5.75 or 1.6
						-- multiple arcs?
						Arc(x,y,z,size,180,mod(facing + math.pi, math.pi * 2))
					end
				end
				-- combat tracker
				for i=1,#Enemies do
					local e = Enemies[i]
					if squid_combat_tracker[e] and (_incapacitateDR(e) == 1 or _drRemains(e, "incapacitate") >= 17) then
						if UnitAffectingCombat(e) then
							local time_since_action = time - squid_combat_tracker[e]
							local time_til_combat_ends = 6 - time_since_action
							local x,y,z = ObjectPosition(e)
							if time_til_combat_ends <= 4 then
								LibDraw.SetColorRaw(.4, 1, .6, 1)
								LibDraw.Text("Combat Ends in " .. (time_til_combat_ends <= 1 and max(0,round(time_til_combat_ends,1)) or math.floor(time_til_combat_ends)), "GameFontNormalLarge", x, y, z+3)
							end
						else
							local time_since_action = time - squid_combat_tracker[e]
							local time_til_combat_ends = 6 - time_since_action
							local x,y,z = ObjectPosition(e)
							if time_since_action <= 11 and time_since_action > 1 then
								LibDraw.SetColorRaw(.1, 1, .2, 1)
								LibDraw.Text("- OUT OF COMBAT -", "GameFontNormalLarge", x, y, z+3)
							end
						end
					end
				end

				-- rogue cc lines
				if cc_draw_line then
					
					local unit = cc_draw_line.unit
					local spell = cc_draw_line.spellID
					local ready = cc_draw_line.ready

					local range = GetSpellRange(spell)

					if UnitIsVisible(unit) then
						
						local x,y,z = ObjectPosition(unit)
						local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)

						local combat_dist = _distance(unit) 

						local angle = GetAnglesBetweenObjects(unit,"player")
						
						local out_of_range = range > 0 and combat_dist > range or range == 0 and not _meleeRange(unit) 

						local red_range = range + 8

						if out_of_range then

							if combat_dist > red_range then
								-- red arrow
								local arrow_size = 0.86
								local arrow_shape = {
								  {-arrow_size, -arrow_size, 0, 0, 0, 0},
								  {arrow_size, -arrow_size, 0, 0, 0, 0},
								}
							    LibDraw.SetColor(255, 0, 0, 100)
							    LibDraw.SetWidth(2)
							    LibDraw.Array(arrow_shape, px - 4 * math.cos(angle), py - 4 * math.sin(angle), pz, nil, nil, math.rad(90) + angle)
							end

						    -- yellow arrow
							local arrow_size = 0.73
							local arrow_shape = {
							  {-arrow_size, -arrow_size, 0, 0, 0, 0},
							  {arrow_size, -arrow_size, 0, 0, 0, 0},
							}
						    LibDraw.SetColor(255, 255, 45, 100)
						    LibDraw.SetWidth(2)
						    LibDraw.Array(arrow_shape, px - 3.75 * math.cos(angle), py - 3.75 * math.sin(angle), pz, nil, nil, math.rad(90) + angle)
						end

						local super_close_range = range == 0 and 4 or 5

						if dist >= super_close_range then
						    -- green arrow
							local arrow_size = 0.59
							local arrow_shape = {
							  {-arrow_size, -arrow_size, 0, 0, 0, 0},
							  {arrow_size, -arrow_size, 0, 0, 0, 0},
							}
						    LibDraw.SetColor(0, 255, 0, 100)
						    LibDraw.SetWidth(2)

						    local greenarrow_dist = min(3.5, dist - 3)
						    LibDraw.Array(arrow_shape, px - greenarrow_dist * math.cos(angle), py - greenarrow_dist * math.sin(angle), pz, nil, nil, math.rad(90) + angle)
						end

					    local texture = {
							texture = GetSpellTexture(spell),
							width = 34, height = 34,
							alpha = 1,
						}

						local texture_dist = dist < super_close_range and 0 or min(6, dist-2)

						local px,py,pz = px,py,pz
						if dist < super_close_range then angle = ObjectFacing(unit) px,py,pz = x,y,z-3 end

						LibDraw.Texture(texture,px - texture_dist * math.cos(angle), py - texture_dist * math.sin(angle), pz+.25);

						local countdown = cc_draw_line.countdown or countdown or countdown_val-time
						
						LibDraw.SetColorRaw(1 - (countdown/6),1,0,1)
						LibDraw.Text(round(countdown,1),"GameFontNormal",px - texture_dist * math.cos(angle), py - texture_dist * math.sin(angle), pz+2+(dist < super_close_range and .5 or 0))

						LibDraw.SetColorRaw(.4 + (out_of_range and .6 or 0),1-(combat_dist > red_range and 1 or 0),0,.025 + (not out_of_range and .1 or 0) + (ready and .4 or 0) + (_spellCooldown(36554) > max(0,countdown-.3) and .2 or 0) + ((countdown/6)/2))

						local actual_range = range == 0 and 5.95 or range+UnitCombatReach("player")+UnitCombatReach(unit)

						if out_of_range then
							LibDraw.SetWidth(8)

							-- line to where we are in range
							LibDraw.Line(px,py,pz,GetPositionBetweenPositions(x,y,z,px,py,pz,actual_range+.25))

							LibDraw.SetColorRaw(.4,1,0,.08 + (ready and .4 or 0))
							LibDraw.SetWidth(8)
							-- LibDraw.Circle(x,y,z,actual_range)
							Arc(x,y,z,actual_range,90,GetAnglesBetweenPositions(x,y,z,px,py,pz),true)
						else
							LibDraw.SetWidth(11)
							LibDraw.Circle(x,y,z,actual_range)
						end


					end

				end
			end

			--hardcast flamestrike debug
			if last_flamestrike_pos and unit_casting_info("player") == "Flamestrike" then
				LibDraw.SetColorRaw(1, .25, 0, .25)
				LibDraw.SetWidth(3)
				local x,y,z = last_flamestrike_pos.x,last_flamestrike_pos.y,last_flamestrike_pos.z
				if x and y and z then
					LibDraw.Text("Flamestrike", "GameFontNormalSmall", x, y, z+2)
					LibDraw.Circle(x,y,z,8)
				end
			end

			if stealth_tracker then
				for i=1,#stealth_tracker do if stealth_tracker[i] then
					local elapsed = time - stealth_tracker[i].time
					if UnitIsVisible(stealth_tracker[i].pointer) and UnitBuffID(stealth_tracker[i].pointer,stealth_tracker[i].id) then
						local pointer = stealth_tracker[i].pointer
						stealth_tracker[i].speed = GetUnitSpeed(pointer) or stealth_tracker[i].speed
						stealth_tracker[i].direction = GetMovingDirection(pointer) or stealth_tracker[i].direction
						local x,y,z = ObjectPosition(pointer)
						stealth_tracker[i].x = x or stealth_tracker[i].x
						stealth_tracker[i].y = y or stealth_tracker[i].y 
						stealth_tracker[i].z = z or stealth_tracker[i].z
						stealth_tracker[i].time = time
						stealth_tracker[i].update = true
					end
					if elapsed < 2.5 and ( not UnitIsVisible(stealth_tracker[i].pointer) or UnitBuffID(stealth_tracker[i].pointer,stealth_tracker[i].id) and stealth_tracker[i].update ) then
						local x,y,z = stealth_tracker[i].x,stealth_tracker[i].y,stealth_tracker[i].z
						local dir = stealth_tracker[i].direction
						local speed = stealth_tracker[i].speed
						local traveled = speed * elapsed
						if x and y and z and dir and speed then
							local estX,estY,estZ = GroundZ(x + traveled * math.cos(dir), y + traveled * math.sin(dir), z)
							if estX and estY and estZ then
								LibDraw.SetColorRaw(1,.5,.25,math.max(.5,1 - (elapsed/3)))
								LibDraw.Circle(estX,estY,estZ,2.5)
								LibDraw.Text(stealth_tracker[i].name, "GameFontNormalSmall", estX, estY, estZ+2)
							end
						end
					end
					if elapsed > 5 then
						table.remove(stealth_tracker,i)
					end
				end end
			end

			--sphere test
			if sphere_test then

				LibDraw.SetColorRaw(1, .85, .1, 1)
				LibDraw.Cone(px+5,py+5,pz,1.25)
				LibDraw.Text("EXPLOSIVE", SquidFont, px+5,py+5,pz+3)
			end

			--debug draws

			-- blink resulting position by angle
			if blink_pos_debug then
				LibDraw.SetColorRaw(.86, .24, .87, .65)
				LibDraw.SetWidth(3)
				for i=1,math.pi*2,.5 do
					local x,y,z = position_after_blink(i)
					if x and y and z then
						-- LibDraw.Text("Blinking Here", SquidFont, x, y, z+1)
						LibDraw.Circle(x,y,z,1)
					else
						print("no circl?")
					end
				end
			end

			-- target_line=true
			if target_line then
				if current_target then
					local x,y,z = ObjectPosition("target")
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.SetWidth(12)
					Line(px,py,pz,x,y,z)
				end
			end	

			-- blink_los_debug=true
			if blink_los_debug then
				local x,y,z = blink_los_point(current_focus,100)
				if x and y and z then
					-- x,y,z = GroundZ(x,y,z)
					local texture = {
						texture = GetSpellTexture(1953),
						width = 32, height = 32,
						alpha = 1,
					}
					LibDraw.Texture(texture,x,y,z+2);
					LibDraw.SetColorRaw(.86, .24, .87, .65)
					LibDraw.SetWidth(12)
					-- LibDraw.Text("Blinking Here", SquidFont, x, y, z+1)
					LibDraw.Circle(x,y,z,2)
				end
			end

			--draw LoS blink position	
			if blink_los_draw then
				local x,y,z = blink_los_point(blink_los_draw,40)
				if x and y and z then
					local texture = {
						texture = GetSpellTexture(1953),
						width = 32, height = 32,
						alpha = 1,
					}
					LibDraw.Texture(texture,x,y,z+2);
					LibDraw.SetColorRaw(.9, .54, .013, .65)
					LibDraw.SetWidth(2)
					-- LibDraw.Text("Blinking Here", SquidFont, x, y, z+1)
					LibDraw.Circle(x,y,z,2)
					if not player_can_see_coords(x,y,z) then
						LibDraw.SetColorRaw(.9, .54, .013, .85)
						LibDraw.SetWidth(4)
						local dx,dy,dz = GetPositionBetweenPositions(px,py,pz,x,y,z,5)
						LibDraw.Texture(texture,dx,dy,dz+2);
						Line(px,py,pz,x,y,z)
					end
				end
			end

			--explosive draw
			if explosive_draw and UnitIsVisible(explosive_draw) then
				local x,y,z = ObjectPosition(explosive_draw)
				if x and y and z then
					LibDraw.SetColorRaw(1, .85, .1, 1)
					LibDraw.Text("EXPLOSIVE", SquidFont, x, y, z+3)
					LibDraw.Circle(x,y,z,2)
				end
			end

			-- blink_db_debug = true
			if blink_db_debug then
				local x,y,z = blink_db_point(current_focus)
				if x and y and z then
					-- x,y,z = GroundZ(x,y,z)
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.Text("Blink DB Position", SquidFont, x, y, z+2)
					LibDraw.Circle(x,y,z,3)
				end
			end

			if squid_alter then
				local x,y,z = unpack(squid_alter["start_pos"])
				if x and y and z and squid_alter["start_hp"] then
					-- x,y,z = GroundZ(x,y,z)
					local hp_change = round ( squid_alter["start_hp"] - _HP("player"), 2)

					local texture = {
						texture = GetSpellTexture(108978),
						width = 42, height = 42,
						alpha = 1,
					}

					local g = min ( 1, min(1, (hp_change / 100) * 2) + .35 )
					local r_add = 0
					if hp_change < 0 then
						r_add = r_add + min(1, ((abs(hp_change)/100)*2.5) + .2 )
					end
					LibDraw.SetColorRaw(r_add, g, .45, 1)
					
					LibDraw.SetWidth(7)
					local op = hp_change <= 0 and "-" or "+"
					LibDraw.Texture(texture,x,y,z+2.5)
					LibDraw.Circle(x,y,z,2.5)
					LibDraw.SetColorRaw(g, r_add, .45, 1)
					LibDraw.Text(op .. hp_change .. "%","GameFontNormalLarge", x, y, z+2)
				end
			end

			if draw_all_missiles then
				for i=1,#squid_missiles do
					
					local missile = squid_missiles[i]
					
					local x,y,z = unpack(missile.dest)
					LibDraw.SetColorRaw(131/255, 236/255, 74/255, .8)
					LibDraw.Text(GetSpellInfo(missile.spellid), SquidFont, x, y, z+2)
					-- spell visual id have size info?
					LibDraw.Circle(x,y,z,5)

					local cx,cy,cz = unpack(missile.pos)
					LibDraw.SetColorRaw(131/255, 236/255, 155/255, .8)
					LibDraw.Circle(cx,cy,cz,2.5)

				end
			end

			--missile drawings
			for i=1,#squid_missiles do
				local missile = squid_missiles[i]
				--infernals
				if missile.spellid == 1122 and UnitIsVisible(missile.caster) and UnitCanAttack("player",missile.caster) then
					local x,y,z = unpack(missile.dest)
					LibDraw.SetColorRaw(131/255, 236/255, 74/255, .8)
					LibDraw.Text("ENEMY INFERNAL!!!", SquidFont, x, y, z+2)
					local cx,cy,cz = unpack(missile.pos)
					local dist = GetDistanceBetweenPositions(x,y,z,cx,cy,cz)
					est_time = round(dist/31, 3)


					LibDraw.Text((est_time * 1000) .. " ms", SquidFont, x, y, z)
					LibDraw.Circle(x,y,z,9)
				end
				--trap
				if missile.spellid == 187650 and UnitIsVisible(missile.caster) and UnitCanAttack("player",missile.caster) then
					local x,y,z = unpack(missile.dest)
					local sx,sy,sz = unpack(missile.source)
					local cx,cy,cz = unpack(missile.pos)
					local angle = GetAnglesBetweenPositions(cx,cy,cz,x,y,z)
					LibDraw.SetColorRaw(80/255, 115/255, 211/255, 1)
					LibDraw.Line(sx,sy,sz,x,y,z)
					LibDraw.Circle(x,y,z,2.5)
					LibDraw.Text("Trap", SquidFont, x,y,z)
					LibDraw.SetColorRaw(80/255, 115/255, 211/255, .3)
					LibDraw.Circle(cx + 1 * math.cos(angle),cy + 1 * math.sin(angle),cz,2.5)
				end
			end

			for i=1,#Enemies do
				if _rootCheck(Enemies[i]) and _isMeleeDps(Enemies[i]) then
					if _distance(Enemies[i]) < 7 then
						local x,y,z = ObjectPosition(Enemies[i])
						LibDraw.SetWidth(6)
						LibDraw.SetColorRaw(1, .3, .47, 1)
						LibDraw.Circle(x,y,z,6)
					end
				end
			end

			-- meteor_debug=true
			if meteor_debug then
				local x,y,z,hit,avg_dist
				if meteor_debug ~= true then
					x,y,z,hit,avg_dist = best_meteor_point(current_target,true) 
				else
					x,y,z,hit,avg_dist = best_meteor_point(current_target)
				end
				if x and y and z then
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.SetWidth(8)
					LibDraw.Text("Meteor Drop Position", SquidFont, x, y, z+2)
					LibDraw.Text("Hits: " .. hit .. " - AVG: " .. math.floor(avg_dist), SquidFont, x, y, z)
					LibDraw.Circle(x,y,z,8)
					LibDraw.Circle(x,y,z,.5)
				end
			end

			-- rop_debug=true
			if rop_debug then
				local x,y,z = rop_unit_to_unit(current_focus,current_target)
				if x and y and z then
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.Text("RoP Position", SquidFont, x, y, z+2)
					LibDraw.Circle(x,y,z,8)
				end
			end

			if groundz_debug then
				local x,y,z = GetGroundZ(px,py,0x100111)
				if x and y and z then
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.Circle(x,y,z,2)
				end
				x,y,z = GroundZ(px,py,pz)
				if x and y and z then
					LibDraw.SetColorRaw(.2, 1, .2, 1)
					LibDraw.Circle(x,y,z,3)
				end
			end

			if click_debug then
				local x,y,z = GetLastClickInfo()
				if x and y and z then
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.Text("Click Position", SquidFont, x, y, z+2)
					LibDraw.Circle(x,y,z,8)
				end
			end

			-- last_blink_debug=true
			if last_blink_debug then
				local x,y,z
				for i=1,#AreaTriggers do
					if ObjectID(AreaTriggers[i]) == 11513 then
						x,y,z = ObjectPosition(AreaTriggers[i])
						break
					end
				end
				if x and y and z then
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.Text("Last Blink", SquidFont, x, y, z+2)
					LibDraw.Circle(x,y,z,1)
				end
			end

			if prediction_debug then
				local x,y,z = PredictUnitPosition("player",prediction_debug or .79)
				if x and y and z and player_can_see_coords(x,y,z) then
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.SetWidth(2)
					LibDraw.Circle(x,y,z,.25)
					LibDraw.Circle(px,py,pz,.25)
					LibDraw.Text(GetDistanceBetweenPositions(px,py,pz,x,y,z), SquidFont, x, y, z+2)
					LibDraw.SetWidth(2)
					Line(px,py,pz,x,y,z)
				end
			end

			--draw optimal aggressive position
			if position_draw_debug and UnitIsVisible(current_target) and UnitIsVisible(theirHealer) and not unit_is_unit(theirHealer,current_target) then
				
				local x,y,z = ObjectPosition(current_target)
				local X,Y,Z = ObjectPosition(theirHealer)
				local dist_between = GetDistanceBetweenPositions(x,y,z,X,Y,Z)

				local BX,BY,BZ
				if dist_between > 15 then
					
					BX,BY,BZ = GetPositionBetweenPositions(x,y,z,X,Y,Z,dist_between/2)
					
					local points = {}

					local direction
					for i=0,math.pi*2,.6 do
						local xx,yy,zz = GroundZ (BX + 12 * math.cos(i), BY + 12 * math.sin(i), BZ)
						if xx and yy and zz and not TraceLine(xx,yy,zz+2,x,y,z+2,0x100111) and not TraceLine(xx,yy,zz+2,X,Y,Z+2,0x100111) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
							direction = i
							local mx = xx --+ 7.25 * math.cos(direction)
							local my = yy --+ 7.25 * math.sin(direction)
							local mz = zz
							
							-- local combined_dist = GetDistanceBetweenPositions(xx,yy,zz,x,y,z) + GetDistanceBetweenPositions(xx,yy,zz,X,Y,Z)
							local combined_dist = GetDistanceBetweenPositions(xx,yy,zz,X,Y,Z)
							table.insert(points,{xx=mx,yy=my,zz=mz,d=combined_dist})
						end
					end

					table.sort(points,function(x,y) return x.d < y.d end)

					if #points > 0 then
						local a,b,c = points[1].xx,points[1].yy,points[1].zz
						BX,BY,BZ = a,b,c
					else
						BX,BY,BZ = nil
					end

				end

				if BX and BY and BZ then
					LibDraw.SetColorRaw(.6, .4, .85, 1)
					LibDraw.SetWidth(4)
					LibDraw.Text("Optimal Position", SquidFont, BX, BY, BZ+2)
					LibDraw.Circle(BX,BY,BZ,5)
				end
			end

			killx,killy,killz = nil
			if squid_killshot and current_target then
				local x,y,z = ObjectPosition(current_target)
				local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)
				killx,killy,killz = GetPositionBetweenPositions(px,py,pz,x,y,z,dist-22)
				LibDraw.SetColorRaw(1, 0, .87, 1)
				LibDraw.Text("Stand here for a free kill.", SquidFont, killx, killy, killz+2)
				LibDraw.Circle(killx,killy,killz,3)
			end
			-- LibDraw.DrawHelper()

			--awareness
			if arena and not _isHealer("player") and ourHealer and UnitIsVisible(ourHealer) then
				
				local d = _distance(ourHealer)

				local disable_while_visible = SQUID.disable_while_visible

				local alerts_enabled = SQUID.awareness_alerts_enabled
				local lines_enabled = SQUID.awareness_lines_enabled
				local good_line = SQUID.good_line_enabled

				local can_see_healer = disable_while_visible and player_can_see(ourHealer)
				
				local x,y,z = ObjectPosition(ourHealer)
				x,y,z = GroundZ(x,y,z)
				local los = _LoS(ourHealer)

				if x and y and z and (not can_see_healer or not disable_while_visible) then
					
					--ranging the healer alert
					if d > 39.5 then
						if alerts_enabled then
							if not healer_range_alert or GetTime() - healer_range_alert > 15 then
								Squid_Alert_Big("ALERT:","Ranging Healer!",2,nil,201785)
								healer_range_alert = GetTime()
							end
						end
					end
					--ranging the healer line
					if lines_enabled then
						if d > 37.5 then
							local a = (d - 20) / 25
							local range_factor = a
							if a < .2 then a = .2 elseif a > .75 then a = .75  end
							LibDraw.SetColorRaw(1, .2, .2, a)
							LibDraw.SetWidth(1 + min(range_factor*15, 15))
							Line(px,py,pz,x,y,z)
						end
					end
					--losing the healer alert
					if not los then
						if alerts_enabled then
							if not healer_los_alert or GetTime() - healer_los_alert > 15 then
								Squid_Alert_Big("ALERT:","LoS Healer!",2,nil,198838)
								healer_los_alert = GetTime()
							end
						end
						--losing the healer line
						if lines_enabled then
							LibDraw.SetColorRaw(1, .647, 0, .8)
							LibDraw.SetWidth(14)
							Line(px,py,pz,x,y,z)
						end
					end
					--Good line (Green)
					if los and d <= 39.5 then
						if good_line then
							LibDraw.SetColorRaw(.2, .95, .44, .5)
							LibDraw.SetWidth(8)
							Line(px,py,pz,x,y,z)
						end
					end
				end

				--Healer Dist Cone
				if not UnitBuffID("player",32727) and d > 3.5 then
					if SQUID.positioning_help then

						local a = (d < 21 and 1 or .2)
						--red arc
						LibDraw.SetColorRaw(1, .15, .04, a)
						LibDraw.SetWidth(4)
						LibDraw.Arc(x,y,z,24,60,GetAnglesBetweenObjects(ourHealer,"player"))
						a = (d < 30 and d >= 21 and 1 or .2)
						--yellow arc
						LibDraw.SetColorRaw(.7, .7, .15, a)
						LibDraw.SetWidth(4)
						LibDraw.Arc(x,y,z,33,60,GetAnglesBetweenObjects(ourHealer,"player"))
						a = (d < 38 and d >= 30 and 1 or .2)
						--green arc
						LibDraw.SetColorRaw(.16, 1, .21, a)
						LibDraw.SetWidth(4)
						LibDraw.Arc(x,y,z,41,60,GetAnglesBetweenObjects(ourHealer,"player"))
						

					end
				end

			end

			-- units casting on player
			-- for i=1,#Enemies do
			-- 	local e = Enemies[i]
			-- 	local cast,_,_,_,_,_,_,_,castid = unit_casting_info(e)
			-- 	if cast then
			-- 		local tar = UnitSpellTarget(e)
			-- 		if unit_is_unit("player",tar) then
			-- 			local x,y,z = ObjectPosition(e)
			-- 			local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)
			-- 			local bx,by,bz = GetPositionBetweenPositions(x,y,z,px,py,pz,dist-4)
			-- 			local pct = _castPctDone(e)
			-- 			local mod = pct / 100
			-- 			-- LibDraw.Text("LoS Blink Position", SquidFont, x, y, z+2)
			-- 			-- LibDraw.Box(bx,by,bz,16,16)
			-- 			local casttexture = {
			-- 			texture = GetSpellTexture(castid),
			-- 			width = 32 * mod, height = 32 * mod,
			-- 			alpha = 1,
			-- 			}
			-- 			local boundingbox = {
			-- 			texture = GetSpellTexture(castid),
			-- 			width = 30, height = 30,
			-- 			alpha = .35,
			-- 			}
			-- 			LibDraw.Texture(boundingbox,bx,by,bz);
			-- 			LibDraw.Texture(casttexture,bx,by,bz);
			-- 			LibDraw.SetColorRaw(.2, .8, .4, 1)
			-- 			LibDraw.Text(math.floor(pct),SquidFontMedium,bx,by,bz+.3)
			-- 			LibDraw.SetColorRaw(1, 0, .4, 1)
			-- 			LibDraw.SetWidth(50)
			-- 			Line(px,py,pz,x,y,z)
			-- 		end
			-- 	end
			-- end

			--draw units out of range
			local flamecannon_stacks = _buffStacks("player",203285)
			local fc_value = flamecannon_stacks*3
			local player_reach = 1.5
			local sheep_range = 30 + fc_value + player_reach
			local gpy_range = 40 + fc_value + player_reach

			if arena and select(2,UnitClass("player")) == "MAGE" then
				--sheep range
				local e
				for i=1,#Enemies do
					e = Enemies[i]
					if _distance(e) > sheep_range-player_reach and not unit_is_unit(e,current_target) and UnitIsPlayer(e) then
						local x,y,z = ObjectPosition(e)
						--blueish arc
						LibDraw.SetColorRaw(.65, .85, .92, .95)
						LibDraw.SetWidth(4)
						local angle = (x and y and z and GetAnglesBetweenPositions(px,py,pz,x,y,z) or 1)
						local lx,ly,lz = LibDraw.Crescent(px,py,z,sheep_range,6,angle,true)
						LibDraw.SetColorRaw(.65, .85, .92, .4)
						LibDraw.SetWidth(2)
						if lx and ly and lz then
							LibDraw.Line(lx,ly,lz,x,y,z)
						end
					end
				end
			end

			--Mage next cc tar
			if UnitIsVisible(mage_next_cc_target) and player_can_see(mage_next_cc_target) then

				local unit = mage_next_cc_target
				local cc = mage_next_cc
				local dr = mage_next_cc_dr
				local remains = mage_next_cc_time

				if remains and dr and cc and unit then
					
					local x,y,z = ObjectPosition(unit)
					local texture = {
						texture = GetSpellTexture(cc),
						width = 32, height = 32,
						alpha = 1,
					}

					local remains_text

					if remains == 0 then
						remains_text = "Ready!"
					else
						remains_text = math.ceil(remains)
					end

					dr = dr == 1 and "Full" or dr == .5 and "Half" or dr == .25 and "Short" or "Immune"

					-- local x,y,z = GroundZ (ux + dist * math.cos(i), uy + dist * math.sin(i), uz+2)

					local cam_x,cam_y,cam_z = GetCameraPosition()

					local angles 
					if px and py and pz and x and y and z then 
						angles = GetAnglesBetweenPositions(px,py,pz,x,y,z) + (math.pi / 2)
					else
						angles = 1
					end
					
					if x and y and z and px and py and pz then
						local draw_x,draw_y,draw_z = GetPositionBetweenPositions(x,y,z,px,py,pz,2.5)

						if draw_x and draw_y and draw_z then
							draw_x = draw_x + 1.5 * math.cos(angles)
							draw_y = draw_y + 1.5 * math.sin(angles)

							-- LibDraw.Texture(texture,x + 2 * math.cos(angles),y + 2 * math.sin(angles),z+1.5);
							LibDraw.Texture(texture,draw_x,draw_y,z+1.5);

							local g = (18 - remains) / 18

							local r = 1 - g

							r = dr == "Full" and 0 or r

							g = dr == "Full" and 1 or g

							LibDraw.SetColorRaw(r, g, 0, 1)
							-- LibDraw.Text(dr .. "  |  " .. remains_text,SquidFont,x + 2 * math.cos(angles),y + 2 * math.sin(angles),z+.5)
							LibDraw.Text(dr .. "  |  " .. remains_text,SquidFont,draw_x,draw_y,z+.5)
						end

					end

				end

			end

			RedSpellBars=true
			if RedSpellBars then
				if TargetFrameSpellBar then
					local bar = TargetFrameSpellBar
					local startcolor = bar.startCastColor
					if UnitIsVisible(current_target) then
						local spell_target = UnitSpellTarget(current_target)
						if unit_is_unit("player",spell_target) then
							startcolor:SetRGB(.9,0,0)
							if not startcolor.iamtarget then local t = current_target ClearTarget() TargetUnit(t) startcolor.iamtarget=true startcolor.iamnottarget=nil end
						else
							startcolor:SetRGB(1,0.7,0)
							if not startcolor.iamnottarget then local t = current_target ClearTarget() TargetUnit(t) startcolor.iamnottarget=true startcolor.iamtarget=nil end
						end
					end
				end
				if FocusFrameSpellBar then
					local bar = FocusFrameSpellBar
					local startcolor = bar.startCastColor
					if UnitIsVisible(current_focus) then
						local spell_target = UnitSpellTarget(current_focus)
						if unit_is_unit("player",spell_target) then
							startcolor:SetRGB(.9,0,0)
							if not startcolor.iamtarget then local t = current_focus ClearFocus() FocusUnit(t) startcolor.iamtarget=true startcolor.iamnottarget=nil end
						else
							startcolor:SetRGB(1,0.7,0)
							if not startcolor.iamnottarget then local t = current_focus ClearFocus() FocusUnit(t) startcolor.iamnottarget=true startcolor.iamtarget=nil end
						end
					end
				end
			end

			local mo_names = SQUID.mouseover_names
			local pow = math.pow

			--end of awareness
			local scx,scy = GetCursorPosition()
			local horrific_vision
			local map_id = GetMapId()
			if map_id == 2212 then -- FIXME (Add Stormwind)
				horrific_vision = "Orgrimmar"
			elseif map_id == 2213 then
				horrific_vision = "Stormwind"
			end
			if horrific_vision then
				
				-- jump when we have the fucking bugs on us
				if _buffStacks("player",311390) >= 3 
				and (not UnitCastingInfo("player") and not UnitChannelInfo("player") and not _isMoving("player") or _buffStacks("player",311390) >= 5) then
					Squid_Alert("Jumping","Bugs",nil,nil,311390)
					JumpOrAscendStart()
					AscendStop()
				end

				local caches = {
					[342135] = true, -- Normal Zone Cache
					[342134] = true, -- Normal Zone Cache
				}

				local crystal_id = 341368

				local vials = {
					[341341] = "Red",
					[341337] = "Black",
					[341338] = "Blue",
					[341339] = "Green",
					[341340] = "Purple",
				}
				local vial_effects = {
					[1] = "Sanity",
					[2] = "Defensive",
					[3] = "Healing",
					[4] = "Fire Breath",
					[5] = "Poison",
				}
				local vial_order = {
					[1] = "Black",
					[2] = "Green",
					[3] = "Red",
					[4] = "Blue",
					[5] = "Purple",
					["Black"] = 1,
					["Green"] = 2,
					["Red"] = 3,
					["Blue"] = 4,
					["Purple"] = 5,
				}
				local opposite_vial = {
					["Black"] = 2,
					["Green"] = 3,
					["Red"] = 4,
					["Blue"] = 5,
					["Purple"] = 1,
				}
				local function vial_effect(colorid)
					if not SQUID.poisoned_vial then return "?" end

					local color_effect = {}

					local sanity_index = opposite_vial[SQUID.poisoned_vial]

					local index = 1
					while index <= 5 do
						if sanity_index <= 5 then
							color_effect[sanity_index] = index
							sanity_index = sanity_index + 1
							if sanity_index > 5 then sanity_index = 1 end
						end
						index = index + 1
					end
					return vial_effects[color_effect[colorid]]
				end

				for i=1,#Objects do
					local o = Objects[i]
					local id = ObjectID(o)
					local name = ObjectName(o)
					local vial_type = vials[id]
					local is_cache = name == "Black Empire Cache"
					local is_crystal = name == "Odd Crystal"
					local is_bomb = id == 334122
					local is_cage = id == 326606
					if vial_type then
						local x,y,z = ObjectPosition(o)
						if not SQUID.poisoned_vial then
							if horrific_vision == "Orgrimmar" then
								local dist_to_spot = x and y and z and GetDistanceBetweenPositions(x, y, z, 1550.026, -4320.7255, 25.96109) or 999
								Squid_Alert("Searching for poisoned vial, please move close to it!")
								if dist_to_spot <= 3 then
									SQUID.poisoned_vial = vial_type
								end
							elseif horrific_vision == "Stormwind" then
								local dist_to_spot = x and y and z and GetDistanceBetweenPositions(x, y, z, -8673.7294, 823.6614, 97.1873) or 999
								Squid_Alert("Searching for poisoned vial, please move close to it!")
								if dist_to_spot <= 3 then
									SQUID.poisoned_vial = vial_type
								end
							end
						else
							local effect = vial_effect(vial_order[vial_type])
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end
							
							local s = .65 + max(.5,a)

							local r,g,b

							if vial_type == "Blue" then
								r,g,b = .45,.65,1
							elseif vial_type == "Purple" then
								r,g,b = .576,.439,.858
							elseif vial_type == "Green" then
								r,g,b = .596,.984,.596
							elseif vial_type == "Black" then
								r,g,b = .45,.45,.45
							else
								r,g,b = 1,.1,.1 -- Red, or...
							end

			                LibDraw.SetColorRaw(r,g,b,1)

			                if x and y and z then
				                LibDraw.Text(effect .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

				                LibDraw.SetWidth(s * 2)

				                if dist > 5 then
					                Line(x, y, z+s*1.25, x, y, z)
					                Line(x-s, y, z, x+s, y, z)
					                Line(x, y-s, z, x, y+s, z)
					           	else
					           		local sx,sy = WorldToScreen(x,y,z)
									if sx and sy then
										if scx and scy then
											sy = sy + wf_top
											local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
											if d < max(80 - dist, 35) then
												if GetKeyState(0x02) == true then
													if effect ~= "Poison" then
														InteractUnit(o)
														Squid_Alert("Helping you click " .. effect .. " vial", ":)")
													else
														Squid_Alert("Don't click the poison vials dude!",":(")
													end
												end
											end
										end
									end
					            end
					        end

						end
					end
					if is_cache then
						local x,y,z = ObjectPosition(o)

						local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

						local a = (100 - dist) / 100
						if a > 1 then a = 1 end
						if a < .3 then a = .3 end
						
						local s = .65 + max(.5,a)

						local r,g,b = 1,1,1

		                LibDraw.SetColorRaw(r,g,b,1)

		                if x and y and z then
			                LibDraw.Text("Cache" .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

			                LibDraw.SetWidth(s * 2)

			                if dist > 4.9 then
				                Line(x, y, z+s*1.25, x, y, z)
				                Line(x-s, y, z, x+s, y, z)
				                Line(x, y-s, z, x, y+s, z)
				           	else
				           		local sx,sy = WorldToScreen(x,y,z)
								if sx and sy then
									if scx and scy then
										sy = sy + wf_top
										local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
										if d < max(80 - dist, 25) then
											if GetKeyState(0x02) == true then
												InteractUnit(o)
												Squid_Alert("Helping you click the cache", ":)")
											end
										end
									end
								end
				            end
				        end
					end
					if is_bomb then
						local x,y,z = ObjectPosition(o)
						local r,g,b = .4,.4,.7
		                LibDraw.SetColorRaw(r,g,b,1)
		                if x and y and z then
		                	LibDraw.Text("Bomb", "GameFontNormal", x, y, z+3.5)
		                end
					end
					if is_cage then
						local x,y,z = ObjectPosition(o)
						local r,g,b = .4,.4,.7
		                LibDraw.SetColorRaw(r,g,b,1)
		                if x and y and z then
		                	LibDraw.Text("Cage", "GameFontNormal", x, y, z+3.5)
		                end
					end
					if is_crystal then
						local x,y,z = ObjectPosition(o)

						local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

						local a = (100 - dist) / 100
						if a > 1 then a = 1 end
						if a < .3 then a = .3 end
						
						local s = .65 + max(.5,a)

						local r,g,b = 1,.749,0

		                LibDraw.SetColorRaw(r,g,b,1)

		                if x and y and z then
			                LibDraw.Text("Crystal" .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

			                LibDraw.SetWidth(s * 2)

			                if dist > 4.9 then
				                Line(x, y, z+s*1.25, x, y, z)
				                Line(x-s, y, z, x+s, y, z)
				                Line(x, y-s, z, x, y+s, z)
				           	else
				           		local sx,sy = WorldToScreen(x,y,z)
								if sx and sy then
									if scx and scy then
										sy = sy + wf_top
										local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
										if d < max(80 - dist, 25) then
											if GetKeyState(0x02) == true then
												InteractUnit(o)
												Squid_Alert("Helping you click the crystal", ":)")
											end
										end
									end
								end
				            end
				        end
					end
				end
			else
				SQUID.poisoned_vial = nil
			end

			local torghast = map_id == 2162
			if torghast then
				
				local anima_orbs = {
					[336799] = "Anima Hoard",	-- Common Powers? Rare Powers?
					[330193] = "Anima Cell",	-- Rare Powers?
					[323351] = "Anima Cell",	-- Heart, Heart, Sword - Common, Uncommon, Common
					[325740] = "Plundered Cell",-- Heart, Heart - Uncommon, Common
					[324030] = "Anima Cell", 	-- Common Powers?
					[338483] = "Anima Cell",
					[324031] = "Anima Hoard",
					[325758] = "Prisoner's Anima",
				}

				local vases = {
					[164698] = "Vase", -- normal vase
					[165523] = "Vase", -- normal vase?

					[167986] = "Orb Vase", -- is got a orbz in it
				}

				local souls = {
					[169640] = "Tormented Soul Remnant",
					[169716] = "Tormented Soul Remnant",
					[169787] = "Tormented Soul Remnant",
					-- [169560] = "soul placeholder?",
					[169902] = "Click Me",--"Bound Soul Remnant",
					[157561] = "Click Me",--"Bound Soul Remnant",
					[169785] = "Click Me",--"Bound Soul Remnant",
					[169480] = "Unchain Me",--"Heavily Bound Soul Remnant",
					[171159] = "Walk Over Me",--"Unraveling Soul Remnant",
					[169628] = "Tormented Soul Remnant",
					[169782] = "Click Me",--"Bound Soul Remnant",
					[171166] = "Walk Over Me",--"Unraveling Soul Remnant",
				}

				local random_objects = {
					[166660] = "Lever",
					[167003] = "Lever",
				}

				local vaults = {
					[164624] = "Rune Locked Vault",
				}

				for i=1,#Objects do
					local o = Objects[i]
					local id = ObjectID(o)
					local name = ObjectName(o)
					local is_vase = vases[id]
					local is_anima = anima_orbs[id]
					local is_soul = souls[id]
					local is_vault = vaults[id]
					local replenishment_orb = id == 26911
					local lootable = UnitCanBeLooted(o)
					local is_exit = id == 156480
					local is_key = name == "Spectral Key"

					if is_key then
						local x,y,z = ObjectPosition(o)
						if x and y and z and GetDistanceBetweenPositions(px,py,pz,x,y,z) > 8 then
							local texture = {
								texture = 134248,
								width = 25, height = 25,
								alpha = 1,
							}
							LibDraw.SetColorRaw(0,1,0,1)
							LibDraw.Texture(texture,x,y,z);
						end
					end

					if is_exit then
						local x,y,z = ObjectPosition(o)
						if x and y and z and GetDistanceBetweenPositions(px,py,pz,x,y,z) > 35 + (not TraceLine(px,py,pz+2,x,y,z+2,0x100111) and 100 or 0) then
							local texture = {
								texture = 135743,
								width = 85, height = 85,
								alpha = 1,
							}
							LibDraw.Texture(texture,x,y,z);
						end
					end

					if is_vault and _distance(o) > 5 then
						local x,y,z = ObjectPosition(o)
						local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
						local a = (100 - dist) / 100
						if a > 1 then a = 1 end
						if a < .3 then a = .3 end
						local texture = {
							texture = 413587,
							width = 38, height = 38,
							alpha = a,
						}
						LibDraw.SetColorRaw(0,1,0,1)
						LibDraw.Texture(texture,x,y,z);
						LibDraw.Text(name, "GameFontNormal", x,y,z+4)
					end

					if lootable then
						local x,y,z = ObjectPosition(o)
						if x and y and z then
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end
							local texture = {
								texture = 133784,
								width = 38, height = 38,
								alpha = a,
							}
							LibDraw.Texture(texture,x,y,z);
						end
					end

					if replenishment_orb then
						local x,y,z = ObjectPosition(o)
						if x and y and z then
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end
							local hp = {
								texture = 136041,
								width = 38, height = 38,
								alpha = a,
							}
							LibDraw.Texture(hp,x,y,z);
						end
					end

					if is_vase then
						local x,y,z = ObjectPosition(o)
						if x and y and z then
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end
							local vase 

							if is_vase == "Vase" then 
								vase = {
									texture = 133748,
									width = 35, height = 35,
									alpha = a,
								}
							else
								vase = {
									texture = 1119885,
									width = 45, height = 45,
									alpha = 1,
								}
							end
							LibDraw.Texture(vase,x,y,z);
						end
					end

					if is_anima then
						local x,y,z = ObjectPosition(o)
						if x and y and z then
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .5 then a = .5 end
							local orb = {
								texture = 348545,
								width = 40 - (a*3), height = 40 - (a*3),
								alpha = a,
							}
							LibDraw.SetColorRaw(0,1,0,1)
							LibDraw.Texture(orb,x,y,z+4);
							LibDraw.Text(name, "GameFontNormal", x,y,z+2)
							if AutoFollow and dist < 5 then
								InteractUnit(o)
							end
						end
					end

					if is_soul then
						local x,y,z = ObjectPosition(o)
						if x and y and z then
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .5 then a = .5 end
							local soul = {
								texture = 463284,
								width = 42 - (a*3), height = 42 - (a*3),
								alpha = a,
							}
							LibDraw.SetColorRaw(0,1,0,1)
							LibDraw.Texture(soul,x,y,z);
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							if dist < 45 then
								LibDraw.Text(is_soul, "GameFontNormal", x,y,z+3.75)
							end
						end
					end

					if is_cache then
						LibDraw.SetColorRaw(0,1,0,1)
						local x,y,z = ObjectPosition(o)

						local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

						local a = (100 - dist) / 100
						if a > 1 then a = 1 end
						if a < .3 then a = .3 end
						
						local s = .65 + max(.5,a)

						local r,g,b = 1,1,1

		                LibDraw.SetColorRaw(r,g,b,1)

		                if x and y and z then
			                LibDraw.Text("Cache" .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

			                LibDraw.SetWidth(s * 2)

			                if dist > 4.9 then
				                Line(x, y, z+s*1.25, x, y, z)
				                Line(x-s, y, z, x+s, y, z)
				                Line(x, y-s, z, x, y+s, z)
				           	else
				           		local sx,sy = WorldToScreen(x,y,z)
								if sx and sy then
									if scx and scy then
										sy = sy + wf_top
										local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
										if d < max(80 - dist, 25) then
											if GetKeyState(0x02) == true then
												InteractUnit(o)
												Squid_Alert("Helping you click the cache", ":)")
											end
										end
									end
								end
				            end
				        end
					end
					if is_bomb then
						local x,y,z = ObjectPosition(o)
						local r,g,b = .4,.4,.7
		                LibDraw.SetColorRaw(r,g,b,1)
		                if x and y and z then
		                	LibDraw.Text("Bomb", "GameFontNormal", x, y, z+3.5)
		                end
					end
					if is_cage then
						local x,y,z = ObjectPosition(o)
						local r,g,b = .4,.4,.7
		                LibDraw.SetColorRaw(r,g,b,1)
		                if x and y and z then
		                	LibDraw.Text("Cage", "GameFontNormal", x, y, z+3.5)
		                end
					end
					if is_crystal then
						local x,y,z = ObjectPosition(o)

						local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

						local a = (100 - dist) / 100
						if a > 1 then a = 1 end
						if a < .3 then a = .3 end
						
						local s = .65 + max(.5,a)

						local r,g,b = 1,.749,0

		                LibDraw.SetColorRaw(r,g,b,1)

		                if x and y and z then
			                LibDraw.Text("Crystal" .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

			                LibDraw.SetWidth(s * 2)

			                if dist > 4.9 then
				                Line(x, y, z+s*1.25, x, y, z)
				                Line(x-s, y, z, x+s, y, z)
				                Line(x, y-s, z, x, y+s, z)
				           	else
				           		local sx,sy = WorldToScreen(x,y,z)
								if sx and sy then
									if scx and scy then
										sy = sy + wf_top
										local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
										if d < max(80 - dist, 25) then
											if GetKeyState(0x02) == true then
												InteractUnit(o)
												Squid_Alert("Helping you click the crystal", ":)")
											end
										end
									end
								end
				            end
				        end
					end
				end


			end -- end torghast

			-- draw all objects with names
			if SQUID.draw_objects then
				if #SQUID.objects_to_draw > 0 then
					for i=1,#Objects do if not draw_only_dead_objs or time - draw_only_dead_objs > 3 or UnitIsDead(Objects[i]) then
						local name=ObjectName(Objects[i])
						--RARE FINDER
						if SQUID.rare_finder then
							local classification = UnitClassification(Objects[i])
							if classification == "rareelite" then
								local x,y,z = ObjectPosition(Objects[i])
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								if UnitIsDead(Objects[i]) then
									LibDraw.SetColorRaw(1, .5, .2, .8)
								else
									LibDraw.SetColorRaw(.3, 1, .02, 1)
								end

								if mo_names then
									local sx,sy = WorldToScreen(x,y,z)
									if sx and sy then
										if scx and scy then
											sy = sy + wf_top
											local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
											if d < max(80 - dist, 25) then
												LibDraw.Text(name .. " - " .. dist, "GameFontNormal", x, y, z+4)
												if dist < 4.8 then
													if GetKeyState(0x02) == true then
														InteractUnit(Objects[i])
														Squid_Alert("Interacting with",name)
													end
												end
											end
										end
									end
								else
									LibDraw.Text(name .. " - " .. dist, "GameFontNormal", x, y, z+4)
								end

								local a = (100 - dist) / 100
								local g = a

								if a > 1 then a = 1 end
								if a < .75 then a = .75 end
								local w = 3 + (a * 2)

								LibDraw.SetWidth(w)

								local r = 1
								local g = .87
								local b = 0

								local s = 1 + a

								LibDraw.SetColorRaw(r, g, b, a)

								Line(px,py,pz,x,y,z)

								Line(x, y, z+s*1.5, x, y, z)
				                Line(x-s, y, z, x+s, y, z)
				                Line(x, y-s, z, x, y+s, z)
							end
						end
						local pow = math.pow
						--OBJECT FINDER
						for n=1,#SQUID.objects_to_draw do
							if name and strmatch(strlower(name):gsub("%s+",""),SQUID.objects_to_draw[n]) then
								local x,y,z = ObjectPosition(Objects[i])
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								if name ~= player_name and dist < SQUID.max_object_finder_dist and x and y and z then
									
									if UnitIsDead(Objects[i]) then
										LibDraw.SetColorRaw(1, .5, .2, .8)
									else
										LibDraw.SetColorRaw(.3, 1, .02, 1)
									end

									if mo_names then
										local sx,sy = WorldToScreen(x,y,z)
										if sx and sy then
											if scx and scy then
												sy = sy + wf_top
												local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
												if d < max(80 - dist, 25) then
													LibDraw.Text(name .. " - " .. dist, "GameFontNormal", x, y, z+3.5)
													if dist < 4.8 then
														if GetKeyState(0x02) == true then
															InteractUnit(Objects[i])
															Squid_Alert("Interacting with",name)
														end
													end
												end
											end
										end
									else
										LibDraw.Text(name .. " - " .. dist, "GameFontNormal", x, y, z+3.5)
									end

								 	local a = (100 - dist) / 100
								 	local g = a
									if a > 1 then a = 1 end
									if a < .3 then a = .3 end
									if g > 1 then g = 1 end
									if g < 0 then g = 0 end
									local s = 1 + max(.5,a)
					                LibDraw.SetColor(255,0,0)
					                LibDraw.SetWidth(s * 2)
					                if dist > 4 then
						                Line(x, y, z+s*1.5, x, y, z)
						                Line(x-s, y, z, x+s, y, z)
						                Line(x, y-s, z, x, y+s, z)
						            end
									if SQUID.draw_line_to_objects then

										local w = 2 + (a * 4)
										LibDraw.SetWidth(w)
										local r = 1
										r = r - g
										LibDraw.SetColorRaw(r, g, 0, a)
										Line(px,py,pz,x,y,z)
									end
									if SQUID.auto_interact_objects then
										if dist < 10 then
											-- if not OBJECT_INTERACT_TIME or time - OBJECT_INTERACT_TIME > 1.5 then
												Squid_Alert("Interacting with ",name)
												InteractUnit(Objects[i])
												OBJECT_INTERACT_TIME=time
											-- end
										elseif test_move_thing then
											local x,y,z = ObjectPosition(Objects[i])
											MoveTo(x,y,z)
										end
									end
								end
							end
						end
					end end
				else
					-- no
					-- for i=1,#Objects do
					-- 	local name=ObjectName(Objects[i])
					-- 	local x,y,z=ObjectPosition(Objects[i],true)
					-- 	local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
					-- 	if name ~= player_name and dist < SQUID.max_object_finder_dist then
					-- 		LibDraw.SetColorRaw(.2, .8, .4, .6)
					-- 		LibDraw.Text(name .. " - " .. dist, SquidFont, x, y, z+2)
					-- 		if SQUID.draw_line_to_objects then
					-- 			LibDraw.SetWidth(15)
					-- 			LibDraw.SetColorRaw(1, 0, .87, 1)
					-- 			Line(px,py,pz,x,y,z)
					-- 		end
					-- 	end
					-- end
				end
				if ZygorGuidesViewerFrame then
					local already_tracked = {}
					local blacklist = {"Watch","Accept","Turn","to"}
					-- for i=1,6 do
						-- local line = _G["ZygorGuidesViewerPointerArrow_StealthTitle"]
						-- if line then
						-- 	local text = line:GetText()
						-- 	if text then
						-- 		words = {strsplit(" ",text)}
						-- 		for n=1,#words do
						-- 			if string.len(words[n]) >= 5 and not tContains(blacklist,words[n]) then
						-- 				for j=1,#Objects do
						-- 					local t = Objects[j]
						-- 					local name = ObjectName(t)
						-- 					if not tContains(already_tracked,t) and name and strmatch(strlower(name):gsub("%s+",""),strlower(words[n])) then
						-- 						table.insert(already_tracked,t)
						-- 						local x,y,z=ObjectPosition(t,true)
						-- 						local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
						-- 						if UnitIsDead(t) then
						-- 							LibDraw.SetColorRaw(1, .5, .2, .8)
						-- 						else
						-- 							LibDraw.SetColorRaw(.2, .8, .4, .8)
						-- 						end
						-- 						LibDraw.Text(name .. " - " .. dist, SquidFont, x, y, z+2)
						-- 						if SQUID.draw_line_to_objects then
						-- 							LibDraw.SetWidth(3)
						-- 							LibDraw.SetColorRaw(1, 0, .87, 1)
						-- 							Line(px,py,pz,x,y,z)
						-- 						end
						-- 						if SQUID.auto_interact_objects then
						-- 							if dist < 5 then
						-- 								-- if not OBJECT_INTERACT_TIME or time - OBJECT_INTERACT_TIME > 1.5 then
						-- 									Squid_Alert("Interacting with ",name)
						-- 									InteractUnit(t)
						-- 									OBJECT_INTERACT_TIME=time
						-- 								-- end
						-- 							end
						-- 						end
						-- 					end
						-- 				end
						-- 			end
						-- 			-- print(words[n])
						-- 		end
						-- 	end
						-- end
				end
				-- end
				local object_prefixes = {
					"Click",
					"Kill",
					"Collect",
					"Talk to",
					"Use it on",
					"Extinguish"
				}
				local useless_suffixes = {
					"enemies around this area",
					"around this area",
					"around the area",
					"inside the cave",
				}
				local escapes = {
				    ["|c%x%x%x%x%x%x%x%x"] = "", -- color start
				    ["|r"] = "", -- color end
				    ["|H.-|h(.-)|h"] = "%1", -- links
				    ["|T.-|t"] = "", -- textures
				    ["{.-}"] = "", -- raid target icons
				}
				local function unescape(str)
				    for k, v in pairs(escapes) do
				        str = gsub(str, k, v)
				    end
				    return str
				end

				local index = 1
				local obj_name_cache = {}
				local obj_name = function(obj)
					if obj_name_cache[obj] then return obj_name_cache[obj] end
					local name = ObjectName(obj)
					obj_name_cache[obj] = name
					return name
				end

				local tracking = {}
				Debug_Tracking_Table = tracking
				for step = 1,5 do
					for line = 1,10 do
						local content = _G["ZygorGuidesViewerFrame_Step"..step.."_Line"..line.."Content"]
						if content then
							local label = content.label
							if label then 
								label = label:GetText()
								if type(label) == "string" then
									label = unescape(label)
									for i=1,#object_prefixes do
										if string.match(label,object_prefixes[i]) then
											label = string.gsub(label,object_prefixes[i],"")
											for n=1,#useless_suffixes do
												label = string.gsub(label,useless_suffixes[n],"")
											end
											label = string.gsub(label, "%s*", "")
											local amt = strmatch(label,"[0-9]+")
											if amt then amt = tonumber(amt) end
											label = string.gsub(label, "[0-9]", "")
											if amt and amt > 0 then
												label = string.gsub(label, "%([^()]*%)","")
												if string.sub(label,-3) == "ies" then
													label = string.sub(label, 1, -4)
												end
												label = string.gsub(label, "s$", "")
												label = string.gsub(label, "%s*", "")
											end
											-- print(label,amt)
											-- print(label)
											if label and type(label) == "string" and label ~= "" then
												table.insert(tracking,strlower(label))
											end
										end
									end
								end
							end
						end
					end
				end
				local function is_tracked(name)
					for i=1,#tracking do
						if strmatch(name,tracking[i]) or strmatch(tracking[i],name) then return true end
					end
				end
				if #tracking > 0 then
					for i=1,#Objects do
						local t = Objects[i]
						local name
						local og_name = obj_name(t)
						if og_name then
							name = strlower(og_name)
							name = string.gsub(name, "%s*", "")
						end
						if name and is_tracked(name) then
							local x,y,z=ObjectPosition(t)
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							if dist < SQUID.max_object_finder_dist then
								if UnitIsDead(t) then
									LibDraw.SetColorRaw(1, .5, .2, .8)
								else
									LibDraw.SetColorRaw(.2, .8, .4, .8)
								end
								LibDraw.Text(og_name .. " - " .. dist, SquidFont, x, y, z+2)
								if SQUID.draw_line_to_objects then
									local a = (100 - dist) / 100
									if a < .125 then a = .125 end
									if a > 1 then a = 1 end
									LibDraw.SetWidth(a * 3 + (dist < 15 and 1.5 or 0))
									LibDraw.SetColorRaw(a, a/2, 1 - a, a)
									Line(px,py,pz,x,y,z)
								end
								if SQUID.auto_interact_objects then
									if dist < 5 then
										-- if not OBJECT_INTERACT_TIME or time - OBJECT_INTERACT_TIME > 1.5 then
											Squid_Alert("Interacting with ",og_name)
											InteractUnit(t)
											OBJECT_INTERACT_TIME=time
										-- end
									end
								end
							end
						end
					end
				end
			end

			FLOWER_EXISTS = nil
			--flower draw
			for i=1,#Squid_OM do
				local o = Squid_OM[i]
				if ObjectID(o) == 164589 and UnitCanAttack("player",o) then
					-- print("flower found")
					local x,y,z = ObjectPosition(o)
					if x and y and z then
						-- print("xyz good")
						x, y, z = GroundZ(x,y,z) or x, y, z

						LibDraw.SetWidth(18)
	                    LibDraw.SetColorRaw(1, 0, 1, 1)

	                    local s = 2
	                    Line(x, y, z+s*2, x, y, z)
	                    Line(x, y, z-s*2, x, y, z)
	                    Line(x-s, y, z, x+s, y, z)
	                    Line(x, y-s, z, x, y+s, z)

	                    local wf_top = WorldFrame:GetTop()
	                	local scx,scy = GetCursorPosition()
						local sx,sy = WorldToScreen(x,y,z)
						local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
						if sx and sy then
							if scx and scy then
								sy = sy + wf_top
								local d = sqrt( math.pow(scx - sx, 2) + math.pow(scy - sy, 2) )
								if d < max(200 - dist, 35) then
									LibDraw.Text(name, "GameFontNormalSmall", x, y, z+2)
									if GetKeyState(0x1) and not GetKeyState(0x2) then
										C_Timer.After(.1,function() 
											TargetUnit(o)
											Squid_Alert("Podtender Targeted", nil, 6, nil, 267026)
										end)
									end
									if not flower_targeted or GetTime() - flower_targeted > 5 then
										TargetUnit(o)
										Squid_Alert("Podtender Targeted", nil, 6, nil, 267026)
										flower_targeted = GetTime()
									end
								end
							end
						end

						if not flower_targeted or GetTime() - flower_targeted > 8 then
							TargetUnit(o)
							Squid_Alert("Podtender Targeted", nil, 6, nil, 267026)
							flower_targeted = GetTime()
						end
						FLOWER_EXISTS = o
					end
				end
			end

			--Circle at cursor drawing for PetPlayer
		 	if PetPlayerDraw then
		 		local x,y,z = WorldPositionFromCursor()
		 		if x and y and z then
			 		LibDraw.SetColorRaw(1, 0, 0, 1)
			 		LibDraw.Circle(x, y, z, 2)
			 	end
		 	end

		 	--circle and text at port location
		 	if UnitBuffID("player",101643) then
		 		--coords of port already saved from combat log events
		 		if portcoords and portcoords.situated then
		 			local x,y,z = portcoords.x,portcoords.y,portcoords.z
		 			if x and y and z then
		 				local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
		 				--port circle ( red when out of range )
		 				if dist >= 40 then
		 					LibDraw.SetColorRaw(.8, .2, .4, .5)
		 				else
			 				LibDraw.SetColorRaw(.2, .8, .4, .6)
			 			end
			 			LibDraw.Circle(x, y, z, 2)
			 			--dist text
			 			LibDraw.Text(dist .. " yds", SquidFont, x, y, z+2)
		 			end
		 		else -- otherwise we have to find the object and get its coords
		 			local playername=UnitName("player")
		 			for i=1,#Objects do
		 				local name=ObjectName(Objects[i])
		 				if name == playername and not unit_is_unit("player",Objects[i]) and UnitCreatureID(Objects[i]) <= 55000 then
		 					local x,y,z = ObjectPosition(Objects[i])
		 					local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
			 				--port circle ( red when out of range )
			 				if dist >= 40 then
			 					LibDraw.SetColorRaw(.8, .2, .4, .5)
			 				else
				 				LibDraw.SetColorRaw(.2, .8, .4, .6)
				 			end
				 			LibDraw.Circle(x, y, z, 2)
				 			--dist text
				 			LibDraw.Text(dist .. " yds", SquidFont, x, y, z+2)

		 					if _buffRemains("player",101643) < 895 then
			 					portcoords = {}
					 			portcoords.x=x
					 			portcoords.y=y
					 			portcoords.z=z
					 			portcoords.situated=true
					 		end
		 				end
		 			end
		 		end
		 	end


		 	--greenscreen
			if squid_greenscreen then
				local green = {
				texture = 1111111,
				width = 5000, height = 5000,
				alpha = 1,
				}
				LibDraw.Texture(green,px,py,pz);
			end

		end)
		LibDraw.Enable(0.01)

		libdraw_init=true
	end

	--gui
	if cfe and not Squid_GUI_Init then

		-- local sq_mm = CreateFrame("Frame")

		--minimap shit
		-- local MiniMapX, MiniMapY = -54.6, 58.8
		-- local minimapShapes = {
		-- 	["ROUND"] = {true, true, true, true},
		-- 	["SQUARE"] = {false, false, false, false},
		-- 	["CORNER-TOPLEFT"] = {true, false, false, false},
		-- 	["CORNER-TOPRIGHT"] = {false, false, true, false},
		-- 	["CORNER-BOTTOMLEFT"] = {false, true, false, false},
		-- 	["CORNER-BOTTOMRIGHT"] = {false, false, false, true},
		-- 	["SIDE-LEFT"] = {true, true, false, false},
		-- 	["SIDE-RIGHT"] = {false, false, true, true},
		-- 	["SIDE-TOP"] = {true, false, true, false},
		-- 	["SIDE-BOTTOM"] = {false, true, false, true},
		-- 	["TRICORNER-TOPLEFT"] = {true, true, true, false},
		-- 	["TRICORNER-TOPRIGHT"] = {true, false, true, true},
		-- 	["TRICORNER-BOTTOMLEFT"] = {true, true, false, true},
		-- 	["TRICORNER-BOTTOMRIGHT"] = {false, true, true, true},
		-- }
		-- sq_mm.MiniMap = CreateFrame("Button", "Minimap", Minimap)
		-- sq_mm.MiniMap:SetFrameStrata("MEDIUM")
		-- sq_mm.MiniMap:SetWidth(31)
		-- sq_mm.MiniMap:SetHeight(31)
		-- sq_mm.MiniMap:RegisterForClicks("AnyUp")
		-- sq_mm.MiniMap:RegisterForDrag("RightButton")
		-- sq_mm.MiniMap:RegisterForDrag("LeftButton")
		-- sq_mm.MiniMap:SetFrameLevel(8)
		-- sq_mm.MiniMap:SetHighlightTexture("Interface\\Minimap\\UI-Minimap-ZoomButton-Highlight")
		-- sq_mm.MiniMap:SetPoint("CENTER", MiniMapX, MiniMapY)
		-- if MinimapDisplay then
		-- 	sq_mm.MiniMap:Show()
		-- end
		
		-- sq_mm.MinimapOverlay = sq_mm.MiniMap:CreateTexture(nil, "OVERLAY")
		-- sq_mm.MinimapOverlay:SetWidth(53)
		-- sq_mm.MinimapOverlay:SetHeight(53)
		-- sq_mm.MinimapOverlay:SetTexture("Interface\\AddOns\\xenRotations\\Memes\\xrborderoff.blp")
		-- sq_mm.MinimapOverlay:SetPoint("TOPLEFT")
		-- local MinimapOverlay = sq_mm.MinimapOverlay
		
		-- --Overlay texture changes based on xrStart
		-- function _xrMMoverlay()
		-- 	if SquidLobster and MinimapOverlay:GetTexture() ~= "Interface\\AddOns\\xenRotations\\Memes\\xrborder.blp" then
		-- 		MinimapOverlay:SetTexture("Interface\\AddOns\\xenRotations\\Memes\\xrborder.blp")
		-- 	end
		-- 	if not SquidLobster and MinimapOverlay:GetTexture() ~= "Interface\\AddOns\\xenRotations\\Memes\\xrborderoff.blp" then
		-- 		MinimapOverlay:SetTexture("Interface\\AddOns\\xenRotations\\Memes\\xrborderoff.blp")
		-- 	end
		-- end
		-- MinimapOverlayChange = CreateFrame("Frame")
		-- MinimapOverlayChange:SetScript("OnUpdate",_xrMMoverlay)
		
		-- MinimapBG = sq_mm.MiniMap:CreateTexture(nil, "BACKGROUND")
		-- MinimapBG:SetWidth(20)
		-- MinimapBG:SetHeight(20)
		-- MinimapBG:SetTexture("Interface\\Minimap\\UI-Minimap-Background")
		-- MinimapBG:SetPoint("TOPLEFT", 7, -5)
		-- MinimapIcon = sq_mm.MiniMap:CreateTexture(nil, "ARTWORK")
		-- MinimapIcon:SetWidth(20)
		-- MinimapIcon:SetHeight(20)	
		-- MinimapIcon:SetTexture("Interface\\AddOns\\xenRotations\\Memes\\xroff.blp")
		-- MinimapIcon:SetTexCoord(0.05, 0.95, 0.05, 0.95)
		-- MinimapIcon:SetPoint("TOPLEFT", 7, -5)
		-- sq_mm.MiniMap:SetScript("OnClick", function(self, clickType)
		-- 	if clickType == "LeftButton" then
		-- 		SquidToggle();
		-- 	elseif clickType == "RightButton" then
		-- 		if sq_mm.kickFrame:IsShown() then
		-- 			sq_mm.kickFrame:Hide()
		-- 			sq_mm.kickFrame.kickSlider:Hide()
		-- 		else
		-- 			sq_mm.kickFrame:Show()
		-- 			sq_mm.kickFrame.kickSlider:Show()
		-- 		end
		-- 	end
		-- end)
		-- sq_mm.MiniMap:SetScript("OnDragStart", function(self, btn)
		-- 	self.dragging = true
		-- 	self:LockHighlight()
		-- 	MinimapIcon:SetTexCoord(0, 1, 0, 1)
		-- 	self:SetScript("OnUpdate", function(self, btn)
		-- 		local mx, my = Minimap:GetCenter()
		-- 		local px, py = GetCursorPosition()
		-- 		local scale = Minimap:GetEffectiveScale()
		-- 		px, py = px / scale, py / scale
		-- 		local deg = math.deg(math.atan2(py - my, px - mx)) % 360
		-- 		local angle = math.rad(deg)
		-- 		local x, y, q = math.cos(angle), math.sin(angle), 1
		-- 		if x < 0 then q = q + 1 end
		-- 		if y > 0 then q = q + 2 end
		-- 		local minimapShape = GetMinimapShape and GetMinimapShape() or "ROUND"
		-- 		local quadTable = minimapShapes[minimapShape]
		-- 		if quadTable[q] then
		-- 			x, y = x*80, y*80
		-- 		else
		-- 			local diagRadius = 103.13708498985
		-- 			x = math.max(-80, math.min(x*diagRadius, 80))
		-- 			y = math.max(-80, math.min(y*diagRadius, 80))
		-- 		end
		-- 		self:SetPoint("CENTER", self:GetParent(), "CENTER", x, y)
		-- 		MiniMapX = x
		-- 		MiniMapY = y
		-- 	end)
		-- 	GameTooltip:Hide()
		-- end)
		-- sq_mm.MiniMap:SetScript("OnDragStop", function(self, btn)
		-- 	self.dragging = nil
		-- 	self:SetScript("OnUpdate", nil)
		-- 	MinimapIcon:SetTexCoord(0.05, 0.95, 0.05, 0.95)
		-- 	self:UnlockHighlight()
		-- end)

		local squid_bg = Squid_Directory() .. "/media/squidbgfile.blp"
		local squid_button = Squid_Directory() .. "/media/squidbutton.blp"
		local squid_icon_checked = Squid_Directory() .. "/media/squid_icon_checked.blp"
		local squid_icon_unchecked = Squid_Directory() .. "/media/squid_icon_unchecked.blp"
		local squid_slider_thumb = Squid_Directory() .. "/media/sliderthumb.blp"
		local squid_slider_thumb_new = Squid_Directory() .. "/media/sliderthumb2.blp"
		--init frame (???)
		local init_frame = CreateFrame("Frame")
		init_frame:GetWidth()

		local backdrop = {
		bgFile = squid_bg,
		tileSize = 256,
		edgeFile = nil,--"Interface\\FriendsFrame\\UI-Toast-Border",
		tile = 1,
		edgeSize = 3,
		insets = {
			top = 0, --2
			right = 0, --2
			left = 0, --3
			bottom = 0, --3
		 	}
		}

		local backdrop2 = {
		bgFile = squid_bg,
		tileSize = 900,
		edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
		tile = 1,
		edgeSize = 2,
		insets = {
			top = 0, --2
			right = 0, --2
			left = 0, --3
			bottom = 0, --3
		 	}
		}

		local backdrop3 = {
		bgFile = "Interface/Tooltips/UI-Tooltip-Background",
		tileSize = 900,
		edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
		tile = 1,
		edgeSize = 2,
		insets = {
			top = 0, --2
			right = 0, --2
			left = 0, --3
			bottom = 0, --3
		 	}
		}

		local slider_backdrop = {
		bgFile = nil,
		tileSize = 8,
		edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
		tile = 1,
		edgeSize = 4,
		insets = {
			top = 0, --2
			right = 0, --2
			left = 0, --3
			bottom = 0, --3
		 	}
		}

		local slider_backdrop2 = {
		bgFile = "Interface/Tooltips/UI-Tooltip-Background",
		tileSize = 8,
		edgeFile = nil,--"Interface\\FriendsFrame\\UI-Toast-Border",
		tile = 1,
		edgeSize = 5,
		insets = {
			top = 0, --2
			right = 2, --2
			left = 2, --3
			bottom = 0, --3
		 	}
		}

		local slider_backdrop3 = {
		bgFile = "Interface/Tooltips/UI-Tooltip-Background",
		tileSize = 8,
		edgeFile = nil,--"Interface\\FriendsFrame\\UI-Toast-Border",
		tile = 1,
		edgeSize = 0,
		insets = {
			top = 0, --2
			right = 12, --2
			left = 12, --3
			bottom = 0, --3
		 	}
		}

		SQFRAMEHOLDER = CreateFrame("Frame", nil, BackdropTemplate);

		-- create the frame that will hold all other frames/objects:
		local f = SQFRAMEHOLDER or CreateFrame("Frame", nil, BackdropTemplate); -- re-size this to whatever size you wish your ScrollFrame to be, at this point
		Mixin(f, BackdropTemplateMixin)
		f:SetBackdrop(backdrop)
		f:SetHeight(250)
		f:SetWidth(450)
		if SQUID.gui_coords.a1 then -- keep gui pos where user likes it
			local a1,a2,x,y = SQUID.gui_coords.a1,SQUID.gui_coords.a2,SQUID.gui_coords.x,SQUID.gui_coords.y
			f:SetPoint(a1,nil,a2,x,y)
		else
			f:SetPoint("CENTER",230,-20)
		end
		f:SetFrameStrata("HIGH")
		f:SetMovable(true)
		f:SetScript("OnMouseUp",function(self) self:StopMovingOrSizing() local a1,_,a2,x,y = self:GetPoint() SQUID.gui_coords = {a1=a1,a2=a2,x=x,y=y} end)
		f:SetScript("OnMouseDown",function(self) self:StartMoving() end)

		-- logotext
		f.logo_text = f:CreateFontString(f,"HIGH")
		f.logo_text:SetFont(sui,18)
		f.logo_text:SetText("project squid")
		f.logo_text:SetPoint("TOPLEFT",f,"TOPLEFT",8.1,-8.1)
		-- versiontext
		-- f.version_text = f:CreateFontString(f,"HIGH")
		-- f.version_text:SetFont(sui,8)
		-- f.version_text:SetText("v." .. squid_version)
		-- f.version_text:SetPoint("TOPLEFT",f,"TOPLEFT",95.5,-26)

		--epic changey rgb logo squiddo
		local r = 230
		local g = 230
		local b = 250
		local r_dir = "b"
		local g_dir = "f"
		local b_dir = "f"
		local tick = 0
		f:SetScript("OnUpdate",function()
			tick = tick + 1
			if tick >= 15 then
				if r_dir == "f" then
					r = r + 1--math.random(1,2)
				else
					r = r - 1--math.random(1,2)
				end
				if g_dir == "f" then
					g = g + 1--math.random(1,2)
				else
					g = g - 1--math.random(1,2)
				end
				if b_dir == "f" then
					b = b + 1--math.random(1,2)
				else
					b = b - 1--math.random(1,2)
				end

				-- we like lighter color
				-- if math.random(1,6) == 4 then
				-- 	r_dir = "f"
				-- 	b_dir = "f"
				-- end

				if r > 211 then
					r = 211
					r_dir = "b"
				elseif r < 164 then
					r = 164
					r_dir = "f"
				end

				if g > 164 then
					g = 164
					g_dir = "b"
				elseif g < 132 then
					g = 132
					g_dir = "f"
				end

				if b > 244 then
					b = 244
					b_dir = "b"
				elseif b < 182 then
					b = 182
					b_dir = "f"
				end

				-- if r > 230 then
				-- 	r = 230
				-- 	r_dir = "b"
				-- elseif r < 148 then
				-- 	r = 148
				-- 	r_dir = "f"
				-- elseif r > 160 and b < 200 then
				-- 	r_dir = "b"
				-- end
				-- if g > 220 then
				-- 	g = 220
				-- 	g_dir = "b"
				-- elseif g < 72 then
				-- 	g = 72
				-- 	g_dir = "f"
				-- elseif g > 140 and (r < 160 or b < 160) then
				-- 	g_dir = "b"
				-- end
				-- if b > 240 then
				-- 	b = 240
				-- 	b_dir = "b"
				-- elseif b < 140 then
				-- 	b = 140
				-- 	b_dir = "f"
				-- elseif b > 180 and r < 160 then
				-- 	b_dir = "b"
				-- end
				f.logo_text:SetTextColor(r/255,g/255,b/255)
				tick = 0
			end
		end)

		--TAB SECTION
		local tabs = {}
		f.tab_section =  CreateFrame("Frame", f, BackdropTemplate)
		f.tab_section:SetParent(f)
		Mixin(f.tab_section, BackdropTemplateMixin)
		f.tab_section:SetBackdrop(backdrop)
		f.tab_section:SetBackdropColor(0,0,0,0)
		f.tab_section:SetHeight(175)
		f.tab_section:SetWidth(110)
		f.tab_section:SetPoint("BOTTOMLEFT",f,"BOTTOMLEFT",5,20)

		f.tab_section.scroll_position = 1 -- default scroll position
		f.tab_section.input = {} -- holds recent scroll input history (each scroll tick, with the time it was sent allowing for our smooth scrolling to work.)
		f.tab_section.momentum = {} -- momentum of scrolling speed

		f.tab_section.VIEWABLE_HEIGHT = f.tab_section:GetHeight()
		f.tab_section.SCROLLABLE_HEIGHT = f.tab_section:GetHeight()
		f.tab_section.USED_HEIGHT = 0

		local scrollspace_mod = 8

		--current tab text : )
		f.tab_text = f:CreateFontString(f,"HIGH")
		f.tab_text:SetFont(sui_bold,16)
		f.tab_text:SetText(current_tab or "No Tab Selected")
		f.tab_text:SetTextColor(155/255, 155/255, 254/255, 1)
		f.tab_text:SetPoint("TOP",f,"TOP",50,-20)

		local current_tab

		--new populate
		local function populate(name, hide_columns)
			recent_population = GetTime()
			if hide_columns then
				f.c1:Hide()
				f.c2:Hide()
				-- do custom shit that covers the whole GUI ? yeah but make it an element i guess
			else
				f.c1:Show()
				f.c2:Show()
			end
			for i=1,#f.tab_section.tabs do
				local tab = f.tab_section.tabs[i]
				--populate the columns with elements from the tabs
				if tab.name == name then
					current_tab = tab
					tab.selected = true
					tab.adjust_scroll_position = tab.scroll_position
					tab.adjust_scroll_positionc2 = tab.scroll_positionc2
					tab:GetFontString():SetTextColor(255/255, 250/255, 254/255, 1)
					tab:GetFontString():SetFont(sui,18.5,'OUTLINE')
					f.tab_text:SetText(tab.name)
					local matching_elements = 0
					for n=1,#f.c1.elements do
						local e = f.c1.elements[n]
						if e.tab == tab then
							e:Show()
							matching_elements = matching_elements + 1
						end
					end
					for n=1,#f.c2.elements do
						local e = f.c2.elements[n]
						if e.tab == tab then
							e:Show()
							matching_elements = matching_elements + 1
						end
					end
					if matching_elements == 0 then
						f.c1:Hide()
						f.c2:Hide()
						tab.nothing_message:Show()
					end
				else --depopulate the other tabs
					tab:GetFontString():SetVertexColor(155/255, 155/255, 254/255, 1)
					tab:GetFontString():SetFont(sui,17)
					tab.selected = false
					for n=1,#f.c1.elements do
						local e = f.c1.elements[n]
						if e.tab == tab then
							e:Hide()
						end
					end
					for n=1,#f.c2.elements do
						local e = f.c2.elements[n]
						if e.tab == tab then
							e:Hide()
						end
					end
					tab.nothing_message:Hide()
				end
			end
		end

		populate_tab = populate

		--new gui createtab
		function create_gui_tab(properties)
			local text = properties.text
			local func = properties.func
			local parent = properties.parent
			local tab = CreateFrame("Button",nil,parent,nil,"UIPanelButtonTemplate")
			tab:SetFrameStrata("HIGH")

			tab.name=text

			tab:SetText(text)
			tab:SetNormalTexture(squid_button)
			tab:GetNormalTexture():SetVertexColor(1,1,1,0)
			tab:SetHighlightTexture(squid_button)
			tab:SetScript("OnClick",function(self) func(self.name) end)
			tab:GetFontString():SetFont(sui,17,nil)
			tab:GetFontString():SetTextColor(155/255, 155/255, 254/255, 1)
			
			tab:GetFontString():SetSize(105,17)
			tab:GetFontString():SetJustifyV("MIDDLE")
			tab:GetFontString():SetJustifyH("LEFT")

			tab:SetSize(95,24)
			
			tab:SetScript("OnEnter", function(self) if not self.selected then self:GetFontString():SetFont(sui,18.25,nil) self:GetFontString():SetTextColor(195/255, 195/255, 254/255, 1) end end)
			tab:SetScript("OnLeave", function(self) if not self.selected then self:GetFontString():SetFont(sui,17,nil) self:GetFontString():SetTextColor(155/255, 155/255, 254/255, 1) end end)

			if not parent.tabs then
				parent.tabs = {}
			end

			local space_between = tab:GetHeight()

			if #parent.tabs > 0 then
				local lta1,_,_,x,y = parent.tabs[#parent.tabs]:GetPoint()
				tab:SetPoint(lta1,x,y-space_between)
				tab.point = {tab:GetPoint()}
			else
				tab:SetPoint("TOP",parent,"TOP",0,0)
				tab.point = {tab:GetPoint()}
			end

			f.tab_alpha = CreateFrame("Frame")
			f.tab_alpha:SetParent(f)
			f.tab_alpha:SetScript("OnUpdate",function()
				local lta1,parent,lta2,x,y = unpack(tab.point)

				local cutoff = tab:GetHeight()
				tab:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
				lta1,_,_,x,y = tab:GetPoint() -- original coordinates
				local parent_height = parent:GetHeight()
				
				if y < -parent_height + cutoff then
					tab:SetAlpha(max(0, 1 - ((abs(y) - (parent_height-cutoff) ) / cutoff)))
				elseif y > 0 then
					tab:SetAlpha(max(0, 1 - (y/(cutoff+13))))
				else
					tab:SetAlpha(1)
				end

				if tab:GetAlpha() <= 0 then
					tab:Hide()
				else
					tab:Show()
				end
			end)

			tab.nothing_message = f:CreateFontString(f,"HIGH")
			tab.nothing_message:SetFont(sui_bold,11)
			tab.nothing_message:SetText("Sorry, there's nothing on this tab yet ;[\n\nIf you have any suggestions, let us know on discord!")
			tab.nothing_message:SetPoint("CENTER",f,"CENTER",54,0)
			tab.nothing_message:Hide()--nothing message, in case  nothing is in the tab

			tab.space_between = space_between

			tab.c1 = {
				SCROLLABLE_HEIGHT = f.tab_section:GetHeight(),
				USED_HEIGHT = 0
			}
			tab.c2 = {
				SCROLLABLE_HEIGHT = f.tab_section:GetHeight(),
				USED_HEIGHT = 0
			}

			table.insert(parent.tabs,tab)

			parent.USED_HEIGHT = parent.USED_HEIGHT + space_between
			if parent.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
				if parent.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
					parent.SCROLLABLE_HEIGHT = parent.SCROLLABLE_HEIGHT + (parent.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
				else
					parent.SCROLLABLE_HEIGHT = parent.SCROLLABLE_HEIGHT + space_between
				end
			end

			-- return the tab from the parent
			for i=1,#parent.tabs do
				if parent.tabs[i] == tab then
					return parent.tabs[i]
				end
			end

		end

		-- table of all specs
		specs = {}
		for i=1,4 do
			local specname = select(2,GetSpecializationInfo(i)) 
			if specname then
				table.insert(specs,specname)
			end
		end

		-- get current spec and remove it from list of other specs
		local currentSpec = GetSpecialization()
		local currentSpecName = currentSpec and select(2, GetSpecializationInfo(currentSpec)) or "None"

		if currentSpecName == "" then currentSpecName = "Low" end

		local previous_spec = currentSpecName

		-- refresh + sort tabs on specialization change
		function sort_tabs(specname)

			f.tab_section.VIEWABLE_HEIGHT = f.tab_section:GetHeight()
			f.tab_section.SCROLLABLE_HEIGHT = f.tab_section:GetHeight()
			f.tab_section.USED_HEIGHT = 0
			
			local current_spec_index
			local class_index
			local old_spec_index

			for i=1,#f.tab_section.tabs do
				local tab = f.tab_section.tabs[i]
				if tab.name == specname then
					current_spec_index = i
				elseif tab.name == UnitClass("player") then
					class_index = i 
				elseif tab.name == previous_spec then
					old_spec_index = i
				end
			end

			previous_spec = specname

			-- swap old and new tab indexes
			if old_spec_index then

				table.insert(f.tab_section.tabs, old_spec_index, table.remove(f.tab_section.tabs,current_spec_index))

				table.insert(f.tab_section.tabs, current_spec_index, table.remove(f.tab_section.tabs,old_spec_index+1))

				f.tab_section.tabs[old_spec_index]:Show()

				f.tab_section.tabs[current_spec_index]:Hide()

			end

			-- reposition the tabs
			for i=1,#f.tab_section.tabs do
				local tab = f.tab_section.tabs[i]
				-- position tab
				if i > 1 then
					local lta1,_,_,x,y = f.tab_section.tabs[i-1]:GetPoint()
					tab:SetPoint(lta1,x,y-tab.space_between)
					tab.point = {tab:GetPoint()}
				else
					tab:SetPoint("TOP",f.tab_section,"TOP",0,0)
					tab.point = {tab:GetPoint()}
				end
				-- respace
				f.tab_section.USED_HEIGHT = f.tab_section.USED_HEIGHT + tab.space_between
				if f.tab_section.USED_HEIGHT >= f.tab_section.VIEWABLE_HEIGHT then
					if f.tab_section.USED_HEIGHT - f.tab_section.VIEWABLE_HEIGHT < tab.space_between then
						f.tab_section.SCROLLABLE_HEIGHT = f.tab_section.SCROLLABLE_HEIGHT + (f.tab_section.USED_HEIGHT - f.tab_section.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						f.tab_section.SCROLLABLE_HEIGHT = f.tab_section.SCROLLABLE_HEIGHT + tab.space_between
					end
				end
			end

		end

		--create all of the default tabs
		local class = UnitClass("player")
		local tabs = {"General", class, currentSpecName, "Utility", "PvE", "Interface", "Cooldowns", "Automation", "Objects", "Awareness",}--"Poopy Shit", "Asshole", "Bong Rip", "Dick Cheese", "Weed", "Asscrack", "Tiddies", "Squiddies"}

		for i=1,#tabs do
			create_gui_tab({text=tabs[i], func=populate, parent=f.tab_section})
		end

		-- create hidden spec tabs
		for i=1,#specs do if specs[i] ~= currentSpecName then
			create_gui_tab({text=specs[i], func=populate, parent=f.tab_section})
		end end

		-- sort_tabs()

		-- print in chat about settings changing
		local function settings_print(var_string,event,element)
			if element == "checkbox" then
				squid_print(not get_squid_var(var_string) and "|cffff6060" .. var_string .. " disabled" or var_string .. " enabled.") 
			end
		end

		-- new
		SQUID.settings = SQUID.settings or {} -- init
		function set_squid_var(var_string,event,element)
			if not var_string then return false end
			if element == "slider" then
				if type(event) == "number" then 
					SQUID.settings[var_string] = math.floor(event)
				end
			elseif element == "checkbox" then
				SQUID.settings[var_string] = event
				settings_print(var_string, event, element)
			elseif element == "editbox" then
				if var_string == "Object Finder List" then
				    if not event then
				    	SQUID.settings[var_string] = nil
				    	SQUID.objects_to_draw = {}
				    else
						local split = {}
						for i=1,20 do
							split[i] = select(i,strsplit(",",event))
							if split[i] then split[i] = strlower(split[i]):gsub("%s+","") end
						end
						if #split > 0 then
							SQUID.objects_to_draw=split
							SQUID.settings[var_string] = event
						else
							SQUID.objects_to_draw={}
							SQUID.settings[var_string] = nil
							return false -- sets it back to default text , self:SetText(self.text)
						end
					end
				end
			elseif element == "dropdown" then
				--blalala
			end

		end

		-- returns the var set, or saves the default value to that var
		function get_squid_var(var_string,default,element)
			local setting = SQUID.settings[var_string]
			if setting then
				return SQUID.settings[var_string]
			elseif default then
				SQUID.settings[var_string] = default
				return default
			end
		end

		--new header
		local function create_header(properties)
			
			-- which tab will populate this checkbox?
			local tab = properties.tab

			local color = properties.color

			local column = properties.column
			--which column are we populating this checkbox to?
			local parent
			if column == 1 then
				parent = f.c1
			elseif column == 2 then
				parent = f.c2
			else
				column = 1
				parent = f.c1
			end

			local text = properties.text
			local font = properties.font or sui

			local container = CreateFrame("Frame", parent, BackdropTemplate)
			container:SetParent(parent)
			-- Mixin(container,BackdropTemplateMixin)
			-- container:SetBackdrop(backdrop3)
			container:SetWidth(130)
			container:SetHeight(18)

			container.tab = tab
			container.parent = parent
			container.column = column

			-- local anchor,_,anchor2,x,y = AlertFrames_Anchor:GetPoint()
			-- alert:SetPoint("CENTER",AlertFrames_Anchor,"CENTER",0,20)
			-- alert:SetHeight(125)
			-- alert:SetWidth(400)

			-- local font = cfe
			-- alert:SetClampedToScreen(true)
			-- alert.Text = alert:CreateFontString(nil, "HIGH", nil)
			-- alert.Text:SetFont(font,13,'THICKOUTLINE')

			container.txt = container:CreateFontString(nil,"HIGH")

			container.txt:SetFont(font,18)
			container.txt:SetText(text)
			container.txt:SetSize(130,36)
			container.txt:SetPoint("CENTER",container,"CENTER",0,0)

			container.txt:SetJustifyV("MIDDLE")
			container.txt:SetJustifyH("LEFT")

			if color then
				local r,g,b,a = unpack(color)
				container.txt:SetTextColor(r,g,b,a)
			else
				container.txt:SetTextColor(155/255, 155/255, 254/255, 1)
			end

			local space_between = container:GetHeight() + 6

			local elements_in_tab = 0
			for i=1,#parent.elements do
				local e = parent.elements[i]
				if e.tab == tab then
					elements_in_tab = elements_in_tab + 1
				end
			end

			local original_space_between = space_between

			if elements_in_tab > 0 then
				local e = parent.elements
				local lta1,_,_,x,y = e[#e]:GetPoint()
				container:SetPoint("TOPLEFT",parent,"TOPLEFT",0,y-space_between)
				container.point = {container:GetPoint()}
			else
				container:SetPoint("TOPLEFT",parent,"TOPLEFT",0,-3)
				container.point = {container:GetPoint()}
			end

			f.container_alpha = CreateFrame("Frame")
			f.container_alpha:SetParent(f)
			f.container_alpha:SetScript("OnUpdate",function()
				local lta1,parent,lta2,x,y = unpack(container.point)

				local cutoff = original_space_between
				container:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
				lta1,_,_,x,y = container:GetPoint() -- original coordinates
				local parent_height = parent:GetHeight()
				
				if y < -parent_height + cutoff then
					container:SetAlpha(max(0, 1 - ((abs(y) - (parent_height-cutoff+12) ) / cutoff)))
				elseif y > 0 then
					container:SetAlpha(max(0, 1 - (y/(cutoff))))
				else
					container:SetAlpha(1)
				end
				if tab.selected then
					if container:GetAlpha() <= 0 then
						container:Hide()
					else
						container:Show()
					end
				end
			end)

			container.space = 5
			local extra_space_mod = container.space / 2

			if column == 1 then
				tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between + extra_space_mod
				if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between + extra_space_mod
					end
				end
			elseif column == 2 then
				tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between + extra_space_mod
				if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between + extra_space_mod
					end
				end
			end

			table.insert(parent.elements,container)

		end

		--new header
		local function create_subheader(properties)
			
			-- which tab will populate this checkbox?
			local tab = properties.tab

			local color = properties.color

			local column = properties.column
			--which column are we populating this checkbox to?
			local parent
			if column == 1 then
				parent = f.c1
			elseif column == 2 then
				parent = f.c2
			else
				column = 1
				parent = f.c1
			end

			local text = properties.text
			local font = properties.font or sui

			local container = CreateFrame("Frame", parent, BackdropTemplate)
			container:SetParent(parent)
			-- Mixin(container,BackdropTemplateMixin)
			-- container:SetBackdrop(backdrop3)
			container:SetWidth(130)
			container:SetHeight(19)

			container.tab = tab
			container.parent = parent
			container.column = column

			-- local anchor,_,anchor2,x,y = AlertFrames_Anchor:GetPoint()
			-- alert:SetPoint("CENTER",AlertFrames_Anchor,"CENTER",0,20)
			-- alert:SetHeight(125)
			-- alert:SetWidth(400)

			-- local font = cfe
			-- alert:SetClampedToScreen(true)
			-- alert.Text = alert:CreateFontString(nil, "HIGH", nil)
			-- alert.Text:SetFont(font,13,'THICKOUTLINE')

			container.txt = container:CreateFontString(nil,"HIGH")

			container.txt:SetFont(font,13)
			container.txt:SetText(text)
			container.txt:SetSize(130,25)
			container.txt:SetPoint("CENTER",container,"CENTER",0,0)

			container.txt:SetJustifyV("MIDDLE")
			container.txt:SetJustifyH("LEFT")

			container.type = "subheader"

			if color then
				local r,g,b,a = unpack(color)
				container.txt:SetTextColor(r,g,b,a)
			else
				container.txt:SetTextColor(155/255, 155/255, 254/255, 1)
			end

			local space_between = container:GetHeight() + 8

			local elements_in_tab = 0
			for i=1,#parent.elements do
				local e = parent.elements[i]
				if e.tab == tab then
					elements_in_tab = elements_in_tab + 1
				end
			end

			local original_space_between = space_between

			if elements_in_tab > 0 then
				local e = parent.elements
				local lta1,_,_,x,y = e[#e]:GetPoint()
				local move_backwards = e[#e].type == "checkbox" and 3 or e[#e].type == "slider" and 3 or 0 
				container:SetPoint("TOPLEFT",parent,"TOPLEFT",3,y-space_between)
				container.point = {container:GetPoint()}
			else
				container:SetPoint("TOPLEFT",parent,"TOPLEFT",3,-3)
				container.point = {container:GetPoint()}
			end

			f.container_alpha = CreateFrame("Frame")
			f.container_alpha:SetParent(f)
			f.container_alpha:SetScript("OnUpdate",function()
				local lta1,parent,lta2,x,y = unpack(container.point)

				local cutoff = original_space_between
				container:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
				lta1,_,_,x,y = container:GetPoint() -- original coordinates
				local parent_height = parent:GetHeight()
				
				if y < -parent_height + cutoff then
					container:SetAlpha(max(0, 1 - ((abs(y) - (parent_height-cutoff+12) ) / cutoff)))
				elseif y > 0 then
					container:SetAlpha(max(0, 1 - (y/(cutoff))))
				else
					container:SetAlpha(1)
				end
				if tab.selected then
					if container:GetAlpha() <= 0 then
						container:Hide()
					else
						container:Show()
					end
				end
			end)

			container.space = 5
			local extra_space_mod = container.space / 2

			if column == 1 then
				tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between + extra_space_mod
				if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between + extra_space_mod
					end
				end
			elseif column == 2 then
				tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between + extra_space_mod
				if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between + extra_space_mod
					end
				end
			end

			table.insert(parent.elements,container)

		end

		--new checkbox
		function create_checkbox(properties)
			
			-- which tab will populate this checkbox?
			local tab = properties.tab

			local column = properties.column
			--which column are we populating this checkbox to?
			local parent
			if column == 1 then
				parent = f.c1
			elseif column == 2 then
				parent = f.c2
			else
				column = 1
				parent = f.c1
			end

			local text = properties.text
			local setting = properties.setting -- hook "SetChecked" function to check & uncheck this box when value changes

			local tooltip = properties.tooltip
			local var = properties.var
			local new_var = properties.new_var

			if new_var then
				var = get_squid_var(new_var)
			end

			local func = properties.func

			local default = properties.default -- default setting (true=checked, false=unchecked)

			local under_subheader = properties.under_subheader

			local box_type = "checkbox"

			local box = CreateFrame("CheckButton",nil,parent)
			box:SetSize(13,13)
			box:SetNormalTexture(squid_icon_unchecked)
			box:SetHighlightTexture(squid_icon_unchecked)
			box:GetHighlightTexture():SetVertexColor(.3,.3,0,.4)
			box:SetCheckedTexture(squid_icon_checked)
			box:SetFrameStrata("HIGH")
			box:SetChecked(var) -- set checked based on current value
			if default == true then
				if var == nil then
					box:SetChecked(default)
					func(new_var,true,box_type)
				end
			end
			box:SetScript("PostClick",function(self,event)
				if new_var then
					if box:GetChecked() then
						func(new_var,true,box_type)
					else
						func(new_var,false,box_type)
					end
				else
					if func then func(self,event) end
				end
				if self:GetChecked() then
					--checked sound
					if not SQUID.sounds_disabled then
						local soundfile = Squid_Directory() .. "/media/checkbox.wav"
						PlaySoundFile(soundfile,"Master")
					end
				else
					--unchecked sound
					if not SQUID.sounds_disabled then
						local soundfile = Squid_Directory() .. "/media/tap.wav"
						PlaySoundFile(soundfile,"Master")
					end
				end
			end)
			if tooltip then
				box:SetScript("OnEnter",function(self)
					if not SQUID.hidetooltips then
						--starting point
						GameTooltip:Show()
						GameTooltip:SetOwner(f,"CENTER",0,0);
						GameTooltip:SetAnchorType("ANCHOR_TOPLEFT",0,0);
						GameTooltip:SetBackdrop(backdrop2)
						GameTooltip:SetBackdropColor(155/255,155/255,254/255,1)
						GameTooltipText:SetFont(sui,4,'OUTLINE')
						GameTooltip:SetText("|cFF8787dd" .. tooltip);
					end
				end)
				box:SetScript("OnLeave",function(self)
					GameTooltipText:SetFont("Fonts\\FRIZQT__.TTF",12)
					GameTooltip:Hide()
				end)
			end

			-- hook "setchecked" and change the box from the outside world
			local setvar_og = set_squid_var
			set_squid_var = function(given_var,event,box_type,...)
				if given_var == new_var then
					box:SetChecked(event)
				end
				setvar_og(given_var,event,box_type,...)
			end

			box:SetScale(1)
			box.tab = tab
			box.parent = parent
			-- parent = box.parent
			box.type = "checkbox"

			local space_between = box:GetHeight() + 3.5
			local elements_in_tab = 0
			for i=1,#parent.elements do
				local e = parent.elements[i]
				if e.tab == tab then
					elements_in_tab = elements_in_tab + 1
				end
			end

			local move_forward = under_subheader and 4 or 0
			if elements_in_tab > 0 then
				local e = parent.elements
				local lta1,_,_,x,y = e[#e]:GetPoint()
				local extra_space = (e[#e].space or 0) + (e[#e].type == "subheader" and 5 or 0)
				space_between = space_between + extra_space
				-- space_between = space_between + prev_height -- adding from previous element's height
				box:SetPoint("TOPLEFT",parent,"TOPLEFT",2 + move_forward,y-space_between)
				box.point = {box:GetPoint()}
			else
				box:SetPoint("TOPLEFT",parent,"TOPLEFT",2 + move_forward,-5.5)
				box.point = {box:GetPoint()}
			end

			f.box_alpha = CreateFrame("Frame")
			f.box_alpha:SetParent(f)
			f.box_alpha:SetScript("OnUpdate",function()
				local lta1,parent,lta2,x,y = unpack(box.point)

				local cutoff = box:GetHeight() + 3.5
				box:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
				lta1,_,_,x,y = box:GetPoint() -- original coordinates
				local parent_height = parent:GetHeight()
				
				if y < -parent_height + cutoff then
					box:SetAlpha(max(0, 1 - ((abs(y) - (parent_height-cutoff+3.5) ) / cutoff)))
				elseif y > 0 then
					box:SetAlpha(max(0, 1 - (y/(cutoff+11))))
				else
					box:SetAlpha(1)
				end
				if tab.selected then
					if box:GetAlpha() <= 0 then
						box:Hide()
					else
						box:Show()
					end
				end
			end)

			box:SetText(text)
			box:GetFontString():SetFont(sui,11)

			-- box:GetFontString():SetPoint("CENTER",box,"CENTER",w,0)
			local txt = box:GetFontString()
			txt:SetSize(125,20)
			txt:SetPoint("CENTER",box,"CENTER",74,0)
			txt:SetJustifyV("MIDDLE")
			txt:SetJustifyH("LEFT")

			if column == 1 then
				tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between
				if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between
					end
				end
			elseif column == 2 then
				tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between
				if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between
					end
				end
			end

			box:Hide()

			table.insert(parent.elements,box)

		end

		--new slider
		function create_slider(properties)
			
			-- which tab will populate this checkbox?
			local tab = properties.tab

			local value = properties.value
			local min = properties.min
			local max = properties.max
			local step = properties.step
			local low = properties.low
			local high = properties.high
			local text = properties.text
			local tooltip = properties.tooltip
			local var = properties.var -- fix this later
			local new_var = properties.new_var
			local onvaluechanged = properties.onvaluechanged

			local under_subheader = properties.under_subheader

			if new_var then
				var = get_squid_var(new_var)
			end

			if not var then
				set_squid_var(new_var, value, "slider")
				var=value
			end

			local column = properties.column
			--which column are we populating this checkbox to?
			local parent
			if column == 1 then
				parent = f.c1
			elseif column == 2 then
				parent = f.c2
			else
				column = 1
				parent = f.c1
			end

			local setting = properties.setting -- hook "SetChecked" function to check & uncheck this box when value changes

			local randomseed = math.random(1,9999999)

			local slider = CreateFrame("Slider","SquidSlider"..randomseed,parent,"OptionsSliderTemplate")
			Mixin(slider, BackdropTemplateMixin)
			slider:ClearAllPoints()
			slider.text = text
			slider:SetBackdrop(slider_backdrop3)
			slider:SetBackdropColor(.8,.8,.8,.36)
			slider:SetThumbTexture(squid_slider_thumb_new)
			-- slider:SetThumbSize(2)
			slider:SetWidth(120)
			slider:SetHeight(4)
			slider:SetMinMaxValues(min,max)
			slider:SetValue(var or value)
			slider:SetValueStep(step)
			getglobal(slider:GetName().."Low"):SetText(" ")
			getglobal(slider:GetName().."Text"):SetText(text)
			getglobal(slider:GetName().."High"):SetText(var or value)
			getglobal(slider:GetName().."High"):SetFont(sui,11)
			getglobal(slider:GetName().."Text"):SetFont(sui,12)

			getglobal(slider:GetName().."Text"):SetSize(140,20)
			getglobal(slider:GetName().."Text"):SetJustifyV("MIDDLE")
			getglobal(slider:GetName().."Text"):SetJustifyH("LEFT")

			local text_anchor,_,_,text_x,text_y = getglobal(slider:GetName().."Text"):GetPoint()
			getglobal(slider:GetName().."Text"):SetPoint(text_anchor,text_x+21,text_y+6)
			getglobal(slider:GetName().."Text"):SetTextColor(175/255, 176/255, 254/255, 1)

			local text_anchor,_,_,text_x,text_y = getglobal(slider:GetName().."High"):GetPoint()
			getglobal(slider:GetName().."High"):SetPoint(text_anchor,text_x+25,text_y)
			getglobal(slider:GetName().."High"):SetSize(35,10)
			getglobal(slider:GetName().."High"):SetJustifyV("MIDDLE")
			getglobal(slider:GetName().."High"):SetJustifyH("LEFT")
			getglobal(slider:GetName().."High"):SetJustifyH("LEFT")
			getglobal(slider:GetName().."High"):SetTextColor(155/255, 155/255, 254/255, 1)

			slider:SetFrameStrata("HIGH")

			slider.tab = tab
			slider.parent = parent
			slider.type = "slider"

			if tooltip then
				slider:SetScript("OnEnter",function(self)
					if not SQUID.hidetooltips then
						GameTooltip:Show()
						GameTooltip:SetOwner(f,"CENTER",0,0);
						GameTooltip:SetAnchorType("ANCHOR_TOPLEFT",0,0);
						GameTooltip:SetBackdrop(backdrop)
						GameTooltip:SetBackdropColor(155/255,155/255,254/255,1)
						GameTooltipText:SetTextColor(255/255,255/255,255/255,1)
						GameTooltipText:SetFont(sui,4,nil)
						GameTooltip:SetText("|cFF8787dd" .. tooltip);
					end
				end)
				slider:SetScript("OnLeave",function(self)
					GameTooltipText:SetFont("Fonts\\FRIZQT__.TTF",12)
					GameTooltip:Hide()
				end)
			end

			-- slider:SetScript("OnMouseWheel",function(self,event)
			-- 	if event == -1 then
			-- 		self:SetValue(self:GetValue() - self:GetValueStep())
			-- 	else
			-- 		self:SetValue(self:GetValue() + self:GetValueStep())
			-- 	end
			-- end)

			slider.parent = column
			local slider_type = "slider"
			slider.type = slider_type

			slider:SetScript("OnValueChanged",function(self,event)
				if new_var then
					onvaluechanged(new_var,event,"slider")
				else
					onvaluechanged(self,event)
				end
				getglobal(slider:GetName().."High"):SetText(math.floor(self:GetValue()))
				-- getglobal(slider:GetName().."High"):SetPoint(text_anchor,text_x+12-(strlen(self:GetValue())-1),text_y)
				--unchecked sound
				local min_val, max_val = slider:GetMinMaxValues()
				if not SQUID.sounds_disabled and event ~= slider_previous_value and ((not slider_previous_value or abs(event - slider_previous_value) > math.max(slider:GetValueStep(), max_val/75)) or slider_sound and GetTime() - slider_sound > .04 and slider_previous_value and abs(event - slider_previous_value) >= 1) and (not slider_sound or GetTime() - slider_sound > .04) then
					local soundfile = Squid_Directory() .. "/media/tap.wav"
					PlaySoundFile(soundfile,"Master")
					slider_sound_played = GetTime()
					slider_previous_value = event
					slider_sound = GetTime()
				end
			end)

			-- hook function that sets the var and update the slider value when changed
			local setvar_og = set_squid_var
			set_squid_var = function(given_var,event,slider_type,...)
				if given_var == new_var then
					slider:SetValue(event)
				end
				setvar_og(given_var,event,slider_type,...)
			end

			if var and not slider.initial_update then
				getglobal(slider:GetName().."High"):SetText(var)
				if getglobal(slider:GetName().."High"):GetText() == var then
					slider:SetValue(var)
					slider.initial_update = true
				end
			end

			local space_between = slider:GetHeight() + 37

			local elements_in_tab = 0
			for i=1,#parent.elements do
				local e = parent.elements[i]
				if e.tab == tab then
					elements_in_tab = elements_in_tab + 1
				end
			end

			local original_space_between = space_between

			local move_forward = under_subheader and 4 or 0
			if elements_in_tab > 0 then
				local e = parent.elements
				local lta1,_,_,x,y = e[#e]:GetPoint()
				local extra_space = e[#e].space or 0
				space_between = space_between + extra_space
				slider:SetPoint("TOPLEFT",parent,"TOPLEFT",-9 + move_forward,y-space_between)
				slider.point = {slider:GetPoint()}
			else
				slider:SetPoint("TOPLEFT",parent,"TOPLEFT",-9 + move_forward,-20)
				slider.point = {slider:GetPoint()}
			end

			f.slider_alpha = CreateFrame("Frame")
			f.slider_alpha:SetParent(f)
			f.slider_alpha:SetScript("OnUpdate",function()
				local lta1,parent,lta2,x,y = unpack(slider.point)

				local cutoff = original_space_between
				slider:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
				lta1,_,_,x,y = slider:GetPoint() -- original coordinates
				local parent_height = parent:GetHeight()
				
				if y < -parent_height + cutoff then
					slider:SetAlpha(math.max(0, 1 - ((abs(y) - (parent_height-cutoff+20) ) / cutoff)))
				elseif y > 0 then
					slider:SetAlpha(math.max(0, 1 - (y/(cutoff-28))))
				else
					slider:SetAlpha(1)
				end
				if tab.selected then
					if slider:GetAlpha() <= 0 then
						slider:Hide()
					else
						slider:Show()
					end
				end
			end)

			if column == 1 then
				tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between
				if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between
					end
				end
			elseif column == 2 then
				tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between
				if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between
					end
				end
			end

			slider:Hide()

			table.insert(parent.elements,slider)

		end

		-- new editbox
		local function create_editbox(properties)

			local tab = properties.tab

			local title = properties.title -- title of the box
			local text = properties.text -- default text in box
			local lines = properties.lines or 1 -- how many lines for this editbox ( it gets taller, more space to write more shit )
			
			-- column & parent frame
			local column = properties.column
			local parent
			if column == 1 then
				parent = f.c1
			elseif column == 2 then
				parent = f.c2
			else
				column = 1
				parent = f.c1
			end

			local var = properties.var -- editbox will only work with the new method of saving vars
			local saved_text = get_squid_var(var)

			local under_subheader = properties.under_subheader

			local editbox = CreateFrame("EditBox",nil,parent)
			Mixin(editbox, BackdropTemplateMixin)
			
			editbox.text = text
			
			editbox:SetSize(135,13 * lines)

			editbox:SetFont(sui,11)

			if saved_text then 
				editbox:SetText(saved_text)
				print(saved_text)
			else
			 	editbox:SetText(text)
			end

			editbox:SetBackdrop(backdrop3)

			editbox:SetTextInsets(2,2,2,2)

			editbox:SetMultiLine(lines)
			editbox:SetBackdropColor(.71,.71,.96,.64)
			editbox:SetBackdropBorderColor(.7,.7,.7,.4)

			editbox:SetFontObject("GameFontHighlight")
			editbox:SetAutoFocus(false)

			editbox:SetScript("OnEnterPressed",function(self) 
				local text = self:GetText()
				if text:gsub("%s+","") ~= "" then
					local var_set = set_squid_var(var, text, "editbox")
					if var_set == false then self:SetText(self.text) end
				else
					set_squid_var(var, nil, "editbox")
					self:SetText(self.text)
				end
				self:ClearFocus() 
			end)

			editbox:SetScript("OnEscapePressed",function(self) 
				local text = self:GetText()
				if text:gsub("%s+","") ~= "" then
					local var_set = set_squid_var(var, text, "editbox")
					if var_set == false then self:SetText(self.text) end
				else
					set_squid_var(var, text, "editbox")
					self:SetText(self.text)
				end
				self:ClearFocus() 
			end)

			editbox:SetScript("OnEditFocusGained",function(self) if self:GetText() == text then self:SetText("") end end)
			editbox:SetScript("OnEditFocusLost",function(self) 
				local txt = self:GetText() 
				if txt:gsub("%s+", "") == "" then 
					self:SetText(self.text)
				end 
			end)

			editbox.parent = parent
			editbox.tab = tab
			editbox.type = "editbox"

			if title then
				editbox.title = editbox:CreateFontString(editbox,"HIGH")
				editbox.title:SetFont(sui,14)
				editbox.title:SetText(title)
				editbox.title:SetTextColor(155/255,155/255,254/255,1)
				editbox.title:SetPoint("TOPLEFT",editbox,"TOPLEFT",1,18)
			end

			local space_between = editbox:GetHeight() + (title and 9 or -1)

			local elements_in_tab = 0
			for i=1,#parent.elements do
				local e = parent.elements[i]
				if e.tab == tab then
					elements_in_tab = elements_in_tab + 1
				end
			end

			editbox.space = space_between

			local original_space_between = space_between
			local move_forward = under_subheader and 4 or 0
			if elements_in_tab > 0 then
				local e = parent.elements
				local lta1,_,_,x,y = e[#e]:GetPoint()
				-- local extra_space = e[#e].space or 0
				-- space_between = space_between + extra_space
				editbox:SetPoint("TOPLEFT",parent,"TOPLEFT",0 + move_forward, y - space_between)
				editbox.point = {editbox:GetPoint()}
			else
				editbox:SetPoint("TOPLEFT",parent,"TOPLEFT",0 + move_forward,-20)
				editbox.point = {editbox:GetPoint()}
			end

			f.editbox_alpha = CreateFrame("Frame")
			f.editbox_alpha:SetParent(f)
			f.editbox_alpha:SetScript("OnUpdate",function()
				local lta1,parent,lta2,x,y = unpack(editbox.point)

				local cutoff = original_space_between
				editbox:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
				lta1,_,_,x,y = editbox:GetPoint() -- original coordinates
				local parent_height = parent:GetHeight()
				
				if y < -parent_height + cutoff then
					editbox:SetAlpha(math.max(0, 1 - ((abs(y) - (parent_height-cutoff-16) ) / cutoff)))
				elseif y > 0 then
					editbox:SetAlpha(math.max(0, 1 - (y/(cutoff-23))))
				else
					editbox:SetAlpha(1)
				end
				if tab.selected then
					if editbox:GetAlpha() <= 0 then
						editbox:Hide()
					else
						editbox:Show()
					end
				end
			end)

			-- space_between = (space_between * 2) + (title and 8 or 0)

			if column == 1 then
				tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between
				if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between
					end
				end
			elseif column == 2 then
				tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between
				if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between
					end
				end
			end

			editbox:Hide()

			table.insert(parent.elements,editbox)

		end

		local extra_scrollable = (f.tab_section.SCROLLABLE_HEIGHT - f.tab_section:GetHeight() + 1) * scrollspace_mod
		CreateFrame("Frame"):SetScript("OnUpdate",function()
			extra_scrollable = (f.tab_section.SCROLLABLE_HEIGHT - f.tab_section:GetHeight() + 1) * scrollspace_mod
			-- print(extra_scrollable)
			if extra_scrollable == scrollspace_mod then extra_scrollable = 1 end
		end)

		-- print(extra_scrollable)

		--slider to display current scroll position and allow for drag scrolling
		f.tab_section.slider = CreateFrame("Slider","SqTabSectionSuperScroller",f.tab_section,"OptionsSliderTemplate")
		local slider = f.tab_section.slider
		Mixin(slider, BackdropTemplateMixin)
		slider:ClearAllPoints()
		slider:SetPoint("RIGHT",f.tab_section,"RIGHT",0,0)
		slider:SetFrameStrata("HIGH")
		slider:SetOrientation('VERTICAL')
		slider:SetBackdrop(slider_backdrop2)
		slider:SetBackdropColor(0,0,0,.28)
		slider:SetBackdropBorderColor(1,1,1,.6)
		slider:SetThumbTexture(squid_slider_thumb)
		slider.Thumb:SetHeight( (f.tab_section:GetHeight() / f.tab_section.SCROLLABLE_HEIGHT) * f.tab_section:GetHeight() )
		-- slider:SetThumbSize(2)
		slider:SetWidth(8)
		slider:SetHeight(f.tab_section:GetHeight())
		slider:SetMinMaxValues(1,extra_scrollable)
		slider:SetValue(f.tab_section.scroll_position)
		slider:SetScript("OnValueChanged",function(self) 
			f.tab_section.scroll_position = self:GetValue()
		end)
		slider:SetValueStep(1)
		getglobal(slider:GetName().."Low"):SetText("")
		getglobal(slider:GetName().."High"):SetText("")

		CreateFrame("Frame"):SetScript("OnUpdate",function()
			if (f.tab_section:GetHeight() / f.tab_section.SCROLLABLE_HEIGHT) * f.tab_section:GetHeight() == f.tab_section:GetHeight() then
				slider:Hide()
			else
				slider:Show()
			end
		end)

		-- custom squid super scroller :)
		f.tab_section:SetScript("OnUpdate",function(self)
			-- know if we're hovering the frame
			if MouseIsOver(self) then
				f.tab_section.hovering = true
			else
				f.tab_section.hovering = false
			end
			
			-- handle momentum
			local momentum_value = 0

			local last_direction
			local momentum_modifier = 0

			local time = GetTime()

			-- iterate backwards for removing tables and resetting momentum if the newest input is different than the previous
			for i = #f.tab_section.momentum, 1, -1 do
				
				local m = f.tab_section.momentum[i]
				local direction = m.direction
				local ends = m.ends

				local val = (ends - time) / .65

				if val < 0 then
					table.remove(f.tab_section.momentum,i)
				else
					last_direction = direction
					if i == 1 then -- newest input
						if direction == "DOWN" then
							if last_direction ~= "DOWN" then
								momentum_value = 0
								momentum_modifier = 0
								momentum_value = momentum_value + val
							else
								momentum_value = momentum_value + val
								momentum_modifier = momentum_modifier + 1
							end
						else
							if last_direction ~= "UP" then
								momentum_value = 0
								momentum_modifier = 0
								momentum_value = momentum_value - val
							else
								momentum_value = momentum_value - val
								momentum_modifier = momentum_modifier + 1
							end
						end
					else
						if direction == "DOWN" then
							momentum_value = momentum_value + val
							momentum_modifier = momentum_modifier + 1
						else
							momentum_value = momentum_value - val
							momentum_modifier = momentum_modifier + 1
						end
					end
				end

			end

			momentum_value = momentum_value * (3.25+momentum_modifier) -- value multiplier, the amount of scrolling each point of momentum will do!

			if abs(momentum_value) > 0 then
				slider:SetValue(slider:GetValue() + momentum_value)
				-- print(slider:GetValue())
			end

		end)

		f.tab_section:SetScript("OnMouseWheel", function(self,event)
			if event == -1 then -- mouse wheel down
				-- print("MW DOWN!")
				table.insert(f.tab_section.momentum,{direction = "DOWN", ends = GetTime() + .65})
			elseif event == 1 then
				-- print("MW UP!")
				table.insert(f.tab_section.momentum,{direction = "UP", ends = GetTime() + .65})
			end
		end)

		--COLUMN 1
		f.c1 =  CreateFrame("Frame", f, BackdropTemplate)
		f.c1:SetParent(f)
		Mixin(f.c1, BackdropTemplateMixin)
		f.c1:SetBackdrop(backdrop)
		f.c1:SetBackdropColor(0,0,0,0)
		f.c1:SetHeight(175)
		f.c1:SetWidth(160)
		f.c1:SetPoint("BOTTOM",f,"BOTTOM",-25,20)

		f.c1.elements = {}
		f.c1.scroll_position = 1 -- default scroll position
		f.c1.input = {} -- holds recent scroll input history (each scroll tick, with the time it was sent allowing for our smooth scrolling to work.)
		f.c1.momentum = {} -- momentum of scrolling speed

		f.c1.VIEWABLE_HEIGHT = f.c1:GetHeight()
		f.c1.SCROLLABLE_HEIGHT = f.c1:GetHeight()
		f.c1.USED_HEIGHT = 0

		local extra_scrollable = (f.c1.SCROLLABLE_HEIGHT - f.c1:GetHeight() + 1) * scrollspace_mod

		CreateFrame("Frame"):SetScript("OnUpdate",function()
			if current_tab then
				extra_scrollable = (current_tab.c1.SCROLLABLE_HEIGHT - f.c1:GetHeight() + 1) * scrollspace_mod
			else
				extra_scrollable = (f.c1.SCROLLABLE_HEIGHT - f.c1:GetHeight() + 1) * scrollspace_mod
			end
			-- print(extra_scrollable)
			if extra_scrollable == scrollspace_mod then extra_scrollable = 1 end
		end)

		--slider to display current scroll position and allow for drag scrolling
		f.c1.slider = CreateFrame("Slider","SQC1SuperScroller",f.c1,"OptionsSliderTemplate")
		local slider2 = f.c1.slider
		Mixin(slider2, BackdropTemplateMixin)
		slider2:ClearAllPoints()
		slider2:SetPoint("RIGHT",f.c1,"RIGHT",0,0)
		slider2:SetFrameStrata("HIGH")
		slider2:SetOrientation('VERTICAL')
		slider2:SetBackdrop(slider_backdrop2)
		slider2:SetBackdropColor(0,0,0,.28)
		slider2:SetBackdropBorderColor(1,1,1,.6)
		slider2:SetThumbTexture(squid_slider_thumb)
		slider2.Thumb:SetHeight( (f.c1:GetHeight() / f.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() )
		-- slider:SetThumbSize(2)
		slider2:SetWidth(8)
		slider2:SetHeight(f.c1:GetHeight())
		slider2:SetMinMaxValues(1,extra_scrollable)
		slider2:SetValue(f.c1.scroll_position)
		slider2:SetScript("OnValueChanged",function(self) 
			f.c1.scroll_position = self:GetValue()
		end)
		slider2:SetValueStep(1)
		getglobal(slider2:GetName().."Low"):SetText("")
		getglobal(slider2:GetName().."High"):SetText("")

		slider2:SetScript("OnMouseDown",function()
			if current_tab then
				current_tab.adjust_scroll_position = nil
				current_tab.adjust_scroll_positionc2 = nil
			end
		end)

		CreateFrame("Frame"):SetScript("OnUpdate",function()
			if current_tab and (f.c1:GetHeight() / current_tab.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() == f.c1:GetHeight() or not current_tab and (f.c1:GetHeight() / f.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() == f.c1:GetHeight() then
				slider2:Hide()
			else
				slider2:Show()
			end
			if not slider2.checked_val or GetTime() - slider2.checked_val > 1 or recent_population and GetTime() - recent_population < .1 then
				if current_tab then
					slider2.Thumb:SetHeight( (f.c1:GetHeight() / current_tab.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() )
				else
					slider2.Thumb:SetHeight( (f.c1:GetHeight() / f.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() )
				end
				slider2:SetMinMaxValues(1,extra_scrollable)
				slider2.checked_val = GetTime()
			end
			if current_tab then
				if current_tab.adjust_scroll_position then
					if abs(slider2:GetValue() - current_tab.adjust_scroll_position) > 10 then
						local fps = GetFramerate()
						local duration = .175*fps
						local step = (current_tab.adjust_scroll_position - slider2:GetValue()) / duration
						slider2:SetValue(slider2:GetValue() + step)
					else
						current_tab.adjust_scroll_position = nil
					end
				end
				if f.c1.scroll_position ~= 1 then
					current_tab.scroll_position = f.c1.scroll_position
				end
			end
		end)

		-- custom squid super scroller :)
		f.c1:SetScript("OnUpdate",function(self)
			-- know if we're hovering the frame
			if MouseIsOver(self) then
				f.c1.hovering = true
			else
				f.c1.hovering = false
			end
			
			-- handle momentum
			local momentum_value = 0

			local last_direction
			local momentum_modifier = 0

			local time = GetTime()

			-- iterate backwards for removing tables and resetting momentum if the newest input is different than the previous
			for i = #f.c1.momentum, 1, -1 do
				
				local m = f.c1.momentum[i]
				local direction = m.direction
				local ends = m.ends

				local val = (ends - time) / .6

				if val < 0 then
					table.remove(f.c1.momentum,i)
				else
					last_direction = direction
					if i == 1 then -- newest input
						if direction == "DOWN" then
							if last_direction ~= "DOWN" then
								momentum_value = 0
								momentum_modifier = 0
								momentum_value = momentum_value + val
							else
								momentum_value = momentum_value + val
								momentum_modifier = momentum_modifier + 1
							end
						else
							if last_direction ~= "UP" then
								momentum_value = 0
								momentum_modifier = 0
								momentum_value = momentum_value - val
							else
								momentum_value = momentum_value - val
								momentum_modifier = momentum_modifier + 1
							end
						end
					else
						if direction == "DOWN" then
							momentum_value = momentum_value + val
							momentum_modifier = momentum_modifier + 1
						else
							momentum_value = momentum_value - val
							momentum_modifier = momentum_modifier + 1
						end
					end
				end

			end

			momentum_value = momentum_value * (4+momentum_modifier)-- value multiplier, the amount of scrolling each point of momentum will do!

			if abs(momentum_value) > 0 then
				slider2:SetValue(slider2:GetValue() + momentum_value)
			end

		end)

		f.c1:SetScript("OnMouseWheel", function(self,event)
			if event == -1 then -- mouse wheel down
				table.insert(f.c1.momentum,{direction = "DOWN", ends = GetTime() + .6})
			elseif event == 1 then
				table.insert(f.c1.momentum,{direction = "UP", ends = GetTime() + .6})
			end
			if current_tab then
				current_tab.adjust_scroll_position = nil
				current_tab.adjust_scroll_positionc2 = nil
			end
		end)

		--COLUMN 2
		f.c2 =  CreateFrame("Frame", f, BackdropTemplate)
		f.c2:SetParent(f)
		Mixin(f.c2, BackdropTemplateMixin)
		f.c2:SetBackdrop(backdrop)
		f.c2:SetBackdropColor(0,0,0,0)
		f.c2:SetHeight(175)
		f.c2:SetWidth(160)
		f.c2:SetPoint("BOTTOMRIGHT",f,"BOTTOMRIGHT",-5,20)

		f.c2.elements = {}
		f.c2.scroll_position = 1 -- default scroll position
		f.c2.input = {} -- holds recent scroll input history (each scroll tick, with the time it was sent allowing for our smooth scrolling to work.)
		f.c2.momentum = {} -- momentum of scrolling speed

		f.c2.VIEWABLE_HEIGHT = f.c2:GetHeight()
		f.c2.SCROLLABLE_HEIGHT = f.c2:GetHeight()
		f.c2.USED_HEIGHT = 0

		local extra_scrollable = (f.c2.SCROLLABLE_HEIGHT - f.c2:GetHeight() + 1) * scrollspace_mod
		CreateFrame("Frame"):SetScript("OnUpdate",function()
			if current_tab then
				extra_scrollable = (current_tab.c2.SCROLLABLE_HEIGHT - f.c2:GetHeight() + 1) * scrollspace_mod
			else
				extra_scrollable = (f.c2.SCROLLABLE_HEIGHT - f.c2:GetHeight() + 1) * scrollspace_mod
			end
			-- print(extra_scrollable)
			if extra_scrollable == scrollspace_mod then extra_scrollable = 1 end
		end)

		--slider to display current scroll position and allow for drag scrolling
		f.c2.slider = CreateFrame("Slider","SQc2SuperScroller",f.c2,"OptionsSliderTemplate")
		local slider3 = f.c2.slider
		Mixin(slider3, BackdropTemplateMixin)
		slider3:ClearAllPoints()
		slider3:SetPoint("RIGHT",f.c2,"RIGHT",0,0)
		slider3:SetFrameStrata("HIGH")
		slider3:SetOrientation('VERTICAL')
		slider3:SetBackdrop(slider_backdrop2)
		slider3:SetBackdropColor(0,0,0,.28)
		slider3:SetBackdropBorderColor(1,1,1,.6)
		slider3:SetThumbTexture(squid_slider_thumb)
		slider3.Thumb:SetHeight( (f.c2:GetHeight() / f.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() )
		-- slider:SetThumbSize(2)
		slider3:SetWidth(8)
		slider3:SetHeight(f.c2:GetHeight())
		slider3:SetMinMaxValues(1,extra_scrollable)
		slider3:SetValue(f.c2.scroll_position)
		slider3:SetScript("OnValueChanged",function(self) 
			f.c2.scroll_position = self:GetValue()
		end)
		slider3:SetValueStep(1)
		getglobal(slider3:GetName().."Low"):SetText("")
		getglobal(slider3:GetName().."High"):SetText("")

		CreateFrame("Frame"):SetScript("OnUpdate",function()
			if current_tab and (f.c2:GetHeight() / current_tab.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() == f.c2:GetHeight() or not current_tab and (f.c2:GetHeight() / f.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() == f.c2:GetHeight() then
				slider3:Hide()
			else
				slider3:Show()
			end
			if not slider3.checked_val or GetTime() - slider3.checked_val > 1 or recent_population and GetTime() - recent_population < .1 then
				if current_tab then
					slider3.Thumb:SetHeight( (f.c2:GetHeight() / current_tab.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() )
				else
					slider3.Thumb:SetHeight( (f.c2:GetHeight() / f.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() )
				end
				slider3:SetMinMaxValues(1,extra_scrollable)
				slider3.checked_val = GetTime()
			end
			if current_tab then
				if current_tab.adjust_scroll_positionc2 then
					-- if slider3:GetValue() ~= current_tab.adjust_scroll_positionc2 then
					-- 	slider3:SetValue(current_tab.adjust_scroll_positionc2)
					if abs(slider3:GetValue() - current_tab.adjust_scroll_positionc2) > 10 then
						local fps = GetFramerate()
						local duration = .175*fps
						local step = (current_tab.adjust_scroll_positionc2 - slider3:GetValue()) / duration
						slider3:SetValue(slider3:GetValue() + step)
					else
						current_tab.adjust_scroll_positionc2 = nil
					end
				end
				if f.c2.scroll_position ~= 1 then
					current_tab.scroll_positionc2 = f.c2.scroll_position
				end
			end
		end)

		-- custom squid super scroller :)
		f.c2:SetScript("OnUpdate",function(self)
			-- know if we're hovering the frame
			if MouseIsOver(self) then
				f.c2.hovering = true
			else
				f.c2.hovering = false
			end
			
			-- handle momentum
			local momentum_value = 0

			local last_direction

			local time = GetTime()

			local momentum_modifier = 0

			-- iterate backwards for removing tables and resetting momentum if the newest input is different than the previous
			for i = #f.c2.momentum, 1, -1 do
				
				local m = f.c2.momentum[i]
				local direction = m.direction
				local ends = m.ends

				local val = (ends - time) / .6

				if val < 0 then
					table.remove(f.c2.momentum,i)
				else
					last_direction = direction
					if i == 1 then -- newest input
						if direction == "DOWN" then
							if last_direction ~= "DOWN" then
								momentum_value = 0
								momentum_modifier = 0
								momentum_value = momentum_value + val
							else
								momentum_value = momentum_value + val
								momentum_modifier = momentum_modifier + 1
							end
						else
							if last_direction ~= "UP" then
								momentum_value = 0
								momentum_modifier = 0
								momentum_value = momentum_value - val
							else
								momentum_value = momentum_value - val
								momentum_modifier = momentum_modifier + 1
							end
						end
					else
						if direction == "DOWN" then
							momentum_value = momentum_value + val
							momentum_modifier = momentum_modifier + 1
						else
							momentum_value = momentum_value - val
							momentum_modifier = momentum_modifier + 1
						end
					end
				end

			end

			momentum_value = momentum_value * (4+momentum_modifier) -- value multiplier, the amount of scrolling each point of momentum will do!

			if abs(momentum_value) > 0 then
				slider3:SetValue(slider3:GetValue() + momentum_value)
			end

		end)

		f.c2:SetScript("OnMouseWheel", function(self,event)
			if event == -1 then -- mouse wheel down
				table.insert(f.c2.momentum,{direction = "DOWN", ends = GetTime() + .6})
			elseif event == 1 then
				table.insert(f.c2.momentum,{direction = "UP", ends = GetTime() + .6})
			end
		end)

		-- controls entire frame animation :)
		local dir

		--exit button not tied to tabs
		local exit = CreateFrame("Button",nil,f,nil,"UIPanelButtonTemplate")
		exit:SetText("x")
		exit:SetNormalTexture(squid_button)
		exit:GetNormalTexture():SetVertexColor(1,1,1,.4)
		exit:SetHighlightTexture(squid_button)
		exit:SetScript("OnClick",function(self)
			-- f:Hide()
			dir = -1
		end)
		exit:GetFontString():SetFont(sui_bold,15,nil)
		exit:GetFontString():SetTextColor(155/255, 155/255, 254/255, 1)
		exit:SetSize(28,25)
		exit:SetScript("OnEnter",function(self) self:GetFontString():SetTextColor(1,.2,.2,1) end)
		exit:SetScript("OnLeave",function(self) self:GetFontString():SetTextColor(155/255, 155/255, 254/255, 1) end)
		exit:SetPoint("TOPRIGHT",0,0)

		-- GET RID OF THIS SHIT
		--functions for elements in the gui

		local toggle_object_finder=function(self)
			SQUID.draw_objects = not SQUID.draw_objects
			squid_print(not SQUID.draw_objects and "|cffff6060Object finder disabled." or "Object finder enabled.") 
			if SQUID.draw_objects then self:SetChecked(true) else self:SetChecked(false) end
		end
		local toggle_object_finder_lines=function(self)
			SQUID.draw_line_to_objects = not SQUID.draw_line_to_objects
			squid_print(not SQUID.draw_line_to_objects and "|cffff6060Lines to objects disabled." or "Lines to objects enabled.") 
			if SQUID.draw_line_to_objects then self:SetChecked(true) else self:SetChecked(false) end
		end
		local toggle_object_finder_auto_interact=function(self)
			SQUID.auto_interact_objects = not SQUID.auto_interact_objects
			squid_print(not SQUID.auto_interact_objects and "|cffff6060Auto interact objects disabled." or "Auto interact objects enabled.") 
			if SQUID.auto_interact_objects then self:SetChecked(true) else self:SetChecked(false) end
		end
		local auto_tricks_handler = function(self)
			SQUID.auto_tricks_of_the_trade = not SQUID.auto_tricks_of_the_trade
			squid_print(not SQUID.auto_tricks_of_the_trade and "|cffff6060Auto Tricks Disabled" or "Auto Tricks Enabled.")
		end
		local solo_mode_handler = function(self)
			SQUID.solo_mode = not SQUID.solo_mode
			squid_print(not SQUID.solo_mode and "|cffff6060Solo Mode Disabled" or "Solo Mode Enabled.")
		end
		local obj_onenter=function(self) 
			local text = self:GetText()
			if text:gsub("%s+","") ~= "" then
				SQUID.obj_box_saved_text = text
				local split = {}
				for i=20,1,-1 do
					split[i] = select(i,strsplit(",",text))
					if split[i] then split[i] = strlower(split[i]):gsub("%s+","") end
					if split[i] == "" then table.remove(split,i) end
				end
				if #split > 0 then
					SQUID.objects_to_draw=split
				else
					self:SetText(self.text)
					SQUID.objects_to_draw={}
					SQUID.obj_box_saved_text = nil
				end
			else
				self:SetText(self.text)
				SQUID.objects_to_draw={}
				SQUID.obj_box_saved_text = nil
			end
			self:ClearFocus() 
		end
		local obj_onescape=function(self)
			local text = self:GetText()
			if text:gsub("%s+","") ~= "" then
				SQUID.obj_box_saved_text = text
			else
				SQUID.obj_box_saved_text = nil
			end
			self:ClearFocus() 
		end
		local mindelay_handler=function(self) 
			if SQUID.min_mindelay > SQUID.max_mindelay then
				SQUID.min_mindelay = SQUID.max_mindelay
				squid_print("Please make sure min delay value is less than or equal to the max delay.")
				self:SetValue(SQUID.min_mindelay)
			end
			local v=math.floor(self:GetValue())
			SQUID.min_mindelay=v
			if SQUID.min_mindelay > SQUID.max_mindelay then
				SQUID.min_mindelay = SQUID.max_mindelay
				self:SetValue(SQUID.min_mindelay)
			end
		end
		local maxdelay_handler=function(self) 
			if SQUID.max_mindelay < SQUID.min_mindelay then
				SQUID.max_mindelay = SQUID.min_mindelay
				squid_print("Please make sure max delay value is greater than or equal to the min delay.")
				self:SetValue(SQUID.max_mindelay)
			end
			local v=math.floor(self:GetValue())
			SQUID.max_mindelay=v
			if SQUID.max_mindelay < SQUID.min_mindelay then
				SQUID.max_mindelay = SQUID.min_mindelay
				self:SetValue(SQUID.max_mindelay)
			end
		end
		local min_combust_hp_handler=function(self)
			local v=math.floor(self:GetValue())
			SQUID.min_combust_hp=v
		end
		local autoblock_handler=function(self) 
			local v=math.floor(self:GetValue())
			if v == 0 then
				getglobal(self:GetName().."Text"):SetText(self.text .. " - " .. "DISABLED")
			else
				getglobal(self:GetName().."Text"):SetText(self.text)
			end
			SQUID.auto_block=v
		end
		local auto_vial_handler = function(self)
			SQUID.auto_vial = not SQUID.auto_vial
			squid_print(not SQUID.auto_vial and "|cffff6060Auto Vial disabled" or "Auto Vial enabled.") 
		end
		local auto_vial_handler_percent = function(self) 
			local v=math.floor(self:GetValue())
			if v == 0 then
				getglobal(self:GetName().."Text"):SetText(self.text .. " - " .. "DISABLED")
			else
				getglobal(self:GetName().."Text"):SetText(self.text)
			end
			SQUID.auto_vial_percent=v
		end
		local block_after_caut_handler=function(self)
			SQUID.block_after_caut = not SQUID.block_after_caut
			squid_print(not SQUID.block_after_caut and "|cffff6060Block after cauterize disabled" or "Block after cauterize enabled.") 
		end
		local object_finder_dist_handler=function(self) 
			local v=math.floor(self:GetValue())
			SQUID.max_object_finder_dist=v
		end
		local glimmer_everything_handler=function(self)
			SQUID.glimmer_everything = not SQUID.glimmer_everything
		end
		local sound_disabler=function(self)
			SQUID.sounds_disabled = not SQUID.sounds_disabled
			squid_print(not SQUID.sounds_disabled and "|cffff6060Squid sounds disabled" or "Squid sounds enabled.") 
		end
		local auto_burst_handler=function(self)
			SQUID.auto_burst = not SQUID.auto_burst
			squid_print(not SQUID.auto_burst and "|cffff6060Auto burst disabled" or "Auto burst enabled.") 
		end
		local auto_bs_handler=function(self)
			SQUID.bs_cancel = not SQUID.bs_cancel
			squid_print(not SQUID.bs_cancel and "|cffff6060Auto bs cancel disabled" or "Auto bs cancel enabled.") 
		end
		local spread_handler=function(self)
			SQUID.spread_mode = not SQUID.spread_mode
			squid_print(not SQUID.spread_mode and "|cffff6060Spread mode disabled" or "Spread mode enabled.") 
		end
		local aura_mastery_handler=function(self)
			SQUID.auto_aura_mastery = not SQUID.auto_aura_mastery
			squid_print(not SQUID.auto_aura_mastery and "|cffff6060Aura mastery disabled" or "Aura mastery enabled.") 
		end
		local wings_handler=function(self)
			SQUID.auto_wings = not SQUID.auto_wings
			squid_print(not SQUID.auto_wings and "|cffff6060Auto wings disabled" or "Auto wings enabled.") 
		end
		local holy_avenger_handler=function(self)
			SQUID.auto_holy_avenger = not SQUID.auto_holy_avenger
			squid_print(not SQUID.auto_holy_avenger and "|cffff6060Auto holy avenger disabled" or "Auto holy avenger enabled.") 
		end
		local unlock_squidalerts=function(self)
			Squid_Alerts_Unlocked = not Squid_Alerts_Unlocked
			squid_print(not Squid_Alerts_Unlocked and "|cffff6060Squid alerts locked." or "Squid alerts unlocked.") 
		end
		local auto_cc_handler=function(self)
			SQUID.auto_cc = not SQUID.auto_cc
			squid_print(not SQUID.auto_cc and "|cffff6060Auto cc disabled" or "Auto cc enabled.") 
		end
		local auto_leap_handler=function(self)
			SQUID.auto_leap = not SQUID.auto_leap
			squid_print(not SQUID.auto_leap and "|cffff6060Auto leap disabled" or "Auto leap enabled.") 
		end
		local auto_charge_handler=function(self)
			SQUID.auto_charge = not SQUID.auto_charge
			squid_print(not SQUID.auto_charge and "|cffff6060Auto charge disabled" or "Auto charge enabled.") 
		end
		local auto_chains_handler=function(self)
			SQUID.auto_chains = not SQUID.auto_chains
			squid_print(not SQUID.auto_chains and "|cffff6060Auto chains disabled" or "Auto chains enabled.") 
		end
		local anon_handler=function(self)
			SQUID.anon = not SQUID.anon
			squid_print(not SQUID.anon and "|cffff6060Anonymization Disabled" or "Anonymization Enabled")
			ReloadUI()
		end
		local flag_pick_handler=function(self)
			SQUID.flag_pick = not SQUID.flag_pick
			squid_print(not SQUID.flag_pick and "|cffff6060Flag Pick Disabled" or "Flag Pick Enabled")
		end
		local auto_paladin_handler=function(self)
			SQUID.auto_paladin = not SQUID.auto_paladin
			squid_print(not SQUID.auto_paladin and "|cffff6060Auto Paladin Disabled" or "Auto Paladin Enabled")
		end
		local auto_fel_rush_handler=function(self)
			SQUID.AutoFelRush = not SQUID.AutoFelRush
			squid_print(not SQUID.AutoFelRush and "|cffff6060Auto Felrush Disabled" or "Auto Felrush Enabled")
		end
		local disable_while_visible_handler=function(self)
			SQUID.disable_while_visible = not SQUID.disable_while_visible
			squid_print(not SQUID.disable_while_visible and "|cffff6060Smart Mode Disabled" or "Smart Mode Enabled")
		end
		local alerts_enabled_handler=function(self)
			SQUID.awareness_alerts_enabled = not SQUID.awareness_alerts_enabled
			squid_print(not SQUID.awareness_alerts_enabled and "|cffff6060Awareness Alerts Disabled" or "Awareness Alerts Enabled")
		end
		local lines_enabled_handler=function(self)
			SQUID.awareness_lines_enabled = not SQUID.awareness_lines_enabled
			squid_print(not SQUID.awareness_lines_enabled and "|cffff6060Awareness Lines Disabled" or "Awareness Lines Enabled")
		end
		local good_line_handler=function(self)
			SQUID.good_line_enabled = not SQUID.good_line_enabled
			squid_print(not SQUID.good_line_enabled and "|cffff6060Good Line Disabled" or "Good Line Enabled")
		end
		local stop_to_cc_handler=function(self)
			SQUID.stop_to_cc = not SQUID.stop_to_cc
			squid_print(not SQUID.stop_to_cc and "|cffff6060Movement Stopping for CC Disabled" or "Movement Stopping for CC Enabled")
		end
		local positioning_help_handler=function(self)
			SQUID.positioning_help = not SQUID.positioning_help
			squid_print(not SQUID.positioning_help and "|cffff6060Positioning Draws Disabled" or "Positioning Draws Enabled")
		end
		local auto_juke_handler=function(self)
			SQUID.auto_juke = not SQUID.auto_juke
			squid_print(not SQUID.auto_juke and "|cffff6060Fake casting disabled" or "Fake casting enabled")
		end
		local min_jukedelay_handler=function(self) 
			if SQUID.min_jukedelay > SQUID.max_jukedelay then
				SQUID.min_jukedelay = SQUID.max_jukedelay
				squid_print("Please make sure min delay value is less than or equal to the max delay.")
				self:SetValue(SQUID.min_jukedelay)
			end
			local v=math.floor(self:GetValue())
			SQUID.min_jukedelay=v
			if SQUID.min_jukedelay > SQUID.max_jukedelay then
				SQUID.min_jukedelay = SQUID.max_jukedelay
				self:SetValue(SQUID.min_jukedelay)
			end
		end
		local max_jukedelay_handler=function(self) 
			if SQUID.max_jukedelay < SQUID.min_jukedelay then
				SQUID.max_jukedelay = SQUID.min_jukedelay
				squid_print("Please make sure max delay value is greater than or equal to the min delay.")
				self:SetValue(SQUID.max_jukedelay)
			end
			local v=math.floor(self:GetValue())
			SQUID.max_jukedelay=v
			if SQUID.max_jukedelay < SQUID.min_jukedelay then
				SQUID.max_jukedelay = SQUID.min_jukedelay
				self:SetValue(SQUID.max_jukedelay)
			end
		end
		local max_juke_attempts_handler=function(self) 
			local v=math.floor(self:GetValue())
			SQUID.max_juke_attempts=v
		end
		local auto_queue_handler=function(self)
			SQUID.auto_queue = not SQUID.auto_queue
			squid_print(not SQUID.auto_queue and "|cffff6060Auto queue disabled" or "Auto queue enabled")
		end
		local mmr_tank_handler=function(self)
			SQUID.tank_mmr = not SQUID.tank_mmr
			squid_print(not SQUID.tank_mmr and "|cffff6060MMR Tank Disabled" or "MMR Tank Enabled")
		end
		local cap_bot_handler=function(self)
			SQUID.cap_bot = not SQUID.cap_bot
			squid_print(not SQUID.cap_bot and "|cffff6060Arena bot disabled" or "Arena bot enabled")
		end
		local auto_combust_handler=function(self)
			SQUID.auto_combust = not SQUID.auto_combust
			squid_print(not SQUID.auto_combust and "|cffff6060Auto Combustion disabled" or "Auto Combustion enabled")
			if AlertFrames_Anchor then
        		if SQUID.auto_combust then
          			Squid_Alert("|cFFdecbebAuto Combustion Enabled",nil,nil,.25,190319)
        		else
	         		Squid_Alert("|cFFca2aa5Auto Combustion Disabled",nil,nil,.25,190319)
	       		end
	      	end
		end
		local rare_finder_handler=function(self)
			SQUID.rare_finder = not SQUID.rare_finder
			squid_print(not SQUID.rare_finder and "|cffff6060Rare finder disabled" or "Rare finder enabled")
		end
		local kill_healers_handler=function(self)
			SQUID.kill_healers = not SQUID.kill_healers
			squid_print(not SQUID.kill_healers and "|cffff6060Run at healers disabled" or "Run at healers enabled - yee haw")
		end
		local only_skirms_handler=function(self)
			SQUID.only_skirms = not SQUID.only_skirms
			squid_print(not SQUID.only_skirms and "|cffff6060Only skirms disabled" or "Only skirms enabled")
		end
		local only_bgs_handler=function(self)
			SQUID.only_bgs = not SQUID.only_bgs
			squid_print(not SQUID.only_bgs and "|cffff6060Battleground queues disabled" or "Battleground queues enabled")
		end
		local only_cc_healers_handler=function(self)
			SQUID.only_cc_healers = not SQUID.only_cc_healers
			squid_print(not SQUID.only_cc_healers and "|cffff6060CC Only Healers Disabled" or "CC Only Healers Enabled")
		end
		local toggle_flash_handler=function()
			SQUID.toggle_flash = not SQUID.toggle_flash
			squid_print(not SQUID.toggle_flash and "|cffff6060Toggle flash disabled" or "Toggle flash enabled")
		end
		local auto_target_handler=function()
			SQUID.auto_target = not SQUID.auto_target
			squid_print(not SQUID.auto_target and "|cffff6060Auto Targeting Disabled" or "Auto Targeting Enabled")
		end
		local mouseover_names_handler=function()
			SQUID.mouseover_names = not SQUID.mouseover_names
			squid_print(not SQUID.mouseover_names and "|cffff6060Mouseover names disabled" or "Mouseover names enabled")
		end
		local track_quests_handler=function()
			SQUID.track_quests = not SQUID.track_quests
			squid_print(not SQUID.track_quests and "|cffff6060Track quests disabled" or "Track quests enabled")
		end
		local scorch_filler_handler=function()
			SQUID.scorch_filler = not SQUID.scorch_filler
			squid_print(not SQUID.scorch_filler and "|cffff6060Scorch filler disabled" or "Scorch filler enabled")
		end
		local auto_temp_handler=function()
			SQUID.auto_temp = not SQUID.auto_temp
			squid_print(not SQUID.auto_temp and "|cffff6060Auto temp disabled" or "Auto temp enabled")
		end
		local streaming_mode_handler=function()
			SQUID.streaming_mode = not SQUID.streaming_mode
			squid_print(not SQUID.streaming_mode and "|cffff6060Streaming mode disabled" or "Streaming mode enabled")
		end
		local squid_line_scale_handler=function(self) 
			local v=math.floor(self:GetValue())
			v=v/100
			SQUID.line_scale=v
		end

		tabs = f.tab_section.tabs

		--Create and populate tabs
		local tabname
		local tab

		--Information Tab
		tabname = "Information"
		for i=1,#tabs do if tabs[i].name == tabname then
			tab = tabs[i]
		end end

		-- testing, want to add patch notes / update information or any notes for customers here :)
		-- create_checkbox({tab=tab,column=1,text="Disable Sounds",tooltip="Disable all sounds from squid's alert system.\n\nWarning: This may result in reduced fun.",var=SQUID.sounds_disabled,func=sound_disabler})
		-- create_checkbox({tab=tab,column=1,text="Incognito Mode",tooltip="Useful for hiding the fact you're using Squid to anyone watching your gameplay.\n\n - Disables on-screen drawings and alerts from Squid\n\n - Keeps the script from casting AoE spells outside of your camera view\n\n - Smart AFK detection will auto-pause the rotation when AFK or tabbed out\n\n - Enables other experimental humanization features\n\nI also recommend hiding cursor on your streaming software if possible.",var=SQUID.streaming_mode,func=streaming_mode_handler})
		
		--General Tab
		tabname = "General"
		for i=1,#tabs do if tabs[i].name == tabname then
			tab = tabs[i]
		end end

		-- test elements for new settings saving method
		-- create_slider({tab=tab,column=1,text="How many foods?",tooltip="Let us know how many foods you want.",min=1,max=6000,new_var="How Many Foods",value=1000,step=1,onvaluechanged=set_squid_var})
		-- create_checkbox({tab=tab,column=1,text="Disable Sounds",tooltip="Disable all sounds from squid's alert system.\n\nWarning: This may result in reduced fun.",new_var="Disable Sounds",func=set_squid_var})
		
		-- --mindelaytime sliders
		-- create_header({tab=tab,column=1,text="Real Settings"})

		create_checkbox({tab=tab,column=1,text=locale == "zhCN" and "" or "Disable Sounds",tooltip="Disable all sounds from squid's alert system.\n\nWarning: This may result in reduced fun.",var=SQUID.sounds_disabled,func=sound_disabler})
		create_checkbox({tab=tab,column=1,text="Incognito Mode",tooltip="Useful for hiding the fact you're using Squid to anyone watching your gameplay.\n\n - Disables on-screen drawings and alerts from Squid\n\n - Keeps the script from casting AoE spells outside of your camera view\n\n - Smart AFK detection will auto-pause the rotation when AFK or tabbed out\n\n - Enables other experimental humanization features\n\nI also recommend hiding cursor on your streaming software if possible.",var=SQUID.streaming_mode,func=streaming_mode_handler})
		-- create_checkbox({tab=tab,text="Paranoid Mode",tooltip="More expiramental features to simulate human-like activity even to those watching your gameplay.\n\n - Keeps the script from using AoE on targets outside of your camera view, among other features",var=SQUID.streaming_mode,func=streaming_mode_handler})
		create_checkbox({tab=tab,column=1,text="Unlock Alert Frames",tooltip="Unlocks project squid's alert frames and displays test alerts.\n\nWith this you can move Big & Small alerts wherever you want\n\nJust drag the anchors to move them!",var=Squid_Alerts_Unlocked,func=unlock_squidalerts})
		create_checkbox({tab=tab,column=1,text="Anonymize Names",tooltip="Anonymize your name, and your party member's names.\n\nUseful for streaming or recording gameplay with squid active.\n\nReloads UI automatically, so be prepared for that.",var=SQUID.anon,func=anon_handler})
		create_checkbox({tab=tab,column=1,text="Grab Flags",tooltip="Quickly auto pick flags and mine carts in BGs.",var=SQUID.flag_pick,func=flag_pick_handler,default=true})
		create_checkbox({tab=tab,column=1,text="Toggle Flash",tooltip="Any toggles are accompanied by an animation around the edge of your screen\n\nGreen / red based on whether you enabled / disabled.",var=SQUID.toggle_flash,func=toggle_flash_handler})
		create_checkbox({tab=tab,column=1,text="Auto Target",tooltip = "Will Automatically acquire a target upon target death.",var=SQUID.auto_target,func=auto_target_handler,default=false})

		-- create_header({tab=tab,column=1,text="Test Elements"})

		-- create_checkbox({tab=tab,column=1,text="For Tests",tooltip="This is a box that will do nothing",func=printobj})
		-- create_checkbox({tab=tab,column=1,text="Only tests",tooltip="This is a box that will do nothing",func=printobj})
		-- create_checkbox({tab=tab,column=1,text="That's all",tooltip="This is a box that will do nothing",func=printobj})
		-- create_checkbox({tab=tab,column=1,text="Simply Tests",tooltip="This is a box that will do nothing",func=printobj})
		-- create_header({tab=tab,column=1,text="More Tests :]",color={155/255,165/255,255/255,1}})
		-- create_checkbox({tab=tab,column=1,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
		-- create_slider({tab=tab,column=1,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
		-- create_checkbox({tab=tab,column=1,text="Extra Large Test Box",tooltip="This is a box that will do nothing",func=printobj})
		-- create_checkbox({tab=tab,column=1,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
		-- create_header({tab=tab,column=1,text="Deez Sliders",color={155/255,165/255,255/255,1}})
		-- create_slider({tab=tab,column=1,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
		-- create_slider({tab=tab,column=1,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
		-- create_slider({tab=tab,column=1,text="Testicle Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})

		-- create_header({tab=tab,column=2,text="Test Elements"})
		-- create_checkbox({tab=tab,column=2,text="For Tests",tooltip="This is a box that will do nothing",func=printobj})
		
		-- create_checkbox({tab=tab,column=2,text="Only tests",tooltip="This is a box that will do nothing",func=printobj})
		-- create_checkbox({tab=tab,column=2,text="That's all",tooltip="This is a box that will do nothing",func=printobj})
		-- create_checkbox({tab=tab,column=2,text="Simply Tests",tooltip="This is a box that will do nothing",func=printobj})
		-- -- create_header({tab=tab,column=2,text="Test Elements :]",color={175/255,200/255,255/255,1}})
		
		-- create_checkbox({tab=tab,column=2,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
	
		-- create_slider({tab=tab,column=2,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
		-- create_checkbox({tab=tab,column=2,text="Extra Large Test Box",tooltip="This is a box that will do nothing",func=printobj})
		-- create_checkbox({tab=tab,column=2,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
		-- create_header({tab=tab,column=2,text="Deez Sliders"})
		-- create_slider({tab=tab,column=2,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
		-- create_slider({tab=tab,column=2,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
		-- create_slider({tab=tab,column=2,text="Testicle Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})

		-- create_checkbox({tab=tab,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
		-- local function set_keybind(self,keybind)
		-- 	SetBinding(self:GetText(),keybind)
		-- end

		local function find_spec_tab(specName)
			for i=1,#tabs do if tabs[i].name == specName then
				return tabs[i]
			end end
		end

		-- --Class Tab
		local function first_upper(str)
		    return (str:gsub("^%l", string.upper))
		end
		local class = first_upper(strlower(select(2,UnitClass("player"))))
		if class == "Demonhunter" then
			class = "Demon Hunter"
		elseif class == "Deathknight" then
			class = "Death Knight"
		end
		tabname = UnitClass("player")

		for i=1,#tabs do if tabs[i].name == tabname then
			tab = tabs[i]
		end end

		-- spec tab update function
		local function on_spec_changed(self, event)
			if event == "PLAYER_SPECIALIZATION_CHANGED" then
				local spec = GetSpecialization()
				local specName = select(2, GetSpecializationInfo(spec))
				sort_tabs(specName)
			end
		end

		--class specific settings
		if class == "Monk" then
			-- create_checkbox({tab=tab,text="Monk Testa",tooltip="This monk test lol",func=printobj})
			-- create_checkbox({tab=tab,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
		elseif class == "Warrior" then
			if locale == "zhCN" then
				create_checkbox({tab=tab,column=1,text="",tooltip="",var=SQUID.auto_burst,func=auto_burst_handler})
			else
				create_checkbox({tab=tab,column=1,text="Auto Burst",tooltip="Automate usage of burst (Warbreaker / Avatar)",var=SQUID.auto_burst,func=auto_burst_handler})	
				create_checkbox({tab=tab,column=1,text="Auto Charge",tooltip="Automate usage of charge",var=SQUID.auto_charge,func=auto_charge_handler,default=true})	
				create_checkbox({tab=tab,column=1,text="Auto Leap",tooltip="Automate usage of leap",var=SQUID.auto_leap,func=auto_leap_handler,default=true})	
				create_checkbox({tab=tab,column=1,text="Cancel Bladestorm",tooltip="Automatically cancels bladestorm to interrupt",var=SQUID.bs_cancel,func=auto_bs_handler,default=true})	
			end
		elseif class == "Rogue" then
			
			-- General Rogue Tab
			create_checkbox({tab=tab,column=1,text="Auto Tricks",tooltip="Auto Tricks when you have aggro.",var=SQUID.auto_tricks_of_the_trade,func=auto_tricks_handler, default=true})
			create_checkbox({tab=tab,column=1,text="Auto Vial",tooltip="Auto Vial at % HP",var=SQUID.auto_vial,func=auto_vial_handler, default=true})
			create_slider({tab=tab,column=1,text="Min HP%",tooltip="Min HP% to use Crimson Vial",low="0",high="100",min=0,max=100,var=SQUID.auto_vial_percent,value=50,step=1,onvaluechanged=auto_vial_handler_percent})
			
			-- Subtlety Tab
			local tab = find_spec_tab("Subtlety")
			
			-- Subtlety PvP Header
			create_header({tab=tab,column=1,text="PvP Settings"})
			
			-- Visuals Subheader
			create_subheader({tab=tab,column=1,text="Visuals"})
			local under_subheader = true
			create_checkbox({tab=tab,column=1,text="Backstab Drawing",tooltip="Draws a small arc behind your enemy target for +20% backstab damage.\n\nDrawing will enlarge during sap for easy rupture to the side.",new_var="Backstab Drawing",func=set_squid_var,default=true,under_subheader=under_subheader})

			-- Execute Subheader
			create_subheader({tab=tab,column=1,text="Execute"})
			create_checkbox({tab=tab,column=1,text="Auto Execute",tooltip="Automatically calculates and performs a lethal execution when possible.\n\nWill use cooldowns and step if needed to perform executes.",new_var="SubPvP - Execute",func=set_squid_var,default=true,under_subheader=under_subheader})
			create_checkbox({tab=tab,column=1,text="Don't Step",tooltip="Won't use step for executes, instead only performing them on targets in melee range.",new_var="SubPvP - No Execute Step",func=set_squid_var,default=false,under_subheader=under_subheader})
			create_slider({tab=tab,column=1,text="Execute GCDs",tooltip="Number of GCDS to calculate for available execute damage.\n\nLower is more successful because the enemy will have less time to react.\nHigher will result in more frequent executes on targets with more HP.",min=1,max=2,new_var="SubPvP - Execute GCDs",value=1,step=1,onvaluechanged=set_squid_var,under_subheader=under_subheader})
			
		elseif class == "Paladin" then
			if locale == "zhCN" then
				create_checkbox({tab=tab,column=1,text="PvP Healing",tooltip="Automatically uses healing abilities in PvP.\r\nThis is useful if you're not a very experienced hpal.",var=SQUID.auto_paladin,func=auto_paladin_handler})
				create_checkbox({tab=tab,column=1,text="Raid Mode",tooltip="Prioritize glimmers on everything in the raid, regardless of hp.\n\Definitely use this in raids, NOT in Mythic+\n\Not recommended in arenas.\r\nIf you don't have glimmer trait, go get 3 of them.",var=SQUID.glimmer_everything,func=glimmer_everything_handler,default=true})
				create_checkbox({tab=tab,column=1,text="Aura Mastery",tooltip="Automatically uses aura mastery in PvE based on raid hp.",var=SQUID.auto_aura_mastery,func=aura_mastery_handler,default=true})
				create_checkbox({tab=tab,column=1,text="Avenging Wrath",tooltip="Automatically uses wings in PvE based on raid hp.",var=SQUID.auto_wings,func=wings_handler,default=true})
				create_checkbox({tab=tab,column=1,text="Holy Avenger",tooltip="Automatically uses Holy Avenger in PvE based on raid hp.",var=SQUID.auto_holy_avenger,func=holy_avenger_handler,default=true})
			else
				create_checkbox({tab=tab,column=1,text="PvP Healing",tooltip="Automatically uses healing abilities in PvP.\r\nThis is useful if you're not a very experienced hpal.",var=SQUID.auto_paladin,func=auto_paladin_handler})
				create_checkbox({tab=tab,column=1,text="Raid Mode",tooltip="Prioritize glimmers on everything in the raid, regardless of hp.\n\Definitely use this in raids, NOT in Mythic+\n\Not recommended in arenas.\r\nIf you don't have glimmer trait, go get 3 of them.",var=SQUID.glimmer_everything,func=glimmer_everything_handler,default=true})
				create_checkbox({tab=tab,column=1,text="Aura Mastery",tooltip="Automatically uses aura mastery in PvE based on raid hp.",var=SQUID.auto_aura_mastery,func=aura_mastery_handler,default=true})
				create_checkbox({tab=tab,column=1,text="Avenging Wrath",tooltip="Automatically uses wings in PvE based on raid hp.",var=SQUID.auto_wings,func=wings_handler,default=true})
				create_checkbox({tab=tab,column=1,text="Holy Avenger",tooltip="Automatically uses Holy Avenger in PvE based on raid hp.",var=SQUID.auto_holy_avenger,func=holy_avenger_handler,default=true})
			end
		elseif class == "Druid" then
			if locale == "zhCN" then
				create_checkbox({tab=tab,column=1,text="",tooltip="",var=SQUID.auto_burst,func=auto_burst_handler,default=true})
				create_checkbox({tab=tab,column=1,text="AOE",tooltip="PVP,,(, )",var=SQUID.spread_mode,func=spread_handler})
			else
				create_checkbox({tab=tab,column=1,text="Auto Burst",tooltip="Automate usage of berserk / incarn\n\This is done so in an intelligent way\n\Checks for CC on healer, and ensures a TF will be ready",var=SQUID.auto_burst,func=auto_burst_handler,default=true})
				create_checkbox({tab=tab,column=1,text="Spread Mode",tooltip="Spread bleeds to enemies in range\n\Only bleeds players (unless targeted) in pvp\n\This mode is not recommended in most cases.",var=SQUID.spread_mode,func=spread_handler})
			end
			--add auto burst for druid - SQUID.auto_burst
			--add spread for druid - SQUID.spread_mode
		elseif class == "Mage" then
			
			create_header({tab=tab,column=1,text="PvP Settings"})

			create_subheader({tab=tab,column=1,text="Crowd Control"})
			
			local under_subheader = true
			create_checkbox({tab=tab,column=1,text="Auto CC",tooltip="Automate usage of CC abilities (Ring of Frost, DB, Sheep)\n\nDoes an excellent job getting crowd control off DR consistently.\n\n(Recommend leaving this ENABLED for 99% of players)",new_var="Auto CC",func=set_squid_var,default=true,under_subheader=under_subheader})
			create_checkbox({under_subheader=under_subheader,tab=tab,column=1,text="Stop Moving To Cast CC",tooltip="Will force stop movement to cast CC (Ring of Frost / Sheep)\n\nHelps tremendously if you're not always aware of DRs and how the script plays.",var=SQUID.stop_to_cc,func=stop_to_cc_handler})
			create_checkbox({under_subheader=under_subheader,tab=tab,column=1,text="Only CC Healers",tooltip="Disable auto cc on off dps, and only cc healers.",var=SQUID.only_cc_healers,func=only_cc_healers_handler})
			
			create_subheader({tab=tab,column=1,text="Defensives"})
			create_slider({under_subheader=under_subheader,tab=tab,column=1,text="Auto Block",tooltip="- LEAVE AT 0% TO DISABLE -\n\nAuto-Block is always DISABLED by default.\n\nIf you wish to have the mage script auto-block for you:\n\nSet slider to HP percentage that you want it to use block (1-50%)",low="OFF",high="50",min=0,max=50,var=SQUID.auto_block,value=0,step=1,onvaluechanged=autoblock_handler})
			create_checkbox({under_subheader=under_subheader,tab=tab,column=1,text="Only After Caut",tooltip="Script will only auto-block after cauterize procs.\n\nAuto block will only happen if the slider is set above zero.",var=SQUID.block_after_caut,func=block_after_caut_handler})
			create_checkbox({under_subheader=under_subheader,tab=tab,column=1,text="Auto Alter Time",tooltip="Automatically use alter time",var=SQUID.auto_temp,func=auto_temp_handler,default=true})

			create_subheader({tab=tab,column=1,text="Fake Casting"})
			create_checkbox({under_subheader=under_subheader,tab=tab,text="Fake Cast",tooltip="Enables automatic fake-casting of cc abilities\n\nThe script will attempt 2-3 jukes if the enemy can interrupt you\n\nAdjust the sliders to change the range of cast % in which it will attempt a juke.\n\nThis can be useful but is sometimes not necessary since you have 3 spell schools, and can blink to avoid interrupts.",var=SQUID.auto_juke,func=auto_juke_handler})
			create_slider({under_subheader=under_subheader,tab=tab,text="Minimum % Cast to Fake",tooltip="The EARLIEST percentage into a cast which the script will attempt to fake cast.\n\nSetting this value higher will result in less quick stopcasts.\n\nThe larger the difference between these values, the less predictable your jukes will be.",low="1",high="80",min=1,max=80,var=SQUID.min_jukedelay,value=1,step=1,onvaluechanged=min_jukedelay_handler})
			create_slider({under_subheader=under_subheader,tab=tab,text="Maximum % Cast to Fake",tooltip="The LATEST percentage into a cast which the script will attempt to fake cast.\n\nSetting this value lower will result in quicker stopcasts.\n\nThe larger the difference between these values, the less predictable your jukes will be.",low="5",high="99",min=5,max=99,var=SQUID.max_jukedelay,value=60,step=1,onvaluechanged=max_jukedelay_handler})
			create_slider({under_subheader=under_subheader,tab=tab,text="Max Fake Cast Attempts",tooltip="The MOST fake casts the script will attempt before just finishing the cast.\n\nSet this value lower to spend less time fake casting.",low="1",high="8",min=1,max=8,var=SQUID.max_juke_attempts,value=2,step=1,onvaluechanged=max_juke_attempts_handler})
			
			create_subheader({tab=tab,column=1,text="Misc"})
			create_checkbox({under_subheader=under_subheader,tab=tab,text="Scorch Filler",tooltip="Cast scorch as a filler in PvP rotation.\n\nDisabling this is recommended for more experienced mages.",var=SQUID.scorch_filler,func=scorch_filler_handler,default=true})
			create_checkbox({tab=tab,column=1,text="Auto Food",tooltip="Make food automatically",new_var="Auto Food",func=set_squid_var,default=true,under_subheader=under_subheader})
			
			-- Crowd Control Header
			
			-- create_checkbox({tab=tab,text="Spread Mode",tooltip="Spread bleeds to enemies in range\n\Only bleeds players (unless targeted) in pvp",var=SQUID.spread_mode,func=spread_handler})
		elseif class == "Death Knight" then
			create_checkbox({tab=tab,text="Chains Peel",tooltip="Automate usage of Chains of Ice to slow melee dps.",var=SQUID.auto_chains,func=auto_chains_handler,default=true})
		elseif class == "Demon Hunter" then
			create_checkbox({tab=tab,text="Auto Fel Rush",tooltip="Automate Fel Rush as a gapcloser when moving towards your target.",var=SQUID.AutoFelRush,func=auto_fel_rush_handler,default=true})
		end

		--clear selected tab
		tab = nil

		--Utility Tab
		tabname = "Utility"
		for i=1,#tabs do if tabs[i].name == tabname then
			tab=tabs[i]
		end end

		create_header({tab=tab,column=1,text="Humanization"})
		create_slider({tab=tab,column=1,text=locale == "zhCN" and "" or "Min Delay",tooltip="This is Squid's 'General' humanization setting.\n\nYou can set a delay (in milliseconds) on bot-like actions.\nBot-like actions include interrupts, totem stomp, dispel, etc.\n\n- For best humanization:\nMin should be at least average human reaction time (120-200)\nMax should be as high as possible (300-600)\n\nThe delay is constantly randomized between your 2 selections.\n\n*Note* Interrupts are 99% of cast until 1-4 jukes are attempted.",low="0",high="600",min=0,max=600,var=SQUID.min_mindelay,value=160,step=1,onvaluechanged=mindelay_handler})
		create_slider({tab=tab,column=1,text=locale == "zhCN" and "" or "Max Delay",tooltip="This is Squid's 'General' humanization setting.\n\nYou can set a delay (in milliseconds) on bot-like actions.\nBot-like actions include interrupts, totem stomp, dispel, etc.\n\n- For best humanization:\nMin should be at least average human reaction time (120-200)\nMax should be as high as possible (300-600)\n\nThe delay is constantly randomized between your 2 selections.\n\n*Note* Interrupts are 99% of cast until 1-4 jukes are attempted.",low="0",high="600",min=0,max=600,var=SQUID.max_mindelay,value=310,step=1,onvaluechanged=maxdelay_handler})
		create_slider({tab=tab,column=1,text="Stomp Delay",tooltip="Add an ADDITIONAL delay to totem / psyfiend / banner stomping.\n\nThe random delay from the above sliders already affects totem stomps.\n > This ADDS to that delay.\n\ne.g, 200ms minDelay + 200ms totemDelay = 400ms totemDelay",min=0,max=200,new_var="Totem Stomp Delay",value=0,step=1,onvaluechanged=set_squid_var})

		--PvE Tab
		tabname = "PvE"
		for i=1,#tabs do if tabs[i].name == tabname then
			tab=tabs[i]
		end end

		--general PvE settings

		--class specific PvE settings
		if class == "Monk" then

		elseif class == "Warrior" then
		
		elseif class == "Paladin" then
			
		elseif class == "Druid" then
			
		elseif class == "Mage" then
			
			--auto combustion checkbox
			-- create_checkbox({tab=tab,text="Auto Combust",tooltip="Toggle automatic usage of Lucid Dreams + Combustion\n\nRotation will pool 1 rune of power, lucid dreams and meteor for combustion.",var=SQUID.auto_combust,func=auto_combust_handler,default=true})
			
			--auto combust hp slider
			create_slider({tab=tab,text="Combust Min HP",tooltip="Minimum HP of target to auto combust",low="100",high="200000",min=100,max=2000000,var=SQUID.min_combust_hp,value=40000,step=1,onvaluechanged=min_combust_hp_handler})
			create_checkbox({tab=tab,text="Solo Mode",tooltip="- PvE Solo Content Mode\n\nThe script will stop pooling for combust when not in instanced content.\n\nThis makes most solo content like questing much smoother.",var=SQUID.solo_mode,func=solo_mode_handler,default=true})
			-- create_checkbox({tab=tab,text="Disable World PvP",tooltip="Stop squid from changing to PvP mode in open world.",var=SQUID.pve_only,func=pve_only_handler})
			
		elseif class == "Death Knight" then
			
		elseif class == "Demon Hunter" then
		
		end

		--clear selected tab
		tab = nil

		--objects tab
		tabname = "Objects"
		for i=1,#tabs do if tabs[i].name == tabname then
			tab=tabs[i]
		end end
		
		create_checkbox({tab=tab,text="Draw Line",tooltip="Draws a line to the objects, helping you find them.\n\This may be annoying if you're tracking a lot of objects.",func=toggle_object_finder_lines,var=SQUID.draw_line_to_objects})
		create_checkbox({tab=tab,text="Rare Finder",tooltip="Distinguishable waypoint + line to any rare mobs.\n\nWill draw the line regardless of line setting and objects list",func=rare_finder_handler,var=SQUID.rare_finder})
		create_checkbox({tab=tab,text="Show Names on Mouseover",tooltip="Hides names and only shows waypoints until you mouseover them.\n\nThis can reduce screen clutter a LOT.",func=mouseover_names_handler,var=SQUID.mouseover_names,default=true})
		create_checkbox({tab=tab,text="Auto Interact",tooltip="Automatically interacts with objects you've defined.\n\This is useful for farming herbs when you can do it on your mount.",func=toggle_object_finder_auto_interact,var=SQUID.auto_interact_objects})

		create_slider({tab=tab,column=2,text="Max Range",tooltip="Set the range (in yds) that Object Finder will search for objects.\n\Render distance is typically no more than 150 yards for most dynamic objects.",low="5",high="500",min=5,max=500,var=SQUID.max_object_finder_dist,value=200,step=1,onvaluechanged=object_finder_dist_handler})
		create_checkbox({tab=tab,column=2,text="Track Quest Objects",tooltip="- WARNING: THIS WILL REDUCE FRAMERATE -\n\nAttempts to track any and all quest objectives.",func=track_quests_handler,var=SQUID.track_quests})
		create_checkbox({tab=tab,column=2,text=locale == "zhCN" and "" or "Object Finder",tooltip=locale == "zhCN" and ", . .NPC." or "- Enable Squid Object Finder -\n\nEasily find any game object or unit using this! (Generally not useful in PvP)\n\nJust enter the name of the object you're looking for in the editbox below\n\nEntries can be full or partial name, and are not case-sensitive!\n\nThe name of the object will be drawn over it's location in the game world,\nwith the distance beside it.",func=toggle_object_finder,var=SQUID.draw_objects})
		create_editbox({tab=tab,column=2,title="Objects List",text="Type object names here, separated by commas.",lines=3,var="Object Finder List"})
		
		--awareness tab
		tabname = "Awareness"
		for i=1,#tabs do if tabs[i].name == tabname then
			tab=tabs[i]
		end end

		create_slider({tab=tab,text="Line Scale",tooltip="Adjust the scale of lines that make squid's drawings.\n\nDecrease for thinner lines, increase for thicker.\n\nDefault value: 1",low="0.2",high="2",min=20,max=200,var=SQUID.line_scale,value=100,step=10,onvaluechanged=squid_line_scale_handler})
		create_checkbox({tab=tab,text="Smart Mode",tooltip="Awareness features will only trigger when your healer is out of your camera view.\n\nThis is useful to disable drawings and alerts when you're already aware of positioning.",var=SQUID.disable_while_visible,func=disable_while_visible_handler})
		create_checkbox({tab=tab,text="Alerts",tooltip="Big alerts that remind you when you are out of LoS or out of range of your healer.\n\nThis can be annoying but useful for those trying to train better positioning.",var=SQUID.awareness_alerts_enabled,func=alerts_enabled_handler})
		create_checkbox({tab=tab,text="Bad Line",tooltip="Red line drawn to your healer when out of position.\n\nRed line is more transparent when out of range.\n\nLine is more opaque when out of LoS.",var=SQUID.awareness_lines_enabled,func=lines_enabled_handler,default=true})
		create_checkbox({tab=tab,text="Good Line",tooltip="Green line drawn to your healer when in LoS and range.\n\nIf you want to always know your healers positioning this is useful.",var=SQUID.good_line_enabled,func=good_line_handler})
		create_checkbox({tab=tab,text="Positioning",tooltip="Drawings for optimal positioning.\n\nPlay within the green / yellow zones when targeted.\n\nExtremely useful for any class.\n\n35-40 yds from healer is green [best]\n\n30-35 yds is yellow [good]\n\n0-30 yds is red [bad]",var=SQUID.positioning_help,func=positioning_help_handler,default=true})

		--clear selected tab
		tab = nil

		tabname = "Automation"
		for i=1,#tabs do if tabs[i].name == tabname then
			tab=tabs[i]
		end end

		create_checkbox({tab=tab,text="Full AFK",tooltip="Fully automates movement and all cooldowns\n\nUse with auto queue to spam arenas while AFK / asleep",func=cap_bot_handler,var=SQUID.cap_bot})

		create_checkbox({tab=tab,text="Auto Que",tooltip="Automatically queues for arena based on group size (skirmish if alone)\n\nWill also automatically accept ready checks and queue pops",func=auto_queue_handler,var=SQUID.auto_queue})
		create_checkbox({tab=tab,text="MMR Tank",tooltip="Leaves arena immediately after entering combat\n\nOnly works when Full AFK mode is enabled",func=mmr_tank_handler,var=SQUID.tank_mmr})
		
		create_checkbox({tab=tab,text="Queue BGs",tooltip="Queue for BGs regardless of group size\n\nUse this if you just want to que BGs!",func=only_bgs_handler,var=SQUID.only_bgs})
		create_checkbox({tab=tab,text="Queue Skirms",tooltip="Only queue for skirms regardless of group size\n\nUse this if you just want to que skirmishes!",func=only_skirms_handler,var=SQUID.only_skirms,default=true})
		create_checkbox({tab=tab,text="Always Leave Skirms",tooltip="Automatically leaves after skirms instead of requeueing after victories.",new_var="Leave Skirms",func=set_squid_var})
		
		create_checkbox({tab=tab,text="Kill Healers",tooltip="MOW THEM DOWNNNN KILL THE HEALERSSSS LETS GOOOO",func=kill_healers_handler,var=SQUID.kill_healers})

		--hide tooltips button not tied to tabs
		-- local stext = locale == "zhCN" and "" or "show tooltips"
		-- local htext = locale == "zhCN" and "" or "hide tooltips"
		
		-- local hidetooltips = CreateFrame("Button",nil,f,nil,"UIPanelButtonTemplate")
		-- hidetooltips:SetText(SQUID.hidetooltips and stext or htext)
		-- hidetooltips:SetNormalTexture(squid_button)
		-- hidetooltips:GetNormalTexture():SetVertexColor(1,1,1,.3)
		-- hidetooltips:SetHighlightTexture(squid_button)
		-- hidetooltips:SetScript("OnClick",function(self)
		-- 	SQUID.hidetooltips = not SQUID.hidetooltips
		-- 	self:SetText(SQUID.hidetooltips and stext or htext)
		-- 	GameTooltip:Hide()
		-- end)
		-- hidetooltips:SetScript("OnEnter",function(self)
		-- 	if not SQUID.hidetooltips then
		-- 		GameTooltip:Show()
		-- 		GameTooltip:SetOwner(f,"CENTER",0,0);
		-- 		GameTooltip:SetAnchorType("ANCHOR_TOPLEFT",0,0);
		-- 		GameTooltip:SetBackdrop(backdrop2)
		-- 		GameTooltip:SetBackdropColor(0.2,0.2,0.2,1)
		-- 		GameTooltipText:SetFont(cfe,4,nil)
		-- 		GameTooltip:SetText("Hide project squid's tooltips (like this one) in the GUI.");
		-- 	end
		-- end)
		-- hidetooltips:SetScript("OnLeave",function(self)
		-- 	GameTooltipText:SetFont("Fonts\\FRIZQT__.TTF",12)
		-- 	GameTooltip:Hide()
		-- end)
		-- hidetooltips:GetFontString():SetFont(cfe,8,nil)
		-- hidetooltips:SetSize(enable:GetFontString():GetWidth()+3,25)
		-- hidetooltips:SetPoint("CENTER",90,-60)

		--auto populate the default tab (general)
		populate("General")

		-- do some things on specialization change event
		f:RegisterEvent("PLAYER_SPECIALIZATION_CHANGED")
		f:SetScript("OnEvent",on_spec_changed)

		SQFRAMEHOLDER = f
		f:Hide() -- hide gui initially
	
		local alpha_frame = CreateFrame("Frame"):SetScript("OnUpdate",function()
			if not dir then
				dir = 1
				f:SetAlpha(0)
			elseif dir == 1 then
				local a = f:GetAlpha()
				local duration = .75*GetFramerate()
				local step = 1/duration
				if a < 1 then
					f:SetAlpha(a + step)
				end
			elseif dir == -1 then
				local a = f:GetAlpha()
				local duration = .45*GetFramerate()
				local step = 1/duration
				if a > 0 then
					f:SetAlpha(a - step)
				else
					f:Hide()
				end
			end
		end)

		local function squid_gui_toggle()
			if f:IsShown() then
				dir = -1
			else

				--show the frame
				dir = nil
				f:Show()
				

				--set the alpha to 0
				local a = 0
				f:SetAlpha(a)

				--rebuild alpha from 0 to 1
				local fps = 1/GetFramerate()
				for i=0,1,fps do
					a = a + i
					f:SetAlpha(a)
				end

			end
		end

		local function open_meshlink()
			OpenURL("https://mega.nz/file/UtBgFbaA#tHgCl3n_Xn3kDZ2TOW1ngMo1khfgSrbshth56FYHB0U")
		end

		StaticPopupDialogs["OPEN_MESHLINK"] = {
			text = 'Click Yes to download Shadowlands navigation meshes. Extract the "mmaps" folder to the folder containing EWT.',
			button1 = "Yes",
			button2 = "No",
			OnAccept = function()
				open_meshlink()
			end,
			timeout = 0,
			whileDead = true,
			hideOnEscape = true,
			preferredIndex = 3,  -- avoid some UI taint, see http://www.wowace.com/announcements/how-to-avoid-some-ui-taint/
		}

		local function Squid_Mesh_Popup()
			StaticPopup_Show ("OPEN_MESHLINK")
		end

		local function squid_fools()
			print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Hello, " .. UnitName("player") .. ". We have detected an \"UNAUTHORIZED THIRD PARTY PROGRAM\" running on your computer. Your account will be suspended and an email will be sent to you shortly describing the offense in place. Please move to a safe location in game as soon as possible. Thanks for your attention.")
			PlaySound(SOUNDKIT.TELL_MESSAGE);
			C_Timer.After(45,function()
			    print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-CallOfDutyBlackOps4:12:12:0:0:32:16:4:28:0:16\124t [Xen]: Yo. It's Xen. I'm detecting GM activity. Is this guy fucking with you? I'm at Burger King right now but it's chill, I'm controlling your game remotely through my microcomputing nano-device. Let me take care of this for you.")	
				PlaySound(SOUNDKIT.TELL_MESSAGE);
				C_Timer.After(35,function()
					print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t To [Holinka]: Sir, I strongly deny any such accusations. I am innocent, and you've done nothing to prove me guilty. I must also rebuttal by asking why you have made no significant effort to improve the accessibility and fun of your game? Me and the boys have been grinding out this shitty ass gear system for months, and all we wish to do is queue it up.")
					PlaySound(SOUNDKIT.TELL_MESSAGE);
					C_Timer.After(18,function()
						print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t To [Holinka]: He who is without sin may cast the first stone.")
						PlaySound(SOUNDKIT.TELL_MESSAGE);
						C_Timer.After(25,function()
							print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Sorry, our decision is final. We have sufficient evidence of our findings. You agreed to the Terms of Use when you created your Blizzard account. You will now be removed from the game, as I must suspend your account. We're sorry for any inconvenience this may have caused.")
							PlaySound(SOUNDKIT.TELL_MESSAGE);
							C_Timer.After(25,function()
								print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: But... our decision is final... How is this possible? The ban button isn't working? What the fuck kind of black magic is this?")
								PlaySound(SOUNDKIT.TELL_MESSAGE);
								C_Timer.After(12,function()
									print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Who the fuck are y-")
									PlaySound(SOUNDKIT.TELL_MESSAGE);
									C_Timer.After(16,function()
										print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-CallOfDutyBlackOps4:12:12:0:0:32:16:4:28:0:16\124t [Xen]: Goodnight, sweet Holinka. Aight young Squid, you can get on with your business now. Enjoy the rest of your day this fine April evening, and let me know if any GMs try to fuck with you again. Pce out.")	
										PlaySound(SOUNDKIT.TELL_MESSAGE);
									end)
								end)
							end)
						end)
					end)
				end)
			end)
		end

		function squid_slash_cmd(msg,editbox,arg1,arg2)
			if msg == "" then
				squid_gui_toggle()
			end
			if msg == "burst" then
				SquidBurst()
			end
			if msg == "trinket" then
				SquidTrinket()
			end
			if msg == "mesh" then
				Squid_Mesh_Popup()
			end
			if msg == "spread" then
				spread_handler()
			end
			if msg == "fools" then
				squid_fools()
			end
			local action, target = SecureCmdOptionParse(msg);
		    if ( action ) then
		    	local spellExists = DoesSpellExist(action)
				local name, bag, slot = SecureCmdItemParse(action);
				if ( spellExists ) then
					-- now we can pause if spell is on gcd
					if IsSpellOnGCD( action ) and _spellCooldown( action ) <= 1.5 then
						SquidPaused=GetTime()
					end
					if target == "healer" then
						for i=1,#Enemies do
							if _isHealer(Enemies[i]) then
								SQ_CastSpellByName(action,Enemies[i])
							end
						end
					else
						SQ_CastSpellByName(action, target);
					end
					SQ_QueuedSpell = {spell = action, target = target, time = GetTime()}
				elseif ( slot or GetItemInfo(name) ) then
					SecureCmdUseItem(name, bag, slot, target);
				end
		    end
		end


		SLASH_Squid1 = "/squid"
		SLASH_Squid2 = "/sq"
		SLASH_Squid3 = "/squ"
		SLASH_Squid4 = "/squi"
		SLASH_Squid5 = "/xr"
		SLASH_Squid6 = "/c"
		SlashCmdList["Squid"] = squid_slash_cmd

		Squid_GUI_Init=true
	end -- end of gui
end

function Squid_Alert(message1,message2,sound,fadetime,texture,refresh_old)

	local time = GetTime()
	local framerate = GetFramerate()
	local stop_func

	--no duplicates
	if message2 then
		for i=1,#AlertFrames do
			if AlertFrames[i].Text:GetText() == message1 .. " |cff00ccff" .. message2 then
				AlertFrames[i].Alpha = 1
				AlertFrames[i]:SetAlpha(1)
				AlertFrames[i].newupdate = time + (fadetime or 1)
				return false;
			end
		end
	else
		-- if message1 ~= "|cFFdecbebRotation Enabled" 
		-- and message1 ~= "|cFFca2aa5Rotation Disabled" 
		-- and message1 ~= "|cFFdecbebAuto Combustion Enabled" 
		-- and message1 ~= "|cFFca2aa5Auto Combustion Disabled" then
		local enabled_match = strmatch(message1,"Enabled")
		local disabled_match = strmatch(message1,"Disabled")
		
		if not enabled_match and not disabled_match then
			for i=1,#AlertFrames do
				if AlertFrames[i].Text:GetText() == message1 then
					AlertFrames[i].Alpha = 1
					AlertFrames[i]:SetAlpha(1)
					AlertFrames[i].newupdate = time + (fadetime or 1)
					return false;
				end
			end
		else
			if enabled_match then
				for i=1,#AlertFrames do
					if AlertFrames[i] then
						if strmatch(AlertFrames[i].Text:GetText(),"Disabled") then
							AlertFrames[i]:Hide()
							tremove(AlertFrames,i)
						elseif strmatch(AlertFrames[i].Text:GetText(),message1) then
							AlertFrames[i].Alpha = 1
							AlertFrames[i]:SetAlpha(1)
							AlertFrames[i].newupdate = time + 1
							stop_func = true
						end
					end
				end
			end
			if disabled_match then
				for i=1,#AlertFrames do
					if AlertFrames[i] then
						if strmatch(AlertFrames[i].Text:GetText(),"Enabled") then
							AlertFrames[i]:Hide()
							tremove(AlertFrames,i)
						elseif strmatch(AlertFrames[i].Text:GetText(),message1) then
							AlertFrames[i].Alpha = 1
							AlertFrames[i]:SetAlpha(1)
							AlertFrames[i].newupdate = time + 1
							stop_func = true
						end
					end
				end
			end
		end
	end

	if stop_func then return false end

	local alert = CreateFrame("Frame")
	local anchor,_,anchor2,x,y = AlertFrames_Anchor:GetPoint()
	alert:SetPoint("CENTER",AlertFrames_Anchor,"CENTER",0,20)
	alert:SetHeight(125)
	alert:SetWidth(400)

	local font = sui_bold
	alert:SetClampedToScreen(true)
	alert.Text = alert:CreateFontString(nil, "HIGH", nil)
	alert.Text:SetFont(font,13,'THICKOUTLINE')

	alert:SetScript("OnMouseUp",nil);
	alert:SetScript("OnMouseDown",nil);

	if message2 then
		alert.Text:SetText(message1 .. " |cff00ccff" .. message2)
	else
		alert.Text:SetText(message1)
	end

	alert.Start = time
	alert.End = time + 2
	alert.Time = 2
	alert.Alpha = 1

	alert.Text:SetPoint("CENTER",alert,"CENTER",0,0) -- +200

	local t = GetSpellTexture(texture)
	if t then
		alert.Texture = alert:CreateTexture(nil,"OVERLAY",nil)
		alert.Texture:SetTexture(t)
		alert.Texture:ClearAllPoints()
		-- alert.Texture:SetParent(alert)
		alert.Texture:SetWidth(19)
		alert.Texture:SetHeight(19)
		if AlertFrames[1] and AlertFrames[1].Texture then
			local pos,parent,pos2,offset = AlertFrames[1].Texture:GetPoint()
			-- no more alternating icon position
			-- if pos == "LEFT" then
			-- 	alert.Texture:SetPoint("RIGHT",alert.Text,"RIGHT",25,0)---(20+(alert.Text:GetWidth()/2)),0)
			-- else
				alert.Texture:SetPoint("LEFT",alert.Text,"LEFT",-25,0)---(20+(alert.Text:GetWidth()/2)),0)
			-- end
		else
			alert.Texture:SetPoint("LEFT",alert.Text,"LEFT",-25,0)
		end

	end

	--initial alert animation
	alert:SetScript("OnUpdate",function(self)
		if self then
			local duration = .08*framerate
			local step = 4/duration
			local desired_size = 12 --desired size of text after the animation is complete
			local size = select(2,self.Text:GetFont())
			if size <= desired_size+2 and not self.switch then
				self.Text:SetFont(font,size+step,"OUTLINE");
			elseif size > desired_size then
				self.Text:SetFont(font,size-step,"OUTLINE");
				self.switch = true
			end
		end
	end)

	--begin fade animation after designated time ( 2.5s default )
	C_Timer.After(fadetime or 2.5,function()
		alert:SetScript("OnUpdate",function(self)
			if not self.newupdate or self.newupdate < GetTime() then
				if self then
					local duration = .7*framerate
					local step = 1/duration
					self:SetAlpha(self.Alpha);
					self.Alpha = self.Alpha - step
				end
			end
		end)
	end)

	alert.index = #AlertFrames+1

	table.insert(AlertFrames,alert)

	--play soundfile
	if not SQUID.sounds_disabled and sound and (not soundplayed[sound] or time - soundplayed[sound] > .3) then

		local cork = Squid_Directory() .. "/media/cork.mp3"
		local danger = Squid_Directory() .. "/media/danger1.mp3"
		local positive = Squid_Directory() .. "/media/positive1.mp3"
		local cork2 = Squid_Directory() .. "/media/cork2.mp3"
		local alert1 = Squid_Directory() .. "/media/alert1.mp3"
		local alert2 = Squid_Directory() .. "/media/alert2.wav"
		local alert3 = Squid_Directory() .. "/media/alert3.mp3"
		local happy_alert = Squid_Directory() .. "/media/happy_alert.mp3"

		--cork sound
		if sound == 1 then
			PlaySoundFile(cork,"Master")
		end
		--danger sound
		if sound == 2 then
			PlaySoundFile(danger,"Master")
		end
		--positive sound
		if sound == 3 then
			PlaySoundFile(positive,"Master")
		end
		--second cork sound
		if sound == 4 then
			PlaySoundFile(cork2,"Master")
		end
		--alert sound
		if sound == 5 then
			PlaySoundFile(alert1,"Master")
		end
		--alert sound 2
		if sound == 6 then
			PlaySoundFile(alert2,"Master")
		end
		--alert sound 3
		if sound == 7 then
			PlaySoundFile(alert3,"Master")
		end
		--happy smiley alert :)
		if sound == 8 then
			PlaySoundFile(happy_alert,"Master")
		end

		soundplayed[sound]=time

	end

	return true

end

function Squid_Alert_Big(message1,message2,sound,fadetime,texture)

	local time=GetTime()
	local framerate = GetFramerate()

	--no duplicates
	if message2 then
		for i=1,#BigAlertFrames do
			if BigAlertFrames[i].Text:GetText() == message1 .. " |cff00ccff" .. message2 then
				BigAlertFrames[i].Alpha = 1
				BigAlertFrames[i]:SetAlpha(1)
				BigAlertFrames[i].newupdate = time + (fadetime or 1)
				return false;
			end
		end
	else
		for i=1,#BigAlertFrames do
			if BigAlertFrames[i].Text:GetText() == message1 then
				BigAlertFrames[i].Alpha = 1
				BigAlertFrames[i]:SetAlpha(1)
				BigAlertFrames[i].newupdate = time + (fadetime or 1)
				return false;
			end
		end
	end

	--75 , 115 (+ y axis)

	local alert = CreateFrame("Frame")
	local anchor,_,anchor2,x,y = BigAlertFrames_Anchor:GetPoint()
	alert:SetPoint("CENTER",BigAlertFrames_Anchor,"CENTER",0,-25)
	-- alert:SetPoint("CENTER",15,75)
	alert:SetHeight(125)
	alert:SetWidth(400)

	local font = sui_bold
	alert:SetClampedToScreen(true)
	alert.Text = alert:CreateFontString(nil, "HIGH", nil)
	alert.Text:SetFont(font,18,'OUTLINE')

	alert:SetScript("OnMouseUp",nil);
	alert:SetScript("OnMouseDown",nil);

	if message2 then
		alert.Text:SetText(message1 .. " |cff00ccff" .. message2)
	else
		alert.Text:SetText(message1)
	end

	alert.Start = time
	alert.End = time + 2
	alert.Time = 2
	alert.Alpha = 1

	alert.Text:SetPoint("CENTER",alert,"CENTER",0,0)

	if texture then
		local t=GetSpellTexture(texture)
		alert.Texture = alert:CreateTexture(nil,"OVERLAY",nil)
		alert.Texture:SetTexture(t)
		alert.Texture:ClearAllPoints()
		-- alert.Texture:SetParent(alert)
		alert.Texture:SetWidth(22)
		alert.Texture:SetHeight(22)
		alert.Texture:SetPoint("LEFT",alert.Text,"LEFT",-32,0)
	end

	--initial alert animation
	alert:SetScript("OnUpdate",function(self)
		if self then
			local duration = .08*framerate
			local step = 4/duration
			local desired_size = 18 --desired size of text after the animation is complete
			local size = select(2,self.Text:GetFont())
			if size <= desired_size+2 and not self.switch then
				self.Text:SetFont(font,size+step,"OUTLINE");
			elseif size > desired_size then
				self.Text:SetFont(font,size-step,"OUTLINE");
				self.switch = true
			end
		end
	end)

	--begin fade animation after designated time ( 2.5s default )
	C_Timer.After(fadetime or 2.5,function()
		alert:SetScript("OnUpdate",function(self)
			if not self.newupdate or self.newupdate < GetTime() then
				if self then
					local duration = .7*framerate
					local step = 1/duration
					self:SetAlpha(self.Alpha);
					self.Alpha = self.Alpha - step
				end
			end
		end)
	end)

	alert.index = #BigAlertFrames+1

	table.insert(BigAlertFrames,alert)

	--play soundfile
	if not SQUID.sounds_disabled and sound and (not soundplayed[sound] or time - soundplayed[sound] > .3) then

		local cork = Squid_Directory() .. "/media/cork.mp3"
		local danger = Squid_Directory() .. "/media/danger1.mp3"
		local positive = Squid_Directory() .. "/media/positive1.mp3"
		local cork2 = Squid_Directory() .. "/media/cork2.mp3"
		local alert1 = Squid_Directory() .. "/media/alert1.mp3"
		local alert2 = Squid_Directory() .. "/media/alert2.wav"
		local alert3 = Squid_Directory() .. "/media/alert3.mp3"
		local happy_alert = Squid_Directory() .. "/media/happy_alert.mp3"

		--cork sound
		if sound == 1 then
			PlaySoundFile(cork,"Master")
		end
		--danger sound
		if sound == 2 then
			PlaySoundFile(danger,"Master")
		end
		--positive sound
		if sound == 3 then
			PlaySoundFile(positive,"Master")
		end
		--second cork sound
		if sound == 4 then
			PlaySoundFile(cork2,"Master")
		end
		--alert sound
		if sound == 5 then
			PlaySoundFile(alert1,"Master")
		end
		--alert sound 2
		if sound == 6 then
			PlaySoundFile(alert2,"Master")
		end
		--alert sound 3
		if sound == 7 then
			PlaySoundFile(alert3,"Master")
		end
		--happy smiley alert :)
		if sound == 8 then
			PlaySoundFile(happy_alert,"Master")
		end

		soundplayed[sound]=time

	end

	return true

end

--Hook keybinds to display descriptions in tooltips
local function keybind_description_handler(name)
	return name == "Maim Focus" and "Maim your focus target next time you reach 5 cp\r\n\Command expires 5 seconds after pressing\r\n\Will leap when ready to maim if out of range" 
	or name == "Killshot" and "Hold to set up a kill on your target,\r\n\with a full sheep into gpy, ring, gpy,\r\n\ blink DB,meteor, and combust" 
	or name == "Maim Target" and "Maim your target next time you reach 5 cp\r\n\Command expires 5 seconds after pressing\r\n\Will leap when ready to maim if out of range" 
	or name == "Maim Healer" and "Maim the healer next time you reach 5 cp\r\n\Command expires 5 seconds after pressing\r\n\Will leap when ready to maim if out of range" 
	or name == "Squid Toggler" and "Use this as a keybind to easily Enable and Disable the rotation with one button."
	or name == "Burst Key" and "Press to use burst cooldowns + force the rotation to dump available damage."
	or name == "Block Key" and "Hold down to force a manual Ice Block."
	or name == "Combust Toggle" and "Toggle auto combustion phase in PvE. Does not do anything in PvP rotation -yet-."
	or name == "Meteor / Orb" and "Hold to force a Meteor or Frozen Orb on your target."
	or name == "CC Healer" and "Hold to force CC on the enemy Healer."
	or name == "CC Focus" and "Hold to force CC your focus target."
	or name == "CC Off-Target" and "Hold to force CC on the off-target."
	or name == "Blink -> DB Healer" and "Hold to DB the Healer if in range, same key will otherwise blink into DB range if needed."
	or name == "Blink -> DB Focus" and "Hold to DB your focus if in range, same key will otherwise blink into DB range if needed."
	or name == "Blink -> DB Target" and "Hold to DB your target if in range, same key will otherwise blink into DB range if needed."
	or name == "Ring of Frost Healer" and "Hold to force Ring of Frost on the Healer. Will attempt to predict movement if they're moving."
	or name == "Ring of Frost Focus" and "Hold to force Ring of Frost on your focus target. Will attempt to predict movement if they're moving."
	or name == "Ring of Frost Target" and "Hold to force Ring of Frost on your target. Will attempt to predict movement if they're moving."
	or name == "Retreat Forward" and "Press to do a 180 and retreat forward. This action is very smooth and will not affect camera / gameplay."
	or name == "Dmg Key (Healers)" and "Hold to do damage as a healer"
	or name == "Poly > Gpy > Ring > Gpy Setup" and "Hold down to perform this combo. Useful in 1v1 situations."

	or ""
end

CreateFrame("Frame"):SetScript("OnUpdate",function()
	if KeyBindingFrame and KeyBindingFrame:IsShown() then
		for i=1,21 do
			local key = _G["KeyBindingFrameKeyBinding"..i]
			local getname = function(self) return self.description:GetText() end
			key.getname = getname
			if key and key:IsShown() then
				local box = _G["KeyBindingFrameKeyBinding"..i.."Key1Button"]
				box:SetScript("OnEnter",function(self)
					local name = _G["KeyBindingFrameKeyBinding"..i]:getname()
					GameTooltip:Show()
					GameTooltip:SetOwner(self,"ANCHOR_CURSOR",0,0);
					GameTooltip:SetAnchorType("ANCHOR_CURSOR",0,0);
					GameTooltip:SetText(keybind_description_handler(name));
				end)
				box:SetScript("OnLeave",function(self)
					GameTooltip:Hide()
				end)
			end
		end
	end
end)

local sa_og = Squid_Alert
local sa_b_og = Squid_Alert_Big
local LibDraw_line_og
local LibDraw_text_og
local LibDraw_texture_og

function toggle_squid_streaming_mode()
	if not squid_streaming_mode_enabled then

		sa_og = Squid_Alert
		sa_b_og = Squid_Alert_Big
		LibDraw_line_og = LibDraw.Draw2DLine
		LibDraw_text_og = LibDraw.Text
		LibDraw_texture_og = LibDraw.Texture

		Squid_Alert = function() end
		Squid_Alert_Big = function() end
		LibDraw.Draw2DLine = function() end
		LibDraw.Text = function() end
		LibDraw.Texture = function() end

		squid_streaming_mode_enabled = true

	else

		Squid_Alert = sa_og
		Squid_Alert_Big = sa_b_og
		LibDraw.Draw2DLine = LibDraw_line_og
		LibDraw.Text = LibDraw_text_og
		LibDraw.Texture = LibDraw_texture_og

		squid_streaming_mode_enabled = false

	end
end

-- $Id: LibStub.lua 76 2007-09-03 01:50:17Z mikk $
-- LibStub is a simple versioning stub meant for use in Libraries.  http://www.wowace.com/wiki/LibStub for more info
-- LibStub is hereby placed in the Public Domain
-- Credits: Kaelten, Cladhaire, ckknight, Mikk, Ammo, Nevcairiel, joshborke
local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 1  -- NEVER MAKE THIS AN SVN REVISION! IT NEEDS TO BE USABLE IN ALL REPOS!
local LibStub = _G[LIBSTUB_MAJOR]

-- Check to see is this version of the stub is obsolete
if not LibStub or LibStub.minor < LIBSTUB_MINOR then
	LibStub = LibStub or {libs = {}, minors = {} }
	_G[LIBSTUB_MAJOR] = LibStub
	LibStub.minor = LIBSTUB_MINOR
	
	-- LibStub:NewLibrary(major, minor)
	-- major (string) - the major version of the library
	-- minor (string or number ) - the minor version of the library
	-- 
	-- returns nil if a newer or same version of the lib is already present
	-- returns empty library object or old library object if upgrade is needed
	function LibStub:NewLibrary(major, minor)
		assert(type(major) == "string", "Bad argument #2 to `NewLibrary' (string expected)")
		minor = assert(tonumber(strmatch(minor, "%d+")), "Minor version must either be a number or contain a number.")
		
		local oldminor = self.minors[major]
		if oldminor and oldminor >= minor then return nil end
		self.minors[major], self.libs[major] = minor, self.libs[major] or {}
		return self.libs[major], oldminor
	end
	
	-- LibStub:GetLibrary(major, [silent])
	-- major (string) - the major version of the library
	-- silent (boolean) - if true, library is optional, silently return nil if its not found
	--
	-- throws an error if the library can not be found (except silent is set)
	-- returns the library object if found
	function LibStub:GetLibrary(major, silent)
		if not self.libs[major] and not silent then
			error(("Cannot find a library instance of %q."):format(tostring(major)), 2)
		end
		return self.libs[major], self.minors[major]
	end
	
	-- LibStub:IterateLibraries()
	-- 
	-- Returns an iterator for the currently registered libraries
	function LibStub:IterateLibraries() 
		return pairs(self.libs) 
	end
	
	setmetatable(LibStub, { __call = LibStub.GetLibrary })
end

AddEWTCallback(function()
	--[[ $Id: CallbackHandler-1.0.lua 14 2010-08-09 00:43:38Z mikk $ ]]
	local MAJOR, MINOR = "CallbackHandler-1.0", 6
	local CallbackHandler = LibStub:NewLibrary(MAJOR, MINOR)

	if not CallbackHandler then return end -- No upgrade needed

	local meta = {__index = function(tbl, key) tbl[key] = {} return tbl[key] end}

	-- Lua APIs
	local tconcat = table.concat
	local assert, error, loadstring = assert, error, loadstring
	local setmetatable, rawset, rawget = setmetatable, rawset, rawget
	local next, select, pairs, type, tostring = next, select, pairs, type, tostring

	-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
	-- List them here for Mikk's FindGlobals script
	-- GLOBALS: geterrorhandler

	local xpcall = xpcall

	local function errorhandler(err)
		return geterrorhandler()(err)
	end

	local function CreateDispatcher(argCount)
		local code = [[
		local next, xpcall, eh = ...

		local method, ARGS
		local function call() method(ARGS) end

		local function dispatch(handlers, ...)
			local index
			index, method = next(handlers)
			if not method then return end
			local OLD_ARGS = ARGS
			ARGS = ...
			repeat
				xpcall(call, eh)
				index, method = next(handlers, index)
			until not method
			ARGS = OLD_ARGS
		end

		return dispatch
		]]

		local ARGS, OLD_ARGS = {}, {}
		for i = 1, argCount do ARGS[i], OLD_ARGS[i] = "arg"..i, "old_arg"..i end
		code = code:gsub("OLD_ARGS", tconcat(OLD_ARGS, ", ")):gsub("ARGS", tconcat(ARGS, ", "))
		return assert(loadstring(code, "safecall Dispatcher["..argCount.."]"))(next, xpcall, errorhandler)
	end

	local Dispatchers = setmetatable({}, {__index=function(self, argCount)
		local dispatcher = CreateDispatcher(argCount)
		rawset(self, argCount, dispatcher)
		return dispatcher
	end})

	--------------------------------------------------------------------------
	-- CallbackHandler:New
	--
	--   target            - target object to embed public APIs in
	--   RegisterName      - name of the callback registration API, default "RegisterCallback"
	--   UnregisterName    - name of the callback unregistration API, default "UnregisterCallback"
	--   UnregisterAllName - name of the API to unregister all callbacks, default "UnregisterAllCallbacks". false == don't publish this API.

	function CallbackHandler:New(target, RegisterName, UnregisterName, UnregisterAllName, OnUsed, OnUnused)
		-- TODO: Remove this after beta has gone out
		assert(not OnUsed and not OnUnused, "ACE-80: OnUsed/OnUnused are deprecated. Callbacks are now done to registry.OnUsed and registry.OnUnused")

		RegisterName = RegisterName or "RegisterCallback"
		UnregisterName = UnregisterName or "UnregisterCallback"
		if UnregisterAllName==nil then	-- false is used to indicate "don't want this method"
			UnregisterAllName = "UnregisterAllCallbacks"
		end

		-- we declare all objects and exported APIs inside this closure to quickly gain access
		-- to e.g. function names, the "target" parameter, etc


		-- Create the registry object
		local events = setmetatable({}, meta)
		local registry = { recurse=0, events=events }

		-- registry:Fire() - fires the given event/message into the registry
		function registry:Fire(eventname, ...)
			if not rawget(events, eventname) or not next(events[eventname]) then return end
			local oldrecurse = registry.recurse
			registry.recurse = oldrecurse + 1

			Dispatchers[select('#', ...) + 1](events[eventname], eventname, ...)

			registry.recurse = oldrecurse

			if registry.insertQueue and oldrecurse==0 then
				-- Something in one of our callbacks wanted to register more callbacks; they got queued
				for eventname,callbacks in pairs(registry.insertQueue) do
					local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.
					for self,func in pairs(callbacks) do
						events[eventname][self] = func
						-- fire OnUsed callback?
						if first and registry.OnUsed then
							registry.OnUsed(registry, target, eventname)
							first = nil
						end
					end
				end
				registry.insertQueue = nil
			end
		end

		-- Registration of a callback, handles:
		--   self["method"], leads to self["method"](self, ...)
		--   self with function ref, leads to functionref(...)
		--   "addonId" (instead of self) with function ref, leads to functionref(...)
		-- all with an optional arg, which, if present, gets passed as first argument (after self if present)
		target[RegisterName] = function(self, eventname, method, ... --[[actually just a single arg]])
			if type(eventname) ~= "string" then
				error("Usage: "..RegisterName.."(eventname, method[, arg]): 'eventname' - string expected.", 2)
			end

			method = method or eventname

			local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.

			if type(method) ~= "string" and type(method) ~= "function" then
				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - string or function expected.", 2)
			end

			local regfunc

			if type(method) == "string" then
				-- self["method"] calling style
				if type(self) ~= "table" then
					error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): self was not a table?", 2)
				elseif self==target then
					error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): do not use Library:"..RegisterName.."(), use your own 'self'", 2)
				elseif type(self[method]) ~= "function" then
					error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - method '"..tostring(method).."' not found on self.", 2)
				end

				if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
					local arg=select(1,...)
					regfunc = function(...) self[method](self,arg,...) end
				else
					regfunc = function(...) self[method](self,...) end
				end
			else
				-- function ref with self=object or self="addonId" or self=thread
				if type(self)~="table" and type(self)~="string" and type(self)~="thread" then
					error("Usage: "..RegisterName.."(self or \"addonId\", eventname, method): 'self or addonId': table or string or thread expected.", 2)
				end

				if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
					local arg=select(1,...)
					regfunc = function(...) method(arg,...) end
				else
					regfunc = method
				end
			end


			if events[eventname][self] or registry.recurse<1 then
			-- if registry.recurse<1 then
				-- we're overwriting an existing entry, or not currently recursing. just set it.
				events[eventname][self] = regfunc
				-- fire OnUsed callback?
				if registry.OnUsed and first then
					registry.OnUsed(registry, target, eventname)
				end
			else
				-- we're currently processing a callback in this registry, so delay the registration of this new entry!
				-- yes, we're a bit wasteful on garbage, but this is a fringe case, so we're picking low implementation overhead over garbage efficiency
				registry.insertQueue = registry.insertQueue or setmetatable({},meta)
				registry.insertQueue[eventname][self] = regfunc
			end
		end

		-- Unregister a callback
		target[UnregisterName] = function(self, eventname)
			if not self or self==target then
				error("Usage: "..UnregisterName.."(eventname): bad 'self'", 2)
			end
			if type(eventname) ~= "string" then
				error("Usage: "..UnregisterName.."(eventname): 'eventname' - string expected.", 2)
			end
			if rawget(events, eventname) and events[eventname][self] then
				events[eventname][self] = nil
				-- Fire OnUnused callback?
				if registry.OnUnused and not next(events[eventname]) then
					registry.OnUnused(registry, target, eventname)
				end
			end
			if registry.insertQueue and rawget(registry.insertQueue, eventname) and registry.insertQueue[eventname][self] then
				registry.insertQueue[eventname][self] = nil
			end
		end

		-- OPTIONAL: Unregister all callbacks for given selfs/addonIds
		if UnregisterAllName then
			target[UnregisterAllName] = function(...)
				if select("#",...)<1 then
					error("Usage: "..UnregisterAllName.."([whatFor]): missing 'self' or \"addonId\" to unregister events for.", 2)
				end
				if select("#",...)==1 and ...==target then
					error("Usage: "..UnregisterAllName.."([whatFor]): supply a meaningful 'self' or \"addonId\"", 2)
				end


				for i=1,select("#",...) do
					local self = select(i,...)
					if registry.insertQueue then
						for eventname, callbacks in pairs(registry.insertQueue) do
							if callbacks[self] then
								callbacks[self] = nil
							end
						end
					end
					for eventname, callbacks in pairs(events) do
						if callbacks[self] then
							callbacks[self] = nil
							-- Fire OnUnused callback?
							if registry.OnUnused and not next(callbacks) then
								registry.OnUnused(registry, target, eventname)
							end
						end
					end
				end
			end
		end

		return registry
	end

end)

AddEWTCallback(function()
	
	local MAJOR = "LibInspect"

	LibInspect = {
        version = 69.0
    }

	LibInspect.events = LibInspect.events or LibStub ("CallbackHandler-1.0"):New (LibInspect)
	if not LibInspect.events then error("LibInspect requires CallbackHandler") end

	local UPDATE_EVENT = "GroupInSpecT_Update"
	local REMOVE_EVENT = "GroupInSpecT_Remove"
	local INSPECT_READY_EVENT = "GroupInSpecT_InspectReady"
	local QUEUE_EVENT = "GroupInSpecT_QueueChanged"

	local COMMS_PREFIX = "LGIST11"
	local COMMS_FMT = "1"
	local COMMS_DELIM = "\a"

	local INSPECT_DELAY = 1.5
	local INSPECT_TIMEOUT = 10 -- If we get no notification within 10s, give up on unit

	local MAX_ATTEMPTS = 2

	--[===[@debug@
	lib.debug = false
	local function debug (...)
	  if lib.debug then  -- allow programmatic override of debug output by client addons
	    print (...)
	  end
	end
	--@end-debug@]===]

	function LibInspect.events:OnUsed(target, eventname)
	  if eventname == INSPECT_READY_EVENT then
	    target.inspect_ready_used = true
	  end
	end

	function LibInspect.events:OnUnused(target, eventname)
	  if eventname == INSPECT_READY_EVENT then
	    target.inspect_ready_used = nil
	  end
	end

	-- Frame for events
	local frame = _G[MAJOR .. "_Frame"] or CreateFrame ("Frame", MAJOR .. "_Frame")
	LibInspect.frame = frame
	frame:Hide()
	frame:UnregisterAllEvents ()
	frame:RegisterEvent ("PLAYER_LOGIN")
	frame:RegisterEvent ("PLAYER_LOGOUT")
	if not frame.OnEvent then
	  frame.OnEvent = function(this, event, ...)
	    local eventhandler = LibInspect[event]
	    return eventhandler and eventhandler (LibInspect, ...)
	  end
	  frame:SetScript ("OnEvent", frame.OnEvent)
	end


	-- Hide our run-state in an easy-to-dump object
	LibInspect.state = {
	  mainq = {}, staleq = {}, -- inspect queues
	  t = 0,
	  last_inspect = 0,
	  current_guid = nil,
	  throttle = 0,
	  tt = 0,
	  debounce_send_update = 0,
	}
	LibInspect.cache = {}
	LibInspect.static_cache = {}


	-- Note: if we cache NotifyInspect, we have to hook before we cache it!
	if not LibInspect.hooked then
	  hooksecurefunc("NotifyInspect", function (...) return LibInspect:NotifyInspect (...) end)
	  LibInspect.hooked = true
	end
	function LibInspect:NotifyInspect(unit)
	  self.state.last_inspect = GetTime()
	end


	-- Get local handles on the key API functions
	local CanInspect                      = _G.CanInspect
	local ClearInspectPlayer              = _G.ClearInspectPlayer
	local GetClassInfo                    = _G.GetClassInfo
	local GetNumSubgroupMembers           = _G.GetNumSubgroupMembers
	local GetNumSpecializationsForClassID = _G.GetNumSpecializationsForClassID
	local GetPlayerInfoByGUID             = _G.GetPlayerInfoByGUID
	local GetInspectSelectedPvpTalent     = _G.C_SpecializationInfo.GetInspectSelectedPvpTalent
	local GetInspectSpecialization        = _G.GetInspectSpecialization
	local GetSpecialization               = _G.GetSpecialization
	local GetSpecializationInfo           = _G.GetSpecializationInfo
	local GetSpecializationInfoForClassID = _G.GetSpecializationInfoForClassID
	local GetSpecializationRoleByID       = _G.GetSpecializationRoleByID
	local GetSpellInfo                    = _G.GetSpellInfo
	local GetPvpTalentInfoByID            = _G.GetPvpTalentInfoByID
	local GetPvpTalentSlotInfo            = _G.C_SpecializationInfo.GetPvpTalentSlotInfo
	local GetTalentInfo                   = _G.GetTalentInfo
	local GetTalentInfoByID               = _G.GetTalentInfoByID
	local IsInRaid                        = _G.IsInRaid
	--local NotifyInspect                   = _G.NotifyInspect -- Don't cache, as to avoid missing future hooks
	local GetNumClasses                   = _G.GetNumClasses
	local UnitExists                      = _G.UnitExists
	local UnitGUID                        = _G.UnitGUID
	local UnitInParty                     = _G.UnitInParty
	local UnitInRaid                      = _G.UnitInRaid
	local UnitIsConnected                 = _G.UnitIsConnected
	local UnitIsPlayer                    = _G.UnitIsPlayer
	local UnitIsUnit                      = _G.UnitIsUnit
	local UnitName                        = _G.UnitName
	local SendAddonMessage                = _G.C_ChatInfo.SendAddonMessage
	local RegisterAddonMessagePrefix      = _G.C_ChatInfo.RegisterAddonMessagePrefix

	local MAX_TALENT_TIERS                = _G.MAX_TALENT_TIERS
	local NUM_TALENT_COLUMNS              = _G.NUM_TALENT_COLUMNS
	local NUM_PVP_TALENT_SLOTS            = 4


	local global_spec_id_roles_detailed = {
	  -- Death Knight
	  [250] = "tank", -- Blood
	  [251] = "melee", -- Frost
	  [252] = "melee", -- Unholy
	  -- Demon Hunter
	  [577] = "melee", -- Havoc
	  [581] = "tank", -- Vengeance
	  -- Druid
	  [102] = "ranged", -- Balance
	  [103] = "melee", -- Feral
	  [104] = "tank", -- Guardian
	  [105] = "healer", -- Restoration
	  -- Hunter
	  [253] = "ranged", -- Beast Mastery
	  [254] = "ranged", -- Marksmanship
	  [255] = "melee", -- Survival
	  -- Mage
	  [62] = "ranged", -- Arcane
	  [63] = "ranged", -- Fire
	  [64] = "ranged", -- Frost
	  -- Monk
	  [268] = "tank", -- Brewmaster
	  [269] = "melee", -- Windwalker
	  [270] = "healer", -- Mistweaver
	  -- Paladin
	  [65] = "healer", -- Holy
	  [66] = "tank", -- Protection
	  [70] = "melee", -- Retribution
	  -- Priest
	  [256] = "healer", -- Discipline
	  [257] = "healer", -- Holy
	  [258] = "ranged", -- Shadow
	  -- Rogue
	  [259] = "melee", -- Assassination
	  [260] = "melee", -- Combat
	  [261] = "melee", -- Subtlety
	  -- Shaman
	  [262] = "ranged", -- Elemental
	  [263] = "melee", -- Enhancement
	  [264] = "healer", -- Restoration
	  -- Warlock
	  [265] = "ranged", -- Affliction
	  [266] = "ranged", -- Demonology
	  [267] = "ranged", -- Destruction
	  -- Warrior
	  [71] = "melee", -- Arms
	  [72] = "melee", -- Fury
	  [73] = "tank", -- Protection
	}

	local class_fixed_roles = {
	  HUNTER = "DAMAGER",
	  MAGE = "DAMAGER",
	  ROGUE = "DAMAGER",
	  WARLOCK = "DAMAGER",
	}

	local class_fixed_roles_detailed = {
	  MAGE = "ranged",
	  ROGUE = "melee",
	  WARLOCK = "ranged",
	}

	-- Inspects only work after being fully logged in, so track that
	function LibInspect:PLAYER_LOGIN ()
	  self.state.logged_in = true

	  self:CacheGameData ()

	  frame:RegisterEvent ("INSPECT_READY")
	  frame:RegisterEvent ("GROUP_ROSTER_UPDATE")
	  frame:RegisterEvent ("PLAYER_ENTERING_WORLD")
	  frame:RegisterEvent ("UNIT_LEVEL")
	  frame:RegisterEvent ("PLAYER_TALENT_UPDATE")
	  frame:RegisterEvent ("PLAYER_SPECIALIZATION_CHANGED")
	  frame:RegisterEvent ("UNIT_SPELLCAST_SUCCEEDED")
	  frame:RegisterEvent ("UNIT_NAME_UPDATE")
	  frame:RegisterEvent ("UNIT_AURA")
	  frame:RegisterEvent ("CHAT_MSG_ADDON")
	  RegisterAddonMessagePrefix (COMMS_PREFIX)

	  local guid = UnitGUID("player")--ObjectPointer("player")
	  local info = self:BuildInfo ("player")
	  self.events:Fire (UPDATE_EVENT, guid, "player", info)
	end

	function LibInspect:PLAYER_LOGOUT ()
	  self.state.logged_in = false
	end


	-- Simple timer
	do
	  LibInspect.state.t = 0
	  if not frame.OnUpdate then -- ticket #4 if the OnUpdate code every changes we should stop borrowing the existing handler
	    frame.OnUpdate = function(this, elapsed)
	      LibInspect.state.t = LibInspect.state.t + elapsed
	      LibInspect.state.tt = LibInspect.state.tt + elapsed
	      if LibInspect.state.t > INSPECT_DELAY then
	        LibInspect:ProcessQueues ()
	        LibInspect.state.t = 0
	      end
	      -- Unthrottle, essentially allowing 1 msg every 3 seconds, but with substantial burst capacity
	      if LibInspect.state.tt > 3 and LibInspect.state.throttle > 0 then
	        LibInspect.state.throttle = LibInspect.state.throttle - 1
	        LibInspect.state.tt = 0
	      end
	      if LibInspect.state.debounce_send_update > 0 then
	        local debounce = LibInspect.state.debounce_send_update - elapsed
	        LibInspect.state.debounce_send_update = debounce
	        if debounce <= 0 then LibInspect:SendLatestSpecData () end
	      end
	    end
	    frame:SetScript("OnUpdate", frame.OnUpdate) -- this is good regardless of the handler check above because otherwise a new anonymous function is created every time the OnUpdate code runs
	  end
	end


	-- Internal library functions

	-- Caches to deal with API shortcomings as well as performance
	LibInspect.static_cache.global_specs = {}           -- [gspec]         -> { .idx, .name_localized, .description, .icon, .background, .role }
	LibInspect.static_cache.class_to_class_id = {}      -- [CLASS]         -> class_id

	-- The talents cache can no longer be pre-fetched on login, but is now constructed class-by-class as we inspect people.
	-- This probably means we want to only ever access it through the GetCachedTalentInfo() helper function below.
	LibInspect.static_cache.talents = {}                -- [talent_id]      -> { .spell_id, .talent_id, .name_localized, .icon, .tier, .column }
	LibInspect.static_cache.pvp_talents = {}            -- [talent_id]      -> { .spell_id, .talent_id, .name_localized, .icon }

	function LibInspect:GetCachedTalentInfo (class_id, tier, col, group, is_inspect, unit)
	  local talent_id, name, icon, sel, _, spell_id = GetTalentInfo (tier, col, group, is_inspect, unit)
	  if not talent_id then
	    --[===[@debug@
	    debug ("GetCachedTalentInfo("..tostring(class_id)..","..tier..","..col..","..group..","..tostring(is_inspect)..","..tostring(unit)..") returned nil") --@end-debug@]===]
	    return {}
	  end
	  local class_talents = self.static_cache.talents
	  if not class_talents[talent_id] then
	    class_talents[talent_id] = {
	      spell_id = spell_id,
	      talent_id = talent_id,
	      name_localized = name,
	      icon = icon,
	      tier = tier,
	      column = col,
	    }
	  end
	  return class_talents[talent_id], sel
	end

	function LibInspect:GetCachedTalentInfoByID (talent_id)
	  local class_talents = self.static_cache.talents
	  if talent_id and not class_talents[talent_id] then
	    local _, name, icon, _, _, spell_id, _, row, col = GetTalentInfoByID (talent_id)
	    if not name then
	      --[===[@debug@
	      debug ("GetCachedTalentInfoByID("..tostring(talent_id)..") returned nil") --@end-debug@]===]
	      return nil
	    end
	    class_talents[talent_id] = {
	      spell_id = spell_id,
	      talent_id = talent_id,
	      name_localized = name,
	      icon = icon,
	      tier = row,
	      column = col,
	    }
	  end
	  return class_talents[talent_id]
	end

	function LibInspect:GetCachedPvpTalentInfoByID (talent_id)
	  local pvp_talents = self.static_cache.pvp_talents
	  if talent_id and not pvp_talents[talent_id] then
	    local _, name, icon, _, _, spell_id = GetPvpTalentInfoByID (talent_id)
	    if not name then
	      --[===[@debug@
	      debug ("GetCachedPvpTalentInfo("..tostring(talent_id)..") returned nil") --@end-debug@]===]
	      return nil
	    end
	    pvp_talents[talent_id] = {
	      spell_id = spell_id,
	      talent_id = talent_id,
	      name_localized = name,
	      icon = icon,
	    }
	  end
	  return pvp_talents[talent_id]
	end

	function LibInspect:CacheGameData ()
	  local gspecs = self.static_cache.global_specs
	  gspecs[0] = {} -- Handle no-specialization case
	  for class_id = 1, GetNumClasses () do
	    for idx = 1, GetNumSpecializationsForClassID (class_id) do
	      local gspec_id, name, description, icon, background = GetSpecializationInfoForClassID (class_id, idx)
	      gspecs[gspec_id] = {}
	      local gspec = gspecs[gspec_id]
	      gspec.idx = idx
	      gspec.name_localized = name
	      gspec.description = description
	      gspec.icon = icon
	      gspec.background = background
	      gspec.role = GetSpecializationRoleByID (gspec_id)
	    end

	    local _, class = GetClassInfo (class_id)
	    self.static_cache.class_to_class_id[class] = class_id
	  end
	end


	function LibInspect:GuidToUnit (guid)
	  local info = self.cache[guid]
	  if info and info.lku and UnitGUID (info.lku) == guid then return info.lku end

	  for i,unit in ipairs (self:GroupUnits ()) do
	    if UnitExists (unit) and UnitGUID (unit) == guid then
	      if info then info.lku = unit end
	      return unit
	    end
	  end
	end


	function LibInspect:Query (unit)
	  if not UnitIsPlayer (unit) then return end -- NPC

	  if UnitIsUnit (unit, "player") then
	    self.events:Fire (UPDATE_EVENT, UnitGUID("player"), "player", self:BuildInfo ("player"))
	    return
	  end

	  local mainq, staleq = self.state.mainq, self.state.staleq

	  local guid = UnitGUID (unit)
	  if not mainq[guid] then
	    mainq[guid] = 1
	    staleq[guid] = nil
	    self.frame:Show () -- Start timer if not already running
	    self.events:Fire (QUEUE_EVENT)
	  end
	end


	function LibInspect:Refresh (unit)
	  local guid = UnitGUID (unit)
	  if not guid then return end
	  --[===[@debug@
	  debug ("Refreshing "..unit) --@end-debug@]===]
	  if not self.state.mainq[guid] then
	    self.state.staleq[guid] = 1
	    self.frame:Show ()
	    self.events:Fire (QUEUE_EVENT)
	  end
	end


	function LibInspect:ProcessQueues ()
	  if not self.state.logged_in then return end
	  if InCombatLockdown () then return end -- Never inspect while in combat
	  if UnitIsDead ("player") then return end -- You can't inspect while dead, so don't even try
	  if InspectFrame and InspectFrame:IsShown () then return end -- Don't mess with the UI's inspections

	  local mainq = self.state.mainq
	  local staleq = self.state.staleq

	  if not next (mainq) and next(staleq) then
	    --[===[@debug@
	    debug ("Main queue empty, swapping main and stale queues") --@end-debug@]===]
	    self.state.mainq, self.state.staleq = self.state.staleq, self.state.mainq
	    mainq, staleq = staleq, mainq
	  end

	  if (self.state.last_inspect + INSPECT_TIMEOUT) < GetTime () then
	    -- If there was an inspect going, it's timed out, so either retry or move it to stale queue
	    local guid = self.state.current_guid
	    if guid then
	      --[===[@debug@
	      debug ("Inspect timed out for "..guid) --@end-debug@]===]

	      local count = mainq and mainq[guid] or (MAX_ATTEMPTS + 1)
	      if not self:GuidToUnit (guid) then
	        --[===[@debug@
	        debug ("No longer applicable, removing from queues") --@end-debug@]===]
	        mainq[guid], staleq[guid] = nil, nil
	      elseif count > MAX_ATTEMPTS then
	        --[===[@debug@
	        debug ("Excessive retries, moving to stale queue") --@end-debug@]===]
	        mainq[guid], staleq[guid] = nil, 1
	      else
	        mainq[guid] = count + 1
	      end
	      self.state.current_guid = nil
	    end
	  end

	  if self.state.current_guid then return end -- Still waiting on our inspect data

	  for guid,count in pairs (mainq) do
	    local unit = self:GuidToUnit (guid)
	    if not unit then
	      --[===[@debug@
	      debug ("No longer applicable, removing from queues") --@end-debug@]===]
	      mainq[guid], staleq[guid] = nil, nil
	    elseif not CanInspect (unit) or not UnitIsConnected (unit) then
	      --[===[@debug@
	      debug ("Cannot inspect "..unit..", aka "..(UnitName(unit) or "nil")..", moving to stale queue") --@end-debug@]===]
	      mainq[guid], staleq[guid] = nil, 1
	    else
	      --[===[@debug@
	      debug ("Inspecting "..unit..", aka "..(UnitName(unit) or "nil")) --@end-debug@]===]
	      mainq[guid] = count + 1
	      self.state.current_guid = guid
	      NotifyInspect (unit)
	      break
	    end
	  end

	  if not next (mainq) and not next (staleq) and self.state.throttle == 0 and self.state.debounce_send_update <= 0 then
	    frame:Hide() -- Cancel timer, nothing queued and no unthrottling to be done
	  end
	  self.events:Fire (QUEUE_EVENT)
	end


	function LibInspect:UpdatePlayerInfo (guid, unit, info)
	  info.class_localized, info.class, info.race_localized, info.race, info.gender, info.name, info.realm = GetPlayerInfoByGUID (guid)
	  local class = info.class
	  if info.realm and info.realm == "" then info.realm = nil end
	  info.class_id = class and self.static_cache.class_to_class_id[class]
	  if not info.spec_role then info.spec_role = class and class_fixed_roles[class] end
	  if not info.spec_role_detailed then info.spec_role_detailed = class and class_fixed_roles_detailed[class] end
	  info.lku = unit
	end


	function LibInspect:BuildInfo (unit)
	  local guid = UnitGUID (unit)
	  if not guid then return end

	  local cache = self.cache
	  local info = cache[guid] or {}
	  cache[guid] = info
	  info.guid = guid

	  self:UpdatePlayerInfo (guid, unit, info)
	  -- On a cold login, GetPlayerInfoByGUID() doesn't seem to be usable, so mark as stale
	  local class = info.class
	  if not class and not self.state.mainq[guid] then
	    self.state.staleq[guid] = 1
	    self.frame:Show ()
	    self.events:Fire (QUEUE_EVENT)
	  end

	  local is_inspect = not UnitIsUnit (unit, "player")
	  local spec = GetSpecialization ()
	  local gspec_id = is_inspect and GetInspectSpecialization (unit) or spec and GetSpecializationInfo (spec)

	  local gspecs = self.static_cache.global_specs
	  if not gspec_id or not gspecs[gspec_id] then -- not a valid spec_id
	    info.global_spec_id = nil
	  else
	    info.global_spec_id = gspec_id
	    local spec_info = gspecs[gspec_id]
	    info.spec_index          = spec_info.idx
	    info.spec_name_localized = spec_info.name_localized
	    info.spec_description    = spec_info.description
	    info.spec_icon           = spec_info.icon
	    info.spec_background     = spec_info.background
	    info.spec_role           = spec_info.role
	    info.spec_role_detailed  = global_spec_id_roles_detailed[gspec_id]
	  end

	  if not info.spec_role then info.spec_role = class and class_fixed_roles[class] end
	  if not info.spec_role_detailed then info.spec_role_detailed = class and class_fixed_roles_detailed[class] end

	  info.talents = info.talents or {}
	  info.pvp_talents = info.pvp_talents or {}

	  -- Only scan talents when we have player data
	  if info.spec_index then
	    info.spec_group = GetActiveSpecGroup (is_inspect)
	    wipe (info.talents)
	    for tier = 1, MAX_TALENT_TIERS do
	      for col = 1, NUM_TALENT_COLUMNS do
	        local talent, sel = self:GetCachedTalentInfo (info.class_id, tier, col, info.spec_group, is_inspect, unit)
	        if sel then
	          info.talents[talent.talent_id] = talent
	        end
	      end
	    end

	    wipe (info.pvp_talents)
	    if is_inspect then
	      for index = 1, NUM_PVP_TALENT_SLOTS do
	        local talent_id = GetInspectSelectedPvpTalent (unit, index)
	        if talent_id then
	          info.pvp_talents[talent_id] = self:GetCachedPvpTalentInfoByID (talent_id)
	        end
	      end
	    else
	      -- C_SpecializationInfo.GetAllSelectedPvpTalentIDs will sometimes return a lot of extra talents
	      for index = 1, NUM_PVP_TALENT_SLOTS do
	        local slot_info = GetPvpTalentSlotInfo (index)
	        local talent_id = slot_info and slot_info.selectedTalentID
	        if talent_id then
	          info.pvp_talents[talent_id] = self:GetCachedPvpTalentInfoByID (talent_id)
	        end
	      end
	    end
	  end

	  info.glyphs = info.glyphs or {} -- kept for addons that still refer to this

	  if is_inspect and not UnitIsVisible (unit) and UnitIsConnected (unit) then info.not_visible = true end

	  return info
	end


	function LibInspect:INSPECT_READY (guid)
	  local unit = self:GuidToUnit (guid)
	  local finalize = false
	  if unit then
	    if guid == self.state.current_guid then
	      self.state.current_guid = nil -- Got what we asked for
	      finalize = true
	      --[===[@debug@
	      debug ("Got inspection data for requested guid "..guid) --@end-debug@]===]
	    end

	    local mainq, staleq = self.state.mainq, self.state.staleq
	    mainq[guid], staleq[guid] = nil, nil

	    local gspec_id = GetInspectSpecialization (unit)
	    if not self.static_cache.global_specs[gspec_id] then -- Bah, got garbage, flag as stale and try again
	      staleq[guid] = 1
	      return
	    end

	    self.events:Fire (UPDATE_EVENT, guid, unit, self:BuildInfo (unit))
	    self.events:Fire (INSPECT_READY_EVENT, guid, unit)
	  end
	  if finalize then
	    ClearInspectPlayer ()
	  end
	  self.events:Fire (QUEUE_EVENT)
	end


	function LibInspect:PLAYER_ENTERING_WORLD ()
	  if self.commScope == "INSTANCE_CHAT" then
	    -- Handle moving directly from one LFG to another
	    self.commScope = nil
	    self:UpdateCommScope ()
	  end
	end


	-- Group handling parts

	local members = {}
	function LibInspect:GROUP_ROSTER_UPDATE ()
	  local group = self.cache
	  local units = self:GroupUnits ()
	  -- Find new members
	  for i,unit in ipairs (self:GroupUnits ()) do
	    local guid = UnitGUID (unit)
	    if guid then
	      members[guid] = true
	      if not group[guid] then
	        self:Query (unit)
	        -- Update with what we have so far (guid, unit, name/class/race?)
	        self.events:Fire (UPDATE_EVENT, guid, unit, self:BuildInfo (unit))
	      end
	    end
	  end
	  -- Find removed members
	  for guid in pairs (group) do
	    if not members[guid] then
	      group[guid] = nil
	      self.events:Fire (REMOVE_EVENT, guid, nil)
	    end
	  end
	  wipe (members)
	  self:UpdateCommScope ()
	end


	function LibInspect:DoPlayerUpdate ()
	  self:Query ("player")
	  self.state.debounce_send_update = 2.5 -- Hold off 2.5sec before sending update
	  self.frame:Show ()
	end


	function LibInspect:SendLatestSpecData ()
	  local scope = self.commScope
	  if not scope then return end

	  local guid = UnitGUID ("player")
	  local info = self.cache[guid]
	  if not info then return end

	  -- fmt, guid, global_spec_id, talent1 -> MAX_TALENT_TIERS, pvptalent1 -> NUM_PVP_TALENT_SLOTS
	  -- sequentially, allow no gaps for missing talents we decode by index on the receiving end.
	  local datastr = COMMS_FMT..COMMS_DELIM..guid..COMMS_DELIM..(info.global_spec_id or 0)
	  local talentCount = 1
	  for k in pairs(info.talents) do
	    datastr = datastr..COMMS_DELIM..k
	    talentCount = talentCount + 1
	  end
	  for i=talentCount,MAX_TALENT_TIERS do
	    datastr = datastr..COMMS_DELIM..0
	  end
	  talentCount = 1
	  for k in pairs(info.pvp_talents) do
	    datastr = datastr..COMMS_DELIM..k
	    talentCount = talentCount + 1
	  end
	  for i=talentCount,NUM_PVP_TALENT_SLOTS do
	    datastr = datastr..COMMS_DELIM..0
	  end

	  --[===[@debug@
	  debug ("Sending LGIST update to "..scope) --@end-debug@]===]
	  SendAddonMessage(COMMS_PREFIX, datastr, scope)
	end


	function LibInspect:UpdateCommScope ()
	  local scope = (IsInGroup (LE_PARTY_CATEGORY_INSTANCE) and "INSTANCE_CHAT") or (IsInRaid () and "RAID") or (IsInGroup (LE_PARTY_CATEGORY_HOME) and "PARTY")
	  if self.commScope ~= scope then
	    self.commScope = scope
	    self:DoPlayerUpdate ()
	  end
	end


	-- Indicies for various parts of the split data msg
	local msg_idx = {}
	msg_idx.fmt             = 1
	msg_idx.guid            = msg_idx.fmt + 1
	msg_idx.global_spec_id  = msg_idx.guid + 1
	msg_idx.talents         = msg_idx.global_spec_id + 1
	msg_idx.end_talents     = msg_idx.talents + MAX_TALENT_TIERS
	msg_idx.pvp_talents     = msg_idx.end_talents + 1
	msg_idx.end_pvp_talents = msg_idx.pvp_talents + NUM_PVP_TALENT_SLOTS - 1

	function LibInspect:CHAT_MSG_ADDON (prefix, datastr, scope, sender)
	  if prefix ~= COMMS_PREFIX or scope ~= self.commScope then return end
	  --[===[@debug@
	  debug ("Incoming LGIST update from "..(scope or "nil").."/"..(sender or "nil")..": "..(datastr:gsub(COMMS_DELIM,";") or "nil")) --@end-debug@]===]

	  local data = { strsplit (COMMS_DELIM,datastr) }
	  local fmt = data[msg_idx.fmt]
	  if fmt ~= COMMS_FMT then return end -- Unknown format, ignore

	  local guid = data[msg_idx.guid]

	  local senderguid = UnitGUID(sender)
	  if senderguid and senderguid ~= guid then return end

	  local info = guid and self.cache[guid]
	  if not info then return end -- Never allow random message to create new group member entries!

	  local unit = self:GuidToUnit (guid)
	  if not unit then return end
	  if UnitIsUnit (unit, "player") then return end -- we're already up-to-date, comment out for solo debugging

	  self.state.throttle = self.state.throttle + 1
	  self.frame:Show () -- Ensure we're unthrottling
	  if self.state.throttle > 40 then return end -- If we ever hit this, someone's being "funny"

	  info.class_localized, info.class, info.race_localized, info.race, info.gender, info.name, info.realm = GetPlayerInfoByGUID (guid)
	  if info.realm and info.realm == "" then info.realm = nil end
	  info.class_id = self.static_cache.class_to_class_id[info.class]

	  local gspecs = self.static_cache.global_specs

	  local gspec_id           = data[msg_idx.global_spec_id] and tonumber (data[msg_idx.global_spec_id])
	  if not gspec_id or not gspecs[gspec_id] then return end -- Malformed message, avoid throwing errors by using this nil

	  info.global_spec_id      = gspec_id
	  info.spec_index          = gspecs[gspec_id].idx
	  info.spec_name_localized = gspecs[gspec_id].name_localized
	  info.spec_description    = gspecs[gspec_id].description
	  info.spec_icon           = gspecs[gspec_id].icon
	  info.spec_background     = gspecs[gspec_id].background
	  info.spec_role           = gspecs[gspec_id].role
	  info.spec_role_detailed  = global_spec_id_roles_detailed[gspec_id]

	  local need_inspect = nil -- shouldn't be needed, but just in case
	  info.talents = wipe (info.talents or {})
	  for i = msg_idx.talents, msg_idx.end_talents do
	    local talent_id = tonumber (data[i]) or 0
	    if talent_id > 0 then
	      local talent = self:GetCachedTalentInfoByID (talent_id)
	      if talent then
	        info.talents[talent_id] = talent
	      else
	        need_inspect = 1
	      end
	    end
	  end

	  info.pvp_talents = wipe (info.pvp_talents or {})
	  for i = msg_idx.pvp_talents, msg_idx.end_pvp_talents do
	    local talent_id = tonumber (data[i]) or 0
	    if talent_id > 0 then
	      local talent = self:GetCachedPvpTalentInfoByID (talent_id)
	      if talent then
	        info.pvp_talents[talent_id] = talent
	      else
	        need_inspect = 1
	      end
	    end
	  end

	  info.glyphs = info.glyphs or {} -- kept for addons that still refer to this

	  local mainq, staleq = self.state.mainq, self.state.staleq
	  local want_inspect = not need_inspect and self.inspect_ready_used and (mainq[guid] or staleq[guid]) and 1 or nil
	  mainq[guid], staleq[guid] = need_inspect, want_inspect
	  if need_inspect or want_inspect then self.frame:Show () end

	  --[===[@debug@
	  debug ("Firing LGIST update event for unit "..unit..", GUID "..guid..", inspect "..tostring(not not need_inspect)) --@end-debug@]===]
	  self.events:Fire (UPDATE_EVENT, guid, unit, info)
	  self.events:Fire (QUEUE_EVENT)
	end


	function LibInspect:UNIT_LEVEL (unit)
	  if UnitInRaid (unit) or UnitInParty (unit) then
	    self:Refresh (unit)
	  end
	  if UnitIsUnit (unit, "player") then
	    self:DoPlayerUpdate ()
	  end
	end


	function LibInspect:PLAYER_TALENT_UPDATE ()
	  self:DoPlayerUpdate ()
	end


	function LibInspect:PLAYER_SPECIALIZATION_CHANGED (unit)
	--  This event seems to fire a lot, and for no particular reason *sigh*
	--  if UnitInRaid (unit) or UnitInParty (unit) then
	--    self:Refresh (unit)
	--  end
	  if unit and UnitIsUnit (unit, "player") then
	    self:DoPlayerUpdate ()
	  end
	end


	function LibInspect:UNIT_NAME_UPDATE (unit)
	  local group = self.cache
	  local guid = UnitGUID (unit)
	  local info = guid and group[guid]
	  if info then
	    self:UpdatePlayerInfo (guid, unit, info)
	    if info.name ~= UNKNOWN then
	      self.events:Fire (UPDATE_EVENT, guid, unit, info)
	    end
	  end
	end


	-- Always get a UNIT_AURA when a unit's UnitIsVisible() changes
	function LibInspect:UNIT_AURA (unit)
	  local group = self.cache
	  local guid = UnitGUID (unit)
	  local info = guid and group[guid]
	  if info then
	    if not UnitIsUnit (unit, "player") then
	      if UnitIsVisible (unit) then
	        if info.not_visible then
	          info.not_visible = nil
	          --[===[@debug@
	          debug (unit..", aka "..(UnitName(unit) or "nil")..", is now visible") --@end-debug@]===]
	          if not self.state.mainq[guid] then
	            self.state.staleq[guid] = 1
	            self.frame:Show ()
	            self.events:Fire (QUEUE_EVENT)
	          end
	        end
	      elseif UnitIsConnected (unit) then
	        --[===[@debug@
	        if not info.not_visible then
	          debug (unit..", aka "..(UnitName(unit) or "nil")..", is no longer visible")
	        end
	        --@end-debug@]===]
	        info.not_visible = true
	      end
	    end
	  end
	end


	function LibInspect:UNIT_SPELLCAST_SUCCEEDED (unit, _, spell_id)
	  if spell_id == 200749 then -- Activating Specialization
	    self:Query (unit) -- Definitely changed, so high prio refresh
	  end
	end


	-- External LibInspectrary functions

	function LibInspect:QueuedInspections ()
	  local q = {}
	  for guid in pairs (self.state.mainq) do
	    table.insert (q, guid)
	  end
	  return q
	end


	function LibInspect:StaleInspections ()
	  local q = {}
	  for guid in pairs (self.state.staleq) do
	    table.insert (q, guid)
	  end
	  return q
	end


	function LibInspect:IsInspectQueued (guid)
	  return guid and ((self.state.mainq[guid] or self.state.staleq[guid]) and true)
	end


	function LibInspect:GetCachedInfo (guid)
	  local group = self.cache
	  return guid and group[guid]
	end


	function LibInspect:Rescan (guid)
	  local mainq, staleq = self.state.mainq, self.state.staleq
	  if guid then
	    local unit = self:GuidToUnit (guid)
	    if unit then
	      if UnitIsUnit (unit, "player") then
	        self.events:Fire (UPDATE_EVENT, guid, "player", self:BuildInfo ("player"))
	      elseif not mainq[guid] then
	        staleq[guid] = 1
	      end
	    end
	  else
	    for i,unit in ipairs (self:GroupUnits ()) do
	      if UnitExists (unit) then
	        if UnitIsUnit (unit, "player") then
	          self.events:Fire (UPDATE_EVENT, UnitGUID("player"), "player", self:BuildInfo ("player"))
	        else
	          local guid = UnitGUID (unit)
	          if guid and not mainq[guid] then
	            staleq[guid] = 1
	          end
	        end
	      end
	    end
	  end
	  self.frame:Show () -- Start timer if not already running

	  -- Evict any stale entries
	  self:GROUP_ROSTER_UPDATE ()
	  self.events:Fire (QUEUE_EVENT)
	end


	local unitstrings = {
	  raid = { "player" }, -- This seems to be needed under certain circumstances. Odd.
	  party = { "player" }, -- Player not part of partyN
	  player = { "player" }
	}
	for i = 1,40 do table.insert (unitstrings.raid, "raid"..i) end
	for i = 1,4  do table.insert (unitstrings.party, "party"..i) end


	-- Returns an array with the set of unit ids for the current group
	function LibInspect:GroupUnits ()
	  local units
	  if IsInRaid () then
	    units = unitstrings.raid
	  elseif GetNumSubgroupMembers () > 0 then
	    units = unitstrings.party
	  else
	    units = unitstrings.player
	  end
	  return units
	end


	-- If demand-loaded, we need to synthesize a login event
	if IsLoggedIn () then LibInspect:PLAYER_LOGIN () end

	_G['LibInspect'] = LibInspect

end)--good vs bad area triggers, dispaly good when needs soaked
Squid_areaTrigger = {
    
    --Player
    [2947] = {size = 7.75, good = function(obj) return unit_is_unit("player", ObjectCreator(obj)) end}, -- rune of power

    --TESTING
    -- [7020] = {size = 1}, -- monk chi sphere
    -- [3319] = {size = 1} -- monk hp sphere
    --[18040] = {size = 2}, -- trink test
   -- [10801] = {size = 8, good = true}, 
   -- [10801] = {size = 8, good = true}, -- test flame patch

   --RANDOM SHIT

    -- [48006,48296,48300,48294] = {size = 2, good = true} -- food things from cookie (these are objects not area triggers)
    
    --BOD
    [20327] = {size = 3}, -- Jaina tornado
    [20310] = {size = 1.5}, -- Jaina cube
    
    --TOL DAGOR
    [16682] = {size = 3},   -- TD - Sandwwwawd

    -- FREEHOLD
    [18148] = {size = 5}, -- whirlpool of blades shit fh 2nd boss
    -- 130099 -- freehjold pig obj id
    -- 129448 129359 freehold sharks notouch
    -- 161408 combat whitelist little shits on ground with miniboss

    -- SEIGE OF BORALUS
    [18385] = {size = 1.5}, -- SoB - Bananas

    -- KING'S REST
    -- [17933] = {size = 2}, -- KR white tornado swirlies

    -- ATAL DAZAR
    [16644] = {size = 3.5}, -- AD skeleton dinos pre trigger
    [16862] = {size = 3.25}, -- AD green goo circles 
    [125868] = {size = 3},  -- AD Spiderz
    -- 16029 AD goo boss green goo ~2.5-3 yd (shit ton of them, too annoying to actually add)
    [17056] = {size = 3.5, good = true}, -- AD eat blood pool
    [16553] = {size = 3.5, good = true}, -- AD eat blood pool
    [16860] = {size = 2}, -- gold balls alunza 2 yd
    [16013] = {size = 4}, -- 16013 purple circles left on ground last boss AD 4 yd (last boss spiders are game objects or units, not aoetriggers)

    -- UNDERROT
    [17026] = {size = 2, good = true}, -- 2nd boss blood ticks
    [138538] = {size = 3.5}, -- faceless tentacle spawns short range cleave

    -- MECHAGON WORKSHOP
    [19739] = {size = 3}, -- blades in mecha ~ 3 yd 
    [20025] = {size = 2.5}, -- bomb going off in mecha ~2.5 yd 
    [19968] = {size = 2}, -- swirling gears on machinist boss (los whitelist this guy..)
    [20825] = {size = 3, good = true}, -- GOOD shield generator things, stand in this shit
    [20605] = {size = 2},-- little zappy circles phase 1 last boss 2 yds
    -- 20030 i believe is the hidden flame cannon area trigger but it's just the center thing 

    -- PLAYERS / PVP
    [10471] = {size = 10, parent = 100943, good = "owner"}, -- earthen wall totem

    -- HORRIFIC VISION OF ORGRIMMAR
    [21726] = {size = 3.5}, -- Rexxar Traps
    [21717] = {size = 3}, -- Rexxar Sha Army
    [21958] = {size = 3.5}, -- Ring of Chaos Orbs (Vez'okk the Lightless)
    [23000] = {size = 1.5, good = true}, -- Promised Power Dmg Buff
    [21175] = {size = 2, good = true}, -- hopelessness gold thing
    -- [4520] = {size = 5}, -- Haunting Shadows Affix (Fears if you stand in it) (shared object id w/ bloodthirsty affix?)

    --HORRIFIC VISION OF STORMWIND


}

Squid_cleaveCasts = {
    
    --test
    -- [2948] = {type = "rect", range = 25, width = 5, targeted=true},

    --randomshit
    [198497] = {type = "rect", range = 25, width = 10},  -- dh starting zone shit
    [200425] = {type = "cone", angle = 50, range = 16},  -- dh starting zone shit
    [250490] = {type = "cone", angle = 45, range = 6},  -- animated strike
    [276876] = {type = "cone", angle = 50, range = 12.75}, -- DH
    [312262] = {type = "rect", range = 8, width = 4},  -- Sonic Scream (Random ass mob idk)
    [309061] = {type = "cone", angle = 180, range = 12}, -- Straight Forward --dire cleave baruk protector (each different spellid is cast at a different angle)
    [309062] = {type = "cone", angle = 180, range = 13, direction = 270}, -- To the right
    [309063] = {type = "cone", angle = 180, range = 13, direction = 90}, -- To the left
    [256709] = {type = "cone", angle = 45, range = 5},-- >.>
    [257036] = {type = "cone", angle = 45, range = 5},-- <.<
    [261488] = {type = "rect", range = 15, width = 5},--random mob charge

    [258864] = {type = "cone", angle = 45, range = 5},-- td thrash  suppression fire
    [256955] = {type = "cone", angle = 45, range = 5},-- td 2nd boss
    [259711] = {type = "cone", angle = 360, range = 6},-- block warden aoe cleave
    [288694] = {type = "cone", angle = 45, range = 5},-- Reaping smash https://www.wowhead.com/spell=288694/shadow-smash
    
    ------------------------Uldir-------------------------------------------
    [273538] = {type = "rect", range = 40, width = 6}, --mytrax
    [274113] = {type = "rect", range = 40, width = 6}, --mytrax transmission lazor
    [272115] = {type = "rect", range = 40, width = 6}, --mytrax p2 beam
    [273282] = {type = "cone", angle = 60, range = 18}, --mytrax
    [265264] = {type = "cone", angle = 60, range = 18},-- zekvoz boss cleave
    [267787] = {type = "cone", angle = 40, range = 15},-- 2nd boss cleave
    [262292] = {type = "cone", angle = 60, range = 20},-- fetid cleave
   
    ------------------------BoD----------------------------------------------
    [285177] = {type = "rect", range = 40, width = 7},-- Jaina https://www.wowhead.com/spell=285177/freezing-blast
    [288345] = {type = "rect", range = 40, width = 5},-- Jaina https://www.wowhead.com/spell=288345/glacial-ray
    [282153] = {type = "rect", range = 40, width = 6},-- High Tinker Mekkatorque https://www.wowhead.com/spell=282153/buster-cannon
    [283606] = {type = "cone", angle = 45, range = 15},-- Opulence https://www.wowhead.com/spell=283606/crush
    [289906] = {type = "cone", angle = 45, range = 15},-- Opulence https://www.wowhead.com/spell=289906/crush
    [282939] = {type = "cone", angle = 40, range = 15},-- Opulence https://www.wowhead.com/spell=282939/flames-of-punishment
    [287659] = {type = "cone", angle = 40, range = 15},-- Opulence https://www.wowhead.com/spell=287659/flames-of-punishment
    [283063] = {type = "cone", angle = 40, range = 15},-- Opulence https://www.wowhead.com/spell=283063/flames-of-punishment
    [287513] = {type = "cone", angle = 40, range = 15},-- Opulence https://www.wowhead.com/spell=287513/flames-of-punishment
    [283587] = {type = "rect", range = 60, width = 5},-- Champion of the Light https://www.wowhead.com/spell=283587/wave-of-light
    [283598] = {type = "rect", range = 60, width = 5},-- Champion of the Light https://ptr.wowhead.com/spell=283598/wave-of-light
    [289572] = {type = "rect", range = 20, width = 3},-- Trash charge https://www.wowhead.com/spell=289572/charge
    [285893] = {type = "cone", angle = 90, range = 10},-- Gonk Wild Maul https://www.wowhead.com/spell=285893/wild-maul
    [289560] = {type = "cone", angle = 90, range = 12},-- Kimbul Lacerating Claws https://www.wowhead.com/spell=282444/lacerating-claws
    [285178] = {type = "rect", range = 45, width = 10},-- Rastakhan Serpent Totem https://www.wowhead.com/spell=285178/serpents-breath
    -- [270833] = {type = "rect", range = 25, width = 10},-- tests
    -- [270839] = {type = "cone", angle = 90, range = 12},-- tests
    
    ------------------------CoS----------------------------------------------
    [282589] = {type = "cone", angle = 30, range = 45},-- The Restless Cabal https://www.wowhead.com/spell=282589/cerebral-assault
    -- [51505] = {type = "cone", angle = 75, range = 30}, -- test bolt
    -- [51505] = {type = "rect", range = 40, width = 3}, -- test bolt
        
    ------------------------Visions-----------------------------------------
   
    -- Stormwind
    [308481] = {type = "rect", range = 25, width = 5}, -- Rift Strike Tentacle Cone
    [309671] = {type = "cone", angle = 25, range = 15}, -- Empowered Forge Breath

    -- Orgrimmar

    ------------------------Ny'Alotha------------------------------------
    [311574] = {type = "rect", range = 30, width = 5}, -- Monstrous Cleave
    [310396] = {type = "rect", range = 35, width = 5, startingpoint = 5}, -- Void Glare Drest'agath
    [309961] = {type = "rect", range = 100, width = 20, startingpoint = 3}, -- Eye of Nzoth Il'gynoth

    ------------------------Mythic Plus--------------------------------------

    -- ATAL'DAZAR
    [253239] = {type = "rect", range = 15, width = 5}, -- AD juggernaut merciless assault forward cone dash 5 yd width ~15 yd range
    [253279] = {type = "rect", range = 15, width = 5}, -- AD juggernaut merciless assault forward cone dash 5 yd width ~15 yd range

    -- MECHAGON: JUNKYARD
    [300777] = {type = "rect", range = 35, width = 5}, -- https://www.wowhead.com/spell=300777/slimewave - Green Slime Charge
    [300188] = {type = "rect", range = 35, width = 4, targeted = true}, -- https://www.wowhead.com/spell=300188/scrap-cannon - Crawler Kameha
    [299475] = {type = "rect", range = 30, width = 6.5}, -- https://www.wowhead.com/spell=299475/b-o-r-k - B.O.R.K
    [300424] = {type = "rect", range = 25, width = 5.5}, -- Big Trogg Shockwave (this one sends area triggers forward could add those)
    [299164] = {type = "rect", range = 40, width = 6}, -- Pedal to the Metal (Motorcycle Charge) https://www.wowhead.com/spell=299164/pedal-to-the-metal
    [298651] = {type = "rect", range = 40, width = 6}, -- Pedal to the Metal (Motorcycle Charge 2) https://www.wowhead.com/spell=298651/pedal-to-the-metal

    -- MECHAGON: WORKSHOP
    [291928] = {type = "rect", range = 40, width = 3, targeted = true}, -- giga zap phase 1 = rect 3 yd 40 yd range
    [297128] = {type = "cone", angle = 360, range = 9}, -- short out cast 8 yd circle around unit ( 294185 may be channel id ? )
    [294185] = {type = "cone", angle = 360, range = 9}, -- ^ same
    [293986] = {type = "rect", range = 26, width = 6}, -- 293986 sonic pulse 6 yd rect unknown range check wowhead
    -- 294291 / 294290 Process Waste Channeled? by waste processing unit cone 8 yd 35 degree angle
    
    -- KING'S REST
    [270487] = {type = "cone", angle = 45, range = 5}, -- https://www.wowhead.com/spell=270487/severing-blade - Berserker Cleave
    [270507] = {type = "cone", angle = 60, range = 20, targeted = true}, -- https://www.wowhead.com/spell=270507/poison-barrage - Poison Barrage
    [270003] = {type = "cone", angle = 65, range = 30}, -- kr robots aoe
    [270502] = {type = "cone", angle = 80, range = 9},  -- hunting leap dinos
    -- [270284] = {type = "rect", range = 55, width = 3}, -- purification beam

    -- WAYCREST MANOR
    [265372] = {type = "cone", angle = 45, range = 5}, -- wm thrash cleave
    [271174] = {type = "cone", angle = 45, range = 5}, --
    [264923] = {type = "cone", angle = 90, range = 25}, -- wm pig boss cleave

    -- THE UNDERROT
    [265540] = {type = "cone", angle = 40, range = 30}, -- https://www.wowhead.com/spell=265540/rotten-bile - Maggot Spit
    [265019] = {type = "cone", angle = 55, range = 7}, -- https://www.wowhead.com/spell=265019/savage-cleave - Matron Cleave
    [260894] = {type = "rect", range = 40, width = 5}, -- https://www.wowhead.com/spell=260894/creeping-rot - 1st Boss Green Kameha
    [272609] = {type = "rect", range = 45, width = 5}, -- https://www.wowhead.com/spell=272609/maddening-gaze - Faceless Fear Kameha
    [260292] = {type = "rect", range = 30, width = 7}, -- 2nd boss charge
    [272457] = {type = "cone", angle = 55, range = 17.5}, -- 3rd boss shockwave
    [269843] = {type = "cone", angle = 45, range = 5}, -- ur last boss upheaval

    -- FREEHOLD
    [257426] = {type = "cone", angle = 60, range = 10}, -- https://www.wowhead.com/spell=257426/brutal-backhand - Enforcer Melee Cleave
    [257784] = {type = "cone", angle = 30, range = 15, targeted=true}, -- https://www.wowhead.com/spell=257784/frost-blast - Bilge Rat Frost Cone
    [274400] = {type = "rect", range = 30, width = 5}, -- https://www.wowhead.com/spell=274400/duelist-dash - Duelist Charge + Stun
    [257870] = {type = "cone", angle = 360, range = 4}, -- https://www.wowhead.com/spell=257870/blade-barrage
    [256589] = {type = "cone", angle = 360, range = 10}, -- https://www.wowhead.com/spell=256589/barrel-smash - Barrel Smash Raoul
    [258381] = {type = "cone", angle = 45, range = 5}, -- https://www.wowhead.com/spell=258381/grapeshot - FIX ME ( Not a cast )
    [258352] = {type = "cone", angle = 45, range = 5}, -- ^ SAME

    -- SHRINE OF THE STORM
    [276268] = {type = "cone", angle = 45, range = 10},-- SotS Templar melee cleave
    [264101] = {type = "rect", range = 30, width = 12},-- SotS aqua boss charge
    [267899] = {type = "cone", angle = 45, range = 5},-- SotS 2nd boss melee cleave
    [267385] = {type = "rect", range = 15, width = 5},-- tentacle cast last boss SotS

    -- THE MOTHERLODE!!
    [257337] = {type = "cone", angle = 45, range = 40},-- ML 1st boss cone
    [268415] = {type = "cone", angle = 45, range = 5},-- ML trash cleave
    [268846] = {type = "cone", angle = 45, range = 5},-- ml trash cleave
    [275907] = {type = "cone", angle = 50, range = 25},-- ML tectonic smash
    [269313] = {type = "cone", angle = 360, range = 8},-- ml final blast
    [268865] = {type = "rect", range = 20, width = 5},-- force cannon
    [262804] = {type = "cone", angle = 45, range = 5},--
    [260669] = {type = "rect", range = 20, width = 3},--ml rixxa pewpew ??

    -- TEMPLE OF SETHRALISS ( cc knot of snakes: added )
    [264574] = {type = "rect", range = 40, width = 3}, -- ToS power shot
    [263309] = {type = "cone", angle = 50, range = 40}, -- ToS 1st boss Cyclone Strike
    [263573] = {type = "cone", angle = 50, range = 40}, --Tos 1st boss stuff
    -- [263912] = {type = "cone", angle = 45, range = 40}, --TOS 2nd boss green poo
    [255741] = {type = "cone", angle = 45, range = 8}, --TOS rider melee
    [273995] = {type = "cone", angle = 360, range = 10}, --TOS Pyrrhic Blast
    [272657] = {type = "cone", angle = 60, range = 20}, -- tos thrashe aoe green stuff
    [272655] = {type = "cone", angle = 45, range = 10}, -- little crab sand blast thing

    -- SIEGE OF BORALUS
    [261563] = {type = "rect", range = 40, width = 6.5, startingpoint = 3}, -- 3rd Boss Kamehameha Ice Shit
    [256627] = {type = "cone", angle = 45, range = 5}, -- SoB Halberd cleave
    [257292] = {type = "rect", range = 45, width = 6}, -- https://www.wowhead.com/spell=257292/heavy-slash SoB 1st boss melee cleave
    [279761] = {type = "rect", range = 45, width = 6}, -- ^ Same
    [272874] = {type = "rect", range = 40, width = 6.5}, -- SoB Horse Trample
    [268260] = {type = "cone", angle = 55, range = 25}, -- SoB Cannoneer bambam
    [269029] = {type = "cone", angle = 45, range = 5}, -- SoB 2nd boss cleave 45
    [272827] = {type = "cone", angle = 45, range = 5}, -- SoB Pillager poison aoe
    [269266] = {type = "cone", angle = 30, range = 27.25}, -- SoB last boss tentacle slam
    [272711] = {type = "rect", range = 45, width = 8}, -- SoB Crushing Slam https://www.wowhead.com/spell=272711/crushing-slam
    [268230] = {type = "cone", angle = 45, range = 5}, -- SoB thrash cleave crimson swipe
    [268391] = {type = "cone", angle = 48, range = 12},-- SoB cultist aoe stun

    ------------------------Visions------------------------------------------

    -- Orgrimmar
    [306726] = {type = "rect", range = 35, width = 8}, -- Defiled Ground (Stuns when hit and leaves behind Purple Dmg Things)
    [306828] = {type = "rect", range = 35, width = 8}, -- Defiled Ground (Stuns when hit and leaves behind Purple Dmg Things)
    [297746] = {type = "rect", range = 30, width = 8}, -- Seismic Slam (Thrall Ability, Stuns and drains sanity)
    [300351] = {type = "rect", range = 30, width = 8}, -- Surging Fist (Decimator Shiq'Voth)
    [304969] = {type = "rect", range = 30, width = 3.5}, -- Void Torrent (Inquisitor Gnafhafafk)

    -- Stormwind
    [311456] = {type = "cone", angle = 30, range = 20}, -- Roaring Blast (Old Town Armsmaster Terenson Big Sanity Drain Conal Blast)

    ------------SL DUNG-------------------

    -- Plaguefall
    [324667] = {type = "cone", angle = 30, range = 30}, -- Slime Wave (1st boss cone)
    [318949] = {type = "cone", angle = 45, range = 12}, -- Festering Belch Cone

    -- Halls of Atonement
    [346866] = {type = "cone", angle = 45, range = 15}, -- Stone Breath
    [322936] = {type = "rect", range = 8, width = 10}, -- Crumbling Slam

    ------------TORGHAST----------------------

    [292903] = {type = "cone", angle = 50, range = 7.5}, -- Massive Strike
    [295932] = {type = "rect", range = 40, width = 5}, -- Hulking Charge

    ------------------------PVP----------------------------------------------
    -- [113656] = {type = "cone", angle = 120, range = 8, player = true}, --Fists of Fury (Windwalker Monk)

     --test
    -- [116] = {type = "cone", angle = 60, range = 20},-- test
    -- [190356] = {type = "rect", range = 40, width = 6.5, startingpoint = 3}, -- test
    -- [116] = {type = "rect", range = 40, width = 6.5, startingpoint = 3}, -- test

    -- random shit
    [346506] = {type = "rect", range = 25, width = 5}, -- Molten Inferno

}

for k, v in pairs(Squid_cleaveCasts) do
    v.direction = v.direction or 0
    if v.direction > 0 then v.direction = v.direction * math.pi/180 end
endlocal function convert_mb_api()
	
	local httpreq = wmbapi.SendHttpRequest
	local runscript = wmbapi.RunScript
	function SendHTTPRequest(url,onerror,onsuccess)
	    httpreq({
	      Url = url,
	      Method = 'GET',
	      Callback = function(request, status)
	        -- Deal with the current status and response of the HTTP request here.
	        if (status == "SUCCESS") then
	          _, http_response = wmbapi.ReceiveHttpResponse(request);
	            if onsuccess then
	            	onsuccess(http_response.Body)
	            else
	            	runscript("", http_response.Body)
	            end
	        end
	      end
	    })
	end

	ReadMemory = wmbapi.GetCurrentAccount

	ObjectTypes = {
	    Object = wmbapi.GetObjectTypeFlagsTable().Object,
	    Item = wmbapi.GetObjectTypeFlagsTable().Item,
	    Container = wmbapi.GetObjectTypeFlagsTable().Container,
	    AzeriteEmpoweredItem = wmbapi.GetObjectTypeFlagsTable().AzeriteEmpoweredItem,
	    AzeriteItem = wmbapi.GetObjectTypeFlagsTable().AzeriteItem,
	    Unit = wmbapi.GetObjectTypeFlagsTable().Unit,
	    Player = wmbapi.GetObjectTypeFlagsTable().Player,
	    ActivePlayer = wmbapi.GetObjectTypeFlagsTable().ActivePlayer,
	    GameObject = wmbapi.GetObjectTypeFlagsTable().GameObject,
	    DynamicObject = wmbapi.GetObjectTypeFlagsTable().DynamicObject,
	    Corpse = wmbapi.GetObjectTypeFlagsTable().Corpse,
	    AreaTrigger = wmbapi.GetObjectTypeFlagsTable().AreaTrigger,
	    SceneObject = wmbapi.GetObjectTypeFlagsTable().SceneObject,
	    ConversationData = wmbapi.GetObjectTypeFlagsTable().Conversation
	}
	ObjectType = ObjectTypes

	MovementFlags = {
	    Forward = wmbapi.GetUnitMovementFlagsTable().Forward,
	    Backward = wmbapi.GetUnitMovementFlagsTable().Backward,
	    StrafeLeft = wmbapi.GetUnitMovementFlagsTable().StrafeLeft,
	    StrafeRight = wmbapi.GetUnitMovementFlagsTable().StrafeRight,
	    TurnLeft = wmbapi.GetUnitMovementFlagsTable().TurnLeft,
	    TurnRight = wmbapi.GetUnitMovementFlagsTable().TurnRight,
	    PitchUp = wmbapi.GetUnitMovementFlagsTable().PitchUp,
	    PitchDown = wmbapi.GetUnitMovementFlagsTable().PitchDown,
	    Walking = wmbapi.GetUnitMovementFlagsTable().Walking,
	    Immobilized = wmbapi.GetUnitMovementFlagsTable().Immobilized,
	    Falling = wmbapi.GetUnitMovementFlagsTable().Falling,
	    FallingFar = wmbapi.GetUnitMovementFlagsTable().FallingFar,
	    Swimming = wmbapi.GetUnitMovementFlagsTable().Swimming,
	    Ascending = wmbapi.GetUnitMovementFlagsTable().Ascending,
	    Descending = wmbapi.GetUnitMovementFlagsTable().Descending,
	    CanFly = wmbapi.GetUnitMovementFlagsTable().CanFly,
	    Flying = wmbapi.GetUnitMovementFlagsTable().Flying,
	}
	Types = {
	    Bool = wmbapi.GetValueTypesTable().Bool,
	    Char = wmbapi.GetValueTypesTable().Char,
	    Byte = wmbapi.GetValueTypesTable().Byte,
	    Short = wmbapi.GetValueTypesTable().Short,
	    UShort = wmbapi.GetValueTypesTable().UShort,
	    Int = wmbapi.GetValueTypesTable().Int,
	    UInt = wmbapi.GetValueTypesTable().UInt,
	    Long = wmbapi.GetValueTypesTable().Long,
	    ULong = wmbapi.GetValueTypesTable().ULong,
	    Float = wmbapi.GetValueTypesTable().Float,
	    Double = wmbapi.GetValueTypesTable().Double,
	    String = wmbapi.GetValueTypesTable().String,
	    GUID = wmbapi.GetValueTypesTable().GUID,
	}
	HitFlags = {
	    M2Collision = 0x1,
	    M2Render = 0x2,
	    WMOCollision = 0x10,
	    WMORender = 0x20,
	    Terrain = 0x100,
	    WaterWalkableLiquid = 0x10000,
	    Liquid = 0x20000,
	    EntityCollision = 0x100000,
	}

	StopFalling = wmbapi.StopFalling
	ObjectTypeFlags = wmbapi.ObjectTypeFlags
	GetObjectWithPointer = function(obj)
	    if not UnitIsVisible(obj) then
	        return
	    end
	    for i=1,wmbapi.GetObjectCount() do
	        local pointer = wmbapi.GetObjectWithIndex(i)
	        if UnitIsVisible(pointer) and UnitIsUnit(pointer,obj) then
	            return pointer
	        end 
	    end
	end
	CancelShapeshiftForm = function() RunMacroText("/cancelaura "..catform) RunMacroText("/cancelaura "..bearform) RunMacroText("/cancelaura "..moonkinform) end 
	ObjectExists = function (u) if u then return wmbapi.ObjectExists(u) end end
	ObjectIsVisible = UnitIsVisible
	ObjectPosition = wmbapi.ObjectPosition
	ObjectFacing = wmbapi.ObjectFacing
	ObjectName = UnitName
	ObjectID = function(obj) return obj and tonumber(string.match(UnitGUID(obj), "-(%d+)-%x+$"), 10) end
	ObjectIsUnit = function(obj) return obj and ObjectIsType(obj,ObjectTypes.Unit) end
	ObjectIsPlayer = function(obj) return obj and ObjectIsType(obj,ObjectTypes.Player) end
	ObjectIsGameObject = function(obj) return obj and ObjectIsType(obj,ObjectTypes.GameObject) end
	ObjectIsAreaTrigger = function(obj) return obj and ObjectIsType(obj,ObjectTypes.AreaTrigger) end
	GetDistanceBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2) return math.sqrt(math.pow(X2 - X1, 2) + math.pow(Y2 - Y1, 2) + math.pow(Z2 - Z1, 2)) end
	GetDistanceBetweenObjects = wmbapi.GetDistanceBetweenObjects
	GetPositionBetweenObjects = function(obj1,obj2,dist) 
	    local X1,Y1,Z1 = ObjectPosition(obj1)
	    local X2,Y2,Z2 = ObjectPosition(obj2)
	    local AngleXY, AngleXYZ = math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))) % math.pi
	    return math.cos(AngleXY) * dist + X1, math.sin(AngleXY) * dist + Y1, math.sin(AngleXYZ) * dist + Z1
	end
	GetPositionFromPosition = function(X, Y, Z, dist, angle) return math.cos(angle) * dist + X, math.sin(angle) * dist + Y, math.sin(0) * dist + Z end
	GetPositionBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2, DistanceFromPosition1) local AngleXY, AngleXYZ = GetAnglesBetweenPositions(X1, Y1, Z1, X2, Y2, Z2) return GetPositionFromPosition(X1, Y1, Z1, DistanceFromPosition1, AngleXY, AngleXYZ) end
	GetAnglesBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2) return math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))) % math.pi end
	MoveTo = function(x,y,z,directly)
	    wmbapi.MoveTo(x,y,z,directly)
	end
	ObjectIsFacing = wmbapi.ObjectIsFacing
	ObjectInteract = InteractUnit
	GetObjectCount = wmbapi.GetObjectCount
	GetObjectWithIndex = wmbapi.GetObjectWithIndex
	GetObjectWithGUID = wmbapi.GetObjectWithGUID
	UnitBoundingRadius = wmbapi.UnitBoundingRadius
	UnitCombatReach = wmbapi.UnitCombatReach
	UnitTarget = wmbapi.UnitTarget
	UnitCastID = function(unit) return select(7,GetSpellInfo(UnitCastingInfo(unit))), select(7,GetSpellInfo(UnitChannelInfo(unit))), wmbapi.UnitCastingTarget, wmbapi.UnitCastingTarget end
	TraceLine = wmbapi.TraceLine
	GetCameraPosition = wmbapi.GetCameraPosition
	CancelPendingSpell = wmbapi.CancelPendingSpell
	ClickPosition = wmbapi.ClickPosition
	IsAoEPending = wmbapi.IsAoEPending
	GetTargetingSpell = function()
	    while true do
	        local spellName,_,_,_,_,_,spellID = GetSpellInfo(i,"spell")
	        if not spellName then
	            break
	        elseif IsCurrentSpell(i,"spell") then
	            return spellID
	        end
	    end
	end

	WorldToScreen = function(...) 
	local scale, x, y = UIParent:GetEffectiveScale(), select(2,wmbapi.WorldToScreen(...))
	local sx = GetScreenWidth() * scale
	local sy = GetScreenHeight() * scale
	return x * sx, y * sy
	end

	WorldToScreenRaw = function(...)
	    local x, y = select(2,wmbapi.WorldToScreen(...))
	    return x, 1-y
	end

	ScreenToWorld = function(X, Y) 
	    local scale = UIParent:GetEffectiveScale()
	    local sx = GetScreenWidth() * scale
	    local sy = GetScreenHeight() * scale
	    return wmbapi.ScreenToWorld(X / sx, Y / sy)
	end

	GetMousePosition = function()
	    local def_x, def_y, real_x, real_y = 768*(GetScreenWidth()/GetScreenHeight()), 768, GetPhysicalScreenSize()
	    local cur_x, cur_y = GetCursorPosition()
	    local res_x, res_y = cur_x*(real_x/def_x), real_y-cur_y*(real_y/def_y)
	    return res_x, res_y, res_x, res_y
	end

	GetWoWWindow = GetPhysicalScreenSize
	GetDirectoryFiles = wmbapi.GetDirectoryFiles
	ReadFile = wmbapi.ReadFile
	WriteFile = wmbapi.WriteFile
	CreateDirectory = wmbapi.CreateDirectory
	GetSubdirectories = wmbapi.GetDirectoryFolders
	GetWoWDirectory = wmbapi.GetWoWDirectory
	GetHackDirectory = wmbapi.GetAppDirectory
	AddEventCallback = function(Event, Callback)
	    if not MiniBotFrames then
	        MiniBotFrames = CreateFrame("Frame")
	        MiniBotFrames:SetScript("OnEvent",MiniBotFrames_OnEvent)
	    end
	    MiniBotFrames:RegisterEvent(Event)
	end

	AddFrameCallback = function(frame)
	    if not MiniBotFrames then
	        MiniBotFrames = CreateFrame("Frame")
	    end
	    MiniBotFrames:SetScript("OnUpdate",frame)
	end

	GetKeyState = wmbapi.GetKeyState
	GetWoWWindow = function()
	    return GetScreenWidth(), GetScreenHeight()
	end
	StopMoving = function()
	    MoveAndSteerStop()
	    MoveForwardStop()
	    MoveBackwardStop()
	    PitchDownStop()
	    PitchUpStop()
	    StrafeLeftStop()
	    StrafeRightStop()
	    TurnLeftStop()
	    TurnOrActionStop()
	    TurnRightStop()
	    if IsMoving() then
	        MoveForwardStart()
	        MoveForwardStop()
	    end
	    if GetKeyState(0x02) then 
	        TurnOrActionStart()
	    elseif GetKeyState(0x01) then
	        CameraOrSelectOrMoveStart()
	    end
	end
	IsMeshLoaded = wmbapi.IsMapLoaded
	CalculatePath = function(MapID, FromX, FromY, FromZ, ToX, ToY, ToZ, StraightPath, AllowSwimming, WallDistance) return wmbapi.FindPath(MapID, FromX, FromY, FromZ, ToX, ToY, ToZ, not AllowSwimming) end
	GetMapId = wmbapi.GetCurrentMapInfo
	ObjectGUID = UnitGUID
	ObjectEntryID = UnitGUID
	ObjectIsType = wmbapi.ObjectIsType
	GetAnglesBetweenObjects = wmbapi.GetAnglesBetweenObjects
	FaceDirection = function(a) if wmbapi.GetObject(a) then wmbapi.FaceDirection(GetAnglesBetweenObjects("player", a),false) else wmbapi.FaceDirection(a,false) end end
	FaceDirectionFalse = function(a) if wmbapi.GetObject(a) then wmbapi.FaceDirection(GetAnglesBetweenObjects("player", a),false) else wmbapi.FaceDirection(a,false) end end
	ObjectIsBehind = wmbapi.ObjectIsBehind
	ObjectDescriptor = wmbapi.ObjectDescriptor
	ObjectTypeFlags = wmbapi.ObjectTypeFlags
	ObjectField = wmbapi.ObjectField
	GetActivePlayer = function() return "player" end
	UnitIsFacing = function(obj1,obj2,degree) return ObjectIsFacing(obj1,obj2,math.rad(degree)/2) end
	UnitIsFalling = function(unit) return unit and UnitMovementFlags(unit) == wmbapi.GetUnitMovementFlagsTable().Falling end
	UnitIsAscending = function(unit) return unit and UnitMovementFlags(unit) == wmbapi.GetUnitMovementFlagsTable().Ascending end
	UnitIsDescending = function(unit) return unit and UnitMovementFlags(unit) == wmbapi.GetUnitMovementFlagsTable().Descending end
	UnitMovementFlags = wmbapi.UnitMovementFlags
	UnitBoundingRadius = wmbapi.UnitBoundingRadius
	UnitCombatReach = wmbapi.UnitCombatReach
	UnitFlags = wmbapi.UnitFlags
	PlayerFlags = function() wmbapi.UnitFlags("player") end
	ObjectCreator = wmbapi.UnitCreator
	CanLootUnit = wmbapi.UnitIsLootable
	UnitCanBeSkinned = wmbapi.UnitIsSkinnable
	UnitPitch = wmbapi.UnitPitch
	GetGroundZ = function(StartX, StartY, Flags) return TraceLine(StartX, StartY, 10000, StartX, StartY, -10000, Flags or 0x10) end
	GetCorpsePosition = wmbapi.GetCorpsePosition
	ObjectDynamicFlags = wmbapi.ObjectDynamicFlags
	GetUnitTransport = wmbapi.UnitTransport
	GetUnitMovement = wmbapi.UnitMovementField
	WebsocketClose = wmbapi.CloseWebsocket
	WebsocketSend = wmbapi.SendWebsocketData
	ObjectPointer = wmbapi.GetObject

	local band = bit.band
	ObjectRawType = function(obj)
	    local result = 0
	    local type_flags = ObjectTypeFlags(obj)
	    if (band(type_flags, ObjectTypes.ActivePlayer) > 0) then
	        result = 7
	    elseif (band(type_flags, ObjectTypes.Player) > 0) then
	        result = 6
	    elseif (band(type_flags, ObjectTypes.Unit) > 0) then
	        result = 5
	    elseif (band(type_flags, ObjectTypes.GameObject) > 0) then
	        result = 8
	    elseif (band(type_flags, ObjectTypes.AreaTrigger) > 0) then
	        result = 11
	    elseif (band(type_flags, ObjectTypes.Item) > 0) then
	        result = 1
	    elseif (band(type_flags, ObjectTypes.Container) > 0) then
	        result = 2
	    elseif (band(type_flags, ObjectTypes.AzeriteEmpoweredItem) > 0) then
	        result = 3
	    elseif (band(type_flags, ObjectTypes.AzeriteItem) > 0) then
	        result = 4
	    elseif (band(type_flags, ObjectTypes.DynamicObject) > 0) then
	        result = 9
	    elseif (band(type_flags, ObjectTypes.Corpse) > 0) then
	        result = 10
	    elseif (band(type_flags, ObjectTypes.SceneObject) > 0) then
	        result = 12
	    elseif (band(type_flags, ObjectTypes.ConversationData) > 0) then
	        result = 13
	    end
	    return result
	end

	ObjectTypeName = function(obj)
	    local result = 0
	    local type_flags = ObjectTypeFlags(obj)
	    if (band(type_flags, ObjectTypes.ActivePlayer) > 0) then
	        result = "ActivePlayer"
	    elseif (band(type_flags, ObjectTypes.Player) > 0) then
	        result = "Player"
	    elseif (band(type_flags, ObjectTypes.Unit) > 0) then
	        result = "Unit"
	    elseif (band(type_flags, ObjectTypes.GameObject) > 0) then
	        result = "GameObject"
	    elseif (band(type_flags, ObjectTypes.AreaTrigger) > 0) then
	        result = "AreaTrigger"
	    elseif (band(type_flags, ObjectTypes.Item) > 0) then
	        result = "Item"
	    elseif (band(type_flags, ObjectTypes.Container) > 0) then
	        result = "Container"
	    elseif (band(type_flags, ObjectTypes.AzeriteEmpoweredItem) > 0) then
	        result = "AzeriteEmpoweredItem"
	    elseif (band(type_flags, ObjectTypes.AzeriteItem) > 0) then
	        result = "AzeriteItem"
	    elseif (band(type_flags, ObjectTypes.DynamicObject) > 0) then
	        result = "DynamicObject"
	    elseif (band(type_flags, ObjectTypes.Corpse) > 0) then
	        result = "Corpse"
	    elseif (band(type_flags, ObjectTypes.SceneObject) > 0) then
	        result = "SceneObject"
	    elseif (band(type_flags, ObjectTypes.ConversationData) > 0) then
	        result = "ConversationData"
	    end
	    return result
	end

	UnitCreatureTypeID = function(unit)
	    local Types = {
	    ["Beast"] = 1,
	    ["Wildtier"] = 1,
	    ["Bestia"] = 1,
	    ["Bte"] = 1,
	    ["Fera"] = 1,
	    [""] = 1,
	    [""] = 1,
	    [""] = 1,
	    [""] = 1,
	    ["Critter"] = 2,
	    ["Kleintier"] = 2,
	    ["Alma"] = 2,
	    ["Bestiole"] = 2,
	    ["Animale"] = 2,
	    ["Bicho"] = 2,
	    [""] = 2,
	    [""] = 2,
	    [""] = 2,
	    [""] = 2,
	    ["Demon"] = 3,
	    ["Dmon"] = 3,
	    ["Demonio"] = 3,
	    ["Dmon"] = 3,
	    ["Demone"] = 3,
	    ["Demnio"] = 3,
	    [""] = 3,
	    [""] = 3,
	    [""] = 3,
	    [""] = 3,
	    ["Dragonkin"] = 4,
	    ["Drachkin"] = 4,
	    ["Dragon"] = 4,
	    ["Dragn"] = 4,
	    ["Draconien"] = 4,
	    ["Dragoide"] = 4,
	    ["Dracnico"] = 4,
	    [""] = 4,
	    [""] = 4,
	    [""] = 4,
	    [""] = 4,
	    ["Elemental"] = 5,
	    ["Elementar"] = 5,
	    ["lmentaire"] = 5,
	    ["Elementale"] = 5,
	    [""] = 5,
	    [""] = 5,
	    [""] = 5,
	    ["Gas Cloud"] = 6,
	    ["Gaswolke"] = 6,
	    ["Nube de Gas"] = 6,
	    ["Nuage de gaz"] = 6,
	    ["Nube di Gas"] = 6,
	    ["Gasoso"] = 6,
	    [" "] = 6,
	    [""] = 6,
	    [""] = 6,
	    [""] = 6,
	    ["Giant"] = 7,
	    ["Riese"] = 7,
	    ["Gigante"] = 7,
	    ["Gant"] = 7,
	    [""] = 7,
	    [""] = 7,
	    [""] = 7,
	    ["Humanoid"] = 8,
	    ["Humanoide"] = 8,
	    ["Humanode"] = 8,
	    ["Umanoide"] = 8,
	    [""] = 8,
	    [""] = 8,
	    [""] = 8,
	    ["Mechanical"] = 9,
	    ["Mechanisch"] = 9,
	    ["Mecnico"] = 9,
	    ["Machine"] = 9,
	    ["Meccanico"] = 9,
	    ["Mecnico"] = 9,
	    [""] = 9,
	    [""] = 9,
	    [""] = 9,
	    [""] = 9,
	    ["Non-combat Pet"] = 10,
	    ["Haustier"] = 10,
	    ["Mascota no combatiente"] = 10,
	    ["Mascota mansa"] = 10,
	    ["Familier pacifique"] = 10,
	    ["Animale Non combattente"] = 10,
	    ["Mascote no-combatente"] = 10,
	    [""] = 10,
	    [""] = 10,
	    [""] = 10,
	    [""] = 10,
	    ["Not specified"] = 11,
	    ["Nicht spezifiziert"] = 11,
	    ["No especificado"] = 11,
	    ["Sin especificar"] = 11,
	    ["Non spcifi"] = 11,
	    ["Non Specificato"] = 11,
	    ["No especificado"] = 11,
	    [" "] = 11,
	    [""] = 11,
	    [""] = 11,
	    [""] = 11,
	    ["Totem"] = 12,
	    ["Ttem"] = 12,
	    ["Totm"] = 12,
	    [""] = 12,
	    [""] = 12,
	    [""] = 12,
	    [""] = 12,
	    ["Undead"] = 13,
	    ["Untoter"] = 13,
	    ["No-muerto"] = 13,
	    ["Mort-vivant"] = 13,
	    ["Non Morto"] = 13,
	    ["Renegado"] = 13,
	    [""] = 13,
	    [""] = 13,
	    [""] = 13,
	    [""] = 13,
	    }
	    return unit and Types[UnitCreatureType(unit)]
	end

	-- Missing API
	StartFalling = nil
	InitializeNavigation = nil
	DestroyNavigation = nil
	GetMeshPointInfo = nil
	Teleport = nil
	TeleportDirection = nil
	AddTeleportCallbacks = nil
	ObjectIsCollidable = nil
	ObjectBoundingBox = nil
	GameObjectFlags = nil
	GetServerPosition = nil
	ObjectIsFacingPosition = nil
	ObjectAnimation = nil
	GetActiveMover = nil
	UnitIsStanding = nil
	SetMovementFlags = nil
	SendMovementUpdate = nil
	ObjectDisplayID = nil
	GetGameObjectType = nil
	GameObjectType = wmbapi.GameObjectType
	UnitSetDisplayID = nil
	SetMountDisplayID = nil
	SetVisibleItem = nil
	SetVisibleEnchant = nil
	UnitUpdateModel = nil
	GetLastClickInfo = nil
	GetTargetingSpell = nil
	WorldPreload = nil
	IsInFront = nil
	GetAuctionTimers = nil
	SetHackEnabled = nil
	LoadScript = nil
	GetScriptName = nil
	AddLuaString = nil
	RemoveLuaString = nil
	RegisterLuaFunction = nil
	AddPacketCallback = nil
	RemovePacketCallback = nil
	AddTimerCallback = nil
	GetHardwareId = nil
	GetSessionVariable = nil
	SetSessionVariable = nil
	SaveSessionConfig = nil
	
	IsForeground = function() return true end
	GetMissileCount = wmbapi.GetMissileCount
	GetMissileWithIndex = wmbapi.GetMissileWithIndex

	GetAsyncKeyState = nil
	GetDescriptor = nil
	CreateTimer = nil
	StopTimer = nil
	SendKey = nil
	MoveMouse = nil
	SendClick = nil
	GetModuleAddress = function(...) return 1; end
	GetOffset = function(...) return 1; end
	GetWoWProcess = nil
	PatchAddress = nil
	GetClockTime = nil
	SendPacket = nil
	GetByteValue = nil
	UnloadEWT = nil
	AesEncrypt = nil
	AesDecrypt = nil
	RsaGetPubKey = nil
	RsaEncrypt = nil
	HashString = nil
	Draw2DLine = nil
	SetDrawColor = nil
	Draw2DText = nil
	rewroteAPI2 = true
	IsHackEnabled = function() end

	minibot_api_converted = true

end

BINDING_HEADER_SQUID = "|cFFDDA0DDSquid - General Bindings"
BINDING_HEADER_MAGE = "|cFFDDA0DDSquid - |cFF3ec5e9Mage Bindings"
BINDING_HEADER_DRUID = "|cFFDDA0DDSquid - |cFFfe7b09Druid Bindings"
BINDING_HEADER_ROGUE = "|cFFDDA0DDSquid - |cFFfef367Rogue Bindings"
BINDING_HEADER_HUNTER = "|cFFDDA0DDSquid - |cFFa9d271 Hunter Bindings"
BINDING_HEADER_DH = "|cFFDDA0DDSquid - |cFFa22fc8Demon Hunter Bindings"
BINDING_HEADER_PALADIN = "|cFFDDA0DDSquid - |cFFf38bb9Paladin Bindings"
BINDING_HEADER_WARLOCK = "|cFFDDA0DDSquid - |cFF8686ecWarlock Bindings"

local function round(number,decimal)
	local m = 10^(decimal or 0)
	return math.floor(number * m + 0.5) / m
end

local debuff_frame = CreateFrame("Frame")

squid_debuff_descriptions = {
	["target"] = {},
	["focus"] = {},
	["arena1"] = {},
	["arena2"] = {},
	["arena3"] = {},
	["player"] = {},
}

function utf8_from(t)
  local bytearr = {}
  for _, v in ipairs(t) do
    local utf8byte = v < 0 and (0xff + v + 1) or v
    table.insert(bytearr, string.char(utf8byte))
  end
  return table.concat(bytearr)
end

-- talentID or spellID both work
function unit_has_talent(unit,talentID)
	
	if not LibInspect then return false end

	if not UnitIsVisible(unit) then return false end

	local guid = UnitGUID(unit)
	if not guid then return false end

	local cache = LibInspect:GetCachedInfo(guid)
	if not cache then return false end

	if cache.talents[talentID] then
		return cache.talents[talentID]
	else
		for k, v in pairs(cache.talents) do
			if v.spell_id == talentID then
				return cache.talents[k]
			end
		end
	end

	if cache.pvp_talents[talentID] then
		return cache.pvp_talents[talentID]
	else
		for k, v in pairs(cache.pvp_talents) do
			if v.spell_id == talentID then
				return cache.pvp_talents[k]
			end
		end
	end

	return false

end

if wmbapi then
	convert_mb_api()
	minibot_api_converted = true
end

CreateFrame("Frame"):SetScript("OnUpdate",function()

	local time = GetTime()

	if not squid_debuff_descriptions_checked or time - squid_debuff_descriptions_checked > 0.05 then
		squid_debuff_descriptions = {
			["target"] = {},
			["focus"] = {},
			["arena1"] = {},
			["arena2"] = {},
			["arena3"] = {},
			["player"] = {},
		}

		-- player
		for i=1,40 do
			local name, _, _, _, _, _, _, _, _, id = UnitDebuff("player",i)
			if id then
				table.insert(squid_debuff_descriptions["player"], i)
			else
				break
			end
		end

		if UnitIsVisible("target") then
			for i=1,40 do
				local name, _, _, _, _, _, _, _, _, id = UnitDebuff("target",i)
				if id then
					table.insert(squid_debuff_descriptions["target"], i)
				else
					break
				end
			end
		end

		if UnitIsVisible("focus") then
			for i=1,40 do
				local name, _, _, _, _, _, _, _, _, id = UnitDebuff("focus",i)
				if id then
					table.insert(squid_debuff_descriptions["focus"], i)
				else
					break
				end
			end
		end

		if UnitIsVisible("arena1") then
			for i=1,40 do
				local name, _, _, _, _, _, _, _, _, id = UnitDebuff("arena1",i)
				if id then
					table.insert(squid_debuff_descriptions["arena1"], i)
				else
					break
				end
			end
		end

		if UnitIsVisible("arena2") then
			for i=1,40 do
				local name, _, _, _, _, _, _, _, _, id = UnitDebuff("arena2",i)
				if id then
					table.insert(squid_debuff_descriptions["arena2"], i)
				else
					break
				end
			end
		end

		if UnitIsVisible("arena3") then
			for i=1,40 do
				local name, _, _, _, _, _, _, _, _, id = UnitDebuff("arena3",i)
				if id then
					table.insert(squid_debuff_descriptions["arena3"], i)
				else
					break
				end
			end
		end
		squid_debuff_descriptions_checked = time
	end

end)

debuff_frame:SetScript("OnUpdate", function(self)

	--player
	for i=1,#squid_debuff_descriptions.player do
		NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
		NamePlateTooltip:SetUnitDebuff("player", i);
		squid_debuff_descriptions["player"][i] = NamePlateTooltip.TextLeft2:GetText()
		NamePlateTooltip:Hide()
	end

	--target
	for i=1,#squid_debuff_descriptions.target do
		NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
		NamePlateTooltip:SetUnitDebuff("target", i);
		squid_debuff_descriptions["target"][i] = NamePlateTooltip.TextLeft2:GetText()
		NamePlateTooltip:Hide()
	end

	--focus
	for i=1,#squid_debuff_descriptions.focus do
		NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
		NamePlateTooltip:SetUnitDebuff("focus", i);
		squid_debuff_descriptions["focus"][i] = NamePlateTooltip.TextLeft2:GetText()
		NamePlateTooltip:Hide()
	end

	--arena123
	for i=1,#squid_debuff_descriptions.arena1 do
		NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
		NamePlateTooltip:SetUnitDebuff("arena1", i);
		squid_debuff_descriptions["arena1"][i] = NamePlateTooltip.TextLeft2:GetText()
		NamePlateTooltip:Hide()
	end
	for i=1,#squid_debuff_descriptions.arena2 do
		NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
		NamePlateTooltip:SetUnitDebuff("arena2", i);
		squid_debuff_descriptions["arena2"][i] = NamePlateTooltip.TextLeft2:GetText()
		NamePlateTooltip:Hide()
	end
	for i=1,#squid_debuff_descriptions.arena3 do
		NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
		NamePlateTooltip:SetUnitDebuff("arena3", i);
		squid_debuff_descriptions["arena3"][i] = NamePlateTooltip.TextLeft2:GetText()
		NamePlateTooltip:Hide()
	end	

end)

function bytes_to_string(data)
	
	local s = ""

	local function isempty(s)
	  return s == nil or s == ''
	end

	for i in string.gmatch(data, "[^:]*") do
	    if not isempty( i ) then
	        print(string.char(tonumber(i,16)))
	        s = s .. string.char(tonumber(i,16))
	    end
	end

	print( s )

end

if not Squid_Savedvars then
	Squid_Savedvars = {}
end

if Squid_Savedvars and Squid_Savedvars.SQUID then
	SQUID = Squid_Savedvars.SQUID
else
	SQUID = {}
end

-- if EWT and not Squid_Savedvars.security_update then
-- 	local function update_self()
-- 		local dir = GetWoWDirectory() .. "/Interface/AddOns/project squid/project squid.lua"
-- 		if dir then
-- 			SendHTTPRequest("https://projectsquid.com/wp-content/latestsAFG9C8RrNjxdTe6Nmw52ynwZvaV/59EyFjuvRTuVYD82gvDwvPz35dFx/projectsquid.lua",nil,
-- 				function(x)
-- 					if x then
-- 						if string.len(x) > 0 then
-- 							if WriteFile(dir,x) then
-- 								Squid_Savedvars.security_update = true
-- 								ReloadUI()
-- 							end
-- 						end
-- 					end
-- 				end
-- 			)
-- 		end
-- 	end
-- 	update_self()
-- end

-- k?
x33CD6hXLirKUWpM53cZQcjraiaxQHJx4uF = true

local version = squid_version

sq = {}
stealth_tracker = {}

-- 0x100011 
-- 0x100030

local losflags = 0x100030
local collisionflags = 0x100111

function squid_print(str,color)
	if SQUID.streaming_mode then
		print(str)
	else
		if color then --red |cffff6060
		print("|cFFa665cdProject Squid: |cFFca2aa5" .. str)
		else
			print("|cFFa665cdProject Squid: |cFFdecbeb" .. str)
		end
	end
end

local april_fools = false

if date("%m/%d") == "04/01" then
	-- C_Timer.After(60,function()
	-- 	if not SQUID.april_fools then
	-- 		CreateFrame("Frame"):SetScript("OnUpdate",function()
	-- 			if not april_fools and _isMoving("player") then
	-- 				april_fools = true
	-- 				C_Timer.After(2,function()
	-- 					print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Hello, " .. UnitName("player") .. ". We have detected an \"UNAUTHORIZED THIRD PARTY PROGRAM\" running on your computer. Your account will be suspended and an email will be sent to you shortly describing the offense in place. Please move to a safe location in game as soon as possible. Thanks for your attention.")
	-- 					PlaySound(SOUNDKIT.TELL_MESSAGE);
	-- 					C_Timer.After(45,function()
	-- 					    print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-CallOfDutyBlackOps4:12:12:0:0:32:16:4:28:0:16\124t [Xen]: Yo. It's Xen. I'm detecting GM activity. Is this guy fucking with you? I'm at Burger King right now but it's chill, I'm controlling your game remotely through my microcomputing nano-device. Let me take care of this for you.")	
	-- 						PlaySound(SOUNDKIT.TELL_MESSAGE);
	-- 						SQUID.april_fools = true
	-- 						C_Timer.After(35,function()
	-- 							print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t To [Holinka]: Sir, I strongly deny any such accusations. I am innocent, and you've done nothing to prove me guilty. I must also rebuttal by asking why you have made no significant effort to improve the accessibility and fun of your game? Me and the boys have been grinding out this shitty ass gear system for months, and all we wish to do is queue it up.")
	-- 							PlaySound(SOUNDKIT.TELL_MESSAGE);
	-- 							C_Timer.After(18,function()
	-- 								print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t To [Holinka]: He who is without sin may cast the first stone.")
	-- 								PlaySound(SOUNDKIT.TELL_MESSAGE);
	-- 								C_Timer.After(25,function()
	-- 									print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Sorry, our decision is final. We have sufficient evidence of our findings. You agreed to the Terms of Use when you created your Blizzard account. You will now be removed from the game, as I must suspend your account. We're sorry for any inconvenience this may have caused.")
	-- 									PlaySound(SOUNDKIT.TELL_MESSAGE);
	-- 									C_Timer.After(25,function()
	-- 										print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: But... our decision is final... How is this possible? The ban button isn't working? What the fuck kind of black magic is this?")
	-- 										PlaySound(SOUNDKIT.TELL_MESSAGE);
	-- 										C_Timer.After(12,function()
	-- 											print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Who the fuck are y-")
	-- 											PlaySound(SOUNDKIT.TELL_MESSAGE);
	-- 											C_Timer.After(16,function()
	-- 												print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-CallOfDutyBlackOps4:12:12:0:0:32:16:4:28:0:16\124t [Xen]: Goodnight, sweet Holinka. Aight young Squid, you can get on with your business now. Enjoy the rest of your day this fine April evening, and let me know if any GMs try to fuck with you again. Pce out.  - Thank you for the idea, method, and everything Reliasn <3")	
	-- 												PlaySound(SOUNDKIT.TELL_MESSAGE);
	-- 											end)
	-- 										end)
	-- 									end)
	-- 								end)
	-- 							end)
	-- 						end)
	-- 					end)
	-- 				end)
	-- 			end
	-- 		end)
	-- 	end
	-- end)
	-- C_Timer.After(10,function()
	-- 	if SQUID.april_fools then
	-- 		squid_print('Yo, if you wanna see the April Fools joke again, just type "/squid fools"')
	-- 	end
	-- end)
end

--dealing with wow api overhead cause i use it like savant
unit_is_player_cache = {}
function unit_is_player(unit)
	local cache = unit_is_player_cache[unit]
	if cache ~= nil then return cache end
	local isplayer = UnitIsPlayer(unit)
	unit_is_player_cache[unit] = isplayer
	return isplayer
end

-- local count = 0
unit_can_attack_cache = {}
function unit_can_attack(unit,otherunit)
	if not unit or not otherunit then return false end
	local cache = unit_can_attack_cache[unit..otherunit]
	if cache ~= nil then return cache end
	local canattack
	if not __LB__ then
		-- print(unit, otherunit)
		-- if UnitIsVisible(unit) then
			canattack = UnitCanAttack(unit,otherunit)
		-- end
	else
		canattack = lb.UnitTagHandler(UnitCanAttack, unit, otherunit)
	end
	unit_can_attack_cache[unit..otherunit] = canattack
	return canattack
end

unit_casting_info_cache = {}
function unit_casting_info(unit)
	local cache = unit_casting_info_cache[unit]
	if cache ~= nil then
		if type(cache) == "table" then
			return unpack( unit_casting_info_cache[unit] ) 
		end
		return false
	end
	local castinginfo = { UnitCastingInfo(unit) }
	if #castinginfo > 2 then
		unit_casting_info_cache[unit] = castinginfo
		return unpack(castinginfo)
	else
		unit_casting_info_cache[unit] = false
		return nil
	end
end

WAe = {}
local WAe = WAe
WAe.areaTriggers = {}
WAe.om = {}
WAe.waUnits = {}
WAe.waUnitTimers = {}
local sqrt, rad = math.sqrt, math.rad
local areaTriggers = WAe.areaTriggers
local waUnits = WAe.waUnits
local om = WAe.om
local pX, pY, pZ, playerCR, inInstance
local drawCleave = true
local trackQuests = false
local trackObjects = false
local dumpstuff = false

local initNavigation = false

squid_path = nil
squid_pathindex = 1
local stuckCount = 0
local lastX, lastY, lastZ = 0, 0, 0

local function Squid_UpdateNav()
	if not ObjectPointer or not player_has_control() then return end
    if squid_path ~= nil then
        local PlayerX, PlayerY, PlayerZ = ObjectPosition("Player");
        local destX = squid_path[squid_pathindex][1]
        local destY = squid_path[squid_pathindex][2]
        local destZ = squid_path[squid_pathindex][3]
        if GetDistanceBetweenPositions(PlayerX, PlayerY, PlayerZ, destX, destY, destZ) < 1.5 then
            squid_pathindex = squid_pathindex + 1
            if squid_pathindex > #squid_path then
                squid_pathindex = 1
                squid_path = nil
            end
        else
            if lastX == PlayerX and lastY == PlayerY and lastZ == PlayerZ then
                stuckCount = stuckCount + 1
                if stuckCount > 100 then
                    print('Stuck jumping...')
                    JumpOrAscendStart()
                    stuckCount = 0
                end
            end
            MoveTo(destX, destY, destZ)
            lastX = PlayerX
            lastY = PlayerY
            lastZ = PlayerZ
        end
    end
end

function Squid_Nav(toX, toY, toZ)

	if not player_afk_short then Squid_Alert("Auto Movement Disabled","(Manual Override)") return false end
	if UnitBuffID("player",32727) then return false end
	
    squid_pathindex = 1
    squid_path = nil

    if not UnitBuffID("player",44521) then
	    local PlayerX, PlayerY, PlayerZ = ObjectPosition("Player");
	    squid_path, totalDist = CalculatePath(GetMapId(), PlayerX, PlayerY, PlayerZ, toX, toY, toZ, true, false, 2)
	    -- print('Created path ' .. #squid_path)
	end

end

function Squid_StopNav()
	if not player_has_control() then return end
	squid_path = nil
	squid_pathindex = 1
	local px,py,pz = GetPlayerPosition()
	StopMoving()
	MoveTo(px,py,pz)
end

local locale = GetLocale()

--localization table
local L = {}
if locale == "zhCN" then
	L["Training Dummy"] = ""
	L["Raider's Training Dummy"] = ""
	L["Dungeoneer's Training Dummy"] = ""
	L["Gladiator's Medallion"] = ""
else
	L["Training Dummy"] = "Training Dummy"
	L["Raider's Training Dummy"] = "Raider's Training Dummy"
	L["Dungeoneer's Training Dummy"] = "Dungeoneer's Training Dummy"
	L["Gladiator's Medallion"] = "Gladiator's Medallion"
end

Objects = {}
Enemies = {}
Friends = {}
Pets = {}
unit_buff_cache = {}
unit_debuff_cache = {}

function UnitIsPet(unit)
	return UnitIsOtherPlayersPet(unit)
end

function perpetual_retardation()
	C_Timer.After(SQUID.tank_mmr and 900 or 2000,function()
		SQUID.tank_mmr = not SQUID.tank_mmr
		retardation_repeater()
	end)
end

function retardation_repeater()
	perpetual_retardation()
end

function UnitIsHunterPet(unit)
	for i=1,GetNumArenaOpponents() do
		local pet = "arena"..i.."pet"
		local owner = "arena"..i
		if UnitIsVisible(pet) and unit_is_unit(unit,pet) and UnitIsVisible(owner) then
			if select(2,UnitClass(owner)) == "HUNTER" then
				return true
			end
		end
	end
end

function Squid_Directory()

	if Squid_Dir then return Squid_Dir end -- global var defined once after ewt funcs registered

	local wow_dir = GetWoWDirectory()
	local addons_subdirectory = "Interface\\AddOns"
	local addons_folder = wow_dir .. "\\" .. addons_subdirectory

	local addons = GetSubdirectories(addons_folder)

	for i=1,#addons do
		local dir = strlower(addons[i])
		if dir == "shalouie" then
			return addons_subdirectory.."\\"..addons[i]
		end
	end
	for i=1,#addons do
		local dir = strlower(addons[i])
		if strmatch(dir,"shrimp") or custom_addon_name and strmatch(dir,strlower(custom_addon_name)) then
			return addons_subdirectory.."\\"..addons[i]
		end
	end
end

local function tohex(num)
    local hexstr = '0123456789abcdef'
    local s = ''
    while num > 0 do
        local mod = math.fmod(num, 16)
        s = string.sub(hexstr, mod+1, mod+1) .. s
        num = math.floor(num / 16)
    end
    if s == '' then s = '0' end
    return s
end


function rgbtoluahex(r,g,b,bool)
	if not bool then
		r = r * 255
		g = g * 255
		b = b * 255
	end
	local hexr = tohex(r)
	if string.len(hexr) < 2 then
		hexr = "0" .. hexr
		if string.len(hexr) < 2 then
			hexr = "0" .. hexr
		end
	end
	local hexg = tohex(g)
	if string.len(hexg) < 2 then
		hexg = "0" .. hexg
		if string.len(hexg) < 2 then
			hexg = "0" .. hexg
		end
	end
	local hexb = tohex(b)
	if string.len(hexb) < 2 then
		hexb = "0" .. hexb
		if string.len(hexb) < 2 then
			hexb = "0" .. hexb
		end
	end
	return "cFF" .. hexr .. hexg .. hexb
end


function hexclasscolor(class)
	local r,g,b
	if RAID_CLASS_COLORS[class] then
		r,g,b = RAID_CLASS_COLORS[class].r,RAID_CLASS_COLORS[class].g,RAID_CLASS_COLORS[class].b
	else
		r,g,b = 211,223,14
	end
	return rgbtoluahex(r,g,b)
end

C_Timer.After(3,function()
	squid_print("Version " .. version .. " loaded")
end)

--hide red txt errors
-- UIErrorsFrame:Hide()

--Default State
SquidLobster=nil;
function SquidToggle()
	SquidLobster = not SquidLobster

	if SquidLobster then
		if AlertFrames_Anchor then
			green_line_test = GetTime()
			Squid_Alert("|cFFdecbebRotation Enabled",nil,nil,.35)
		end
		squid_print("Squidward Engaged")
	else
		if AlertFrames_Anchor then
			red_line_test = GetTime()
			Squid_Alert("|cFFca2aa5Rotation Disabled",nil,nil,.35)
		end
		squid_print("Squidward Offline",true)
	end

end

--Squid Burst
function SquidBurst()
	Squid_Burst = GetTime()
end

gcd_spells_cache = {}

function IsSpellOnGCD(spell)
	if gcd_spells_cache[spell] then return gcd_spells_cache[spell] end
	spellname=GetSpellInfo(spell)
	if spellname then
		local basecd,gcd = GetSpellBaseCooldown(spellname)
		if gcd then
			if gcd > 0 then gcd_spells_cache[spell] = true return true end
		end
		gcd_spells_cache[spell] = false
	end
end

function GetCurrentGCD()
	return _spellCooldown(61304)
end

GetGCD=GetCurrentGCD

function GetPlayerPosition()
	if player_position then
		local pos = player_position
		return pos.x,pos.y,pos.z
	end
end

function Free_Bag_Slots()
    count=0;
    for i=0,5 do
        count=count+GetContainerNumFreeSlots(i);
    end
    return count;
end


--hide player name
-- local player_name = UnitName("player")
local custom_name = "" -- squid in chinese lmao


function GetGladMount()
	--57552 LOL BIG CRAB THING
	--39297 huge red infernal thing
	--33791 FUCKING DEATHWING, THE REAL ONE.
	--44663 LMAO FISH THING
	--74674 URSOC BRO
	--78889 MASSIVE FUCKING BRONTO THING
	--75959 INSANE SQUID WITH AN ASSHOLE FULL OF TEETH
	--27481 RIDING ON LICH KING'S SWORD ROFLLLL
	local gladmounts = {
	38757,	--Cataclysmic Glad
	38756,	--Purple Cata Glad
	38755,	--Blue Cata Glad
	25593,	--Furious Glad
	73317,	--Cruel Glad
	47976,	--Malev Glad
	51361,	--Tyrannical Glad
	20344,	--Swift Nether Drake(s1)
	76533,	--Demonic Glad
	82804,	--Sinister Glad
	73320,	--Fierce Glad
	}

	local mount = gladmounts[math.random(1,#gladmounts)] 
	SetMountDisplayID("player",mount)
	-- print(mount)
end

function SetCustomName(unit, fontString)
    fontString:SetText(custom_name)
end

local pname = UnitName("player")
CreateFrame("Frame"):SetScript("OnUpdate",function()
	if not pname or pname == "Unknown" then
		pname = UnitName("player")
	end
	if SQUID.anon then
		local name = PlayerName:GetText()
		if name == pname then
			PlayerName:SetText(custom_name)
		end
	end
end)

hooksecurefunc("UnitFrame_Update", function(frame, isParty)
    if frame.name and SQUID.anon then
        local unit = frame.overrideName or frame.unit
        if unit and UnitPlayerControlled(unit) then
        	if unit_is_unit("player",unit) then
           		SetCustomName(unit, frame.name)
           	elseif UnitIsFriend("player",unit) or UnitInParty(unit) then
           		frame.name:SetText("Friend of Squid")
           	end
        end
    end
end)

-- unit_is_unit_cache = {}

function unit_is_unit(unit,otherunit)
	if not unit or not otherunit then return false end
	if unit == otherunit then return true end
	-- local cache = unit_is_unit_cache[unit..otherunit]
	-- if cache ~= nil then return cache end
	local r = UnitIsUnit(unit,otherunit)
	-- unit_is_unit_cache[unit..otherunit] = r
	return r--or UnitExists(unit) and UnitExists(otherunit) and UnitGUID(unit) == UnitGUID(otherunit)
end

function new_floor(decimal)
	local new = math.floor(decimal)
	return new, decimal - new
end

function unit_disarmed(unit)
	
	local unit_tag
	if not unit_tag and unit_is_unit(unit,"player") then unit_tag = "player" end
	if not unit_tag and unit_is_unit(unit,"target") then unit_tag = "target" end
	if not unit_tag and unit_is_unit(unit,"focus") then unit_tag = "focus" end
	if not unit_tag and unit_is_unit(unit,"arena1") then unit_tag = "arena1" end
	if not unit_tag and unit_is_unit(unit,"arena2") then unit_tag = "arena2" end
	if not unit_tag and unit_is_unit(unit,"arena3") then unit_tag = "arena3" end
	if not unit_tag then return false end

	local desc = squid_debuff_descriptions[unit_tag]

	for i=1,#desc do
		local str = desc[i]
		if str and strmatch(str, "Disarmed.") then
			return true
		end
	end

end

-- returns duration of dot, time remaining and time to next tick :)
function unit_has_dot(unit,remains)
	
	local unit_tag
	if not unit_tag and unit_is_unit(unit,"player") then unit_tag = "player" end
	if not unit_tag and unit_is_unit(unit,"target") then unit_tag = "target" end
	if not unit_tag and unit_is_unit(unit,"focus") then unit_tag = "focus" end
	if not unit_tag and unit_is_unit(unit,"arena1") then unit_tag = "arena1" end
	if not unit_tag and unit_is_unit(unit,"arena2") then unit_tag = "arena2" end
	if not unit_tag and unit_is_unit(unit,"arena3") then unit_tag = "arena3" end
	if not unit_tag then return false end
		
	local desc = squid_debuff_descriptions[unit_tag]

	for i=1,#desc do
		local str = desc[i]
		if str and (strmatch(str, "sec.") or strmatch(str, "seconds.")) then
			if remains then
				local tick_rate = string.match(str, "every(.*)")
				if tick_rate then tick_rate = strmatch(tick_rate, "%s+(%S+)") else tick_rate = nil end
				if tick_rate then tick_rate = tonumber(tick_rate) end
				if tick_rate then
					local _,_,_,_,_,ends = UnitDebuff(unit, i)
					if ends then
						local last_tick = ends
						local ticks_remain, excess = new_floor( (last_tick - GetTime()) / tick_rate )
						local ticks = {}
						for i=last_tick-(ticks_remain * tick_rate),last_tick,tick_rate do
							local tick = i - GetTime()
							if tick > 0 then
								table.insert(ticks,tick)
							end
						end
						table.sort(ticks, function(x,y) return x < y end)
						local next_tick = ticks[1]
						return last_tick, next_tick, ticks
					end
				end
			else
				return true
			end
		end
	end

end

function unit_has_klepto(unit)
	if (select(2,UnitClass(unit)) ~= "MAGE") then return false end
	if (squid_klepto_tracker[unit] == nil) then return true end

	if (squid_klepto_tracker[unit]["running_klepto"] == false) then
		return false
	elseif (GetTime() - squid_klepto_tracker[unit]["last_cast"] < 27) then
		return false
	else
		return true
	end
end

local function LockoutDuration(spell)
	if spell == "Disrupt" then
		return 3
	elseif spell == "Pummel" then
		return 4
	elseif spell == "Rebuke" then
		return 4
	elseif spell == "Counter Shot" then
		return 3
	elseif spell == "Kick" then
		return 5
	elseif spell == "Mind Freeze" then
		return 4
	elseif spell == "Wind Shear" then
		return 3
	elseif spell == "Optical Blast" then
		return 6
	elseif spell == "Spell Lock" then
		return 6
	elseif spell == "Shadow Lock" then
		return 6
	elseif spell == "Counterspell" then
		return 6
	elseif spell == "Spear Hand Strike" then
		return 4
	elseif spell == "Skull Bash" then
		return 4
	elseif spell == "Solar Beam" then
		return 5
	elseif spell == "Muzzle" then
		return 3
	end
	return 4
end

local chan_delay = math.random(1,3)
function SetMinDelay()
	SQUID.min_mindelay = SQUID.min_mindelay or 155
	SQUID.max_mindelay = SQUID.max_mindelay or 325
	if not minDelayTime then -- init mindelay
		minDelayTime = ((math.random(SQUID.min_mindelay,SQUID.max_mindelay))/1000);
	end
	C_Timer.After(5,function()
		minDelayTime = ((math.random(SQUID.min_mindelay,SQUID.max_mindelay))/1000);
		chan_delay = math.random(1,3)
		mindelayrepeater()
	end)
	SQUID.max_juke_attempts = SQUID.max_juke_attempts or 2
	SQUID.min_jukedelay = SQUID.min_jukedelay or 1
	SQUID.max_jukedelay = SQUID.max_jukedelay or 60
end
function mindelayrepeater()
	SetMinDelay()
end

SetMinDelay()

local function set_net_delay()
	local delay_min = 0
	local delay_max = 100
	if not SQUID.extra_net_delay then
		SQUID.extra_net_delay = math.random(delay_min, delay_max) / 1000
	else
		C_Timer.After(4,function()
			SQUID.extra_net_delay = math.random(delay_min, delay_max) / 1000
			set_net_delay()
		end)
	end
end

function GetNetCorruption()
	local c, r = GetCorruption(), GetCorruptionResistance()
	return max (0, c - r)
end

--Track Attempted Jukes (Self Interrupted Spells)
jukeList = {}
function OnJuke(self,event,...)
	
	if not ObjectPointer then return end

	local sourceName = select(1,...);
	local spellName = select(2,...);
	local sourceGUID = select(4,...)
	local spellID = select(5,...);
		
    local sourcePointer = ObjectPointer (sourceName);

    local time = GetTime()

    if sourcePointer then
  		if not jukeList[sourcePointer] or not jukeList[sourcePointer]["Jukes"] then
	        jukeList[sourcePointer] = {};
	        jukeList[sourcePointer]["Jukes"] = 1;
	        jukeList[sourcePointer]["MaxJukes"] = math.random(2,5);
	        jukeList[sourcePointer]["Reset"] = time+1.4;
	        return
      	end
      	if jukeList[sourcePointer] then
			if not jukeList[sourcePointer]["Fired"] or GetTime()-jukeList[sourcePointer]["Fired"] > .5 then
				jukeList[sourcePointer]["Jukes"] = jukeList[sourcePointer]["Jukes"] + 1;
				jukeList[sourcePointer]["Reset"] = time+1.4;
				jukeList[sourcePointer]["Fired"] = time;
			end
		end
    end

end

JukeFrame = CreateFrame("Frame");
JukeFrame:RegisterEvent("UNIT_SPELLCAST_STOP");
JukeFrame:SetScript("OnEvent",OnJuke);

local function get_unit_buffs(unit)
    local Buffs = {}
    for i = 1, 40 do
      	local Infos = { UnitBuff(unit, i) }
      	if not Infos[10] then 
      		break 
      	end
      	Buffs[i] = Infos
    end
    return unpack(Buffs)
end

local function get_unit_debuffs(unit)
    local Buffs = {}
	for i = 1, 40 do
      	local Infos = { UnitDebuff(unit, i) }
		if not Infos[10] then 
			break
		end
  		Buffs[i] = Infos
    end
    return unpack(Buffs)
end

function find_aura(unit,spellid,filter)
	
	local unpack = unpack
	local spellname = type(spellid) ~= "number" and spellid or " "

	if filter == "HARMFUL" then
		local cache = unit_debuff_cache[unit]
		if not cache then
			unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
			cache = unit_debuff_cache[unit]
			for i=1,#cache do
				if cache[i][10] == spellid or cache[i][1] == spellname then
					return cache[i]
				end
			end
		else
			for i=1,#cache do
				if cache[i][10] == spellid or cache[i][1] == spellname then
					return cache[i]
				end
			end
		end
	end

	if filter == "HELPFUL" then
		local cache = unit_buff_cache[unit]
		if not cache then
			unit_buff_cache[unit] = {get_unit_buffs(unit)}
			cache = unit_buff_cache[unit]
			for i=1,#cache do
				if cache[i][10] == spellid or cache[i][1] == spellname then
					return cache[i]
				end
			end
		else
			for i=1,#cache do
				if cache[i][10] == spellid or cache[i][1] == spellname then
					return cache[i]
				end
			end
		end
	end

end

function UnitBuffID(unit, spellID, source)
	if not unit then return end
    local spellName = type(spellID) == "number" and GetSpellInfo(spellID) or spellID
    local buff = find_aura(unit, spellID, "HELPFUL")
    local buffsource = buff and buff[7]
    if buff and buff[1] == spellName and (not source or unit_is_unit(source,buffsource)) then
        return unpack(buff)
    end
end

function UnitDebuffID(unit, spellID, source)
	if not unit then return end
    local spellName = type(spellID) == "number" and GetSpellInfo(spellID) or spellID
    local debuff = find_aura(unit, spellID, "HARMFUL")
    local debuffsource = debuff and debuff[7]
    if debuff and debuff[1] == spellName and (not source or unit_is_unit(source,debuffsource)) then
        return unpack(debuff)
    end
end

function _debuffStacks(...)
	local debuff = select(3,UnitDebuffID(...));
	return debuff or 0;
end

function _buffStacks(...)
	local buff = select(3,UnitBuffID(...));
	return buff or 0;
end

function _debuffRemains(unit,spellid,source)
	local debuff,_,_,_,_,t = UnitDebuffID(unit,spellid,source)
	if debuff then
		local remain = t - GetTime()
		if remain > 0 then
			return remain
		else
			return -1
		end
	end
	return 0
end

function _buffRemains(unit,spellid,source)
	local buff,_,_,_,_,t = UnitBuffID(unit,spellid,source)
	if buff then
		local remain = t - GetTime()
		if remain > 0 then
			return remain
		else
			return -1
		end
	end
	return 0
end

function _buffUptime(unit,spellid,time)
	local duration,expiration = select(5,UnitBuffID(unit,spellid))
	if duration and expiration then
		if time then
			if time == 0 or expiration-GetTime() < duration-time then
				return true;
			end
		else
			return duration-(expiration-GetTime());
		end
	end
	return 0;
end

function _debuffUptime(unit,spellid,time)
	local duration,expiration = select(5,UnitDebuffID(unit,spellid))
	if duration and expiration then
		if time then
			if time == 0 or expiration-GetTime() < duration-time then
				return true;
			end
		else
			return duration-(expiration-GetTime());
		end
	end
	return 0;
end


function _realDistance(unit,unit2)

	if not unit then return 9999 end

	if not unit2 then
		
		unit2 = "player"

		if distance_cache[unit] then 
			return distance_cache[unit]
		end

		local dist = GetDistanceBetweenObjects(unit,unit2)

		distance_cache[unit] = dist

		return dist

	elseif unit_is_unit("player",unit) then

		if distance_cache[unit2] then 
			return distance_cache[unit2]
		end

		local dist = GetDistanceBetweenObjects(unit,unit2)

		distance_cache[unit2] = dist

		return dist

	else

		return GetDistanceBetweenObjects(unit,unit2)

	end

end

distance_cache = {}

function _distance(unit,unit2)

	if not unit then return 9999 end

	if not unit2 then

		unit2 = "player"

		if distance_cache[unit] then 
			return distance_cache[unit]-UnitCombatReach(unit2)-UnitCombatReach(unit) 
		end

		local dist = GetDistanceBetweenObjects(unit,unit2)

		distance_cache[unit] = dist

		return dist-UnitCombatReach(unit2)-UnitCombatReach(unit)

	elseif unit_is_unit("player",unit) then

		if distance_cache[unit2] then 
			return distance_cache[unit2]-UnitCombatReach(unit2)-UnitCombatReach(unit) 
		end

		local dist = GetDistanceBetweenObjects(unit,unit2)

		distance_cache[unit2] = dist

		return dist-UnitCombatReach(unit2)-UnitCombatReach(unit)

	else

		return GetDistanceBetweenObjects(unit,unit2)-UnitCombatReach(unit2)-UnitCombatReach(unit)

	end

end
	
function _meleeRange(unit,otherUnit)
	otherUnit = otherUnit or "player";
	if not unit or not otherUnit then return false end
	if not IsPlayerSpell(197488) then
		return _realDistance(otherUnit,unit) <= (math.max(UnitCombatReach(otherUnit) + UnitCombatReach(unit) + 4 / 3 + ((_isMoving(otherUnit) and _isMoving(unit)) and 8 / 3 or .5), 5)) + 1;
	else
		return _realDistance(otherUnit,unit) <= (math.max(UnitCombatReach(otherUnit) + UnitCombatReach(unit) + 4 / 3 + ((_isMoving(otherUnit) and _isMoving(unit)) and 8 / 3 or .5), 5)) + 4;
	end
end

function _distanceToCoord(sx,sy,sz,tx,ty,tz)
	if not tx then
		tx,ty,tz = GetPlayerPosition()
	end
	return math.sqrt(((tx-sx)^2)+((ty-sy)^2)+((tz-sz)^2));
end

function _kickTravelTime(unit)
	local traveltime = 0

	if InterruptID == 147362 then
		traveltime = _distance(unit)*.009;
	end
	if InterruptID == 106839 then
		traveltime = .05 + (_distance(unit)*.0085);
	end
	if InterruptID == 1766 and not _meleeRange(unit) then
		traveltime = .375 + squid_avg_latency + 1/GetFramerate()
	end

	if InterruptID == 2139 and not _LoS(unit) then
		traveltime = squid_avg_latency + squid_avg_home_latency + .1
	end

	return traveltime;
end

function _castTime(spellid)
	
	if spellid=="Summon Terrorguard" and not UnitBuffID("player",74434) then return 4.5; end

	if not spellid or not GetSpellInfo(spellid) then return nil; end

	if IsPlayerSpell(60103) or IsPlayerSpell(61882) then if UnitPower("player") >= 20 then return 0; end end

	return select(4, GetSpellInfo(spellid)) / 1000

end

--start end ..  cast = 4,5 channel = 4,5
function _castTimeComplete(unit,total)
	if total then 
		if unit_casting_info(unit) then
			local spellName, _, _, castStartTime, castEndTime, _, _, notInterruptible = unit_casting_info(unit)
			local realCastEndTime = castEndTime/1000
			local realCastStartTime = castStartTime/1000
			local totalCastTime = realCastEndTime - realCastStartTime
			return totalCastTime
		end
		if UnitChannelInfo(unit) then
			local spellName, _, _, channelStartTime, channelEndTime, _, _, notInterruptible = UnitChannelInfo(unit)
			local realChannelEndTime = channelEndTime/1000
			local realChannelStartTime = channelStartTime/1000
			local totalChannelTime = realChannelEndTime - realChannelStartTime
			return totalChannelTime
		end
		return 0;
	else
		if unit_casting_info(unit) then
			local spellName, _, _, castStartTime, castEndTime, _, _, notInterruptible = unit_casting_info(unit)
			local realCastEndTime = castEndTime/1000
			local realCastStartTime = castStartTime/1000
			local castTimeCompleted = GetTime()-realCastStartTime
			return castTimeCompleted
		end
		if UnitChannelInfo(unit) then
			local spellName, _, _, channelStartTime, channelEndTime, _, _, notInterruptible = UnitChannelInfo(unit)
			local realChannelEndTime = channelEndTime/1000
			local realChannelStartTime = channelStartTime/1000
			local channelTimeCompleted = GetTime()-realChannelStartTime
			return channelTimeCompleted
		end
		return 0;
	end
end

function _totalCastTime(unit)
	if unit_casting_info(unit) then
		local spellName, _, _, castStartTime, castEndTime, _, _, notInterruptible = unit_casting_info(unit)
		local realCastEndTime = castEndTime/1000
		local realCastStartTime = castStartTime/1000
		local totalCastTime = realCastEndTime-realCastStartTime
		return totalCastTime
	end
	return 0;
end

function _castTimeLeft(unit)
	if unit_casting_info(unit) then
		local frame = (1/GetFramerate())*1000
		return ((select(5, unit_casting_info(unit)) - frame) - (GetTime()*1000)) / 1000
	end
	if UnitChannelInfo(unit) then
		local frame = (1/GetFramerate())*1000
		return ((select(5, UnitChannelInfo(unit)) - frame) - (GetTime()*1000)) / 1000
	end
	return 0
end

function _castPctDone(unit)
	if unit_casting_info(unit) then
		local spellName, _, _, castStartTime, castEndTime, _, _, notInterruptible = unit_casting_info(unit)
		local castPercentDone = (((GetTime() - castStartTime/1000)) / (castEndTime/1000 - castStartTime/1000) ) * 100
		return castPercentDone
	end
	if UnitChannelInfo(unit) then
		local spellName, _, _, channelStartTime, channelEndTime, _, _, notInterruptible = UnitChannelInfo(unit)
		local channelPercentDone = (((GetTime() - channelStartTime/1000)) / (channelEndTime/1000 - channelStartTime/1000) ) * 100
		return channelPercentDone
	end
	return 0;
end

function _getMovingDirection(unit)
	
	local R = ObjectFacing(unit);
	
	local mod = 0;

	local flags = UnitMovementFlags(unit)

	if not flags then return false 
	else flags = bit.band(flags, 0xF) end

	if flags == 0x2 then
		mod = math.pi;
	elseif flags == 0x4 then
		mod = math.pi * 0.5;
	elseif flags == 0x8 then
		mod = math.pi * 1.5;
	elseif flags == bit.bor(0x1, 0x4) then
		mod = math.pi * (1 / 8) * 2;
	elseif flags == bit.bor(0x1, 0x8) then
		mod = math.pi * (7 / 8) * 2;
	elseif flags == bit.bor(0x2, 0x4) then
		mod = math.pi * (3 / 8) * 2;
	elseif flags == bit.bor(0x2, 0x8) then
		mod = math.pi * (5 / 8) * 2;
	end

	return (R + mod) % (math.pi * 2);
end
GetMovingDirection = _getMovingDirection

moving_towards_table = {}

function _movingTowards(unit,amount,otherUnit,general,nostrafe)
	if not unit then return false end
	if not otherUnit then otherUnit="player" end
	local amount = amount or .102
	local X,Y,Z = ObjectPosition(unit);
	local pX,pY,pZ = ObjectPosition(otherUnit);
	local direction = _getMovingDirection(otherUnit);
	local distance = GetUnitSpeed(otherUnit)*amount
	if UnitIsVisible(unit) then
		local yes = _distanceToCoord(pX + distance * math.cos(direction), pY + distance * math.sin(direction), pZ, X, Y, Z)+(GetUnitSpeed(otherUnit)/10) < _distanceToCoord(pX,pY,pZ,X,Y,Z);
		local flags = {
		1,
		5,
		9,
		8,
		4,
		}
		local playerflags = UnitMovementFlags("player") 
		if yes and (not nostrafe or playerflags == 1 or playerflags == 5 or playerflags == 9) and (general or tContains(flags,playerflags)) then
			for i=1,#moving_towards_table do
				local m = moving_towards_table[i]
				if m then
					if m.unit == unit and m.amount == amount and m.otherUnit == otherUnit and m.general == general then
						return true
					end
				end
			end
			table.insert(moving_towards_table,{unit=unit,amount=amount,otherUnit=otherUnit,general=general,time=GetTime()})
			return true
		else
			for i=1,#moving_towards_table do
				local m = moving_towards_table[i]
				if m then
					if m.unit == unit and m.amount == amount and m.otherUnit == otherUnit and m.general == general then
						table.remove(moving_towards_table,i)
					end
				end
			end
		end
	end
end

function moving_towards_unit_duration(unit,amount,otherUnit,general,directly,nostrafe)
	if not otherUnit then otherUnit="player" end
	local amount = amount or .102
	for i=1,#moving_towards_table do
		local m = moving_towards_table[i]
		if m.unit == unit and m.amount == amount and m.otherUnit == otherUnit and m.general == general then
			return GetTime()-m.time
		end
	end
	return 0
end

function _movingAwayFrom(unit,amount,otherUnit,general,nostrafe)
	if not otherUnit then otherUnit="player" end
	local amount = amount or .102
	local X,Y,Z = ObjectPosition(unit);
	local pX,pY,pZ = ObjectPosition(otherUnit);
	local direction = _getMovingDirection(otherUnit);
	local distance = GetUnitSpeed(otherUnit)*amount
	local yes = _distanceToCoord(pX + distance * math.cos(direction), pY + distance * math.sin(direction), pZ, X, Y, Z) > _distanceToCoord(pX,pY,pZ,X,Y,Z);
	local flags = {
	1,
	5,
	9
	}
	local playerflags = UnitMovementFlags(otherUnit) 
	if yes and (not nostrafe or playerflags == 1) and (general or tContains(flags,playerflags)) then
		return true
	end
end

function predict_distance_from_unit(unit,time)
	if not time then time = 1 end
	local px,py,pz = PredictUnitPosition("player",time)
	local x,y,z = PredictUnitPosition(unit,time)
	if px and py and pz and x and y and z then
		local d = GetDistanceBetweenPositions(px,py,pz,x,y,z)
		return d
	else
		return -1
	end
end

function moving_away_from(unit,extra)
	extra = extra or 0
	local d = _realDistance(unit)
	if d < 5.5 and _amIfacing(unit) then return false end
	if predict_distance_from_unit(unit) > d + extra then return true end
end

los_cache = {}

local los_whitelist = {
	[56754] = true, -- Azure Serpent (Shado'pan Monestary)
	[56895] = true, -- Weak Spot - Raigon (Gate of the Setting Sun)
	[76585] = true, -- Ragewing
	[77692] = true, -- Kromog
	[77182] = true, -- Oregorger
	-- 86644, 	-- Ore Crate from Oregorger boss
	[96759] = true, -- Helya
	[100360] = true, -- Grasping Tentacle (Helya fight)
	[100354] = true, -- Grasping Tentacle (Helya fight)
	[100362] = true, -- Grasping Tentacle (Helya fight)
	[98363] = true, -- Grasping Tentacle (Helya fight)
	[99803] = true, -- Destructor Tentacle (Helya fight)
	[99801] = true, -- Destructor Tentacle (Helya fight)
	[98696] = true, -- Illysanna Ravencrest (Black Rook Hold)
	[114900] = true, -- Grasping Tentacle (Trials of Valor)
	[114901] = true, -- Gripping Tentacle (Trials of Valor)
	[116195] = true, -- Bilewater Slime (Trials of Valor)
	[120436] = true, -- Fallen Avatar (Tomb of Sargeras)
	[116939] = true, -- Fallen Avatar (Tomb of Sargeras)
	[118462] = true, -- Soul Queen Dejahna (Tomb of Sargeras)
	[119072] = true, -- Desolate Host (Tomb of Sargeras)
	[118460] = true, -- Engine of Souls (Tomb of Sargeras)
	[122450] = true, -- Garothi Worldbreaker (Antorus the Burning Throne - Confirmed in game)
	[123371] = true, -- Garothi Worldbreaker (Antorus the Burning Throne)
	[122778] = true, -- Annihilator - Garothi Worldbreaker (Antorus the Burning Throne)
	[122773] = true, -- Decimator - Garothi Worldbreaker (Antorus the Burning Throne)
	[122578] = true, -- Kin'garoth (Antorus the Burning Throne - Confirmed in game)
	[125050] = true, -- Kin'garoth (Antorus the Burning Throne)
	[131863] = true, -- Raal the Gluttonous (Waycrest Manor)
	[134691] = true, -- Static-charged Dervish (Temple of Sethraliss)
	[137405] = true, -- Gripping Terror (Siege of Boralus)
	[140447] = true, -- Demolishing Terror (Siege of Boralus)
	[137119] = true, -- Taloc (Uldir1)
	[137578] = true, -- Blood shtorm (Uldir - Taloc's fight)
	[138959] = true, -- Coalesced Blood (Uldir - Taloc's fight)
	[138017] = true, -- Cudgel of Gore (Uldir - Taloc's fight)
	[130217] = true, -- Nazmani Weevil (Uldir - Taloc's fight)
	[140286] = true, -- Uldir Defensive Beam *Uldir)
	[138530] = true, -- Volatile Droplet (Uldir - Taloc's fight)
    [133392] = true, -- Sethraliss
	[146256] = true, -- Laminaria
	[150773] = true, -- Blackwater Behemoth Mob
	[152364] = true, -- Radiance of Azshara
	[152671] = true, -- Wekemara
	[157602] = true, -- Drest'agath - Ny'alotha
	[158343] = true, -- Organ of Corruption - Ny'alotha
	[157486] = true, -- Horrific Hemorrhage - Ny'alotha
	[158041] = true, -- N'zoth the Corruptor - Ny'alotha
	[166608] = true, -- Mueh'Zala (De'Other Side)
	[168326] = true, -- Shattered Visage (De'Other Side)
}

local index = 1

los_checked = {

}

function _LoS(unit,otherUnit,not_for_cast)
	
	if not otherUnit then otherUnit = "player"; end
	
	if UnitIsVisible(unit) then

		if los_cache[unit..otherUnit] ~= nil then return los_cache[unit..otherUnit] end
		if los_cache[otherUnit..unit] ~= nil then return los_cache[otherUnit..unit] end

		local unit_is_player = unit_is_unit("player",unit)
		local other_unit_is_player = unit_is_unit("player",otherUnit)

		if unit_is_player and other_unit_is_player then return true end

		-- if not unit_is_player and not other_unit_is_player then print(name,name2) end

		local id = ObjectID(unit)
		local id2 = ObjectID(otherUnit)

		--LoS Whitelist
		if los_whitelist[id] or los_whitelist[id2] then return true end

		local time = GetTime()

		local X1,Y1,Z1
		if unit_is_player then 
			X1,Y1,Z1 = GetPlayerPosition() 
		else
			X1,Y1,Z1 = ObjectPosition(unit)
		end

		local X2,Y2,Z2
		if other_unit_is_player then
			X2,Y2,Z2 = GetPlayerPosition() 
		else
			X2,Y2,Z2 = ObjectPosition(otherUnit)
		end

		--buffs and debuffs which affect los

		--smoke cloud
		-- local smoke_cloud_one = UnitDebuffID(unit,298602)
		-- local smoke_cloud_two = UnitDebuffID(otherUnit,298602)

		-- if smoke_cloud_one then
		-- 	return smoke_cloud_two
		-- elseif smoke_cloud_two then
		-- 	return smoke_cloud_one
		-- end

		if not not_for_cast then
			-- --smoke bomb
			local smoke_bomb_one,_,_,_,_,_,source_one = UnitDebuffID(unit,212183)
			local smoke_bomb_two,_,_,_,_,_,source_two = UnitDebuffID(otherUnit,212183)

			--check if units are within smoke bomb, unless it's friendly to the opposing unit
			if source_one then
				if not UnitIsFriend(otherUnit,source_one) then
					-- los_checked[unit] = {los=not smoke_bomb_two, time=GetTime()}
					return smoke_bomb_two
				end
			end
			if source_two then
				if not UnitIsFriend(unit,source_two) then
					-- los_checked[unit] = {los=not smoke_bomb_one, time=GetTime()}
					return smoke_bomb_one
				end
			end
		end

		local los = not TraceLine(X1,Y1,Z1+1.8,X2,Y2,Z2+1.8,losflags)

		los_cache[unit..otherUnit] = los

		-- local frame = 1/GetFramerate()
		-- los_checked[unit] = {los=los, time=GetTime()}

		return los

	end

end

-- time_in_los
function time_in_los(unit)
	
	if not unit then return 0 end

	local los = _LoS(unit)

	local thisunit
	if not los_checked[unit] then
		los_checked[unit] = {los=los, time=GetTime()}
		thisunit = los_checked[unit]
	else
		thisunit = los_checked[unit]
		if thisunit.los ~= los then
			thisunit.los = los
			thisunit.time = GetTime()
		end
	end

	if thisunit then
		return thisunit.los and GetTime() - thisunit.time or 0
	end

end

function los_coords(x,y,z,X,Y,Z)
	return not TraceLine(x,y,z+2,X,Y,Z+2, losflags);
end

hp_cache = {}

function _HP(unit)
	if hp_cache[unit] then return hp_cache[unit] end
	if not unit or not UnitIsVisible(unit) then return 100 end
	if UnitIsDeadOrGhost(unit) then return 100 end
	if UnitIsVisible(unit) and UnitExists(unit) then
		local hp = (100 * UnitHealth(unit) / UnitHealthMax(unit));
		hp_cache[unit] = hp
		return hp
	end
	return 100
end

unit_role_cache = {}

function GetUnitRole(unit)
	if unit_role_cache[unit] then return unit_role_cache[unit] end
	local unit_visible = UnitIsVisible(unit)

	if unit_visible and not unit_is_player(unit) then return "pet" end
	if unit_visible then
		if UnitGroupRolesAssigned(unit) == "HEALER" then
			unit_role_cache[unit] = "healer"
			return "healer";
		end
	end
	if arena then
		for i=1,GetNumArenaOpponents() do if unit_is_unit("arena"..i,unit) then
			local specid = GetArenaOpponentSpec(i)
			if not specid then return nil end
			if select(5,GetSpecializationInfoByID(specid)) == "HEALER" then
				unit_role_cache[unit] = "healer"
				return "healer"
			end
			if select(5,GetSpecializationInfoByID(specid)) == "DAMAGER" or select(5,GetSpecializationInfoByID(specid)) == "TANK" then
				local class = select(6,GetSpecializationInfoByID(specid))
				local spec = select(2,GetSpecializationInfoByID(specid))
				local TankSpecs = {
				"Guardian",
				"Vengeance",
				"Blood",
				"Protection",
				"Brewmaster",
				}
				local MeleeSpecs = {
				"Frost",
				"Unholy",
				"Havoc",
				"Feral",
				"Guardian",
				"Vengeance",
				"Survival",
				"Brewmaster",
				"Windwalker",
				"Protection",
				"Retribution",
				"Assassination",
				"Outlaw",
				"Subtlety",
				"Enhancement",
				"Arms",
				"Fury",
				}; -- frost dk / mage , 
				local RangedSpecs = {
				"Frost",
				"Fire",
				"Arcane",
				"Beast Mastery",
				"Marskmanship",
				"Shadow",
				"Elemental",
				"Affliction",
				"Destruction",
				"Demonology",
				"Balance",
				} -- frost dk / mage
				local HealerSpecs = {
				"Holy",
				"Restoration",
				"Mistweaver",
				"Discipline"
				}
				if tContains(TankSpecs,spec) then
					unit_role_cache[unit] = "tank"
					return "tank"
				end
				if tContains(MeleeSpecs,spec) then
					if spec ~= "Frost" or class ~= "MAGE" then
						unit_role_cache[unit] = "melee"
						return "melee"
					end
				end
				if tContains(RangedSpecs,spec) then
					if spec ~= "Frost" or class ~= "DEATHKNIGHT" then
						unit_role_cache[unit] = "ranged"
						return "ranged"
					end
				end
				if tContains(HealerSpecs,spec) then
					unit_role_cache[unit] = "healer"
					return "healer"
				end
			end
		end end
	end
	local class = select(2,UnitClass(unit));
	if class  == "DRUID" and (UnitPower(unit,8) > 0 or UnitBuffID(unit,24858)) then unit_role_cache[unit] = "ranged" return "ranged"; end
	if class == "DRUID" and UnitPowerMax(unit,0) <= 20000 then unit_role_cache[unit] = "melee" return "melee"; end
	if class == "SHAMAN" and UnitPowerMax(unit,0) <= 20000 then unit_role_cache[unit] = "melee" return "melee"; end
	if class == "DEATHKNIGHT" then return "melee"; end
	if class == "MONK" and UnitPowerMax(unit) < 1000 then unit_role_cache[unit] = "melee" return "melee"; end
	if class == "ROGUE" then unit_role_cache[unit] = "melee" return "melee"; end
	if class == "WARRIOR" then unit_role_cache[unit] = "melee" return "melee"; end
	if class == "PALADIN" and UnitPowerMax(unit,0) <= 20000 then unit_role_cache[unit] = "melee" return "melee"; end
	if class == "DEMONHUNTER" then unit_role_cache[unit] = "melee" return "melee"; end
	if class == "MAGE" then unit_role_cache[unit] = "ranged" return "ranged"; end
	if class == "HUNTER" then unit_role_cache[unit] = "melee" return "melee"; end

	if class == "PALADIN" and UnitPowerMax(unit,0) >= 100000 then unit_role_cache[unit] = "healer" return "healer"; end
	
	if class == "PRIEST" then 
		if UnitPower(unit,13) > 0 or UnitBuffID(unit,232698) then
			unit_role_cache[unit] = "ranged"
			return "ranged"
		else
			--don't cache priests as healers
			return "healer"
		end
	end

	--boomy fallthru
	if class == "DRUID" then unit_role_cache[unit] = "ranged" return "ranged"; end

end

function arena_unit_tag(unit)
	for i=1,GetNumArenaOpponents() do
		if unit_is_unit(unit, "arena"..i) then
			return "arena"..i
		end
	end
end

function _isTank(unit)
	return GetUnitRole(unit) == "tank";
end

function _isMeleeDps(unit)
	local role = GetUnitRole(unit)
	return role == "melee" or role == "tank";
end

function _isHealer(unit)
	return GetUnitRole(unit) == "healer"-- or arena_unit_tag(unit);
end

function _isDps(unit)
	local role = GetUnitRole(unit)
	return role == "melee" or role == "ranged"
end

function _isRangedDps(unit)
	return GetUnitRole(unit) == "ranged";
end

function _spellCooldown(spellid)
	local start, duration
	if spellid == 2061 then
		start, duration = GetSpellCooldown(605)
	elseif spellid == 1784 then
		start, duration = GetSpellCooldown(IsPlayerSpell(108208) and 115191 or 1784)
	else
		start, duration = GetSpellCooldown(spellid)
	end
	local time = GetTime()
	if not start then return 0 end
	if duration + (start - time) > 0 then
		return duration + (start - time)
	else
		return 0
	end
end

function _spellChargeFrac(spellid)
	if GetTime() - select(3,GetSpellCharges(spellid)) > 0 then
		return GetSpellCharges(spellid) + ((GetTime() - select(3,GetSpellCharges(spellid)))/select(4,GetSpellCharges(spellid)));
	else
		return GetSpellCharges(spellid);
	end
end

function _getRecharge(spellID,chargeMax)
	local charges,maxCharges,chargeStart,chargeDuration = GetSpellCharges(spellID)
	if chargeMax then return chargeDuration end
	if charges then
		if charges < maxCharges then
			local chargeEnd = chargeStart + chargeDuration
			return chargeEnd - GetTime()
		end
		return 0
	end
end

function _getFullRechargeTime(spellID)
    local charges,maxCharges,chargeStart,chargeDuration = GetSpellCharges(spellID)
    if charges then
        local currentChargeTime = (charges or 0) < (maxCharges or 0) and chargeDuration - (GetTime() - (chargeStart or 0)) or 0
        local leftChargesTotalTime = (maxCharges - charges - 1) * chargeDuration
        if charges ~= maxCharges then
            return currentChargeTime + leftChargesTotalTime
        end
    end
    return 0
end

function _buffFromTable(unit,t,remains,returnid)
	if remains then
		local cc = {0};
		if returnid then
			cc={{id=0,r=0}};
		else
			cc={0};
		end
		local time = GetTime()
		if not unit_buff_cache[unit] then
			unit_buff_cache[unit] = {get_unit_buffs(unit)}
			local cache = unit_buff_cache[unit]
			for i=1,#cache do
				for n=1,#t do
					local id = t[n]
					if cache[i][10] == id then
						local end_time = cache[i][6]
						local r = end_time - time
						if r > 0 or end_time == 0 then
							if returnid then
								if end_time == 0 then
									table.insert(cc,{id=id,r=999})
								else
									table.insert(cc,{id=id,r=r})
								end
							else
								if end_time == 0 then
									table.insert(cc,999)
								else
									table.insert(cc,r)
								end
							end
						end
					end
				end
			end
		else
			local cache = unit_buff_cache[unit]
			for i=1,#cache do
				for n=1,#t do
					local id = t[n]
					if cache[i][10] == id then
						local end_time = cache[i][6]
						local r = end_time - time
						if r > 0 or end_time == 0 then
							if returnid then
								if end_time == 0 then
									table.insert(cc,{id=id,r=999})
								else
									table.insert(cc,{id=id,r=r})
								end
							else
								if end_time == 0 then
									table.insert(cc,999)
								else
									table.insert(cc,r)
								end
							end
						end
					end
				end
			end
		end
		return cc;
	else
		if not unit_buff_cache[unit] then
			unit_buff_cache[unit] = {get_unit_buffs(unit)}
			local cache = unit_buff_cache[unit]
			for i=1,#cache do
				for n=1,#t do
					local id = t[n]
					if cache[i][10] == id then
						return true,id
					end
				end
			end
		else
			local cache = unit_buff_cache[unit]
			for i=1,#cache do
				for n=1,#t do
					local id = t[n]
					if cache[i][10] == id then
						return true,id
					end
				end
			end
		end
	end
end


function _debuffFromTable(unit,t,remains,returnid)
	if remains then

		local cc = {};

		if returnid then
			cc={{id=0,r=0}};
		else
			cc={0};
		end

		local time = GetTime()

		local cache = unit_debuff_cache[unit]
		if not cache then
			unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
			cache = unit_debuff_cache[unit]
			for i=1,#cache do
				for n=1,#t do
					local id = t[n]
					if cache[i][10] == id then
						local end_time = cache[i][6]
						local r = end_time - time
						if r > 0 then
							if returnid then
								table.insert(cc,{id=id,r=r})
							else
								table.insert(cc,r)
							end
						end
					end
				end
			end
		else
			for i=1,#cache do
				for n=1,#t do
					local id = t[n]
					if cache[i][10] == id then
						local end_time = cache[i][6]
						local r = end_time - time
						if r > 0 then
							if returnid then
								table.insert(cc,{id=id,r=r})
							else
								table.insert(cc,r)
							end
						end
					end
				end
			end
		end

		return cc

	else
		if not unit_debuff_cache[unit] then
			unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
			local cache = unit_debuff_cache[unit]
			for i=1,#cache do
				for n=1,#t do
					local id = t[n]
					if cache[i][10] == id then
						return true,id
					end
				end
			end
		else
			local cache = unit_debuff_cache[unit]
			for i=1,#cache do
				for n=1,#t do
					local id = t[n]
					if cache[i][10] == id then
						return true,id
					end
				end
			end
		end
	end
end

local ccIDs = {
--[[ SILENCES ]]--

--------------------
--[[ DISORIENTS ]]--
--------------------
-- Druid
99, -- Disorienting Roar (talent)
2637,	-- Hibernate
-- Hunter
3355, -- Freezing Trap
19386, -- Wyvern Sting
-- Mage
28272,		-- Pig
118,		-- Sheep
277792,		-- Bee
161354,		-- Monkey
277787,		-- Direhorn
161355,		-- Penguin
161353,		-- Polar Bear
120140,		-- Porcupine
61305,		-- Cat
61721,		-- Rabbit
61780,		-- Turkey
28271,		-- Turtle
82691,		-- Ring of Frost
31661,		-- Dragon's Breath
-- Monk
115078, -- Paralysis
198909,	-- Song of Chi Ji
-- Paladin
105421, -- Blinding Light
20066, -- Repentance
-- Priest
9484, -- Shackle Undead
-- Rogue
1776, -- Gouge
6770, -- Sap
-- Shaman
51514,  -- Hex
-- Pandaren
107079, -- Quaking Palm
--------------
--[[ FEAR ]]--
--------------
-- Hunter
-- Paladin
10326, -- Turn Evil
-- Priest
8122, -- Psychic Scream
-- Rogue
2094, -- Blind
-- Warlock
118699, -- Fear -- new SpellID in MoP, Blood Fear uses same ID
5484, -- Howl of Terror
6358, -- Seduction (Succubus)
115268, -- Mesmerize (Shivarra) -- FIXME: verify this is the correct category
-- Warrior
5246, -- Intimidating Shout (main target)
-----------------------
--[[ CONTROL STUNS ]]--
-----------------------
-- Death Knight
108194, -- Asphyxiate (talent)
91800, -- Gnaw (Ghoul)
91797, -- Monstrous Blow (Dark Transformation Ghoul)
-- Druid
22570, -- Maim
203123,	-- Maim

5211, -- Mighty Bash (talent)
113801, -- Bash (treants in feral spec) (Bugged by blizzard - it instantly applies all 3 levels of DR right now, making any target instantly immune to ctrlstuns)
-- 163505, --rake stun
-- Hunter
24394, -- Intimidation
50519, -- Sonic Blast (Bat)
-- Mage
44572, -- Deep Freeze
157997, -- New ice nova
-- Monk
119392, -- Charging Ox Wave (talent)
119381, -- Leg Sweep (talent)
120086, -- Fists of Fury (Windwalker)
-- Paladin
853, -- Hammer of Justice
119072, -- Holy Wrath (Protection)
105593, -- Fist of Justice (talent)
10326,  -- Turn evil
-- Rogue
1833, -- Cheap Shot
408, -- Kidney Shot
199804, -- Between the eyes
-- Shaman
118905, -- Static Charge (Capacitor Totem)
-- Warlock
30283, -- Shadowfury
89766, -- Axe Toss (Felguard)
22703, -- Infernal Awakening (Infernal)
-- Warrior
132168, -- Shockwave
107570,	--Storm Bolt
132169,	-- Storm Bolt (New SpellID)
-- Demon Hunter
179057, -- Chaos Nova
191427, -- Metamorphosis (Might not be a thing any more.)
211881, -- Fel Eruption
217832,	-- Imprison
221527,	-- Imprison (detainment)
-- Tauren
20549, -- War Stomp
----------------
--[[ HORROR ]]--
----------------
--- Priest
64044, -- Psychic Horror (Stun)

-- Warlock
6789, -- Mortal Coil
--------------
--[[ MISC ]]--
--------------
-- Druid
33786,  --Cyclone
-- Hunter
-- Mage
31661,  --Dragon's Breath
-- Priest
605,	--MC
-- Shaman
-- Warlock
710,    --Banish
-- Warrior
105771, -- Warbringer (talent)
7922	--Charge
}

local bigDmg = 
{
210714,	--Icefury
214634,	--Ebonbolt
116858,	--Chaos Bolt
203286, --Greater Pyroblast
}

local csOnlyChannel =
{
293491, --Cyclotronic Blast
299336, --Focused Azerite Beam
305483,	--Lightning Lasso
-- 198013,	--Eye Beam
}

local mageCS =
{
	28272,		-- Pig
	118,		-- Sheep
	61305,		-- Cat
	61721,		-- Rabbit
	61780,		-- Turkey
	28271,		-- Turtle
	82691,		-- Ring of Frost
	-- 102051,		-- Frostjaw
	
}

local csHeals = {
	740,            -- Tranquility
	8936,           -- Regrowth
	48438,          -- Wild Growth
	33786,          -- Cyclone
	5185,           -- Healing Touch
	5176,           -- Wrath--
	82326,          -- Holy Light
	19750,          -- Flash of Light
	82326,          -- Holy Light
	85222,          -- Light of Dawn
	2061,           -- Flash Heal
	32546,          -- Binding Heal
	2060,           -- Greater Heal
	47540,          -- Penanace --Never kick penance.
	64843,          -- Divine Hymn
	8004,           -- Healing Surge
	77472,          -- Healing Wave
	51514,          -- Hex
	116670,         -- Uplift(monk)
	116694,         -- Effuse
	-- 123273,         -- Surging Mist
	-- 85673,          -- Word of Glory
	114163,         -- Eternal Flame
	33076,          -- Prayer of Mending
	152118,         -- Clarity of will
	-- 152116,         -- Saving Grace
	186263,			-- Shadow Mend
	124682,			-- Enveloping Mist
	115175,			-- Soothing Mist
	32375,			-- Mass Dispel
	47540,
	186263,
	1064,			-- Chain Heal
	214621,			-- Schism
	-- 585,			-- Smite
	289666,			-- Greater Heal
	-- 2061,			-- Flash heal
	-- 33786,			-- Cyclone
	198909,			-- Song of Chi Ji
	289022,			-- Nourish
}
local csAlways = {
	--111771,     -- Demonic Gateway
	--Resurrections--
	2006,
	7328,
	2008,
	50769,
	115310,
	982,    -- revive pet
	203286, -- greater pyroblast
	-- 209789,	-- freezing arrow
	202771,	-- full moon
	-- 211714, -- thal'kiel's consumption
	199786, -- glacial spike
	116858,	-- chaos bolt
	-- 210726,	-- mark of aluneth . . . 
	323764,	-- convoke the spirits
	323673,	-- mindgames
}

local csCCdisorient = {
	--Druid--
	33786,	-- Cyclone

	--Warlock--
	5782,		-- Fear
	118699,		-- Fear
	205367,		-- Dominate Mind

	--Priest--
	605,		-- Mind Control
}

local csCCincapacitate = {
	--Mage--
	28272,		-- Pig
	118,		-- Sheep
	61305,		-- Cat
	61721,		-- Rabbit
	61780,		-- Turkey
	28271,		-- Turtle
	82691,		-- Ring of Frost
	
	--Shaman--
	51514,		-- Hex

	--Paladin
	20066,		-- Repentance

	--Druid--
	2637,		-- Hibernate
}

local csCCPolymorphs = {
	--Mage--
	28272,		-- Pig
	118,		-- Sheep
	277792,		-- Bee
	161354,		-- Monkey
	277787,		-- Direhorn
	161355,		-- Penguin
	161353,		-- Polar Bear
	120140,		-- Porcupine
	61305,		-- Cat
	61721,		-- Rabbit
	61780,		-- Turkey
	28271,		-- Turtle
	82691,		-- Ring of Frost
}


local csCCsilence = {
	-- 102051,		-- Frostjaw
}

local castedDMG	= {
	202771,		-- Full Moon
	203286,		-- Greater Pyroblast
	116858,		-- Chaos Bolt
	-- 157695,   	-- Demon bolt
	199786,		-- Glacial Spike
	214634,		-- Ebonbolt
	-- 19434,		-- Aimed Shot
	--324536,	    -- Malefic Rapture -- This CANNOT be reflected
	323673, 	--Mindgames
}

local csWarlock = {
	30108,    -- UA
	48181,    -- Haunt
	5782,	  -- Fear	
	116858,   -- chaos bolt
	157695,   -- Demon bolt
	198590,	  -- Drain Soul
	193396,	  -- Demonic Empowerment
	324536,	  -- Malefic Rapture
}

local csMageDamage = {
	82691,		-- Ring of Frost
	116,		-- Frostbolt
	44614,		-- Flurry
	199786,		-- Glacial Spike
}

local csArcaneDamage = {
	30451,		-- arcane blast
	5143,		-- arcane missiles
	307443,		-- radiant spark
}

local csList = {
	740,		--Tranquility
	8936,		--Regrowth
	82326,		-- Divine Light
	19750,		-- Flash of Light
	2061,		-- Flash Heal
	32546,		-- Binding Heal
	2060,		-- Greater Heal
	47540,		-- Penanace
	64843,		-- Divine Hymn
	8004,		-- Healing Surge
	77472,		-- Greater Healing Wave
	33786,		--Cyclone

	--Paladin--
	-- 10326,		-- Turn evil
	20066,		-- Repentance
	-- 115750,		-- Blinding Light

	--Priest--
	605,		-- Mind Control
	32375,		-- Mass Dispel

	--Shaman--
	--51514,		-- Hex

	--Warlock--
	5782,		-- Fear
	118699,		-- Fear
	111771,     -- Demonic Gateway
	116858,     -- chaos bolt

	--Resurrections--
	2006,
	7328,
	2008,
	50769,
	115310
}

function _CCcheck(unit)
	if not UnitIsVisible(unit) then return false; end
	local debuffs = _debuffFromTable(unit,ccIDs,true,true);
	if debuffs then
		table.sort(debuffs,function(x,y) return x.r > y.r end);
	end
 	if #debuffs > 0 then
 		return debuffs[1].id ~= 0 and debuffs[1].id or nil;
 	end
end

function player_has_control()
	return not (_CCcheck("player") or not HasFullControl())
end

cc_remains_cache = {}

function _CCremains(unit,clone)

	if not UnitIsVisible(unit) then return 0; end

	if cc_remains_cache[unit] then return cc_remains_cache[unit] end

	local cconunit={};
	local debuffs = _debuffFromTable(unit,ccIDs,true);

	if clone then
		local cloneRemains = _debuffRemains(33786,unit);
		table.insert(debuffs,cloneRemains);
	end

	-- local silenced = ((_isCasterDps(unit) or _isHealer(unit)) and _silenceRemains(unit)) or 0;
	-- if silenced > 0 then
	-- 	table.insert(debuffs,silence);
	-- end

	local rake = _rakeStunRemains(unit)

	if rake > 0 then
		table.insert(debuffs,rake)
	end

	table.sort(debuffs,function(x,y) return x > y end);

	local ccr = debuffs[1]
	if ccr == math.huge then ccr = 0 end
	if not ccr then ccr = 0 end

	cc_remains_cache[unit] = ccr

	return ccr

end

--trapCCremains
local trapcc ={
-----------------------
--[[ CONTROL STUNS ]]--
-----------------------
--Death Knight
108194, -- Asphyxiate (talent)
91800, -- Gnaw (Ghoul)
91797, -- Monstrous Blow (Dark Transformation Ghoul)
--Druid
22570, -- Maim
5211, -- Mighty Bash (talent)
2637,	-- Hibernate
--Hunter
24394, -- Intimidation
50519, -- Sonic Blast (Bat)
117526, -- Binding Shot (talent)
213619,	-- Scatter Shot 

--Mage
44572, -- Deep Freeze
157997, -- New ice nova
102051, -- Frostjaw
--Monk
119392, -- Charging Ox Wave (talent)
119381, -- Leg Sweep (talent)
120086, -- Fists of Fury (Windwalker)
--Paladin
853, -- Hammer of Justice
119072, -- Holy Wrath (Protection)
105593, -- Fist of Justice (talent)
--Rogue
1833, -- Cheap Shot
408,  -- Kidney Shot
199804, -- Between the eyes
2094, -- Blind
1776,  -- Gouge
6770,  -- Sap
--Shaman
118905, -- Static Charge (Capacitor Totem)
118345, -- Pulverize (primal earth elemental)
--Warlock
30283, -- Shadowfury
89766, -- Axe Toss (Felguard)
22703, -- Infernal Awakening (Infernal)
--Warrior
132168,	--shockwave
132169, --stormbolt
5246,	--intimidating shout
-- Demon Hunter
179057, -- Chaos Nova
191427, -- Metamorphosis (Might not be a thing any more.)
211881, -- Fel Eruption
-- Tauren
20549, -- War Stomp
-- other
19386, --wyvern
3355, --Trap
64803,	--snakes
224729,	--Bursting Shot
238559,	--Bursting Shot (new?)
105421, -- Blinding Light
198909,	-- Song of Chi Ji
}
function trap_cc_remains(unit)
	if not UnitIsVisible(unit) then return 0; end
	if not UnitDebuffID(unit,5246) or not _isMoving(unit) then
		local cconunit={};
		local debuffs = _debuffFromTable(unit,trapcc,true);
		local rake = _rakeStunRemains(unit);
		if rake then
			table.insert(debuffs,rake)
		end
		table.sort(debuffs,function(x,y) return x>y end);
		if #debuffs > 0 then
			return debuffs[1];
		end
	end
	return 0;
end

function trap_cc(unit)
	for i=1,#trapcc do
		if UnitDebuffID(unit,trapcc[i]) and (trapcc[i] ~= 5246 or not _isMoving(unit)) then
			if _debuffRemains(unit,trapcc[i]) < 0 then
				--do nothing
			else
				return trapcc[i];
			end
		end
	end
	if _rakeStunned(unit) then
		return 1822;
	end
	return nil;
end

local magic_defensives = {
	--RoS
	53480,
	--Feint
	1966,
	--Sham Wall
	108271,
	--Lock Wall
	104773,
	--Warr Parry
	118038,
	--Survival Instincts
	61336,
	--Ironbark (maybe still just blow whole load into skin always)
	102342,
	--Barkskin
	22812,
	--Temp Shield
	198111,
	--Pris Cloak
	198065,
	--Anti-Magic Zone
	145629,
	--Icebound Fortitude
	48792,
	--Diffuse Magic (maybe add fort brew later, just such long duration hard to tell if worth holding the load)
	122783, 
	-- ultimate sac
	199448,
}

function magic_defensive_remains(unit)
	local buffs =  _buffFromTable(unit,magic_defensives,true)
	table.sort(buffs,function(x,y) return x>y end)
	if #buffs > 0 then
		return buffs[1]
	end
	return 0
end

function trap_travel_time(unit,otherunit)
	otherunit = otherunit or "player";
	if _realDistance(otherunit,unit) < 3 then return -.05 end
	return _realDistance(otherunit,unit)/14.5
end

function perfectTravelDist(unit)
	local dist = (GetUnitSpeed(unit)*trap_travel_time(unit))*.9
	return dist < 5 and dist or 5
end

function immune_trap(unit,remains)
	local no = {
	213610,	--Holy ward
	8178,	--Grounding Totem
	216890,	--Spell Reflection
	236321,	--War Banner
	213602,	--Greater Fade
	}
	--Nono Buffs
	for i=1,#no do 
		if UnitBuffID(unit,no[i]) then 
			if remains then
				return _buffRemains(unit,no[i]);
			else
				return no[i];
			end
		end 
	end
	--Immune Magic
	local immunemagic = _immuneMagic(unit,magic)
	if immunemagic ~= nil then
		if GetSpellInfo(immunemagic) ~= "Touch of Karma" then
			if remains then
				return _debuffRemains(unit,immunemagic);
			else
				return immunemagic;
			end
		end
	end
	if remains then return 0; end
	if not hunter then
		--Pally with Sac
		if select(2,UnitClass(unit)) == "PALADIN" then
			for i=1,#Enemies do if UnitBuffID(Enemies[i],6940) then 
				return 6940;
			end end
		end
	end
end

local stunImmunities = {
	227847,	-- Bladestorm
	48792,	-- Icebound
	213610,	-- Holy Ward
	188499, -- blade dance
}

function _immuneStuns(unit, cheap_shot)
	local hasbuff,buff = _buffFromTable(unit,stunImmunities)
	--Evasion / Die by the Sword / Parry / Blur / Fists--
	if (UnitBuffID(unit,5277) or UnitBuffID(unit,118038) or UnitBuffID(unit,199754) or UnitBuffID(unit,198589) or UnitChannelInfo(unit) == "Fists of Fury") and not cheap_shot then
		if not unit_is_unit("player",unit) and _isFacingMe(unit) then
			return true;
		end
	end
	return hasbuff
end

local ccImmunities = {
	227847,	-- Bladestorm
}

function _immuneCC(unit)
	local hasbuff,buff = _buffFromTable(unit,ccImmunities)
	return hasbuff
end

function cc_immunity_remains(unit)
	
	local debuffs = _debuffFromTable(unit,ccImmunities,true,true);
	local buffs = _buffFromTable(unit,ccImmunities,true,true);

	local all = debuffs
	for k,v in pairs(buffs) do table.insert(debuffs, v) end

	table.sort(all,function(x,y) return x.r > y.r end);

	return all[1].r or 0, all[1].id;

end

local immuneID			=
{
	642,	-- Divine Shield
	45438, 	--Ice Block
	19263, 	--Deterrence
	97417,	--BrittleBarrier
	33786,  --Cyclone
	186265, --Aspect of the Turtle
	221527, --Imprison
	710,	--Banish
	213602,	--Greater Fade

	-- seed?
	
}
function _immuneCheck(unit,cyclone,sac)
	
	local hasdebuff,debuff = _debuffFromTable(unit,immuneID);
	local hasbuff,buff     = _buffFromTable(unit,immuneID);

	--meta
	if _buffRemains(unit,162264) > 28 then
		return 162264
	end

	if not cyclone then
		--clone
		if UnitDebuffID(unit,33786) then
			return 33786
		end
		--imprison
		if UnitDebuffID(unit,221527) then
			return 221527
		end
	end

	if sac then
		if UnitDebuffID(unit,199448) then
			return 199448
		end
	end

	-- if cyclone and (hasbuff or hasdebuff) and (buff == 33786 or debuff == 33786) then return nil end
	return (hasdebuff and debuff) or (hasbuff and buff)

end

function immunity_remains(unit,cyclone)

	local debuffs = _debuffFromTable(unit,immuneID,true,true);
	local buffs = _buffFromTable(unit,immuneID,true,true);

	local all = debuffs
	for k,v in pairs(buffs) do table.insert(debuffs, v) end

	-- for i=1,#debuffs do
	-- 	table.insert(all,debuffs[i])
	-- end
	-- for i=1,#buffs do
	-- 	table.insert(all,buffs[i])
	-- end

	-- table.insert(all,_debuffRemains(unit,33786))
	-- table.insert(all,_debuffRemains(unit,221527))

	table.sort(all,function(x,y) return x.r > y.r end);

	return all[1].r or 0, all[1].id;

end

local immuneMagic  =
{
  642,    --Divine Shield
  45438,  --Ice Block
  31224,  --Cloak of Shadows
  19263,  --Deterrance
  97417,  --BrittleBarrier
  33786,  --Cyclone
  221527, --Imprison
  48707,  --AMS
  6990,   --Spell Reflect
  216890, --Spell Reflect (new)
  114028, --MassSpellReflect
  186265, --Aspect of the Turtle
  212295, --Nether Ward
  204018, --Spell warding
}

function _immuneMagic(unit,ignoreams)
	local fullyimmune = _immuneCheck(unit,cyclone)
	--immune in general
	if fullyimmune then return fullyimmune; end

	--mind controlled
	if UnitDebuffID(unit,605) then return 605; end

	local immunes = immuneMagic

	if ignoreams then
		for i=1,#immunes do if immunes[i] == 48707 then
			table.remove(immunes,i)
		end end
	end

	-- if not cyclone then
	-- 	--karma
	-- 	if UnitBuffID(unit,122470) 
	-- 	or UnitBuffID(unit,125174) then 
	-- 		return 122470;
	-- 	end
	-- 	--clone
	-- 	-- if UnitDebuffID(unit,33786) then
	-- 	-- 	return 33786
	-- 	-- end
	-- 	-- --imprison
	-- 	-- if UnitDebuffID(unit,221527) then
	-- 	-- 	return 221527
	-- 	-- end
	-- end

	local hasdebuff,debuff = _debuffFromTable(unit,immunes);
	local hasbuff,buff     = _buffFromTable(unit,immunes);

	if hasdebuff or hasbuff then return true; end
end

function magic_immunity_remains(unit,ignoreams)
	
	local fully_immune = immunity_remains(unit,cyclone)

	local all = {}

	local immunes = immuneMagic

	if ignoreams then
		for i=1,#immunes do if immunes[i] == 48707 then
			table.remove(immunes,i)
		end end
	end

	local debuffs = _debuffFromTable(unit,immunes,true);
	local buffs = _buffFromTable(unit,immunes,true);

	for i=1,#debuffs do
		table.insert(all,debuffs[i])
	end

	for i=1,#buffs do
		table.insert(all,buffs[i])
	end

	table.insert(all,fully_immune)

	table.sort(all,function(x,y) return x > y end);

	-- for i=1,#all do print(all[i]) end

	return all[1] or 0;

end

function _unitIsFacingUnit(firstUnit,secondUnit,degree)
	if not degree then degree = 0; end
	if UnitIsVisible(firstUnit) and UnitIsVisible(secondUnit) then
		local X,Y = unit_is_unit("player",firstUnit) and GetPlayerPosition() or ObjectPosition(firstUnit);
		local Rotation = ObjectFacing(firstUnit);
		local unitX,unitY = unit_is_unit("player",secondUnit) and GetPlayerPosition() or ObjectPosition(secondUnit);
		return ((X-unitX)*math.cos(-Rotation))-((Y-unitY)*math.sin(-Rotation))<degree or _realDistance(firstUnit,secondUnit) < 1.5;
	end
end

function _isFacingMe(unit)
	return _unitIsFacingUnit(unit,"player");
end

local immunePhysical =
{
	642, --Divine Shield
	1022, 	--Hand of Protection
	45438, 	--Ice Block
	19263, 	--Deterrence
	97417,	--BrittleBarrier
	33786,  --Cyclone
	186265, -- Aspect of the Turtle
	221527, -- imprison
	188499, -- blade dance
}
function _immunePhysical(unit,dmg)

	--immune in general
	if _immuneCheck(unit) then return true; end

	--mind controlled
	if UnitDebuffID(unit,605) then return 605; end

	--karma
	if UnitBuffID(unit,122470) or UnitBuffID(unit,125174) then
		return true;
	end

	if not dmg then
		if not _CCcheck(unit) then
			--Evasion / Die by the Sword / Parry / Blur / Fists--
			if (UnitBuffID(unit,5277) or UnitBuffID(unit,118038) or UnitBuffID(unit,199754) or UnitBuffID(unit,198589) or UnitChannelInfo(unit) == "Fists of Fury") then
				if not unit_is_unit("player",unit) and _isFacingMe(unit) then
					return true;
				end
			end
		end
	end

	local hasdebuff,debuff = _debuffFromTable(unit,immunePhysical);
	local hasbuff,buff     = _buffFromTable(unit,immunePhysical);
	if hasdebuff or hasbuff then return true; end
end

function physical_immunity_remains(unit,cyclone)
	
	local fully_immune,fully_immune_id = immunity_remains(unit,cyclone)

	local all = {}

	local immunes = immunePhysical

	local debuffs = _debuffFromTable(unit,immunes,true,true);
	local buffs = _buffFromTable(unit,immunes,true,true);

	local all = debuffs
	for k,v in pairs(buffs) do table.insert(debuffs, v) end

	table.insert(all,{r=fully_immune,id=fully_immune_id})

	if #all > 0 then
		table.sort(all,function(x,y) return x.r > y.r end);
	end

	-- for i=1,#all do print(all[i]) end

	return all[1] and all[1].r or 0, all[1].id

end

function _inDispellableCC(unit)
	if not UnitIsVisible(unit) then return false; end
	local debuffs =	_debuffFromTable(unit,csCCPolymorphs,true,true);
	if debuffs then
		table.sort(debuffs,function(x,y) return x.r > y.r end);
	end
 	if #debuffs > 0 then
 		return debuffs[1].id ~= 0 and debuffs[1].r > 1.5 and debuffs[1].id or nil;
 	end
end

-- function GetSpellTargetOffset()
-- 	local GUID = UnitGUID("Target")
-- 	for Offset = 0x1000, 0x2000, 0x4 do
-- 		if ObjectField("Player", Offset, Types.GUID) == GUID then
-- 			print(("%X"):format(Offset))
-- 		end
-- 	end
-- end

function UnitSpellTarget(unit)
	if not UnitIsVisible(unit) then return false end
	local cast,channel,castobj,channelobj = UnitCastID(unit)
	return (cast and castobj) or (channel and channelobj)
end

function _purgeCount(unit)
	
	if not unit then return end

	local buffCount = 0

	if not unit_buff_cache[unit] then
		unit_buff_cache[unit] = {get_unit_buffs(unit)}
		local cache = unit_buff_cache[unit]
		for i=1,#cache do
			local bufftype,count = cache[i][4],cache[i][3]
			if bufftype == "Magic" then
				if count > 0 then
					buffCount = buffCount + count
				else
					buffCount = buffCount + 1
				end
			end
		end
	else
		local cache = unit_buff_cache[unit]
		for i=1,#cache do
			local bufftype,count = cache[i][4],cache[i][3]
			if bufftype == "Magic" then
				if count > 0 then
					buffCount = buffCount + count
				else
					buffCount = buffCount + 1
				end
			end
		end
	end

	return buffCount

end

function _purgeAnything(unit)
	if _purgeCount(unit) > 0 then return true; end
end

local canZerk = {
	8122, -- Psychic Scream
	118699, -- Fear -- new SpellID in MoP, Blood Fear uses same ID
	5782, --FEAR
	5484, -- Howl of Terror
	6358, -- Seduction (Succubus)
	115268, -- Mesmerize (Shivarra) -- FIXME: verify this is the correct category
	5246, --Intimidating Shout
	99, -- Incapacitating Roar 
    1776, --gouge
	20066, --Repentance
	115078, --Paralysis
	221527,	--Imprison
	-- 236025,	--Incap Maim
}

function _shouldZerk()
	local delay = minDelayTime/1.6
    for i=1,#canZerk do
	    if _debuffRemains("player",canZerk[i]) >= 2 then
			if delay == 0 or _debuffUptime("player",canZerk[i]) >= delay then
				return true;
			end
		end
	end
	-- add sap only when valid target or rogue is visible nearby
end

local reflectspells = {
"Polymorph",
"Greater Pyroblast",
"Chaos Bolt",
"Cyclone",
}
function _shouldReflect()
	local buffer = ((1000/GetFramerate())/1000)*10 --ms per frame * 10 (10 fps buffer)
	local latency = squid_avg_latency+buffer+.09 --90ms + fps buffer, since latency only updates every 30s, and script only runs once per frame.
	local delay = latency+buffer
	for i=1,#Enemies do
		local cast = unit_casting_info(Enemies[i])
		if cast and tContains(reflectspells,cast) and _castTimeLeft(Enemies[i]) <= delay then
			local et = UnitSpellTarget(Enemies[i])
			if et and unit_is_unit("player",et) then
				return true;
			end
		end
	end
end
function get_spell_school(id)
	-- return id == 16 and "Frost"
	-- or id == 4 and "Fire"
	-- or id == 64 and "Arcane"
	return CombatLog_String_SchoolString(id)
end

-- /run t="target" if UnitExists(t) and (UnitChannelInfo(t) or unit_casting_info(t)) then if select(8,unit_casting_info(unit)) == false or select(7,UnitChannelInfo(unit)) == false then SQ_CastSpellByName("Skull Bash",t); end end
-- /run t="focus" if UnitExists(t) and (UnitChannelInfo(t) or unit_casting_info(t)) then if select(8,unit_casting_info(unit)) == false or select(7,UnitChannelInfo(unit)) == false then SQ_CastSpellByName("Skull Bash",t); end end

--Interrupts (New)
--param unit, unit to check interrupt prio
--param pct, override percentage cast completion value
--param phys, whether or not the interrupt is physical
--param custombuffer, override the minimum cast remaining buffer
local function i(unit,pct,int,physical,custombuffer)

	--stop the function if the unit isn't valid
	if not UnitIsVisible(unit) or UnitIsDead(unit) or UnitIsDeadOrGhost(unit) then return false end

	local magic_interrupt_absorbs = {
	8178,	--grounding totem
	212295,	--nether ward
	}

	local protection,protection_buff = not physical and _buffFromTable(unit,magic_interrupt_absorbs) or nil

	--only players in arena, and never into magical interrupt protection
	if (not arena or unit_is_player(unit)) then

		local channel,_,_,_,_,_,channelInterruptable = UnitChannelInfo(unit)
		local cast,_,_,_,_,_,_,castInterruptable = unit_casting_info(unit)



	end

end

function PvE_Interrupt(unit)
	if not UnitIsVisible(unit) or UnitIsDeadOrGhost(unit) then return false end
	-- if not unit_is_player(unit) then
		local channel,_,_,_,_,_,channel_protected,channelid = UnitChannelInfo(unit)
		local cast,_,_,_,_,_,_,cast_protected,castid = unit_casting_info(unit)

		if not channel and not cast then return false end

		--latency & travel time delay
		local frame_buffer = 2 / GetFramerate() -- 2 frame buffer
		local background_delay = (not IsForeground() and frame_buffer or 0)
		local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + _kickTravelTime(unit) + .108 + (SQUID.extra_net_delay or 0) -- latency + frame buffer + interrupt travel time + 90 ms safety net

		local int_only = {
			late = {

			    -- S4 M+ AFFIX
			    314406, -- Crippling Pestilence (Huge Damage + Disease Slow)
				314411, -- Lingering Doubt (Huge Damage + Curse Cast Speed Reduction)

				-- NY'ALOTHA
				311576, -- https://www.wowhead.com/spell=311576/void-bolt-volley
				313652, -- https://www.wowhead.com/spell=313652/mind-numbing-nova

				-- MECHAGON
				299588, -- https://www.wowhead.com/spell=299588/overclock
				298669, -- https://www.wowhead.com/spell=298669/taze
				300414, -- https://www.wowhead.com/spell=300414/enrage
				300436, -- https://www.wowhead.com/spell=300436/grasping-hex
				300514, -- https://www.wowhead.com/spell=300514/stoneskin
				301088, -- https://www.wowhead.com/spell=301088/detonate
				293827, --  https://www.wowhead.com/spell=293827/giga-wallop

				-- ATAL DAZAR
				250096,	-- https://www.wowhead.com/spell=250096/wracking-pain

				-- TEMPLE OF SETHRALISS
				263318,	-- https://www.wowhead.com/spell=263318/jolt
				263775,	-- https://www.wowhead.com/spell=263775/gust
				268061, -- https://www.wowhead.com/spell=268061/chain-lightning

				-- KING'S REST
				267308,	-- https://www.wowhead.com/spell=267308/lightning-bolt
				267273, -- https://www.wowhead.com/spell=267273/poison-nova
				270901, -- https://www.wowhead.com/spell=270901/induce-regeneration
				270923, -- https://www.wowhead.com/spell=270923/shadow-bolt

				-- THE UNDERROT
				260879,	-- https://www.wowhead.com/spell=260879/blood-bolt
				-- 265523, -- https://www.wowhead.com/spell=265523/summon-spirit-drain-totem
				265433,	-- https://www.wowhead.com/spell=265433/withering-curse
				265487,	-- https://www.wowhead.com/spell=265487/shadow-bolt-volley

				-- WAYCREST MANOR
				265876, -- https://www.wowhead.com/spell=265876/ruinous-volley
				266225,	-- https://www.wowhead.com/spell=266225/darkened-lightning
				260701, -- https://www.wowhead.com/spell=260701/bramble-bolt
				260699, -- https://www.wowhead.com/spell=260699/soul-bolt
				260700, -- https://www.wowhead.com/spell=260700/ruinous-bolt
				263959,	-- https://www.wowhead.com/spell=263959/soul-volley

				-- TOL'DAGOR
				257791,	-- https://www.wowhead.com/spell=257791/howling-fear
				258313,	-- https://www.wowhead.com/spell=258313/handcuff
				258935,	-- https://www.wowhead.com/spell=258935/inner-flames

				-- THE MOTHERLODE!!
				262092,	-- https://www.wowhead.com/spell=262092/inhale-vapors
				268797,	-- https://www.wowhead.com/spell=268797/transmute-enemy-to-goo

				-- SHRINE OF THE STORM
				267818,	-- https://www.wowhead.com/spell=267818/slicing-blast
				268309, -- https://www.wowhead.com/spell=268309/unending-darkness
				268347, -- https://www.wowhead.com/spell=268347/void-bolt

				-- TEMPLE OF SETHRALISS
				272820,	-- https://www.wowhead.com/spell=272820/shock


				--------------------SL---------------------------


				-- HALLS OF ATONEMENT
				323552,	-- Volley of Power
				326607, -- Turn to Stone
				323552, -- Volley of Power

				-- MISTS OF TIRNA SCITHE
				323057,
				326046,
				337235,
				337249,
				337255,

				-- PLAGUEFALL
				329239,
				328094,

				-- SANGUINE DEPTHS
				322433,
				326837,
				335305,

				-- SPIRES OF ASCENTION
				327413,
				327481,
				328137,

				-- THE NECROTIC WAKE
				324293,

				-- THEATER OF PAIN
				320120,
				320300,
				333231,
				342139,
				330875,

				-- TORGHAST
				294165,	-- Accursed Strength
				296523, -- Deafening Howl

				-- RANDOMSHIT
				229083, -- Burning Blast https://www.wowhead.com/spell=229083/burning-blast
				227592,
				229307,
				198495,
				208165,

			},
			
			early = {

				-- AFFIXES 

				-- FREEHOLD
				256060,	-- Revitalizing Brew (FH First Boss Heal) https://www.wowhead.com/spell=256060/revitalizing-brew
				257736,	-- https://www.wowhead.com/spell=257736/thundering-squall

				-- THE UNDERROT
				-- 265433,	-- https://www.wowhead.com/spell=265433/withering-curse

				-- ATAL'DAZAR
				250368,	-- https://www.wowhead.com/spell=250368/noxious-stench
				259572, -- https://www.wowhead.com/spell=259572/noxious-stench

				-- DE OTHER SIDE
				334076, -- {"Shadowcore"} 1b / Death Speaker
				332612, -- {"Healing Wave"} 1b / Atal'ai Hoodoo Hexxer
				323064,	-- {"Blood Barrage"}
				331379, -- {"Lubricate"}
				332084,	-- {"Self-cleaning Cycle"}
				320008, -- {"Frostbolt"}

				-- MISTS OF TIRNA SCITHE
				340544,

				-- SANGUINE DEPTHS
				319654,

				-- THE NECROTIC WAKE
				334748,

				-- RANDOMSHIT
				203957,
				204243,

			},
		}

		local int_or_cc = {

			early = {

				--test
				-- 152108, -- cataclysm test

				-- MECHAGON
				301689, -- https://www.wowhead.com/spell=301689/charged-coil
				293729, -- https://www.wowhead.com/spell=293729/tune-up

				-- THE MOTHERLODE!!
				268702,	-- https://www.wowhead.com/spell=268702/furious-quake
				280604, -- https://www.wowhead.com/spell=280604/iced-spritzer

				-- Vision of Orgrimmar
				298033,	-- Touch of the Abyss
				304251,	-- Void Quills (yikes man just remove this from the fucking GAME man MANANNMNNNNNNNnhnfifuiujfuiojfewrjiuoafjiuhrewajionufio)

				-- MISTS OF TIRNA
				322938,

				-- SANGUINE DEPTHS
				334653,

				-- THE NECROTIC WAKE
				327130,

				-- THEATER OF PAIN
				330810,

				-- TORGHAST
				329783,	-- Shadow Storm
			},

			-- Vision of Orgrimmar
			-- 298033,	-- Touch of the Abyss (STUN)

			-- test
			-- 116858, -- bolt test

			-- AFFIXES
			-- 314592, -- MIND FLAY TENTACLE EYEBALLS

			-- NY'ALOTHA
			-- 310839,	-- https://www.wowhead.com/spell=310839/dirge-from-below

			-- MECHAGON
			300764, -- https://www.wowhead.com/spell=300764/slimebolt
			300650, -- https://www.wowhead.com/spell=300650/suffocating-smog
			300171, -- https://www.wowhead.com/spell=300171/repair-protocol
			300087, -- https://www.wowhead.com/spell=300087/repair

			-- FREEHOLD
			257397,	-- https://www.wowhead.com/spell=257397/healing-balm
			257732,	-- https://www.wowhead.com/spell=257732/shattering-bellow
			257784,	-- https://www.wowhead.com/spell=257784/frost-blast
			-- 257899, -- (45% Dmg Increase + -3% HP/s) https://www.wowhead.com/spell=257899/painful-motivation
			258777, -- https://www.wowhead.com/spell=258777/sea-spout

			-- ATAL DAZAR
			255824,	-- Fanatic's Rage (AD Drazar'ai Juggernaut) https://www.wowhead.com/spell=255824/fanatics-rage
			255041,	-- Terrifying Screech (AD Fear Ptero) https://www.wowhead.com/spell=255041/terrifying-screech
			253583,	-- Fiery Enchant (AD Mob Dmg Increase) https://www.wowhead.com/spell=253583/fiery-enchant
			253517, -- Mending Word AD Heal https://www.wowhead.com/spell=253517/mending-word
			253562,	-- Wildfire (AD / BoD Mob Dmg) https://www.wowhead.com/spell=253562/wildfire
			252781,	-- Unstable Hex (AD Mob Hex) https://www.wowhead.com/spell=252781/unstable-hex
			256849,	-- Dino Might https://www.wowhead.com/spell=256849/dino-might

			-- THE UNDERROT
			265089,	-- https://www.wowhead.com/spell=265089/dark-reconstitution
			265091,	-- https://www.wowhead.com/spell=265091/gift-of-ghuun
			266106, -- https://www.wowhead.com/spell=266106/sonic-screech
			272183, -- https://www.wowhead.com/spell=272183/raise-dead
			278961, -- https://www.wowhead.com/spell=278961/decaying-mind
			272180, -- https://www.wowhead.com/spell=272180/death-bolt

			-- SIEGE OF BORALUS
			256957,	-- https://www.wowhead.com/spell=256957/watertight-shell
			272571, -- https://www.wowhead.com/spell=272571/choking-waters
			274569, -- https://www.wowhead.com/spell=274569/revitalizing-mist

			-- THE MOTHERLODE!!
			263202,	-- https://www.wowhead.com/spell=263202/rock-lance
			262540, -- https://www.wowhead.com/spell=262540/overcharge (This can be purged / spellstolen. Blacklist as a mage?)
			263066, -- https://www.wowhead.com/spell=263066/transfiguration-serum
			263103,	-- https://www.wowhead.com/spell=263103/blowtorch
			268129, -- https://www.wowhead.com/spell=268129/kajacola-refresher
			268709, -- https://www.wowhead.com/spell=268709/earth-shield
			269090, -- https://www.wowhead.com/spell=269090/artillery-barrage
			269302, -- https://www.wowhead.com/spell=269302/toxic-blades

			-- TEMPLE OF SETHRALISS
			261635,	-- https://www.wowhead.com/spell=261635/stoneshield-potion
			265968,	-- https://www.wowhead.com/spell=265968/healing-surge
			272700, -- https://www.wowhead.com/spell=272700/greater-healing-potion

			-- WAYCREST MANOR
			265368,	-- https://www.wowhead.com/spell=265368/spirited-defense
			265407, -- https://www.wowhead.com/spell=265407/dinner-bell
			266036,	-- https://www.wowhead.com/spell=266036/drain-essence
			278551, -- https://www.wowhead.com/spell=278551/soul-fetish	
			278444,	-- https://www.wowhead.com/spell=278444/infest

			-- SHRINE OF THE STORM
			267977,	-- https://www.wowhead.com/spell=267977/tidal-surge
			268030, -- https://www.wowhead.com/spell=268030/mending-rapids
			-- 268050, -- https://www.wowhead.com/spell=268050/anchor-of-binding (maybe don't interrupt this and save it for the heal)
			268317, -- https://www.wowhead.com/spell=268317/rip-mind
			268322, -- https://www.wowhead.com/spell=268322/touch-of-the-drowned
			268375, -- https://www.wowhead.com/spell=268375/detect-thoughts
			274437, -- https://www.wowhead.com/spell=274437/tempest
			276767, -- https://www.wowhead.com/spell=276767/consuming-void

			-- KING'S REST
			269973,	-- https://www.wowhead.com/spell=269973/deathly-chill
			267763, -- https://www.wowhead.com/spell=267763/wretched-discharge
			270492, -- https://www.wowhead.com/spell=270492/hex

			-- TOL DAGOR
			258128,	-- https://www.wowhead.com/spell=258128/debilitating-shout
			258153,	-- https://www.wowhead.com/spell=258153/watery-dome
			258634,	-- https://www.wowhead.com/spell=258634/fuselighter
			258779, -- https://www.wowhead.com/spell=258779/sea-spout
			258869, -- https://www.wowhead.com/spell=258869/blaze
			
			-----------------SL-----------------------

			-- Halls of Atonement
			325876,	-- Curse of Obliteration
			326607,	-- Turn to Stone
			338003, -- Wicked Bolt
			325700, -- Collect Sins

			-- DE OTHER SIDE
			328707,	-- Scribe
			332706, -- Heal
			332705, -- Smite

			-- MISTS OF TIRNA
			322767, -- spirit bolt
			324776, -- bramblethorn coat
			324914, -- nourish the forest

			-- PLAGUEFALL
			328016,
			329917,
			319070,
			328180,
			328094,
			328429,
			321999,
			328475,

			-- SANGUINE DEPTHS
			324609,
			321105,
			326836,
			321038,
			336277,
			322169,
			326952,

			-- SPIRES OF ASCENSION
			317936,
			317963,
			317959,
			317661,
			317648,
			317331,
			328295,

			-- THE NECROTIC WAKE
			323190,
			328667,
			320571,
			320822,
			335143,
			333623,
			338353,

			-- THEATER OF PAIN
			330784,
			341902,
			330562,
			342675,
			341771,
			330868,
			341969,
			330703,

			-- TORGHAST

			295929,	-- Rats!
			242391,	-- Terror
			304946,	-- Shadow Rip
			305136,	-- Shadow Spear

			-- RANDOMSHIT
			226206,	-- Arcane Reconstitution (Arcway Mob Heal) https://www.wowhead.com/spell=226206/arcane-reconstitution
			228625,	-- Banshee Wail
			253544,
			226285,
			227616,
			232115,
			227545,
			228280,
			227917,
			246505,
			236384,
			234179,
			226316,
			228279,
			198962,
			225047,
			210684,
			200658,
			202181,
			228239,
			226269,
			199514,
			200631,
			199726,
			224460,
			199589,
			262090, -- https://www.wowhead.com/spell=262090/cower
		}

		local cc_only = {
			early = {
				
				-- 234153,--drain life test

				-- ATAL'DAZAR
				253721, -- Bulwark of Juju

				-- FREEHOLD
				274400, -- Duelist Dash
				257756, -- goin' bananas

				-- KINGS REST
				270502, -- dino hunting leap

				-- SHRINE OF THE STORM
				276292, -- https://www.wowhead.com/spell=276292/whirling-slam

				-- MECHAGON
				300818, -- https://www.wowhead.com/spell=300818/acid-splash
				300525, -- https://www.wowhead.com/spell=300525/throw-trash
				-- 300560, -- https://www.wowhead.com/spell=300560/throw-trash AoE trash dodgeable

				-- WAYCREST MANOR
				268202, -- https://www.wowhead.com/spell=268202/death-lens

				-- SIEGE OF BORALUS
				272546, -- https://www.wowhead.com/spell=272546/banana-rampage

				-- TOL DAGOR
				258317, -- https://www.wowhead.com/spell=258317/riot-shield

				-- TEMPLE OF SETHRALISS
				263958, -- a knot of snakes

				-- VISION OF STORMWIND
				298584, -- repel


				---------SHADOWLANDS

				-- PLAGUEFALL
				336451,

			},
			mid = {
				-- SHRINE OF THE STORM
				268050, -- https://www.wowhead.com/spell=268050/anchor-of-binding (maybe don't interrupt this and save it for the heal)

				-- HALLS OF ATONEMENT
				325876,	-- Curse of Obliteration
				325523,	-- Deadly Thrust

				-- DE OTHER SIDE
				332671, -- BLADESTORM

				-- TORGH
				294165, -- Accursed  Strenght
				296523,	-- Deafening Howl

				-- MISTS OF TIRNA SCITHE
				324987,

				-- PLAGUEFALL
				321935,
				328651,
				328400,

				-- SPIRES OF ASCENSION
				323682,

				-- NECROTIC WAKE
				338022,
				334747,

				-- THEATER OF PAIN
				330586,

			},
			late = {

			},
		}

		local early_channels = {
			int_or_cc = {

				-- Halls of Atonement
				325700,	-- Collect Sins


				----------------------------------
				314592, -- Mind flay tentacle eyeball affix
				300650, -- Suffocating Smog Mechagon

				-- NY'A
				310839,	-- https://www.wowhead.com/spell=310839/dirge-from-below

				-- TORGH
				329783,	-- Shjadow Storm
			},
			int_only = {
				265433,	-- https://www.wowhead.com/spell=265433/withering-curse
			},
			cc_only = {

				-- Halls of Atonement
				325797,	-- Rapid Fire

				-- Plaguefall
				336451,	-- Bulwark of Maldraxxus

				298584, -- sw vision repel
				257756,	-- goin' bananas
			},
		}

		local mage_blacklist = {
			[299588] = true, -- Overclock, spellstealable haste buff
			[262540] = true, -- Overcharge, spellstealable haste buff
			[293729] = true, -- Tune Up, spellstealable haste buff
		}

		-- int_only.late, int_only.early, int_or_cc, int_or_cc.early, cc_only.early, cc_only.mid, cc_only.late

		--face away from blinding sand
		if castid and castid == 263914 and _castTimeLeft(unit) <= interruptNetDelay and _amIfacing(unit) then
			_faceAwayFromUnit(unit)
		end

		--casts
		if castid then

			if mage_blacklist[castid] and squid_player_class == "MAGE" then return false end

			local cast_time_left = _castTimeLeft(unit)

			local solo_mode = SQUID.solo_mode_enabled

			if not cast_protected then

				-- no instance interrupt anything
				if solo_mode then
					if cast_time_left <= interruptNetDelay then
						return "int_late_or_cc",castid
					elseif cast_time_left <= GetGCD() + interruptNetDelay + .15 then
						return "cc"
					end
				end

				-- late cast interrupt only
				if ( tContains(int_only.late,castid) and cast_time_left <= interruptNetDelay ) then -- ( _castPctDone(unit) >= 99 or cast_time_left <= interruptNetDelay ) ) then
					-- if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "int",castid
					-- end
				end

				-- early cast interrupt only
				if ( tContains(int_only.early,castid) and  _castTimeComplete(unit) >= minDelayTime and not tContains(early_channels.int_only,castid) and not tContains(early_channels.int_or_cc,castid) ) then -- ( _castPctDone(unit) >= 0 or cast_time_left <= interruptNetDelay ) ) then
					-- if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "int",castid
					-- end
				end

			end

			-- int or cc
			if tContains(int_or_cc,castid) and not tContains(early_channels.int_or_cc,castid) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					if not cast_protected then
						return "int_late_or_cc",castid
					else
						return "cc",castid
					end
				end
			end

			-- int or cc early
			if tContains(int_or_cc.early,castid) and not tContains(early_channels.int_or_cc,castid) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					if not cast_protected then
						return "int_early_or_cc",castid
					else
						return "cc",castid
					end
				end
			end

			-- early cast cc only
			if tContains(cc_only.early,castid) and not tContains(early_channels.cc_only,castid) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					return "cc",castid
				end
			end

			-- mid cast cc only
			if ( tContains(cc_only.mid,castid) and ( _castPctDone(unit) >= 40 or cast_time_left <= interruptNetDelay ) ) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					return "cc",castid
				end
			end

			-- late cast cc only
			if ( tContains(cc_only.late,castid) and ( _castPctDone(unit) >= 80 or cast_time_left <= interruptNetDelay ) ) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					return "cc",castid
				end
			end

		end

		--channels
		if channelid then

			if mage_blacklist[channelid] and squid_player_class == "MAGE" then return false end

			local cast_time_left = _castTimeLeft(unit)

			if not channel_protected then
				-- late cast interrupt only
				if ( tContains(int_only.late,channelid) and ( _castPctDone(unit) >= 99 or cast_time_left <= interruptNetDelay ) ) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "int",channelid
					end
				end

				-- early cast interrupt only
				if ( ( tContains(int_only.early,channelid) or tContains(early_channels.int_only) ) and ( _castPctDone(unit) >= 0 or cast_time_left <= interruptNetDelay ) ) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "int",channelid
					end
				end
			end

			-- int or cc
			if tContains(int_or_cc,channelid) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					if not channel_protected then
						return "int_late_or_cc",channelid
					else
						return "cc",channelid
					end
				end
			end

			-- int or cc early
			if tContains(int_or_cc.early,channelid) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					if not channel_protected then
						return "int_early_or_cc",channelid
					else
						return "cc",channelid
					end
				end
			end

			-- int or cc only channeled early
			if tContains(early_channels.int_or_cc,channelid) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					if not channel_protected then
						return "int_early_or_cc",channelid
					else
						return "cc",channelid
					end
				end
			end

			-- early cast cc only
			if tContains(cc_only.early,channelid) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					return "cc",channelid
				end
			end

			-- early channel cc
			if tContains(early_channels.cc_only,channelid) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					return "cc",channelid
				end
			end

			-- mid cast cc only
			if ( tContains(cc_only.mid,channelid) and ( _castPctDone(unit) >= 40 or cast_time_left <= interruptNetDelay ) ) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					return "cc",channelid
				end
			end

			-- late cast cc only
			if ( tContains(cc_only.late,channelid) and ( _castPctDone(unit) >= 80 or cast_time_left <= interruptNetDelay ) ) then
				if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
					return "cc",channelid
				end
			end

		end

	-- end
end

function Friends_Around_Unit(unit,range)
	local count = 0
	for i=1,#Friends do
		if not unit_is_unit(unit,Friends[i]) and _distance(Friends[i],unit) <= range then
			count = count + 1
		end
	end
	return count
end

local dispels = {
	[143579] = {stacks = 3 }, -- Immersius
	[143434] = {stacks = 3 }, -- Fallen Protectors
	[144514] = {stacks = 0 }, -- Norushen
	[144351] = {stacks = 0 }, -- Sha of Pride
	[146902] = {stacks = 0 }, -- Galakras(Korga Poisons)
	[143432] = {stacks = 0 }, -- General Nazgrim
	[142913] = {stacks = 0, range = 10}, -- Malkorok(Displaced Energy)
	[115181] = {stacks = 0 }, -- Spoils of Pandaria(Breath of Fire)
	[143791] = {stacks = 0 }, -- Thok(Corrosive Blood)
	[145206] = {stacks = 0 }, -- Aqua Bomb(Proving Grounds)
	[138733] = {stacks = 0 , range = 8}, -- Jin'rokh the Breaker (Ionization)
	-- Ko'ragh
	[142913] = {stacks = 0, range = 5}, -- http://www.wowhead.com/spell=162185/expel-magic-fire
	[185066] = {stacks = 0}, -- Mark of Necromancer red level
	-- Xavius
	[206651] = {stacks = 3}, -- Xavius Darkening Soul
	[209158] = {stacks = 3}, -- Xavius Blackening Soul
	-- Belac
	[233983] = {stacks = 0, range = 8}, -- Echoing Anguish http://www.wowhead.com/spell=233983/echoing-anguish
	-- Antoran High Command (Antorus)
	[257974] = {stacks = 9}, -- http://www.wowhead.com/spell=257974/chaos-pulse
	-- Imonar the Soulhunter
	[247552] = {stacks = 0, range = 15}, -- http://www.wowhead.com/spell=247552/sleep-canister
	-- Jadefire Masters
	[286988] = {stacks = 0}, -- https://www.wowhead.com/spell=286988/searing-embers
	-- Opulence
	[284470] = {stacks = 0}, -- https://www.wowhead.com/spell=284470/hex-of-lethargy
	-- Conclave of the Chosen
	--[282135] = {stacks = 0, range = 12}, -- https://www.wowhead.com/spell=282135/crawling-hex
	[285879] = {stacks = 0}, --https://www.wowhead.com/spell=285879/mind-wipe
	-- Mekkatorque
	[287167] = {stacks = 0}, -- https://www.wowhead.com/spell=287167/discombobulation
	-- Jaina Proudmoore
	[287626] = {stacks = 0}, -- https://www.wowhead.com/spell=287626/grasp-of-frost
	-- Siege of Boralis
	[275014] = { stacks = 0, range = 7 }, --https://www.wowhead.com/spell=274991/putrid-waters
	[257168] = { stacks = 0 }, --https://www.wowhead.com/spell=257168/cursed-slash
	[272571] = { stacks = 0 }, --https://www.wowhead.com/spell=272571/choking-waters
	[275835] = { stacks = 0 }, --https://www.wowhead.com/spell=275835/stinging-venom-coating
	-- Waycrest Manor
	[261440] = { stacks = 0, range = 8 }, --https://www.wowhead.com/spell=261439/virulent-pathogen
	[261439] = { stacks = 0, range = 8 }, --https://www.wowhead.com/spell=261439/virulent-pathogen
	[264378] = { stacks = 0 }, --https://www.wowhead.com/spell=264378/fragment-soul
	[263891] = { stacks = 0 }, --https://www.wowhead.com/spell=263891/grasping-thorns
	[265352] = { stacks = 0 }, --https://www.wowhead.com/spell=265352/toad-blight
	-- Temple of Sethraliss
	[268008] = { stacks = 0 }, --https://www.wowhead.com/spell=268008/snake-charm
	[268013] = { stacks = 0 }, --https://www.wowhead.com/spell=268013/flame-shock
	[268013] = { stacks = 0 }, --https://www.wowhead.com/spell=268013/flame-shock
	[273563] = { stacks = 0 }, --https://www.wowhead.com/spell=273563/neurotoxin
	[272657] = { stacks = 0 }, --https://www.wowhead.com/spell=272657/noxious-breath
	[267027] = { stacks = 0 }, --https://www.wowhead.com/spell=267027/cytotoxin
	[272699] = { stacks = 0 }, --https://www.wowhead.com/spell=272699/venomous-spit

	-- Tol Dagor
	[258128] = { stacks = 0 }, --https://www.wowhead.com/spell=258128/debilitating-shout
	[265889] = { stacks = 0 }, --https://www.wowhead.com/spell=265889/torch-strike
	[258864] = { stacks = 0 }, --https://www.wowhead.com/spell=258864/suppression-fire
	[257028] = { stacks = 0 }, --https://www.wowhead.com/spell=257028/fuselighter
	[257777] = { stacks = 0 }, --https://www.wowhead.com/spell=257777/crippling-shiv
	-- The Motherloads
	[280605] = { stacks = 0 }, --https://www.wowhead.com/spell=280605/brain-freeze
	[262268] = { stacks = 0 }, --https://www.wowhead.com/spell=262268/caustic-compound
	[268797] = { stacks = 0 }, --https://www.wowhead.com/spell=268797/transmute-enemy-to-goo
	[259853] = { stacks = 0 }, --https://www.wowhead.com/spell=259853/chemical-burn
	[269298] = { stacks = 0 }, --https://www.wowhead.com/spell=269298/widowmaker-toxin
	-- Atal'Dazar
	[252781] = { stacks = 0, range = 9 }, -- https://www.wowhead.com/spell=252781/unstable-hex
	[250096] = { stacks = 0 }, -- https://www.wowhead.com/spell=250096/wracking-pain
	[253562] = { stacks = 0 }, -- https://www.wowhead.com/spell=253562/wildfire
	[255582] = { stacks = 0 }, -- https://www.wowhead.com/spell=255582/molten-gold
	[255041] = { stacks = 0 }, -- https://www.wowhead.com/spell=255041/terrifying-screech
	[255371] = { stacks = 0 }, -- https://www.wowhead.com/spell=255371/terrifying-visage
	[250372] = { stacks = 2 }, --https://www.wowhead.com/spell=250372/lingering-nausea
	[252687] = { stacks = 0 }, --venomfang strike
	[255620] = { stacks = 0 }, --festering eruption
	-- Freehold
	[257908] = { stacks = 0 }, -- https://www.wowhead.com/spell=257908/oiled-blade
	[257436] = { stacks = 0 }, -- https://www.wowhead.com/spell=257436/poisoning-strike
	-- Shrine of the storm
	[264560] = { stacks = 0 }, -- https://www.wowhead.com/spell=264560/choking-brine
	[268233] = { stacks = 0 }, -- https://www.wowhead.com/spell=268233/electrifying-shock
	[268322] = { stacks = 0 }, -- https://www.wowhead.com/spell=268322/touch-of-the-drowned
	[268391] = { stacks = 0 }, -- https://www.wowhead.com/spell=268391/mental-assault
	[268896] = { stacks = 0 }, -- https://www.wowhead.com/spell=268896/mind-rend
	[269104] = { stacks = 0 }, --https://www.wowhead.com/spell=269104/explosive-void
	-- Kings Rest
	[276031] = { stacks = 0 }, -- https://www.wowhead.com/spell=276031/pit-of-despair
	[270492] = { stacks = 0 }, -- https://www.wowhead.com/spell=270492/hex
	[270499] = { stacks = 0 }, -- https://www.wowhead.com/spell=270499/frost-shock
	[270865] = { stacks = 0 }, --https://www.wowhead.com/spell=270865/hidden-blade
	[271563] = { stacks = 0 }, -- https://www.wowhead.com/spell=271563/embalming-fluid
	[270507] = { stacks = 0 }, -- https://www.wowhead.com/spell=270507/poison-barrage
	-- Underrot
	[276031] = { stacks = 2 }, -- https://www.wowhead.com/spell=265468/withering-curse
	[266209] = { stacks = 0 }, -- https://www.wowhead.com/spell=266209/wicked-frenzy
	[272180] = { stacks = 0 }, -- https://www.wowhead.com/spell=272180/death-bolt
	[272609] = { stacks = 0 }, -- https://www.wowhead.com/spell=272609/maddening-gaze
	[269301] = { stacks = 3 }, -- https://www.wowhead.com/spell=269301/putrid-blood
	[278961] = { stacks = 0 }, -- https://www.wowhead.com/spell=278961/decaying-mind
	-- Eternal Palace
	[296737] = { stacks = 0, range = 10}, -- https://www.wowhead.com/spell=296737/arcane-bomb
	[295327] = { stacks = 0}, --https://www.wowhead.com/spell=295327/shattered-psyche
	-- Mechagon
	[300659] = {stacks = 0}, --https://www.wowhead.com/spell=300659/consuming-slime
	[298124] = {stacks = 0}, --https://www.wowhead.com/spell=298124/gooped
	[300414] = {stacks = 0}, --https://www.wowhead.com/spell=300414/enrage
	[294929] = {stacks = 0}, --https://www.wowhead.com/spell=294929/blazing-chomp
	[294195] = {stacks = 0}, --https://www.wowhead.com/spell=294195/arcing-zap
	[284219] = {stacks = 0}, --https://www.wowhead.com/spell=284219/shrink
	-- Trash (Ny'alotha)
	[310224] = {stacks = 10}, --https://www.wowhead.com/spell=307421/annihilation
	-- Maut
	[314993] = {stacks = 0}, --https://www.wowhead.com/spell=314992/drain-essence
	-- S4 M+ AFfix
	[314411] = {stacks = 0}, --https://www.wowhead.com/spell=314411/lingering-doubt
	[314592] = {stacks = 0}, --tentacle mind flay
	[314406] = {stacks = 0},


	-- FUCKING CANCER VISION CANCER CANCER CANCER CANCER CANCCER CANCER CANCER
	[297146] = {stacks = 0},	-- CURSE INFINITELY HEALS THE FUCKING BERSERKERS
	[298510] = {stacks = 3},	-- POISON STUNS YOU AT 5 STACKS GOOD LUCK ANYONE WITHOUT POISON DISP


	--test
	-- [12654] = {stacks = 0},
}

function PvE_Dispel(unit,types)

	if not UnitIsVisible(unit) or UnitIsDeadOrGhost(unit) then return false end
	
	if not types then return false end

	local cache = unit_debuff_cache[unit]
	if not cache then
		unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
		cache = unit_debuff_cache[unit]
		for i=1,#cache do
			local name,count,debuffType,spellID = cache[i][1],cache[i][3],cache[i][4],cache[i][10]
			local should_dispel = tContains(types,debuffType) and dispels[spellID]
			if should_dispel then
				local min_stacks = should_dispel.stacks
				local range = should_dispel.range
				if range then
					if Friends_Around_Unit(unit,range) == 0 and count >= min_stacks then
						return spellID
					end
				else
					if count >= min_stacks then
						return spellID
					end
				end
			end
		end
	else
		local cache = unit_debuff_cache[unit]
		for i=1,#cache do
			local name,count,debuffType,spellID = cache[i][1],cache[i][3],cache[i][4],cache[i][10]
			local should_dispel = tContains(types,debuffType) and dispels[spellID]
			if should_dispel then
				local min_stacks = should_dispel.stacks
				local range = should_dispel.range
				if range then
					if Friends_Around_Unit(unit,range) == 0 and count >= min_stacks then
						return spellID
					end
				else
					if count >= min_stacks then
						return spellID
					end
				end
			end
		end
	end

end

--Interrupts
function Interrupt(unit,int,forcedpct,physical,onlyint,nochannel)
	
	if not UnitIsVisible(unit) or UnitIsDeadOrGhost(unit) then return false end

	if (not arena or unit_is_player(unit)) and (physical or not UnitBuffID(unit,8178)) and (physical or not UnitBuffID(unit,212295)) and (int or not UnitBuffID(unit,289655)) and not UnitBuffID(unit,104773) then

		local channel,_,_,_,_,_,channelInterruptable = UnitChannelInfo(unit)
		local cast,_,_,_,_,_,_,castInterruptable = unit_casting_info(unit)

		if not channel and not cast then return false end

		if nochannel and channel then return false end

		if physical and _immunePhysical(unit) then return false end

		if _immuneCheck(unit) then return false end

		if physical and UnitBuffID(unit,1022) then return false end

		if int then
			if channelInterruptable == true then
				channelInterruptable = false
			end
			if castInterruptable == true then
				castInterruptable = false
			end
		end

		--latency & travel time delay
		local frame_buffer = 1 / GetFramerate() -- 1 frame buffer
		local background_delay = (not IsForeground() and frame_buffer or 0)
		local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + _kickTravelTime(unit) + .115 + (SQUID.extra_net_delay or 0) -- latency + frame buffer + interrupt travel time + safety net

		-- print(interruptNetDelay,_castTimeLeft(unit))

		--pct delay
		local pct=99

		--overwrite based on jukes
		if jukeList[unit] then
			local jukes = jukeList[unit]["Jukes"]
			local max = jukeList[unit]["MaxJukes"]
			if not max then max = 3; end
			if jukes then
				if jukes < max then pct=99 else pct=0 end
			end
		end

		--mages shimmer, can't 99 them...
		if select(2,UnitClass(unit)) == "MAGE" and _isMeleeDps("player") then
			pct = 35;
		end

		--off targets can be kicked faster for melee
		if not unit_is_unit(unit,current_target) and _isMeleeDps("player") then
			pct = 30;
		end

		if lastShadowStep and GetTime()-lastShadowStep <= 2.5 then 
			pct = 0;
		end

		if lastGapClose and GetTime() - lastGapClose <= 1.5 then
			pct = 0;
		end

		--override pct delay
		if forcedpct then
			pct = forcedpct
		end

		local pct_done = _castPctDone(unit)
		local time_left = _castTimeLeft(unit)
		local time_complete = _castTimeComplete(unit)

		--cast pct complete > pct and < net delay
		if ((cast and (pct_done >= pct or time_left <= interruptNetDelay) and (time_left < 1.5))
		--channels insta
		or channel and time_complete >= minDelayTime + (chan_delay == 1 and .55 or chan_delay == 2 and .35 or chan_delay == 3 and .1))
		--time complete > min delay
		and (time_complete >= minDelayTime or time_left <= interruptNetDelay) then
		-- --time left > net delay MINIMUM.
		-- and _castTimeLeft(unit) > interruptNetDelay/1.1 then

			--dont kick if your dk dark sim
			if UnitDebuffID(unit,77606) then return false; end

			--always kick in dungeons
			if not unit_is_player(unit) and select(2,UnitClass("player")) ~= "MAGE" and GetNumGroupMembers() <= 5 and not arena and (channelInterruptable == false or castInterruptable == false) then
				return true
			end

			--always kick as dh
			if select(2,UnitClass("player")) == "DEMONHUNTER" and (channelInterruptable == false or castInterruptable == false) then
				if GetNumGroupMembers() <= 10 then --good to kick everything in rbg, not raids
					return true;
				end
			end

			local friendlyMage = nil
			for i=1,#Friends do
				if select(2,UnitClass(Friends[i])) == "MAGE" then
					friendlyMage=Friends[i]
				end
			end

			--let mage get first kick on priests, unless they're our target / mage in cc 
			--(i would do an los check but those are too expensive!)
			if friendlyMage and select(2,UnitClass("player")) ~= "MAGE" then
				if UnitCooldown(friendlyMage,2139) == 0 and not _CCcheck(friendlyMage) then
					if select(2,UnitClass(unit)) == "PRIEST" and not unit_is_unit(unit,current_target) then
						return false
					end
				end
			end

			--check for mage
			local mageExists;
			if arena then
			    for i=1,GetNumArenaOpponents() do if unit_is_player("arena"..i) and select(2,UnitClass("arena"..i)) == "MAGE" then
			   	 	mageExists="arena"..i;
				end end
			end

			--lowest friend
			local lowestFriend=100;
			for i=1,#Friends do 
				local friendhp = _HP(Friends[i]);
				if friendhp and friendhp < lowestFriend then
					lowestFriend=_HP(Friends[i]);
				end 
			end

			--lowest enemy
			local lowestEnemy = 100;
			for i=1,#Enemies do if unit_is_player(Enemies[i]) and _HP(Enemies[i]) < lowestEnemy then
				lowestEnemy=_HP(Enemies[i]);
			end end

			--they have healer?
			local theirHealer
			for i=1,#Enemies do if _isHealer(Enemies[i]) then theirHealer=Enemies[i] end end

			--their healer in cc?
			local theirHealerCC
			local theirHealerCCremains = 0
			if theirHealer then
				local cc=_CCremains(theirHealer)
				if cc > 0 then
					theirHealerCC = true;
					theirHealerCCremains = cc;
			    end 
			end

			--healer in cc
			local healerInCC;
			if ourHealer and _CCcheck(ourHealer) then healerInCC=true; end

			lowestFriend = lowestFriend - (healerInCC and 30 or 0)

			local cast_target = UnitSpellTarget(unit)
			if not UnitIsVisible(cast_target) then cast_target = nil end

			local los_dest;
			if cast_target then
				if _LoS(unit,cast_target) then 
					los_dest = true; 
				end
			end

			--check cast function
			local function UnitCastingFrom(table)
				local interruptable = castInterruptable == false or channelInterruptable == false or int
				local spell = interruptable and cast
				if not spell then spell = interruptable and channel end
				
				--dont kick hex with friendly druid out of cc .. this logic causes weird problems with hex lasso being a thing now...
				-- if cast == "Hex" then
				-- 	if not _isHealer(unit) or lowestEnemy > 40 then
				-- 		if friendlyDruid then return false; end
				-- 	end
				-- end

				--dont kick cc if dest is immune ... so much cool shit i just can't do without functioning cast dest..
				-- if castDest then
				-- 	local cc = {
				-- 	"Polymorph",
				-- 	"Cyclone",
				-- 	"Fear",
				-- 	"Hex",
				-- 	"Repentance",
				-- 	"Dominate Mind",
				-- 	}
				-- 	if _immuneTrap(castDest,true) and tContains(cc,cast) then return false; end
				-- 	if cast ~= "Dominate Mind" and cast ~= "Fear" and cast ~= "Cyclone" and tContains(cc,cast) and _isBeast(castDest) then return false; end
				-- end

				--check cast
				if type(table) == "table" then
					for i=1,#table do 
						local c = GetSpellInfo(table[i]);
						if c and spell == c then return true; end
					end
				end
				if type(table) == "string" then
					if spell == table then return true; end
				end
				if type(table) == "number" then
					if spell == GetSpellInfo(table) then return true; end
				end
			end

			if UnitCastingFrom(csCCPolymorphs) or UnitCastingFrom(csCCincapacitate) then

				return true;
			end

			--kick CC
			if UnitCastingFrom(csCCPolymorphs) or UnitCastingFrom(csCCincapacitate) or UnitCastingFrom(csCCdisorient) or UnitCastingFrom(csAlways) then
				--dont kick fear unless it's on your healer
				if (cast ~= GetSpellInfo(118699) or (unit_is_unit(castDest,ourHealer) and _disorientDR(ourHealer) >= .5 and lowestFriend < _disorientDR(ourHealer) * 80) or lowestEnemy < 45 + (theirHealerCCremains > 2 and theirHealerCCremains * 10 or 0) - ((100-lowestFriend)*.5)) then
					return true;
				end
			end

			--kick only if channeled
			if UnitCastingFrom(csOnlyChannel) and UnitChannelInfo(unit) then
				return true;
			end

			--cs heals if enemy < %hp
			if lowestEnemy < 92 then
				if _isHealer(unit) or theirHealerCC or not theirHealer then
					if UnitCastingFrom(csHeals) then
						if cast ~= GetSpellInfo(33076) or lowestEnemy < 40 then
							if not mageExists or lowestEnemy < 45 or enemy_in_stun or IsLocked(unit) then
								if lowestEnemy < 55 and _isHealer(unit) then return "important" end
								return true;
							end
						end
					end
				end
			end

			--cs mass dispel (if friend immune or enemy trapped)
			if cast == "Mass Dispel" and (castInterruptable == false or int) then
				
				local friendImmune
				for i=1,#Friends do 
					if UnitBuffID(Friends[i],642) or UnitBuffID(Friends[i],45438) then
						friendImmune=true;
					end 
				end

				local enemyCC
				for i=1,#Enemies do 
					if _inDispellableCC(Enemies[i]) then
						enemyCC=true;
					end 
				end

				if friendImmune or enemyCC then
					return true;
				end

			end

			--scorch or fireball (with combustion up)
			if (cast == "Fireball" or cast == "Scorch") and UnitBuffID(unit,190319) then
				if lowestFriend < 30 then return "important" end
				return true;
			end

			--frost mage damage (mage or teammate extremely low)
			if UnitCastingFrom(csMageDamage) and (_HP(unit) < 35 or lowestFriend < 20) then
				return true;
			end

			--any arcane cast when healer in cc
			if UnitCastingFrom(csArcaneDamage) and (lowestFriend < 40 + (healerInCC and 60 or 0)) then
				return true;
			end

			if select(2,UnitClass(unit)) == "WARLOCK" then
				if UnitBuffID(unit,113858) then --only kick bolts when dark soul is up, have to trust healer dispel on cc casts.
					if cast == "Chaos Bolt" then
						if time_complete >= minDelayTime * 4 or time_left <= interruptNetDelay then
							return true
						end
					else 
						return false;
					end
				else --normal lock kicks
					--kick fear if we have pressure
					local fearkickhp = 50
					fearkickhp = fearkickhp + (theirHealerCC and 35 or 0)
					if cast == "Fear" and _HP(unit) < fearkickhp then
						if time_complete >= minDelayTime * 2.5 or time_left <= interruptNetDelay then
							return true
						end
					end
					--idk kick ua locks out of the game i guess?
					if cast == "Unstable Affliction" and lowestFriend < 80 then
						return true;
					end
					--dont kick bolts unless we really have to while their healer is cc'd
					if cast == "Chaos Bolt" and lowestFriend < 65 and (not theirHealerCC or lowestFriend < 35) then
						if time_complete >= minDelayTime * 2.5 or time_left <= interruptNetDelay then
							return true
						end
					end
				end
			else
				--kick from big dmg (lowest teammate < 60)
				if UnitCastingFrom(castedDMG) and lowestFriend < 60 then
					if lowestFriend < 45 then return "important" end
					return true;
				end
			end

			--holy paladin spells (low hp)
			if (cast == "Holy Light" or cast == "Flash of Light") and (castInterruptable == false or int) and _HP(unit) < 65 then
				return true;
			end

			--kick vt (if you're targeting)
			if cast == "Vampiric Touch" and (unit_is_unit(unit,current_target) or lowestEnemy < 35 or _isHealer("player")) then
				return true;
			end

			--antilock
			-- if UnitCastingFrom(csWarlock) then
			-- 	return true;
			-- end

		end
	end
end

function PhysicalInterrupt(unit,int,pct,physical,custombuffer)
	return Interrupt(unit,int,pct,true,custombuffer);
end

function _unitIsFacingUnit(firstUnit,secondUnit,angle)
	if not angle then angle = 180; end
	if firstUnit and secondUnit then
		return UnitIsFacing(firstUnit,secondUnit,angle)
	end
	return false
end

function _amIfacing(unit)
	if not UnitExists(unit) then return false end
	return _unitIsFacingUnit("player",unit);
end
am_i_facing = _amIfacing

function am_i_facing_angle(unit,angle)
	if not unit then return false end
	if not angle then angle = 180; end
	return UnitIsFacing("player",unit,angle)
	-- local secondUnit=unit
	-- unit="player"
	-- if not secondUnit then return false end
	-- if UnitIsVisible(unit) and UnitIsVisible(secondUnit) then
	-- 	local X,Y,Z = ObjectPosition(unit);
	-- 	local unitX,unitY,unitZ = ObjectPosition(secondUnit);
	-- 	local Rotation = ObjectFacing(unit);
	-- 	local dist = _realDistance(unit,secondUnit)
	-- 	local uhh = (((X-unitX)*math.cos(-Rotation))-((Y-unitY)*math.sin(-Rotation)))
	-- 	uhh = uhh + dist
	-- 	return uhh < angle or dist < 1.5;
	-- end
	-- if not unit then
	-- 	if not angle then angle = .75; end
	-- 	local secondUnit=unit
	-- 	unit="player"
	-- 	if not secondUnit then return false end
	-- 	if UnitIsVisible(unit) and UnitIsVisible(secondUnit) then
	-- 		local X,Y,Z = ObjectPosition(unit);
	-- 		local unitX,unitY,unitZ = ObjectPosition(secondUnit);
	-- 		local Rotation = ObjectFacing(unit);
	-- 		local dist = _realDistance(unit,secondUnit)
	-- 		local uhh = (((X-unitX)*math.cos(-Rotation))-((Y-unitY)*math.sin(-Rotation)))
	-- 		uhh = uhh + dist
	-- 		return uhh < angle or dist < 1.5;
	-- 	end
	-- return false end
end

function facing_bcc(dist,angle)
	if not angle then angle = .75 end
	if not dist then dist = 15 end
	local bcc = {}
	for i=1,#Enemies do if _breakableCC(Enemies[i]) and _distance(Enemies[i]) < dist then
		table.insert(bcc,Enemies[i])
	end end
	for i=1,#bcc do
		if am_i_facing_angle(bcc[i],angle) then
			return true
		end
	end
end

local pCC = {
-- PVP DISPELs --
--------------------
--Death Knight
-- Druid
--99, -- Disorienting Roar (talent)
2637,	-- Hibernate
-- Hunter
3355, -- Freezing Trap
-- Mage
28272,		-- Pig
118,		-- Sheep
277792,		-- Bee
161354,		-- Monkey
277787,		-- Direhorn
161355,		-- Penguin
161353,		-- Polar Bear
120140,		-- Porcupine
61305,		-- Cat
61721,		-- Rabbit
61780,		-- Turkey
28271,		-- Turtle
82691,		-- Ring of Frost
-- Monk
-- Paladin
853, -- Hammer of Justice
105421, -- Blinding Light
20066, -- Repentance
-- Priest
9484, -- Shackle Undead
-- 87204, -- Sin and Punishment
64044, -- Psychic Horror (Stun)
-- 605,	-- MC
-- 200196,	-- Holy Word: Chastise (FIX ME, MIGHT NOT BE DISPELLABLE)
205369,	-- Mind Bomb (Pre Stun)
226943,	-- Mind Bomb (Post Stun)
-- Rogue
-- Shaman
118905, -- Static Charge
51514,  -- Hex
-- Hunter
-- Paladin
-- 10326, -- Turn Evil
-- Priest
8122, -- Psychic Scream
-- Rogue
-- Warlock
5782, -- Fear -- new SpellID in MoP, Blood Fear uses same ID
118699,	-- Fear (BFA spellid)
5484, -- Howl of Terror
6789, -- Mortal Coil
6358, -- Seduction (Succubus)
115268, -- Mesmerize (Shivarra) -- FIXME: verify this is the correct category
-- 111397, -- Blood horror
30283, -- shadowfury
-- Warrior
-- Demon Hunter
206649, -- Eye of Leotheras
179057,	-- Chaos Nova
217832,	-- Imprison
}

local cc = {
--Demon Hunter
179057,	-- Chaos Nova
--Mage
102051, -- Frostjaw (talent)
--Priest
15487, --Silence
 -- Hunter
-- Paladin
10326, -- Turn Evil
-- PVP DISPELs --
--------------------
-- Druid
-- 99, -- Disorienting Roar (talent)
-- Hunter
187650, -- Freezing Trap
19386, -- Wyvern Sting
-- Mage
118, -- Polymorph
28272, -- Polymorph (pig)
28271, -- Polymorph (turtle)
61305, -- Polymorph (black cat)
61025, -- Polymorph (serpent) -- FIXME: gone ?
61721, -- Polymorph (rabbit)
61780, -- Polymorph (turkey)
82691, -- Ring of Frost
44572, -- Deep Freeze
157997, --New ice nova
31661, --Dragon's roar
-- Monk
198909,	-- Song of Chi Ji
-- Paladin
853, -- Hammer of Justice
105593, -- Fist of Justice (talent)
105421, -- Blinding Light
20066, -- Repentance
-- Priest
9484, -- Shackle Undead
87204, -- Sin and Punishment
64044, -- Psychic Horror (Horrify effect)
--605,	--MC
-- Rogue
-- Shaman
118905, -- Static Charge
--51514,  -- Hex
-- Hunter
117526, --binding shit i mean shot
-- Paladin
10326, -- Turn Evil
-- Priest
8122, -- Psychic Scream
-- Rogue
-- Warlock
118699, -- Fear -- new SpellID in MoP, Blood Fear uses same ID
5484, -- Howl of Terror
6789, --Mortal Coil- 
6358, -- Seduction (Succubus)
115268, -- Mesmerize (Shivarra) -- FIXME: verify this is the correct category
111397, -- Blood Horror
-- Warrior
--DK
47476
}
local rootDispels = {
	--96294,		--Chains Of Ice
	--91807,		--ShamblingRush
	339,		-- Entangling Roots
	--45334,		-- Immobilized (Wild Charge - Bear)
	102359,		-- Mass Entanglement
	-- ** FIND NEW ENTRAPMENT **
	136634,		-- Narrow Escape
	122,		-- Frost Nova
	111340,		-- Ice Ward
	--116706,		-- Disable
	--87194,		-- Glyph of Mind Blast
	--114404,		-- Void Tendril's Grasp
	64695,		-- Earthgrab (Earthgrab Totem)
	63685,		-- Freeze (Frozen Power)
	--107566,		-- Staggering Shout
	--39965,		-- Frost Grenade
	--55536,		-- Frostweave Net
	--13099		-- Net-o-Matic
	-- 233395,		-- Remorseless Root
}
local ccProt = {
	34914, 		--VampiricTouch
	30108, 		--UA
}
local mdBuffs = {
642,	-- Divine Shield
45438, 	--Ice Block
1022	--bop
}

function _shouldCleanse(unit)

	-- dont dispel vt or ua when we are literally fucking dead
	if _buffFromTable(unit,ccProt) and lowestFriend < 35 then
		return false
	end

	local schools = {
	"Magic",
	"Poison",
	"Disease",
	}
	local lessDelay = minDelayTime / 1.5;
	local time = GetTime()
	for i=1,#pCC do
		local debuff,_,_,five,six,seven = UnitDebuffID(unit,pCC[i]);
		if debuff and seven-time < six-lessDelay then
			if tContains(schools,five) then
				return pCC[i];
			end
		end
	end
	--voodoo doll
	if UnitDebuffID(unit,271465) then
		return 271465
	end
	--maledict
	if UnitDebuffID(unit,305252) then
		return 305252
	end
	--claw
	if UnitDebuffID(unit,313148) then
		return 313148
	end
	--Dispelling Roots--
	if (_isMeleeDps(unit) or _isHealer(unit)) then
		for i=1,#rootDispels do
			if UnitDebuffID(unit,rootDispels[i]) then
				return rootDispels[i];
			end
		end
	end
end

function should_purify(unit)
	if not unit then return end
	local time = GetTime()
	local lessDelay = minDelayTime / 2;
	local schools = {
	"Magic",
	"Disease",
	}
	--Dispelling CC--
	for i=1,#pCC do
		local debuff,_,_,five,six,seven = UnitDebuffID(unit,pCC[i]);
		if debuff and seven-time < six-lessDelay then
			if tContains(schools,five) then
				return pCC[i];
			end
		end
	end
	--voodoo doll
	if UnitDebuffID(unit,271465) then
		return 271465
	end
	--maledict
	if UnitDebuffID(unit,305252) then
		return 305252
	end
	--claw
	if UnitDebuffID(unit,313148) then
		return 313148
	end
	--Dispelling Roots--
	if (_isMeleeDps(unit) or _isHealer(unit)) then
		for i=1,#rootDispels do
			if UnitDebuffID(unit,rootDispels[i]) then
				return rootDispels[i];
			end
		end
	end
end

function should_cleanse(unit)
	if not unit then return end
	local time = GetTime()
	local lessDelay = minDelayTime / 2;
	local schools = {
	"Magic",
	"Disease",
	}
	--Dispelling CC--
	for i=1,#pCC do
		local debuff,_,_,five,six,seven = UnitDebuffID(unit,pCC[i]);
		if debuff and seven-time < six-lessDelay then
			if tContains(schools,five) then
				return pCC[i];
			end
		end
	end
	--voodoo doll
	if UnitDebuffID(unit,271465) then
		return 271465
	end
	--maledict
	if UnitDebuffID(unit,305252) then
		return 305252
	end
	--Dispelling Roots--
	if (_isMeleeDps(unit) or _isHealer(unit)) then
		for i=1,#rootDispels do
			if UnitDebuffID(unit,rootDispels[i]) then
				return rootDispels[i];
			end
		end
	end
end

function should_md(unit)
	local md_cast_time = _castTime(32375)
	if unit_can_attack("player",unit) and UnitDebuffID(unit,33786) then return false end
	for i=1,#mdBuffs do
		if _buffRemains(unit,mdBuffs[i]) > md_cast_time + 1.5 and (mdBuffs ~= 1022 or _purgeCount(unit) >= 5) then
			return true
		end
	end
end

function _shouldPurify(unit)
	local schools = {
	"Magic",
	"Poison",
	"Disease",
	}
	local lessDelay = minDelayTime / 4.2;
	local time = GetTime()
	for i=1,#pCC do
		local debuff,_,_,five,six,seven = UnitDebuffID(unit,pCC[i]);
		if debuff and seven-time < six-lessDelay then
			if tContains(schools,five) then
				return pCC[i]
			end
		end
	end
	--voodoo doll
	if UnitDebuffID(unit,271465) then
		return 271465
	end
	--maledict
	if UnitDebuffID(unit,305252) then
		return 305252
	end
	--Dispelling Roots--
	if (_isMeleeDps(unit) or _isHealer(unit)) then
		for i=1,#rootDispels do
			if UnitDebuffID(unit,rootDispels[i]) then
				return rootDispels[i]
			end
		end
	end
end

function cleanse_poisons(unit)
	for i=1,30 do
		local debuff,_,_,debufftype = UnitDebuff(unit,i)
		if not debuff then break end
		if debufftype == "Poison" then
			return debuff
		end
	end
end

local rootList = {
	--96294,		--Chains Of Ice
	-- 91807,		--ShamblingRush
	339,		-- Entangling Roots
	212638,		-- Tracker's Net
	45334,		-- Immobilized (Wild Charge - Bear)
	102359,		-- Mass Entanglement
	-- ** FIND NEW ENTRAPMENT **
	136634,		-- Narrow Escape
	122,		-- Frost Nova
	111340,		-- Ice Ward
	116706,		-- Disable
	--87194,		-- Glyph of Mind Blast
	--114404,		-- Void Tendril's Grasp
	64695,		-- Earthgrab (Earthgrab Totem)
	63685,		-- Freeze (Frozen Power)
	--107566,		-- Staggering Shout
	--39965,		-- Frost Grenade
	--55536,		-- Frostweave Net
	--13099		-- Net-o-Matic
	-- 233395,		-- Remorseless Root
}

local roots =
{
	--96294,		--Chains Of Ice
	--91807,		--ShamblingRush
	339,		-- Entangling Roots
	45334,		-- Immobilized (Wild Charge - Bear)
	102359,		-- Mass Entanglement
	136634,		-- Narrow Escape
	122,		-- Frost Nova
	33395,		-- Mage Pet Freeze
	111340,		-- Ice Ward
	--87194,		-- Glyph of Mind Blast
	114404,		-- Void Tendril's Grasp
	64695,		-- Earthgrab (Earthgrab Totem)
	63685,		-- Freeze (Frozen Power)
	107566,		-- Staggering Shout
	199786,		-- Glacial Spike
	200108,		-- Ranger's Net
	190927,		-- Harpoon
	--39965,		-- Frost Grenade
	--55536,		-- Frostweave Net
	--13099		-- Net-o-Matic
	233395,		-- Remorseless Root
	212638,		-- Tracker's Net
	117526, -- Binding Shot (talent)
}

local rootz =
{
	--96294,		--Chains Of Ice
	--91807,		--ShamblingRush
	--339,		-- Entangling Roots
	45334,		-- Immobilized (Wild Charge - Bear)
	--102359,		-- Mass Entanglement
	--136634,		-- Narrow Escape
	--122,		-- Frost Nova
	--33395,		-- Mage Pet Freeze
	--111340,		-- Ice Ward
	--87194,		-- Glyph of Mind Blast
	--114404,		-- Void Tendril's Grasp
	--64695,		-- Earthgrab (Earthgrab Totem)
	63685,		-- Freeze (Frozen Power)
	--107566,		-- Staggering Shout
	--39965,		-- Frost Grenade
	--55536,		-- Frostweave Net
	--13099		-- Net-o-Matic
}

function _rootCheck(unit)
	local hasdebuff,debuff = _debuffFromTable(unit,roots);
	if hasdebuff then return true; end
end

function _rootRemains(unit)
	if not ObjectIsVisible(unit) then return 0; end
	local debuffs = _debuffFromTable(unit,roots,true);
	table.sort(debuffs,function(x,y) return x > y end);
	return debuffs[1] or 0;
end

function _shouldFreedom(unit)
	local lessDelay = minDelayTime / 4.2;
	local isdps = _isMeleeDps(unit)
	local ishealer = _isHealer(unit)
	--Dispelling Roots--
	if isdps and not _CCcheck(unit) then
		for i=1,#rootList do
			if UnitDebuffID(unit,rootList[i]) and _debuffRemains(unit,rootList[i]) > 1.8 then
				return rootList[i];
			end
		end
		if _isSlowed(unit) then
			if (isdps and lowestEnemy < 30) or UnitBuffID(unit,221883) then
				return true;
			end
		end
	end
end

function SquidSac(unit)

	local t=unit or current_target

	if not UnitExists(t) then return false; end

	if UnitDebuffID(t,33786) then return false; end

	SQ_CastSpellByName("Blessing of Sacrifice",t);

end

local stealthIDs = {
	5215, --Prowl
	1784, --Stealth
	115191, --NEW Rogue Stealth
	114018, --Mass Stealth
	110960, --Mage Greater Invis
	115193, --vanish (old)
	119032, --Spectral Guise
	66, --Mage going invis
	198158, --Mass Invis
	188501,	--Spectral Sight (usually good to attack / sap)
	32612,	--new mage invis
	11327,	--vanish (new)
	
}
function _stealthCheck(unit)
	
	-- local buff = _buffFromTable(unit,stealthIDs);
	-- if buff then return buff; end

	local buffs = _buffFromTable(unit,stealthIDs,true,true)
	if buffs then
		table.sort(buffs,function(x,y) return x.r == -1 or x.r > y.r end)
	end

	if #buffs > 0 then
		return buffs[1].id ~= 0 and buffs[1].id or nil;
	end

end

local bigCD = {
--Death Knight
51271, --PillarOfFrost
--Druid
106951, --Berserk
102560, --Boomkin Incarnation
102543, --Feral Incarnation
112071, --Celestial Alignment
194223,	--Celestial Alignment
173562,	--Celestial Alignment
339943, -- Balance of All Things (bunch of crit)
--Hunter
193526, --Rapid Fire
186289, --Aspect of the Eagle
19574,	--Bestial Wrath
193530,	--Aspect of the Wild
--Mage
12472, --IcyVeins
12042, --Arcane Power
190319,	--Combustion
--Paladin
31884, --Wings
231895,	--Crusade
--Priest
10060, --Power Infusion
194249,	--Void Form
--Rouge
51713, --Shadow Dance
51690, --Killing Spree
13750, --AR
121471, --Shadow Blades
--Shaman
114050, --EleAscendance
114051, --EnhAscendance
16166, --ElementalMastery
2825, --Bloodlust
32182, --Heroism
--Warlock
196098,	--Soul Harvest
-- 216708, --Soul consume thing (This is up like 100% of the time, so no.)
--Warrior
1719, --Battle Cry
107574, --Avatar
248622,	--In for the kill
--Demon Hunter
162264, --Metamorphosis
206491,	--Nemesis
247938,	--Chaos Blades
--Windwalker
152173,	--Serenity
137639,	-- Storm, Earth, and Fire
}

function _CDcheck(unit)
	if not unit_is_player(unit) or _isHealer(unit) then return false end
	if enemy_chain_harvest and GetTime() - enemy_chain_harvest < 5 then
		if unit_is_unit(chain_harvest_pointer, unit) then
			return true
		end
	end
	local buffs = _buffFromTable(unit,bigCD)
	if buffs then return true; end
	-- if _buffStacks(unit,231895) >= 6 then return true; end
	if #BigCDTable > 0 then
		for i=1,#BigCDTable do
			local t = BigCDTable[i]
			local source=t.unit
			local dest=t.dest
			local cd=t.spell
			if UnitIsVisible(dest) and unit_is_unit(unit,source) then
				return UnitDebuffID(dest,cd)
			end
		end
	end
end

function _unitTargetMaxHP(unit)
	getUnit = UnitTarget(unit)
	unitHP = UnitHealth(getUnit)
	return unitHP
end

function _unitTargetHP(unit)
	getUnit = UnitTarget(unit)
	unitHP = UnitHealth(getUnit)
	return unitHP
end

function _targetLastTarget()
	if current_target then 
		return;
	else
		RunMacroText("/targetlasttarget")
	end
end
target_last_target = _targetLastTarget

azerite_power_cache = {}
function AzeritePowerTaken(powerid)
	if azerite_power_cache[powerid] then return azerite_power_cache[powerid] end
    local isSelected        
    for _, itemLocation in AzeriteUtil.EnumerateEquipedAzeriteEmpoweredItems() do
        isSelected = C_AzeriteEmpoweredItem.IsPowerSelected(itemLocation, powerid)
        azerite_power_cache[powerid] = isSelected
        if isSelected then return true end
    end
    return false
end

azerite_power_rank_cache = {}
function GetNumAzeritePowerTaken(powerid)
	if azerite_power_rank_cache[powerid] then return azerite_power_rank_cache[powerid] end
    local count = 0
    for _, itemLocation in AzeriteUtil.EnumerateEquipedAzeriteEmpoweredItems() do
        count = count + (C_AzeriteEmpoweredItem.IsPowerSelected(itemLocation, powerid) and 1 or 0)
    end
    azerite_power_rank_cache[powerid] = count
    return count
end

function FrendlyCooldownsUp()
	local count = 0
	for i=1,#Friends do
		if _CDcheck(Friends[i]) then
			count = count + 1
		end
	end
	return count
end

function squid_meteor(unit)
	if _spellCooldown(153561) > 1.25 then return false end
	local x,y,z = best_meteor_point(unit)
	if x and y and z then
		if player_casting_crittable_damage and meteor_cd == 0 and (not comubstion or player_cast_time_left > .5) then SpellStopCasting() end
		SQ_CastSpellByID(153561)
		if IsAoEPending() then
			ClickPosition(x,y,z)
			_targetLastTarget()
			Squid_Alert("Meteor",nil,nil,nil,153561)
		end
		return true
	end
end

function EnemiesAttacking(friend,role)
	local count=0
	local melee=0
	local range=0
	local cds=0
	for i=1,#Enemies do
		local e = Enemies[i]
		if (not arena or unit_is_player(e)) and _CCremains(e) < .25 and not _isHealer(e) then
			local r = arena and _isRangedDps(e) or UnitCastingInfo(e)
			local m = arena and _isMeleeDps(e) or not r

			local inrange
			if unit_is_unit(friend,"player") then
				if m then inrange = _distance(e) < 6 end
				if r then inrange = _distance(e) < 40 and _LoS(e) end
			else
				if m then inrange = _distance(friend,e) < 6 end
				if r then inrange = _distance(friend,e) < 40 and _LoS(friend,e) end
			end
			if inrange then
				if not role or (role == 1 and m) or (role == 2 and r) then
					local cd_up = _CDcheck(e)
					local enemytarget=UnitTarget(e)
					if unit_is_unit(friend,enemytarget) then
						count = count + 1
						melee = melee + (m and 1 or 0)
						range = range + (r and 1 or 0)
						cds = cds + (cd_up and 1 or 0)
					end
				end
			end
		end
	end
	return count,melee,range,cds
end

function UnitEnemiesAttacking(unit,role)
	local count=0
	local melee=0
	local range=0
	local cds=0
	-- if not unit then error("No unit specified (UnitEnemiesAttacking") return 0,0,0,0 end
	if unit_can_attack("player",unit) then
		for i=1,#Friends do if not unit_is_unit(Friends[i],"player") then
			local e = Friends[i]
			if (not arena or unit_is_player(e)) and not _isHealer(e) then
				local friend_target = UnitTarget(e)
				if unit_is_unit(unit,friend_target) then

					local m = _isMeleeDps(e)
					local r = _isRangedDps(e)

					local inrange = true
					-- if m then inrange = _distance(unit,e) < 6.5 end
					-- if r then inrange = _distance(unit,e) < 40 end

					if inrange and (_CCremains(e) < .5 or ccdoesntmatter) then
						if not role or (role == 1 and m) or (role == 2 and r) then
							local cd_up = _CDcheck(e)
							count = count + 1
							melee = melee + (m and 1 or 0)
							range = range + (r and 1 or 0)
							cds = cds + (cd_up and 1 or 0)
						end
					end
				end
			end
		end end
	elseif UnitIsFriend("player",unit) then
		return EnemiesAttacking(unit,role)
	end
	return count,melee,range,cds
end

function _isMoving(unit)
	return unit and GetUnitSpeed(unit) > 0 or false
end

function GetSpellRange(spellID)
	return select(6,GetSpellInfo(spellID)) or 0
end

function _spellInRange(spellid,unit,otherUnit)
	if not otherUnit then otherUnit = "player"; end
	if UnitIsVisible(unit) and (type(spellid) == "number" or IsUsableSpell(spellid)) then
		local spellRange = select(6,GetSpellInfo(spellid));
		--balance affinity fix
		spellRange = spellRange + (IsPlayerSpell(197488) and (spellRange == 0 and 8 or 4) or 0)
		--death sentence fix
		spellRange = spellRange + (spellid == 163201 and IsPlayerSpell(198500) and 10 or 0)

		--shadowstrike in stealth                                                              -- tooltip says 25y but it's more like 22.5
		if spellid == 185438 then
			spellRange = spellRange + ((UnitBuffID("player",1784) or UnitBuffID("player",115191)) and 22.5 or 0)
		end
		
		--kill command
		if spellid == 34026 then return true end
		-- print(spellRange, _distance(unit))
		if spellRange > 0 and _distance(unit,otherUnit) <= spellRange then
			return true;
		end
		if spellRange == 0 and _meleeRange(unit,otherUnit) then
			return true;
		end
	end
	return false;
end

trackedPlayers = {}
drReset = 19

drSpells = {
	
	--[[ DISORIENTS ]]--
	-- Covenant?
	[331866] = "disorient", -- Door of Shadows
	-- Druid
	[33786] = "disorient",  -- Cyclone
	--Paladin
	[105421] = "disorient", -- Blinding Light
	[10326] = "disorient", -- Turn Evil
	--Priest
	[8122] = "disorient", -- Psychic Scream
	-- [205369] = "disorient", -- Mind Bomb Pre-Explosion
	[226943]  = "disorient", -- Mind Bomb (New ID?)
	[605] = "disorient", -- Mind Control
	--Rogue
	[2094] = "disorient", -- Blind
	--Warlock
	[5782] = "disorient", --fear
	[118699] = "disorient", --fear fear
	[5484] = "disorient", -- Howl of Terror
	[6358] = "disorient", -- Seduction (Succubus)
	[115268] = "disorient", -- Mesmerize (Shivarra)
	--Warrior
	[5246] = "disorient", -- Intimidating Shout
	--Mage
	[31661] = "disorient", -- Dragon's Breath
	--Monk
	[198909] = "disorient",	-- Song of Chi Ji
	--Death Knight
	[207167] = "disorient", -- Blinding Sleet
	--[[ END DISORIENTS ]]--

	--[[ INCAPACITATE ]]--
	--Racial
	[107079] = "incapacitate", -- Quaking Palm
	--Druid
	[99] = "incapacitate", --Incapacitating Roar
	[2637] = "incapacitate", -- Hibernate
	--Hunter
	[3355] = "incapacitate", -- Freezing Trap
	[187650] = "incapacitate", -- Freezing Trap (Old?)
	[213691] = "incapacitate", -- Scatter Shot
	--Mage
	[118] = "incapacitate", -- Polymorph Sheep
	[28272] = "incapacitate", -- Polymorph (Pig)
	[277792] = "incapacitate", -- Polymorph (Bee)
	[161354] = "incapacitate", -- Polymorph (Monkey)
	[277787] = "incapacitate", -- Polymorph (Direhorn)
	[161355] = "incapacitate", -- Polymorph (Penguin)
	[161353] = "incapacitate", -- Polymorph (Polar Bear)
	[120140] = "incapacitate", -- Polymorph (Porcupine)
	[61305] = "incapacitate", -- Polymorph (Cat)
	[61025] = "incapacitate", -- Polymorph (Snake) (removed?)
	[61721] = "incapacitate", -- Polymorph (Rabbit)
	[61780] = "incapacitate", -- Polymorph (Turkey)
	[28271] = "incapacitate", -- Polymorph (Turtle)
	[161372] = "incapacitate", -- Polymorph (Peacock)
	[82691] = "incapacitate", -- Ring of Frost
	--Monk
	[123394] = "incapacitate", -- Glyph of Breath of Fire
	[115078] = "incapacitate", -- Paralysis
	--Paladin
	[20066] = "incapacitate", -- Repentance
	--Priest
	[200196] = "incapacitate", --Holy Word: Chastise
	--Rogue
	[1776] = "incapacitate", -- Gouge
	[6770] = "incapacitate", -- Sap
	--Shaman
	[51514] = "incapacitate", -- Hex
	[211015] = "incapacitate", -- Hex (Cockroach)
	[210873] = "incapacitate", -- Hex (Compy)
	[211010] = "incapacitate",	-- Hex (Snake)
	[211004] = "incapacitate",	-- Hex (Spider)
	[277784] = "incapacitate",	-- Hex (Wicker Mongrel)
	[277778] = "incapacitate",	-- Hex (Zandalari Tendonripper)
	[309328] = "incapacitate",	-- Hex (Living Honey)
	[269352] = "incapacitate",	-- Hex (Skeletal Raptor)
	--Warlock
	[710] = "incapacitate",   -- Banish ?
	[6789] = "incapacitate",	-- Mortal Coil
	--Demon Hunter
	[217832] = "incapacitate",  -- Imprison
	[221527] = "incapacitate",  -- Imprison (detainment)
	--[[ END INCAPACITATE]]--

	--[[ SILENCES ]]--
	-- Death Knight
	[47476] = "silence", -- Strangulate (removed?)
	-- Druid
	-- [81261] = "silence", -- Solar Beam, Doesn't DR
	-- Paladin
	[31935] = "silence", -- Avenger's Shield
	-- Priest
	[15487] = "silence", -- Silence
	-- Rogue
	[1330] = "silence", -- Garrote Silence
	-- Hunter
	[202933]  = "silence", -- Spider Sting
	--[[END SILENCES]]--

	--[[ STUNS ]]--
	-- Warrior
	[132168] = "stun", -- Shockwave
	[132169] = "stun", -- Storm Bolt 
	-- Death Knight
	[108194] = "stun", -- Asphyxiate
	[221562] = "stun", -- Asphyxiate (Blood)
	[91800] = "stun", -- Gnaw (Ghoul)
	[91797] = "stun", -- Monstrous Blow (Dark Transformation Ghoul)
	[210141]  = "stun", -- Zombie Explosion
	-- Druid
	[203123] = "stun", -- Maim
	[5211] = "stun", -- Mighty Bash
	[163505] = "stun", -- Rake (Stun from Prowl)
	-- Hunter
	[24394] = "stun", -- Intimidation
	-- Monk
	[119392] = "stun", -- Charging Ox Wave (talent)
	[119381] = "stun", -- Leg Sweep
	[120086] = "stun", -- Fists of Fury (Windwalker)
	-- Paladin
	[853] = "stun", -- Hammer of Justice
	[119072] = "stun", -- Holy Wrath (Protection)
	-- Rogue
	[1833] = "stun", -- Cheap Shot
	[408] = "stun", -- Kidney Shot
	-- [199804] = "stun", -- Between the eyes ( no longer a stun )
	-- Shaman
	[118905] = "stun", -- Static Charge (Capacitor Totem)
	[118345] = "stun", -- Pulverize
	-- Warlock
	[30283] = "stun", -- Shadowfury
	[89766] = "stun", -- Axe Toss (Felguard)
	-- Demon Hunter
	[179057] = "stun", -- Chaos Nova
	[191427] = "stun", -- Metamorphosis (Might not be a thing any more.)
	[211881] = "stun", -- Fel Eruption
	--Priest
	[200200] = "stun", -- Censure Chastise
	[64044] = "stun", -- Psychic Horror (Stun effect)
	-- Tauren
	[20549] = "stun", -- War Stomp
	--[[ END STUNS ]]--

	--Roots-
	[339] = "root",    -- Entangling Roots
	[102359] = "root",   -- Mass Entanglement
	[136634] = "root",   -- Narrow Escape
	[122] = "root",    -- Frost Nova
	[33395] = "root",    -- Mage Pet Freeze
	[111340] = "root",   -- Ice Ward
	[114404] = "root",   -- Void Tendril's Grasp
	[64695] = "root",    -- Earthgrab (Earthgrab Totem)
	[63685] = "root",    -- Freeze (Frozen Power)
	[107566] = "root",   -- Staggering Shout
	[200108] = "root",   -- Ranger's Net (talent)
	[116706] = "root",   -- Disable (Monk)
	[235963] = "root",   -- Melee Roots (Earthen Grasp)
	[117526] = "root", -- Binding Shot (talent)

}

listDisorients = {
	-- Covenant
	331866, -- Door of Shadows
	-- Druid
	33786,  -- Cyclone
	--Paladin
	105421, -- Blinding Light
	10326, -- Turn Evil
	--Priest
	8122, -- Psychic Scream
	205369, -- Mind Bomb
	605, -- Mind Control
	--Rogue
	2094, -- Blind
	--Warlock
	5782, --fear
	118699, --fear fear
	5484, -- Howl of Terror
	6358, -- Seduction (Succubus)
	115268, -- Mesmerize (Shivarra)
	--Warrior
	5246, -- Intimidating Shout
	--Mage
	31661, -- Dragon's Breath
	--Monk
	198909,	-- Song of Chi Ji
	--Death Knight
	207167, -- Blinding Sleet
}

listIncapacitates = {
--Racial
	107079, -- Quaking Palm
	--Druid
	99, --Incapacitating Roar
	2637, -- Hibernate
	--Hunter
	3355, -- Freezing Trap
	187650, -- Freezing Trap (Old?)
	213691, -- Scatter Shot
	--Mage
	118, -- Polymorph Sheep
	28272, -- Polymorph (Pig)
	277792, -- Polymorph (Bee)
	161354, -- Polymorph (Monkey)
	277787, -- Polymorph (Direhorn)
	161355, -- Polymorph (Penguin)
	161353, -- Polymorph (Polar Bear)
	120140, -- Polymorph (Porcupine)
	61305, -- Polymorph (Cat)
	61025, -- Polymorph (Snake) (removed?)
	61721, -- Polymorph (Rabbit)
	61780, -- Polymorph (Turkey)
	28271, -- Polymorph (Turtle)
	161372, -- Polymorph (Peacock)
	82691, -- Ring of Frost
	--Monk
	123394, -- Glyph of Breath of Fire
	115078, -- Paralysis
	--Paladin
	20066, -- Repentance
	--Priest
	200196, --Holy Word: Chastise
	--Rogue
	1776, -- Gouge
	6770, -- Sap
	--Shaman
	51514, -- Hex
	211015, -- Hex (Cockroach)
	210873, -- Hex (Compy)
	211010,	-- Hex (Snake)
	211004,	-- Hex (Spider)
	277784,	-- Hex (Wicker Mongrel)
	277778,	-- Hex (Zandalari Tendonripper)
	309328,	-- Hex (Living Honey)
	269352,	-- Hex (Skeletal Raptor)
	--Warlock
	710,   -- Banish ?
	6789,	-- Mortal Coil
	--Demon Hunter
	217832,  -- Imprison
	221527,  -- Imprison (detainment)
}

listSilences = {
    -- Druid
  81261, -- Solar Beam
    -- Paladin
  31935, -- Avenger's Shield
    -- Priest
  15487, -- Silence
    -- Rogue
  1330, -- Garrote
}

listStuns = {
  --[[ STUNS ]]--
  -- Death Knight
  108194, -- Asphyxiate (talent)
  91800, -- Gnaw (Ghoul)
  91797, -- Monstrous Blow (Dark Transformation Ghoul)
  115001, -- Remorseless Winter (talent)
    -- Druid
  22570, -- Maim
  203123, -- Maim
  5211, -- Mighty Bash (talent)
  163505, -- Rake Stun
    -- Hunter
  24394, -- Intimidation
    -- Mage
  44572, -- Deep Freeze
    -- Monk
  119392, -- Charging Ox Wave (talent)
  119381, -- Leg Sweep (talent)
  120086, -- Fists of Fury (Windwalker)
    -- Paladin
  853, -- Hammer of Justice
  119072, -- Holy Wrath (Protection)
  105593, -- Fist of Justice (talent)
  -- Priest
  200200,	--Censure Chastise
  64044, -- Psychic Horror (Stun Effect)
    -- Rogue
  1833, -- Cheap Shot
  408, -- Kidney Shot
  199804, -- Between the eyes
    -- Shaman
  118905, -- Static Charge (Capacitor Totem)
  118345, -- Pulverize
  -- Warlock
  30283, -- Shadowfury
  89766, -- Axe Toss (Felguard)
  22703, -- Infernal Stun
    -- Warrior
  132168, -- Shockwave
  107570, -- Storm Bolt
  132169, -- Storm Bolt (New SpellID)
	-- Demon Hunter
  179057, -- Chaos Nova
  191427, -- Metamorphosis (Might not be a thing any more.)
  211881, -- Fel Eruption
    -- Tauren
  20549, -- War Stomp
}

listRoots = {

  339,    -- Entangling Roots
  102359,   -- Mass Entanglement
  136634,   -- Narrow Escape
  122,    -- Frost Nova
  33395,    -- Mage Pet Freeze
  111340,   -- Ice Ward
  114404,   -- Void Tendril's Grasp
  64695,    -- Earthgrab (Earthgrab Totem)
  63685,    -- Freeze (Frozen Power)
  107566,   -- Staggering Shout
  200108,   -- Ranger's Net (talent)
  116706,   -- Disable (Monk)
  235963,   -- Melee Roots (Earthen Grasp)
   117526, -- Binding Shot (talent)
}

-- DR Category names
drCategoryNames = {
  "stun",
  "disorient",
  "incapacitate",
  "silence",
  "root",
}

function _getDrSpellCategory(spellID)
  return spellID and drSpells[spellID] or nil;
end

function _nextDr(diminished)
  if diminished > 0.25 then return diminished / 2; end
  return 0;
end


function debuffGained(spellID,destName,destPointer)
	if not destPointer then return; end

	local drCat = _getDrSpellCategory(spellID)

	if not trackedPlayers[destPointer] then
		trackedPlayers[destPointer] = {}
		trackedPlayers[destPointer][drCat] = { reset = 0, diminished = 1.0 }
		return
	end

	local tracked = trackedPlayers[destPointer][drCat]

	if tracked and tracked.reset <= GetTime() then
		tracked.diminished = 1.0
		tracked.refresh = nil
	end

end

function debuffFaded(spellID,destName,destPointer)
	if not destPointer then return; end

	local drCat = _getDrSpellCategory(spellID)

	if not trackedPlayers[destPointer] then
		trackedPlayers[destPointer] = {}
	end

	if not trackedPlayers[destPointer][drCat] then
		trackedPlayers[destPointer][drCat] = { reset = 0, diminished = 1.0 }
	end

	local time = GetTime()
	local tracked = trackedPlayers[destPointer][drCat]

	tracked.reset = time + drReset
	tracked.diminished = _nextDr(tracked.diminished)
	tracked.refresh = nil

end

--FIXME6 - ask youness abt inting sheep -- add 2 comblog
function debuffRefresh(spellID,destName,destPointer)

	if not destPointer then return; end

	local drCat = _getDrSpellCategory(spellID)

	if not trackedPlayers[destPointer] then
		trackedPlayers[destPointer] = {}
		trackedPlayers[destPointer][drCat] = { reset = 0, diminished = 1 }
	end

	local tracked = trackedPlayers[destPointer][drCat]

	if tracked then
		tracked.diminished = _nextDr(tracked.diminished)
		tracked.refresh = true
	end
end

function _pulseResetDR()
  local time = GetTime()
  for i=1,#Enemies do
    if trackedPlayers[Enemies[i]] then
      for v=1,#drCategoryNames do
        if trackedPlayers[Enemies[i]][drCategoryNames[v]] then
          local tracked = trackedPlayers[Enemies[i]][drCategoryNames[v]];
          if tracked.reset < time and tracked.diminished ~= 1 and not tracked.refresh then
              tracked.diminished = 1;
              tracked.reset = 0;
          end
        end
      end
    end
  end
  for i=1,#Friends do
    if trackedPlayers[Friends[i]] then
      for v=1,#drCategoryNames do
        if trackedPlayers[Friends[i]][drCategoryNames[v]] then
          local tracked = trackedPlayers[Friends[i]][drCategoryNames[v]];
          if tracked.reset < time and tracked.diminished ~= 1 and not tracked.refresh then
              tracked.diminished = 1;
              tracked.reset = 0;
          end
        end
      end
    end
  end
end

-- function _clearSpellList()
--   for i=1,#spellList do
--     if not spellList[i] == false then
--       if UnitIsVisible(spellList[i].unit) then
--         if math.abs(spellList[i].time-GetTime()) > GetSpellBaseCooldown(spellList[i].spell)/1000 then
--           tremove(spellList,i);
--         end
--       end
--     end
--   end
-- end

function _disorientDR(pointer)
  if not UnitIsVisible(pointer) then return 0; end
  local dr=1;
  if trackedPlayers[pointer] and trackedPlayers[pointer]["disorient"] and trackedPlayers[pointer]["disorient"]["diminished"] then
    dr = trackedPlayers[pointer]["disorient"]["diminished"];
  end
  for i=1,#listDisorients do
    if UnitDebuffID(pointer,listDisorients[i]) then
      return dr/2;
    end
  end
  return dr;
end

function _incapacitateDR(pointer)
  if not UnitIsVisible(pointer) then return 0; end
  local dr=1;
  if trackedPlayers[pointer] and trackedPlayers[pointer]["incapacitate"] and trackedPlayers[pointer]["incapacitate"]["diminished"] then
    dr = trackedPlayers[pointer]["incapacitate"]["diminished"];
  end
  for i=1,#listIncapacitates do
    if UnitDebuffID(pointer,listIncapacitates[i]) then
      return dr/2;
    end
  end
  return dr;
end

function _silenceDR(pointer)
  if not UnitIsVisible(pointer) then return 0; end
  local dr=1;
  if trackedPlayers[pointer] and trackedPlayers[pointer]["silence"] and trackedPlayers[pointer]["silence"]["diminished"] then
    dr = trackedPlayers[pointer]["silence"]["diminished"];
  end
  for i=1,#listSilences do
    if UnitDebuffID(pointer,listSilences[i]) then
      return dr/2;
    end
  end
  return dr;
end

local dots =
{
--Death Knight--
55095, 		-- Frost Fever
55078, 		-- Blood Plague
115989,		-- Unholy Blight
155159,		-- Necrotic Plague
191587,		-- Virulent Plague
--Druid--
33745,		-- Lacerate
8921,		-- Moonfire
1079,		-- Rip
1822,		-- Rake
93402,		-- Sunfire
106830,		-- Thrash
77758,		-- Thrash
--Hunter--
13813,		-- Explosive Trap
118253,		-- Serpent Sting
3674,		-- Black Arrow
53301,		-- Explosive Arrow
--Mage--
113092,		-- Frost Bomb
114923,		-- Nether Tempest
44457,		-- Living Bomb
2136,		-- Fireblast
2120,		-- Flamestrike
11366,		-- Pyroblast
12846,		-- Ignite
155158,		-- Meteor Burn
--Monk--
128531,		-- Blackout Kick
123725,		-- Breath of Fire
--Paladin--
114917,		-- Execution Sentence
31801,		-- Censure
114916,		-- Execution Sentence
--Priest--
34914,		-- Vampiric Touch
2944,		-- Devouring Plague
14914,		-- Holy Fire
589,		-- Shadow Word: Pain
15407,		-- Mind Flay
204213,		-- Purge the Wicked
--Rogue--
122233,		-- Crimson Tempest
2823,		-- Deadly Poison
16511,		-- Hemorrhage
2818,		-- Deadly Poison
703,		-- Garrote
1943,		-- Rupture
--Shaman--
8050,		-- Flame Shock
--Warlock--
27243,		-- Seed of Corruption
980,		-- Agony
348,		-- Immolate
30108,		-- UA
131736,		-- UA
172,		-- Corruption
131740,		-- Corruption
131737,		-- Agony
75017,		-- Doom
64157,		-- Doom
70144,		-- Doom
69969,		-- Doom
63106,		-- Siphon life
205179,		-- Phantom Singularity
--Warrior--
115768,		-- Deep Wounds
113344,		-- BloodBath
}
function _hasDot(unit)
	local hasdebuff,debuff = _debuffFromTable(unit,dots);
	if hasdebuff then return true; end
	--meteor dropping
	if lastMeteor and GetTime()-lastMeteor < 3.5 then
		if lastMeteorSource and UnitIsVisible(lastMeteorSource) then
			if unit_can_attack(lastMeteorSource,unit) then
				return true;
			end
		end
	end
end

function DoNotBCC(unit)
	--immune
	if _immunePhysical(unit) then 
		return true; 
	end
	--cc'd
	if _CCremains(unit) > .2 then
		return true;
	end
	--meteor dropping
	if lastMeteor and GetTime()-lastMeteor < 3.5 then
		if lastMeteorSource and UnitIsVisible(lastMeteorSource) then
			if UnitIsFriend("player",lastMeteorSource) then
				return true;
			end
		end
	end
	--premonition used
	if premonitionUsed and GetTime()-premonitionUsed < 1.5 then
		if premonitionPointer and UnitIsVisible(premonitionPointer) and unit_can_attack("player",premonitionPointer) then
			return true;
		end
	end
	--sac out
	for i=1,#Enemies do
		if UnitBuffID(Enemies[i],6940) or UnitDebuffID(Enemies[i],6940) then
			return true;
		end
	end
end

function Squid_SingleTarget()

end

function DoNotSheep(unit)
	-- --premonition
	-- if premonitionUsed then
	-- 	local time_since_prem = time - premonitionUsed
	-- 	local time_til_prem_proc = 1.5-time_since_prem
	-- 	if player_cast_time_left < time_til_prem_proc then
	-- 		if premonitionPointer and UnitIsVisible(premonitionPointer) and unit_is_unit(player_cast_target,premonitionPointer) then
	-- 			Squid_Alert_Big("Stopcasting","(Premonition)",4,3,305498)
	-- 			SpellStopCasting()
	-- 		end
	-- 	end
	-- end

	--blessing of sac
	local sac_up
	local sac_source

	--small sac
	for i=1,#Enemies do 
		local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],6940)
		if buff then
			sac_up = true
			sac_source = source
		end
	end

	--big sac
	for i=1,#Enemies do 
		local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],199448)
		if buff then
			sac_up = true
			sac_source = source
		end
	end

	--casting on the healer
	if sac_up and unit_is_unit(unit,sac_source) then
		return true
	end

	--meteor
	if UnitDebuffID(unit,155158) then
		if PlayerCanBeKicked() then
			--still want to cast + cancel to bait kicks while they sit in meteor
		else
			return true
		end
	end

	--orb
	if _spellCooldown(198149) > 42.5 then
		if UnitDebuffID(unit,289308) then
			return true
		end
		for i=1,#AreaTriggers do
			local id = ObjectID(AreaTriggers[i])
			if id == 12740 and GetDistanceBetweenObjects(AreaTriggers[i],unit) < 6 then
				return true
			end
		end
	end

	--already in other cc
	-- if UnitIsVisible(player_cast_target) then

	-- 	if _CCremains(player_cast_target) > 6 then

	-- 		return true

	-- 	end

	-- end
	
	--war banner
	if UnitBuffID(unit,236321) then
		return true
	end
end

function _rakeStunned(unit)
    
    local rakes = 0

    local cache = unit_debuff_cache[unit]

	if not cache then
		unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
		cache = unit_debuff_cache[unit]
		for i=1,#cache do
			local name = cache[i][1]
			if name == "Rake" then
				rakes = rakes + 1
			end
		end
	else
		local cache = unit_debuff_cache[unit]
		for i=1,#cache do
			local name = cache[i][1]
			if name == "Rake" then
				rakes = rakes + 1
			end
		end
	end

    if rakes >= 2 then return true end

end

function _rakeStunRemains(unit)
   
    local rakes = 0

    local cache = unit_debuff_cache[unit]
	if not cache then
		unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
		cache = unit_debuff_cache[unit]
		for i=1,#cache do
			local name = cache[i][1]
			if name == "Rake" then
				rakes = rakes + 1
			end
		end
	else
		local cache = unit_debuff_cache[unit]
		for i=1,#cache do
			local name = cache[i][1]
			if name == "Rake" then
				rakes = rakes + 1
			end
		end
	end

    if rakes >= 2 then
    	local time = GetTime()
    	if cache then
    		for i=1,#cache do
				local name,id,end_time = cache[i][1],cache[i][10],cache[i][6]
				if id == 163505 and time - end_time < 4 then
					return end_time - time
				end
			end
		end
	end

	return 0

end

--stunremains
local stuns ={
-----------------------
--[[ CONTROL STUNS ]]--
-----------------------
-- Death Knight
108194, -- Asphyxiate (talent)
91800, -- Gnaw (Ghoul)
91797, -- Monstrous Blow (Dark Transformation Ghoul)
-- Druid
22570, -- Maim
203123,	-- maim
5211, -- Mighty Bash (talent)
113801, -- Bash (treants in feral spec) (Bugged by blizzard - it instantly applies all 3 levels of DR right now, making any target instantly immune to ctrlstuns)
-- Hunter
24394, -- Intimidation
50519, -- Sonic Blast (Bat)
-- Mage
44572, -- Deep Freeze
157997, -- New ice nova
-- Monk
119392, -- Charging Ox Wave (talent)
119381, -- Leg Sweep (talent)
120086, -- Fists of Fury (Windwalker)
-- Paladin
853, -- Hammer of Justice
119072, -- Holy Wrath (Protection)
105593, -- Fist of Justice (talent)
-- Rogue
1833, -- Cheap Shot
408, -- Kidney Shot
199804, -- Between the eyes
-- Shaman
118905, -- Static Charge (Capacitor Totem)
-- Warlock
30283, -- Shadowfury
89766, -- Axe Toss (Felguard)
22703, -- Infernal Awakening (Infernal)
-- Warrior
132168, -- Shockwave
132169,	-- Storm Bolt
-- Demon Hunter
179057, -- Chaos Nova
191427, -- Metamorphosis
211881, -- Fel Eruption
-- Priest
200200,	--Censure Chastise
-- Tauren
20549 -- War Stomp
}

function _stunRemains(unit)
	if not unit then return 0; end
	local cconunit = {};
	local debuffs = _debuffFromTable(unit,stuns,true);
	local r = _rakeStunRemains(unit)
    if r>0 then
    	table.insert(debuffs,r);
    end
    table.sort(debuffs,function(x,y) return x > y end);
	return debuffs[1] or 0;
end


function _stunDR(pointer)
  if not pointer then return 0; end
  local dr=1;
  if trackedPlayers[pointer] and trackedPlayers[pointer]["stun"] and trackedPlayers[pointer]["stun"]["diminished"] then
    dr = trackedPlayers[pointer]["stun"]["diminished"]
  end
  for i=1,#listStuns do
    if UnitDebuffID(pointer,listStuns[i]) and (listStuns[i] ~= 163505 or _rakeStunned(pointer)) then
      return dr/2;
    end
  end
  return dr;
end

function _rootDR(pointer)
  if not pointer then return 0; end
  local dr=1;
  if trackedPlayers[pointer] and trackedPlayers[pointer]["root"] and trackedPlayers[pointer]["root"]["diminished"] then
    dr = trackedPlayers[pointer]["root"]["diminished"];
  end
  for i=1,#listRoots do
    if UnitDebuffID(pointer,listRoots[i]) and (listRoots[i] ~= 116706 or select(11,UnitDebuffID(pointer,116706)) ~= 116095) then
      return dr/2;
    end
  end
  return dr;
end

function _incapacitateCheck(unit)
	local debuffs = _debuffFromTable(unit,listIncapacitates,true,true)
	if debuffs then
		table.sort(debuffs,function(x,y) return x.r > y.r end)
	end
	if #debuffs > 0 then
		return debuffs[1].id ~= 0 and debuffs[1].id or nil;
	end
end

function incapacitate_remains(unit)
	local debuffs = _debuffFromTable(unit,listIncapacitates,true,true)
	table.sort(debuffs,function(x,y) return x.r > y.r end)
	return debuffs[1].r, debuffs[1].id
end

function _disorientCheck(unit)
	local debuffs = _debuffFromTable(unit,listDisorients,true,true)
	if debuffs then
		table.sort(debuffs,function(x,y) return x.r > y.r end)
	end
	if #debuffs > 0 then
		return debuffs[1].id ~= 0 and debuffs[1].id or nil;
	end
end

function _stunCheck(unit)
	local debuffs = _debuffFromTable(unit,listStuns,true,true)
	if debuffs then
		table.sort(debuffs,function(x,y) return x.r > y.r end)
	end
	if #debuffs > 0 then
		return debuffs[1].id ~= 0 and debuffs[1].id or nil;
	end
end

function _silenceCheck(unit)
	local debuffs = _debuffFromTable(unit,listSilences,true,true)
	if debuffs then
		table.sort(debuffs,function(x,y) return x.r > y.r end)
	end
	if #debuffs > 0 then
		return debuffs[1].id ~= 0 and debuffs[1].id or nil;
	end
end

function _drRemains(pointer,drType)
  	if not pointer then return 0; end
  	local remaining = 0;
  	if trackedPlayers[pointer] and trackedPlayers[pointer][drType] and trackedPlayers[pointer][drType].reset then
	    if trackedPlayers[pointer][drType].reset >= GetTime() then
		 	remaining = trackedPlayers[pointer][drType].reset - GetTime();
	  	end
	end
	if remaining == 0 or remaining > 12 then
		if drType == "incapacitate" and _incapacitateCheck(pointer) then
			remaining = drReset
		end
		if drType == "disorient" and _disorientCheck(pointer) then
			remaining = drReset
		end
		if drType == "stun" and _stunCheck(pointer) then
			remaining = drReset
		end
		if drType == "silence" and _silenceCheck(pointer) then
			remaining = drReset
		end
	end
	return remaining;
end

function GetCurrentSnapshot(spell)
	
	local power = 1

	--tiger's fury
	power = power + (UnitBuffID("player",5217) and .15 or 0)
	--bloodtalons
	power = power + (UnitBuffID("player",145152) and .25 or 0)
	--prowl
	power = power + ((spell == 1822 and (was_stealth or UnitBuffID("player",102543)) and .6) or 0)
	--subterfuge / stealth (with shrouded suffocation)
	power = power + ((AzeritePowerTaken(408) and (was_stealth or UnitBuffID("player",115192))) and 1 or 0)

	return power

end

unit_creature_id_cache = {}

function UnitCreatureID (UnitID)

	--caches creature ids
	if unit_creature_id_cache[UnitID] then return unit_creature_id_cache[UnitID] end

	local Parts = {};
	if not UnitGUID(UnitID) then return nil; end
	for Part in string.gmatch(UnitGUID(UnitID), "([^-]+)") do
		table.insert(Parts, Part);
	end
	if Parts[1] == "Creature" then
		local id = tonumber(Parts[6]);
		unit_creature_id_cache[UnitID] = id
		return id
	elseif Parts[1] == "Vehicle" then
		local id = tonumber(Parts[6]);
		unit_creature_id_cache[UnitID] = id
		return id
	elseif Parts[1] == "Pet" then
		local id = tonumber(Parts[6]);
		unit_creature_id_cache[UnitID] = id
		return id
	else
		return nil;
	end
end

function UnitHasDefensive(unit)
	--mage
	--warrior
	--rogue
	--druid
	--monk
	--pally
	--priest
	--shaman
	--warlock
	--hunter
	--dh
end

is_dummy_cache = {}

local dummies = {
-- Misc/Unknown
	[79987]  = "Training Dummy", 	          -- Location Unknown
	[92169]  = "Raider's Training Dummy",     -- Tanking (Eastern Plaguelands)
	[96442]  = "Training Dummy", 			  -- Damage (Location Unknown)
	[109595] = "Training Dummy",              -- Location Unknown
	[113963] = "Raider's Training Dummy", 	  -- Damage (Location Unknown)
	[131985] = "Dungeoneer's Training Dummy", -- Damage (Zuldazar)
	[131990] = "Raider's Training Dummy",     -- Tanking (Zuldazar)
	[132976] = "Training Dummy", 			  -- Morale Booster (Zuldazar)
-- Level 1
	[17578]  = "Hellfire Training Dummy",     -- Lvl 1 (The Shattered Halls)
	[60197]  = "Training Dummy",              -- Lvl 1 (Scarlet Monastery)
	[64446]  = "Training Dummy",              -- Lvl 1 (Scarlet Monastery)
	[144077] = "Training Dummy",              -- Lvl 1 (Dazar'alor) - Morale Booster
-- Level 3
	[44171]  = "Training Dummy",              -- Lvl 3 (New Tinkertown, Dun Morogh)
	[44389]  = "Training Dummy",              -- Lvl 3 (Coldridge Valley)
	[44848]  = "Training Dummy", 			  -- Lvl 3 (Camp Narache, Mulgore)
	[44548]  = "Training Dummy",              -- Lvl 3 (Elwynn Forest)
	[44614]  = "Training Dummy",              -- Lvl 3 (Teldrassil, Shadowglen)
	[44703]  = "Training Dummy", 			  -- Lvl 3 (Ammen Vale)
	[44794]  = "Training Dummy", 			  -- Lvl 3 (Dethknell, Tirisfal Glades)
	[44820]  = "Training Dummy",              -- Lvl 3 (Valley of Trials, Durotar)
	[44937]  = "Training Dummy",              -- Lvl 3 (Eversong Woods, Sunstrider Isle)
	[48304]  = "Training Dummy",              -- Lvl 3 (Kezan)
-- Level 55
	[32541]  = "Initiate's Training Dummy",   -- Lvl 55 (Plaguelands: The Scarlet Enclave)
	[32545]  = "Initiate's Training Dummy",   -- Lvl 55 (Eastern Plaguelands)
-- Level 60
	[32666]  = "Training Dummy",              -- Lvl 60 (Siege of Orgrimmar, Darnassus, Ironforge, ...)
-- Level 65
	[32542]  = "Disciple's Training Dummy",   -- Lvl 65 (Eastern Plaguelands)
-- Level 70
	[32667]  = "Training Dummy",              -- Lvl 70 (Orgrimmar, Darnassus, Silvermoon City, ...)
-- Level 75
	[32543]  = "Veteran's Training Dummy",    -- Lvl 75 (Eastern Plaguelands)
-- Level 80
	[31144]  = "Training Dummy",              -- Lvl 80 (Orgrimmar, Darnassus, Ironforge, ...)
	[32546]  = "Ebon Knight's Training Dummy",-- Lvl 80 (Eastern Plaguelands)
-- Level 85
	[46647]  = "Training Dummy",              -- Lvl 85 (Orgrimmar, Stormwind City)
-- Level 90
	[67127]  = "Training Dummy",              -- Lvl 90 (Vale of Eternal Blossoms)
-- Level 95
	[79414]  = "Training Dummy",              -- Lvl 95 (Broken Shore, Talador)
-- Level 100
	[87317]  = "Training Dummy",              -- Lvl 100 (Lunarfall, Frostwall) - Damage
	[87321]  = "Training Dummy",              -- Lvl 100 (Stormshield) - Healing
	[87760]  = "Training Dummy",              -- Lvl 100 (Frostwall) - Damage
	[88289]  = "Training Dummy",              -- Lvl 100 (Frostwall) - Healing
	[88316]  = "Training Dummy",              -- Lvl 100 (Lunarfall) - Healing
	[88835]  = "Training Dummy",              -- Lvl 100 (Warspear) - Healing
	[88906]  = "Combat Dummy",                -- Lvl 100 (Nagrand)
	[88967]  = "Training Dummy",              -- Lvl 100 (Lunarfall, Frostwall)
	[89078]  = "Training Dummy",              -- Lvl 100 (Frostwall, Lunarfall)
-- Levl 100 - 110
	[92164]  = "Training Dummy", 			  -- Lvl 100 - 110 (Dalaran) - Damage
	[92165]  = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 (Eastern Plaguelands) - Damage
	[92167]  = "Training Dummy",              -- Lvl 100 - 110 (The Maelstrom, Eastern Plaguelands, The Wandering Isle)
	[92168]  = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 (The Wandering Isles, Easter Plaguelands)
	[100440] = "Training Bag", 				  -- Lvl 100 - 110 (The Wandering Isles)
	[100441] = "Dungeoneer's Training Bag",   -- Lvl 100 - 110 (The Wandering Isles)
	[102045] = "Rebellious Wrathguard",       -- Lvl 100 - 110 (Dreadscar Rift) - Dungeoneer
	[102048] = "Rebellious Felguard",         -- Lvl 100 - 110 (Dreadscar Rift)
	[102052] = "Rebellious Imp", 			  -- Lvl 100 - 110 (Dreadscar Rift) - AoE
	[103402] = "Lesser Bulwark Construct",    -- Lvl 100 - 110 (Hall of the Guardian)
	[103404] = "Bulwark Construct",           -- Lvl 100 - 110 (Hall of the Guardian) - Dungeoneer
	[107483] = "Lesser Sparring Partner",     -- Lvl 100 - 110 (Skyhold)
	[107555] = "Bound Void Wraith",           -- Lvl 100 - 110 (Netherlight Temple)
	[107557] = "Training Dummy",              -- Lvl 100 - 110 (Netherlight Temple) - Healing
	[108420] = "Training Dummy",              -- Lvl 100 - 110 (Stormwind City, Durotar)
	[111824] = "Training Dummy", 			  -- Lvl 100 - 110 (Azsuna)
	[113674] = "Imprisoned Centurion",        -- Lvl 100 - 110 (Mardum, the Shattered Abyss) - Dungeoneer
	[113676] = "Imprisoned Weaver", 	      -- Lvl 100 - 110 (Mardum, the Shattered Abyss)
	[113687] = "Imprisoned Imp",              -- Lvl 100 - 110 (Mardum, the Shattered Abyss) - Swarm
	[113858] = "Training Dummy",              -- Lvl 100 - 110 (Trueshot Lodge) - Damage
	[113859] = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 (Trueshot Lodge) - Damage
	[113862] = "Training Dummy",              -- Lvl 100 - 110 (Trueshot Lodge) - Damage
	[113863] = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 (Trueshot Lodge) - Damage
	[113871] = "Bombardier's Training Dummy", -- Lvl 100 - 110 (Trueshot Lodge) - Damage
	[113966] = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 - Damage
	[113967] = "Training Dummy",              -- Lvl 100 - 110 (The Dreamgrove) - Healing
	[114832] = "PvP Training Dummy",          -- Lvl 100 - 110 (Stormwind City)
	[114840] = "PvP Training Dummy",          -- Lvl 100 - 110 (Orgrimmar)
-- Level 102
	[87318]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Lunarfall) - Damage
	[87322]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Stormshield) - Tank
	[87761]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Frostwall) - Damage
	[88288]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Frostwall) - Tank
	[88314]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Lunarfall) - Tank
	[88836]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Warspear) - Tank
	[93828]  = "Training Dummy",              -- Lvl 102 (Hellfire Citadel)
	[97668]  = "Boxer's Trianing Dummy",      -- Lvl 102 (Highmountain)
	[98581]  = "Prepfoot Training Dummy",     -- Lvl 102 (Highmountain)
-- Level 110 - 120
	[126781] = "Training Dummy", 			  -- Lvl 110 - 120 (Boralus) - Damage
	[131989] = "Training Dummy", 			  -- Lvl 110 - 120 (Boralus) - Damage
	[131994] = "Training Dummy", 			  -- Lvl 110 - 120 (Boralus) - Healing
	[144082] = "Training Dummy",              -- Lvl 110 - 120 (Dazar'alor) - PVP Damage
	[144085] = "Training Dummy", 			  -- Lvl 110 - 120 (Dazar'alor) - Damage
	[144081] = "Training Dummy",              -- Lvl 110 - 120 (Dazar'alor) - Damage
	[153285] = "Training Dummy", 			  -- Lvl 110 - 120 (Ogrimmar) - Damage
	[153292] = "Training Dummy", 			  -- Lvl 110 - 120 (Stormwind) - Damage
-- Level 111 - 120
	[131997] = "Training Dummy", 			  -- Lvl 111 - 120 (Boralus, Zuldazar) - PVP Damage
	[131998] = "Training Dummy",              -- Lvl 111 - 120 (Boralus, Zuldazar) - PVP Healing
-- Level 112 - 120
	[144074] = "Training Dummy", 			  -- Lvl 112 - 120 (Dazar'alor) - PVP Healing
-- Level 112 - 122
	[131992] = "Dungeoneer's Training Dummy",  -- Lvl 112 - 122 (Boralus) - Tanking
-- Level 113 - 120 
	[132036] = "Training Dummy", 			  -- Lvl 113 - 120 (Boralus) - Healing
-- Level 113 - 122
	[144078] = "Dungeoneer's Training Dummy", -- Lvl 113 - 122 (Dazar'alor) - Tanking
-- Level 114 - 120
	[144075] = "Training Dummy", 			  -- Lvl 114 - 120 (Dazar'alor) - Healing
-- Level ??
	[24792]  = "Advanced Training Dummy",     -- Lvl ?? Boss (Location Unknown)
	[30527]  = "Training Dummy", 		      -- Lvl ?? Boss (Location Unknown)
	[31146]  = "Raider's Training Dummy",     -- Lvl ?? (Orgrimmar, Stormwind City, Ironforge, ...)
	[87320]  = "Raider's Training Dummy",     -- Lvl ?? (Lunarfall, Stormshield) - Damage
	[87329]  = "Raider's Training Dummy",     -- Lvl ?? (Stormshield) - Tank
	[87762]  = "Raider's Training Dummy",     -- Lvl ?? (Frostwall, Warspear) - Damage
	[88837]  = "Raider's Training Dummy",     -- Lvl ?? (Warspear) - Tank
	[92166]  = "Raider's Training Dummy",     -- Lvl ?? (The Maelstrom, Dalaran, Eastern Plaguelands, ...) - Damage
	[101956] = "Rebellious Fel Lord",         -- lvl ?? (Dreadscar Rift) - Raider
	[103397] = "Greater Bulwark Construct",   -- Lvl ?? (Hall of the Guardian) - Raider
	[107202] = "Reanimated Monstrosity", 	  -- Lvl ?? (Broken Shore) - Raider
	[107484] = "Greater Sparring Partner",    -- Lvl ?? (Skyhold)
	[107556] = "Bound Void Walker",           -- Lvl ?? (Netherlight Temple) - Raider
	[113636] = "Imprisoned Forgefiend",       -- Lvl ?? (Mardum, the Shattered Abyss) - Raider
	[113860] = "Raider's Training Dummy",     -- Lvl ?? (Trueshot Lodge) - Damage
	[113864] = "Raider's Training Dummy",     -- Lvl ?? (Trueshot Lodge) - Damage
	[70245]  = "Training Dummy",              -- Lvl ?? (Throne of Thunder)
	[113964] = "Raider's Training Dummy",     -- Lvl ?? (The Dreamgrove) - Tanking
	[131983] = "Raider's Training Dummy",     -- Lvl ?? (Boralus) - Damage
	[144086] = "Raider's Training Dummy",     -- Lvl ?? (Dazal'alor) - Damage
	[164589] = "Flower Thing", 				  -- Flower thing after guy die
	[174569] = "Training Dummy",
	[174570] = "Swarm Training Dummy",
	[174571] = "Cleave Training Dummy",
	[174568] = "Dungeoneer's Training Dummy",
	[174567] = "Raider's Training Dummy",
	[174566] = "Dungeoneer's Tanking Dummy",
	[174565] = "Raider's Tanking Dummy",
	[175450] = "Raider's Training Dummy",

}

function _isDummy(unit)
	
	if not unit then return false end
	
	local cache = is_dummy_cache[unit]
	if cache ~= nil then return cache end
	
	local id = ObjectID(unit)

	if dummies[id] then
		is_dummy_cache[unit] = true
		return true
	else
		is_dummy_cache[unit] = false
		return false
	end

end

local combat_whitelist = {
    [98081] = "Bellowing Idol", -- Neltharian's Lair 
    [100818] = "Bellowing Idol",
    [133492] = "Corruption Corpuscle",
    [135016] = "Plague Amalgam",
    [131009] = "Spirit of Gold", --Atal
    [125828] = "Soulspawn", --Atal
    [127315] = "Reanimation Totem", -- Atal
    [134691] = "Static Charged Dervish", --Temple
    [147218] = "Spirit of Gold", --Opulence
    [148436] = "Barrier", --Jadefire Masters
    [148415] = "Barrier", --Jadefire Masters
    [147377] = "Barrier", --Jadefire Masters
    [147376] = "Barrier", --Jadefire Masters
    [147374] = "Barrier", --Jadefire Masters
    [147375] = "Barrier", --Jadefire Masters
    [146756] = "Energized Storm", --Jadefire Masters
    [146107] = "Living Bomb", -- Jadefire Masters
    [148522] = "Ice Block", --Jaina
    [148907] = "Prismatic Image", --Jaina
    [148716] = "Risen Soul", --M+ Reaping
    [148893] = "Tormented Soul", --M+ Reaping
    [148894] = "Lost Soul", --M+ Reaping
    [120651] = "Explosive", -- Explosive
    [137051] = "Ancient Mindbender", -- Shrine of Storms - Lord Stormsong
    [136330] = "Soul Thorns", -- Soul Thorns Waycrest Manor
    [133361] = "Wasting Servant", -- Waycrest Manor
    [134388] = "A Knot of Snakes", -- A Knot of Snakes ToS
    [153064] = "Overzealous Hulk", -- Overzealous Hulk
    [154240] = "Azshara's Devoted", -- Azshara's Devoted
    [155354] = "Azshara's Indomitable", -- Azshara's Indomitable
    [153194] = "Briny Bubble", -- Lady Ashvane Fight
    [150773] = "Shimmerskin Pufferfish", -- Shimmerskin Pufferfish
    [154174] = "Horrific Summoner", -- Za'qul
    [154175] = "Horrific Summoner", -- Za'qul
    [151581] = "Horrific Vision", -- Za'qul
    [151900] = "Horrific Summoner", -- Za'qul
    [155278] = "Shimmerskin Pufferfish", --EP Trash
    [158327] = "Crackling Shard", --Ny'alotha - Wrathion
    [158781] = "Shredded Psyche", -- Ny'alotha - Skitra
    [158343] = "Organ of Corruption", -- Ny'alotha - Il'gynoth
    [157612] = "Eye of Drest'agath", -- Ny'alotha - Drest'agath
    [157613] = "Maw of Drest'agath", -- Ny'alotha - Drest'agath
    [157461] = "Mycelial Cyst", -- Ny'alotha - Carapace
    [157475] = "Synthesis Growth", -- Ny'alotha - Carapace
    [158376] = "Psychus", -- Ny'alotha - N'zoth
    [158122] = "Mind's Eye", -- Ny'alotha - N'zoth
    [159578] = "Exposed Synapse", -- Ny'alotha - N'zoth
    [162331] = "Corrupted Neuron", -- Ny'alotha - N'zoth
    [158367] = "Basher Tentacle", -- Ny'alotha - N'zoth
    [158375] = "Corrupter Tentacle", -- Ny'alotha - N'zoth
    [157486] = "Horrific Hemorrhage", -- Ny'alotha - N'zoth
    [160249] = "Spike Tentacle", -- Ny'alotha - N'zoth
    [162933] = "Thought Harvester", -- Ny'alotha - N'zoth
	[161408] = "Malicious Growth", -- M+ S4 Affix
	[166608] = "Mueh'Zala", -- Mueh'Zala (De'Other Side)
	[168326] = "Shattered Visage", -- Shattered Visage (De'Other Side) 
}

local no_touch_units = {
    -- Jade Temple
    {unitID = 56448, buff = 106062}, -- Wise Mari with Bubble
    --Shadopan Monastery
    {unitID = 56747, buff = 110945}, -- Gu Cloudstrike with Charging Soul
    -- Iron Docks
    {unitID = 87451, buff = 164504, spell = 164426}, --Fleshrender Nok'gar, do not attack during defensive stance buff, Todo: Should stop when he cast 164504
    {unitID = 1, buff = 163689}, -- Never attack Sanguine Sphere
    {unitID = 105906, buff = 209915}, -- Don't attack The Eye of Il'gynoth when it has Stuff of Nightmares buff
    {unitID = 95887, buff = 194323}, -- Don't attack Glazer when he casts Focusing
    {unitID = 95888, buff = 205004}, -- Don't attack Cordana Felsong when she casts Vengeance
    {unitID = 95888, buff = 197422}, -- Don't attack Cordana Felsong when she casts Creeping Doom
    {unitID = 112956, buff = 225840}, -- Don't attack Shimmering Manaspine
    {unitID = 104154, buff = 206516}, -- Don't attack Gul'dan when he is in The Eye of Aman'Thul cage
    -- Nighthold: Mythic Spellblade - Fel Soul
    {unitID = 115905},
    -- Tomb of Sargeras
    {unitID = 116689, buff = 233441}, -- Don't attack Atrigan while Bonesaw
    {unitID = 116691, buff = 235230}, -- Don't attack Belac while Fel Squall
    {unitID = 117264, buff = -241008}, -- Don't attack Maiden of Valor unless Buff is Present *** negative buff value denotes not present ***
    -- BfA
    -- Uldir
    {unitID = 137119, buff = 271965}, -- Don't attack Taloc while Powered Down
    {unitID = 131227, buff = 260189}, -- Motherlode last boss flight
    {unitID = 136383, buff = 274230}, -- Mythrax immunity
    -- Battle of Dazar'alor
    {unitID = 144683, buff = 284436}, -- Champion of the Light (A), Ra'wani Kanae, Seal of Reckoning
    {unitID = 144680, buff = 284436}, -- Champion of the Light (H), Frida Ironbellows, Seal of Reckoning
    {unitID = 144942, buff = 289644}, -- Spark Bot,High Tinker Mekkatorque, Mythic 
    {unitID = 145644, buff = 284377}, -- Bwonsamdi with Unliving buff
    -- Freehold
    {unitID = 129448}, -- Shark Boss Shark
    {unitID = 129359}, -- Shark Boss Shark
    -- The Motherlode!
    {unitID = 129232, buff = 260189}, -- Mogul Razdunk with Configuration: Drill buff
    -- Underrot
    {unitID = 137458}, -- Rotting Spore
    -- Siege of Boralus
    {unitID = 128652}, -- Viq'Goth
    -- Atal'Dazar
    {unitID = 129399 , buff =250192}, -- Vol'kaal with Bad Voodoo buff
    -- Temple of Sethraliss
    {unitID = 133379, buff = 263246}, -- Adderis with Lightning Shield
    {unitID = 133944, buff = 263246}, -- Aspix with Lightning Shield
    -- Mechagon
    {unitID = 152703}, -- Walkie Shockie X1
    {buff = 296571}, -- Power Shield 99 % Dmg reduc
    -- Eternal Palace
    {unitID = 152364, buff = 295916}, -- Radiance of Azshara
    {unitID = 155434, buff = 302415}, -- Emissary of Tides Teleporting Home
    {unitID = 155432, buff = 302415}, -- Enchanted Emissary Teleporting Home
    {unitID = 155433, buff = 302415}, -- Void Touched Emissary Teleporting Home
    -- Mythic Za'qul
    {unitID = 150859, buff = 301117}, -- Dark Shield
    -- Eternal Palace
    {unitID = 155126, buff = 300620}, -- Crystalline Shield
    -- Ny'Alotha
    {unitID = 158041, buff = 310126}, -- N'Zoth 99% Shit
    -- Horrific Visions
    {unitID = 158315}, -- Eye of Chaos  
    -- Waycrest Manor
    {buff = 261265},   -- Witch Sisters Ironbark Shield 99% Dmg Reduc
    {buff = 261264},   -- Witch Sisters 99 % dmg red
    {buff = 261266},   -- Witch Sisters 99 % dmg red
    --Thing from Beyond
    {unitID = 161895},
}

local combat_whitelist_buffs = {
	292982,	-- https://www.wowhead.com/spell=292982/disciple-of-nzoth (SotS Mind Control)
	292981,	-- SotS Mind Control Secondary ID
}

function valid_attackable(unit)

	if not unit then return false end

	local solo_mode = SQUID.solo_mode_enabled

	--combat whitelist buffs
	if _debuffFromTable(unit,combat_whitelist_buffs) or _buffFromTable(unit,combat_whitelist_buffs) then return true end

	--object id
	local id = ObjectID(unit)

	--combat whitelist object ids
	if combat_whitelist[id] then return true end
	
	--no touch units
	local no_touch
	for i=1,#no_touch_units do
		local notouch = no_touch_units[i]
		if notouch.unitID == id or notouch.unitID == nil then
			local buff = notouch.buff 
    		if buff == nil then
    			no_touch = true
    		else
    			if UnitBuffID(unit,buff) then
    				no_touch = true
    			end
    		end
    	end
    end

    if no_touch then return false end

    --check combat / dummy
	if UnitAffectingCombat(unit) or ( _isDummy(unit) and UnitAffectingCombat("player") ) or ( solo_mode and unit_is_unit(unit,current_target) and (squid_ttd(unit) < 25 or Squid_Alert_Big("Please manually engage combat")) ) then
			
		return true

	end

end

function IsLocked(unit,remaining)
	if not remaining then
		for i=1,#kickTable do if unit_is_unit(kickTable[i].unit,unit) and not kickTable[i].juked then return true; end end
		return false;
	else
		for i=1,#kickTable do if unit_is_unit(kickTable[i].unit,unit) and not kickTable[i].juked then return kickTable[i].time - GetTime(); end end
		return 0;
	end
end

function UnitIsLocked(unit)
	local remaining = 0
	local locked 
	local school
	for i=1,#kickTable do 
		if unit_is_unit(kickTable[i].unit,unit) and not kickTable[i].juked then 
			remaining = kickTable[i].time - GetTime();
			locked = true
			school = kickTable[i].school
		end
	end
	return locked,remaining,school
end

-- function UnitLockoutRegistered(unit)
-- 	local time=GetTime()
-- 	if #kickTable == 0 then
-- 		return false;
-- 	else
-- 		for i=1,#kickTable do
-- 			if kickTable[i].unit == unit and (kickTable[i].time == time + 
-- end

function SpellRecentlyUsed(spell,window)
	local time=GetTime()
	for i=1,#PlayerSpellCasts do
		if time - PlayerSpellCasts[i].time <= window then
			if PlayerSpellCasts[i].name == spell or PlayerSpellCasts[i].id == spell then
				return true
			end
		end
	end
end

function recently_trinketed(unit, window)
	local time=GetTime()
	for i=1,#TrinketTracker do
		if time - TrinketTracker[i].time <= window then
			if unit_is_unit(unit,TrinketTracker[i].pointer) then
				return true
			end
		end
	end
end

function do_not_sap(unit)
    
    if unit_has_dot(unit) then return true end

    -- blessing of sac
	local sac_up
	local sac_source
	-- small sac
	for i=1,#Enemies do 
		local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],6940)
		if buff then
			sac_up = 6940
			sac_source = source
		end
	end
	-- big sac
	for i=1,#Enemies do 
		local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],199448)
		if buff then
			sac_up = 199448
			sac_source = source
		end
	end
	-- casting on the sac source
	if sac_up and unit_is_unit(unit,sac_source) then
		return sac_up
	end

	local aoe_debuffs = {
		155158, -- meteor burn
		289308,	-- orb
	}
	local aoe_debuff
	for i=1,#aoe_debuffs do
		if UnitDebuffID(unit,aoe_debuffs[i]) then
			aoe_debuff = aoe_debuffs[i]
			break
		end
	end

	-- aoe debuffs
	if aoe_debuff then
		return aoe_debuff
	end

	--war banner
	if UnitBuffID(unit,236321) then
		return 236321
	end

end

function do_not_blind(unit)
    
    -- blessing of sac
	local sac_up
	local sac_source
	-- small sac
	for i=1,#Enemies do 
		local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],6940)
		if buff then
			sac_up = 6940
			sac_source = source
		end
	end
	-- big sac
	for i=1,#Enemies do 
		local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],199448)
		if buff then
			sac_up = 199448
			sac_source = source
		end
	end
	-- casting on the sac source
	if sac_up and unit_is_unit(unit,sac_source) then
		return sac_up
	end

	local aoe_debuffs = {
		155158, -- meteor burn
		289308,	-- orb
	}
	local aoe_debuff
	for i=1,#aoe_debuffs do
		if UnitDebuffID(unit,aoe_debuffs[i]) then
			aoe_debuff = aoe_debuffs[i]
			break
		end
	end

	--war banner
	if UnitBuffID(unit,236321) then
		return 236321
	end

end

function Prev_GCD(count)
	if not count then count = 1 end
	local gcd_casts = { }
	for i=1,#PlayerSpellCasts do
		local cast = PlayerSpellCasts[i]
		if cast then
			local id = cast.id
			if IsSpellOnGCD(id) then
				table.insert(gcd_casts,id)
			end
		end
	end
	return gcd_casts[count]
end

function GetItemCD(itemID)
	if IsEquippedItem(itemID) then
		local start, duration = GetItemCooldown(itemID)
		if start and duration then
			if start == 0 and duration == 0 then return 0 end
			return duration - ( GetTime() - start )
		end
	end
	return math.huge
end

sq_cooldowns = {

	defensives = {

	},

	disruptive = {

	},

	cc = {

	},

    -- Death Knight
    [47528] = { default = true, duration = 15, class = "DEATHKNIGHT" }, -- Mind Freeze
    [48265] = { duration = 45, class = "DEATHKNIGHT" }, -- Death's Advance
    [48707] = { duration = 60, class = "DEATHKNIGHT" }, -- Anti-Magic Shell
    [49576] = { duration = 25, class = "DEATHKNIGHT", charges = 2 }, -- Death Grip
    [51052] = { duration = 120, class = "DEATHKNIGHT" }, -- Anti-Magic Zone
    [61999] = { duration = 600, class = "DEATHKNIGHT" }, -- Raise Ally
    [77606] = { duration = 20, class = "DEATHKNIGHT" }, -- Dark Simulacrum
    [212552] = { duration = 60, class = "DEATHKNIGHT" }, -- Wraith Walk

        -- Blood
        [43265] = { duration = 30, class = "DEATHKNIGHT", specID = { 250, 252 } }, -- Death and Decay
        [47476] = { duration = 60, class = "DEATHKNIGHT", specID = { 250 } }, -- Strangulate
        [49028] = { duration = 120, class = "DEATHKNIGHT", specID = { 250 } }, -- Dancing Rune Weapon
        [55233] = { duration = 90, class = "DEATHKNIGHT", specID = { 250 } }, -- Vampiric Blood
        [108199] = { duration = 120, class = "DEATHKNIGHT", specID = { 250 } }, -- Gorefiend's Grasp
        [194679] = { duration = 25, class = "DEATHKNIGHT", specID = { 250 }, charges = 2 }, -- Rune Tap
        [194844] = { duration = 60, class = "DEATHKNIGHT", specID = { 250 } }, -- Bonestorm
        [203173] = { duration = 15, class = "DEATHKNIGHT", specID = { 250 } }, -- Death Chain
        [205223] = { duration = 45, class = "DEATHKNIGHT", specID = { 250 } }, -- Consumption
        [206931] = { duration = 30, class = "DEATHKNIGHT", specID = { 250 } }, -- Blooddrinker
        [206977] = { duration = 120, class = "DEATHKNIGHT", specID = { 250 } }, -- Blood Mirror
        [219809] = { duration = 60, class = "DEATHKNIGHT", specID = { 250 } }, -- Tombstone
        [221562] = { duration = 45, class = "DEATHKNIGHT", specID = { 250, 252 } }, -- Asphyxiate (Blood)
            [108194] = { parent = 221562 }, -- Asphyxiate (Unholy)
        [221699] = { duration = 60, class = "DEATHKNIGHT", specID = { 250 }, charges = 2 }, -- Blood Tap

        -- Frost
        [47568] = { duration = 120, class = "DEATHKNIGHT", specID = { 251 }, charges = 2 }, -- Empower Rune Weapon
            [207127] = { parent = 47568 }, -- Hungering Rune Weapon
        [48792] = { duration = 180, class = "DEATHKNIGHT", specID = { 251, 252 } }, -- Icebound Fortitude
        [51271] = { duration = 45, class = "DEATHKNIGHT", specID = { 251 } }, -- Pillar of Frost
        [152279] = { duration = 120, class = "DEATHKNIGHT", specID = { 251} }, -- Breath of Sindragosa
        [196770] = { duration = 20, class = "DEATHKNIGHT", specID = { 251 } }, -- Remorseless Winter
        [204143] = { duration = 45, class = "DEATHKNIGHT", specID = { 251 } }, -- Killing Machine
        [204160] = { duration = 45, class = "DEATHKNIGHT", specID = { 251 } }, -- Chill Streak
        [207167] = { duration = 60, class = "DEATHKNIGHT", specID = { 251} }, -- Blinding Sleet
        [207256] = { duration = 90, class = "DEATHKNIGHT", specID = { 251} }, -- Obliteration
        [279302] = { duration = 180, class = "DEATHKNIGHT", specID = { 251} }, -- Frostwyrm's Fury

        -- Unholy
        [42650] = { duration = 480, class = "DEATHKNIGHT", specID = { 252 } }, -- Army of the Dead
        [63560] = { duration = 60, class = "DEATHKNIGHT", specID = { 252 } }, -- Dark Transformation
        [43265] = { duration = 30, class = "DEATHKNIGHT", specID = { 252 } }, -- Death and Decay
            [152280] = { parent = 43265 }, -- Defile
        [47481] = { duration = 90, class = "DEATHKNIGHT", specID = { 252 } }, -- Gnaw (Ghoul)
        [47482] = { duration = 30, class = "DEATHKNIGHT", specID = { 252 } }, -- Leap (Ghoul)
        [49206] = { duration = 180, class = "DEATHKNIGHT", specID = { 252 } }, -- Summon Gargoyle
            [207349] = { parent = 49206 }, -- Dark Arbiter
        [91802] = { duration = 30, class = "DEATHKNIGHT", specID = { 252 } }, -- Shambling Rush (Ghoul)
        [207289] = { duration = 120, class = "DEATHKNIGHT", specID = { 252 } }, -- Unholy Frenzy
        [207319] = { duration = 60, class = "DEATHKNIGHT", specID = { 252 } }, -- Corpse Shield
        [220143] = { duration = 90, class = "DEATHKNIGHT", specID = { 252 } }, -- Apocalypse

    -- Demon Hunter
    [179057] = { duration = 60, class = "DEMONHUNTER" }, -- Chaos Nova
    [183752] = { default = true, duration = 15, class = "DEMONHUNTER" }, -- Disrupt
    [188499] = { duration = 9, class = "DEMONHUNTER" }, -- Blade Dance
    [188501] = { duration = 30, class = "DEMONHUNTER" }, -- Spectral Sight
    [191427] = { duration = 105, class = "DEMONHUNTER" }, -- Metamorphosis
        [187827] = { parent = 191427, duration = 180 }, -- Metamorphosis (Vengeance)
        [162264] = { parent = 191427 }, -- Metamorphosis
    [196718] = { duration = 180, class = "DEMONHUNTER" }, -- Darkness
    [198013] = { duration = 30, class = "DEMONHUNTER" }, -- Eye Beam
    [198793] = { duration = 25, class = "DEMONHUNTER" }, -- Vengeful Retreat
    [203704] = { duration = 60, class = "DEMONHUNTER" }, -- Mana Break
    [205604] = { duration = 60, class = "DEMONHUNTER" }, -- Reverse Magic
    [206649] = { duration = 45, class = "DEMONHUNTER" }, -- Eye of Leotheras
    [206803] = { duration = 60, class = "DEMONHUNTER" }, -- Rain from Above
    [212800] = { duration = 60, class = "DEMONHUNTER" }, -- Blur
        [196555] = { parent = 212800, duration = 90 }, -- Netherwalk
    [214743] = { duration = 60, class = "DEMONHUNTER" }, -- Soul Carver
        [207407] = { parent = 214743 }, -- Soul Carver (Vengeance)
    [221527] = { duration = 45, class = "DEMONHUNTER" }, -- Imprison

        -- Havoc
        [201467] = { duration = 60, class = "DEMONHUNTER", specID = { 577 } }, -- Fury of the Illidari
        [206491] = { duration = 120, class = "DEMONHUNTER", specID = { 577 } }, -- Nemesis
        --[211048] = { duration = 120, class = "DEMONHUNTER", specID = { 577 } }, -- Chaos Blades
        [211881] = { duration = 30, class = "DEMONHUNTER", specID = { 577, 581 } }, -- Fel Eruption

        -- Vengeance
        [202137] = { duration = 60, class = "DEMONHUNTER", specID = { 581 } }, -- Sigil of Silence
        [202138] = { duration = 120, class = "DEMONHUNTER", specID = { 581 } }, -- Sigil of Chains
        [204021] = { duration = 60, class = "DEMONHUNTER", specID = { 581 } }, -- Fiery Brand
        [204596] = { duration = 30, class = "DEMONHUNTER", specID = { 581 } }, -- Sigil of Flame
        [205629] = { duration = 30,  class = "DEMONHUNTER", specID = { 581 } }, -- Demonic Trample
        [205630] = { duration = 90, class = "DEMONHUNTER", specID = { 581 } }, -- Illidan's Grasp
        [207684] = { duration = 90, class = "DEMONHUNTER", specID = { 581 } }, -- Sigil of Misery
        [207810] = { duration = 120, class = "DEMONHUNTER", specID = { 581 } }, -- Nether Bond
        --[218256] = { duration = 20, class = "DEMONHUNTER", specID = { 581 } }, -- Empower Wards
        [263648] = { duration = 20, class = "DEMONHUNTER", specID = { 581 } }, -- Soul Barrier

    -- Priest
    [586] = { duration = 30, class = "PRIEST" }, -- Fade
        [213602] = { parent = 586 }, -- Greater Fade
    [32375] = { duration = 45, class = "PRIEST" }, -- Mass Dispel

        -- Discipline
        [8122] = { duration = 30, class = "PRIEST", specID = { 256, 257, 258 } }, -- Psychic Scream
        [10060] = { duration = 120, class = "PRIEST", specID = { 256, 258 } }, -- Power Infusion
        [33206] = { duration = 180, class = "PRIEST", specID = { 256 } }, -- Pain Suppression
        [34433] = { duration = 180, class = "PRIEST", specID = { 256, 258 } }, -- Shadowfiend
            [123040] = { parent = 34433, duration = 60 }, -- Mindbender (Discipline)
            [200174] = { parent = 34433, duration = 60 }, -- Mindbender (Shadow)
        [47536] = { duration = 90, class = "PRIEST", specID = { 256 } }, -- Rapture
        [62618] = { duration = 180, class = "PRIEST", specID = { 256 } }, -- Power Word: Barrier
        [73325] = { duration = 90, class = "PRIEST", specID = { 256, 257, 258 } }, -- Leap of Faith
        [197862] = { duration = 60, class = "PRIEST", specID = { 256 } }, -- Archangel
        [197871] = { duration = 60, class = "PRIEST", specID = { 256 } }, -- Dark Archangel
        [204263] = { duration = 45, class = "PRIEST", specID = { 256, 257 } }, -- Shining Force
        [305498] = { duration = 12, class = "PRIEST", specID = { 256} }, -- Premonition

        -- Holy
        [19236] = { duration = 90, class = "PRIEST", specID = { 256, 257 } }, -- Desperate Prayer
        [47788] = { duration = 180, class = "PRIEST", specID = { 257 } }, -- Guardian Spirit
        [64843] = { duration = 180, class = "PRIEST", specID = { 257 } }, -- Divine Hymn
        [64901] = { duration = 300, class = "PRIEST", specID = { 257 } }, -- Symbol of Hope
        [196762] = { duration = 30, class = "PRIEST", specID = { 257 } }, -- Inner Focus
        [197268] = { duration = 60, class = "PRIEST", specID = { 257 } }, -- Ray of Hope
        [200183] = { duration = 120, class = "PRIEST", specID = { 257 } }, -- Apotheosis
        [213610] = { duration = 30, class = "PRIEST", specID = { 257 } }, -- Holy Ward
        [215769] = { duration = 300, class = "PRIEST", specID = { 257 } }, -- Spirit of Redemption

        -- Shadow
        [15286] = { duration = 120, class = "PRIEST", specID = { 258 } }, -- Vampiric Embrace
        [15487] = { duration = 45, class = "PRIEST", specID = { 258 } }, -- Silence
        [32379] = { duration = 9, class = "PRIEST", specID = { 258 }, charges = 2 }, -- Shadow Word: Death
        [47585] = { duration = 120, class = "PRIEST", specID = { 258 } }, -- Dispersion
        [64044] = { duration = 45, class = "PRIEST", specID = { 258 } }, -- Psychic Horror
        [108968] = { duration = 300, class = "PRIEST", specID = { 258 } }, -- Void Shift
        [193223] = { duration = 240, class = "PRIEST", specID = { 258 } }, -- Surrender to Madness
        [205065] = { duration = 45, class = "PRIEST", specID = { 258 } }, -- Void Torrent
        [205369] = { duration = 30, class = "PRIEST", specID = { 258 } }, -- Mind Bomb
        [211522] = { duration = 45, class = "PRIEST", specID = { 258 } }, -- Psyfiend

    -- Paladin
    [633] = { duration = 600, class = "PALADIN" }, -- Lay on Hands
    [642] = { duration = 300, class = "PALADIN" }, -- Divine Shield
    [853] = { duration = 60, class = "PALADIN" }, -- Hammer of Justice
    [1022] = { duration = 300, class = "PALADIN", charges = 2 }, -- Blessing of Protection
        [204018] = { parent = 1022, duration = 180 }, -- Blessing of Spellwarding
    [1044] = { duration = 25, class = "PALADIN", charges = 2 }, -- Blessing of Freedom
    [20066] = { duration = 15, class = "PALADIN" }, -- Repentance
    [31884] = { duration = 120, class = "PALADIN" }, -- Avenging Wrath
        [31842] = { parent = 31884 }, -- Avenging Wrath (Holy)
        [216331] = { parent = 31884 }, -- Avenging Crusader
        [224668] = { parent = 31884 }, -- Crusade
        [231895] = { parent = 31884 }, -- Crusade
    [115750] = { duration = 90, class = "PALADIN" }, -- Blinding Light

        -- Holy
        [498] = { duration = 60, class = "PALADIN", specID = { 65, 66 } }, -- Divine Protection
        [6940] = { duration = 120, class = "PALADIN", specID = { 65, 66 }, charges = 2 }, -- Blessing of Sacrifice
        [31821] = { duration = 180, class = "PALADIN", specID = { 65 } }, -- Aura Mastery
        [105809] = { duration = 90, class = "PALADIN", specID = { 65 } }, -- Holy Avenger
        [114158] = { duration = 60, class = "PALADIN", specID = { 65 } }, -- Light's Hammer
        [200652] = { duration = 90, class = "PALADIN", specID = { 65 } }, -- Tyr's Deliverance
        [210294] = { duration = 25, class = "PALADIN", specID = { 65 } }, -- Divine Favor
        [214202] = { duration = 30, class = "PALADIN", specID = { 65 }, charges = 2 }, -- Rule of Law

        -- Protection
        [31850] = { duration = 120, class = "PALADIN", specID = { 66 } }, -- Ardent Defender
        [31935] = { default = true, duration = 15, class = "PALADIN", specID = { 66 } }, -- Avenger's Shield
        [86659] = { duration = 300, class = "PALADIN", specID = { 66 } }, -- Guardian of Ancient Kings
            [228049] = { parent = 86659 }, -- Guardian of the Forgotten Queen
        [96231] = { default = true, duration = 15, class = "PALADIN", specID = { 66, 70 } }, -- Rebuke
        [152262] = { duration = 30, class = "PALADIN", specID = { 66 } }, -- Seraphim
        [190784] = { duration = 45, class = "PALADIN", specID = { 66 } }, -- Divine Steed
        [209202] = { duration = 60, class = "PALADIN", specID = { 66 } }, -- Eye of Tyr
        [215652] = { duration = 25, class = "PALADIN", specID = { 66 } }, -- Shield of Virtue

        -- Retribution
        [184662] = { duration = 120, class = "PALADIN", specID = { 70 } }, -- Shield of Vengeance
        [204939] = { duration = 60, class = "PALADIN", specID = { 70 } }, -- Hammer of Reckoning
        [205191] = { duration = 60, class = "PALADIN", specID = { 70 } }, -- Eye for an Eye
        [205273] = { duration = 45, class = "PALADIN", specID = { 70 } }, -- Wake of Ashes
        [210220] = { duration = 180, class = "PALADIN", specID = { 70 } }, -- Holy Wrath
        [210256] = { duration = 45, class = "PALADIN", specID = { 70 } }, -- Blessing of Sanctuary

    -- Druid
    [1850] = { duration = 120, class = "DRUID" }, -- Dash
        [252216] = { parent = 1850, duration = 45 }, -- Tiger Dash
    [5211] = { duration = 50, class = "DRUID" }, -- Mighty Bash
    [20484] = { duration = 600, class = "DRUID" }, -- Rebirth
    [102280] = { duration = 30, class = "DRUID" }, -- Displacer Beast
    [102359] = { duration = 30, class = "DRUID" }, -- Mass Entanglement
    [102401] = { duration = 15, class = "DRUID" }, -- Wild Charge
    [132469] = { duration = 30, class = "DRUID" }, -- Typhoon

        -- Balance
        [22812] = { duration = { default = 60, [104] = 35 }, class = "DRUID", specID = { 102, 104, 105 } }, -- Barkskin
        [29166] = { duration = 180, class = "DRUID", specID = { 102, 105 } }, -- Innervate
        [78675] = { default = true, duration = 60, class = "DRUID", specID = { 102 } }, -- Solar Beam
        [102560] = { duration = 180, class = "DRUID", specID = { 102 } }, -- Incarnation: Chosen of Elune
        [108238] = { duration = 120, class = "DRUID", specID = { 102, 103, 105 } }, -- Renewal
        [194223] = { duration = 180, class = "DRUID", specID = { 102 } }, -- Celestial Alignment
        [202425] = { duration = 45, class = "DRUID", specID = { 102 } }, -- Warrior of Elune
        [202770] = { duration = 60, class = "DRUID", specID = { 102 } }, -- Fury of Elune
        [205636] = { duration = 60, class = "DRUID", specID = { 102 } }, -- Force of Nature
        [209749] = { duration = 30, class = "DRUID", specID = { 102 } }, -- Faerie Swarm

        -- Feral
        [5217] = { duration = 30, class = "DRUID", specID = { 103 } }, -- Tiger's Fury
        [22570] = { duration = 20, class = "DRUID", specID = { 103 } }, -- Maim
        [61336] = { duration = { default = 180, [104] = 120 }, class = "DRUID", specID = { 103, 104 }, charges = 2 }, -- Survival Instincts
        [102543] = { duration = 180, class = "DRUID", specID = { 103 } }, -- Incarnation: King of the Jungle
        [106839] = { default = true, duration = 15, class = "DRUID", specID = { 103, 104 } }, -- Skull Bash
        [106898] = { duration = 120, class = "DRUID", specID = { 103, 104 } }, -- Stampeding Roar
        [106951] = { duration = 180, class = "DRUID", specID = { 103 } }, -- Berserk
        [202060] = { duration = 45, class = "DRUID", specID = { 103 } }, -- Elune's Guidance
        [203242] = { duration = 60, class = "DRUID", specID = { 103 } }, -- Rip and Tear
        [210722] = { duration = 75, class = "DRUID", specID = { 103 } }, -- Ashamane's Frenzy

        -- Guardian
        [99] = { duration = 30, class = "DRUID", specID = { 104 } }, -- Incapacitating Roar
        [22842] = { duration = 36, class = "DRUID", specID = { 104 } }, -- Frenzied Regeneration
        [102558] = { duration = 180, class = "DRUID", specID = { 104 } }, -- Incarnation: Guardian of Ursoc
        [200851] = { duration = 90, class = "DRUID", specID = { 104 } }, -- Rage of the Sleeper
        [202246] = { duration = 15, class = "DRUID", specID = { 104 } }, -- Overrun
        [204066] = { duration = 90, class = "DRUID", specID = { 104 } }, -- Lunar Beam

        -- Restoration
        [740] = { duration = 180, class = "DRUID", specID = { 105} }, -- Tranquility
        [18562] = { duration = 25, class = "DRUID", specID = { 105}, charges = 2 }, -- Swiftmend
        [33891] = { duration = 180, class = "DRUID", specID = { 105} }, -- Incarnation: Tree of Life
        [102342] = { duration = 60, class = "DRUID", specID = { 105} }, -- Ironbark
        [102351] = { duration = 30, class = "DRUID", specID = { 105} }, -- Cenarion Ward
        [102793] = { duration = 60, class = "DRUID", specID = { 105} }, -- Ursol's Vortex
        [197721] = { duration = 90, class = "DRUID", specID = { 105} }, -- Flourish
        [201664] = { duration = 60, class = "DRUID", specID = { 105} }, -- Demoralizing Roar
        [203651] = { duration = 45, class = "DRUID", specID = { 105} }, -- Overgrowth
        [236696] = { duration = 45, class = "DRUID", specID = { 102, 103, 105} }, -- Thorns
        [208253] = { duration = 90, class = "DRUID", specID = { 105} }, -- Essence of G'Hanir

    -- Warrior
    [100] = { duration = 20, class = "WARRIOR" }, -- Charge
        [198758] = { parent = 100, charges = 2 }, -- Intercept
    [1719] = { duration = 90, class = "WARRIOR" }, -- Recklessness
    [6544] = { duration = 30, class = "WARRIOR", charges = 2 }, -- Heroic Leap
    [6552] = { default = true, duration = 15, class = "WARRIOR" }, -- Pummel
    [18499] = { duration = 60, class = "WARRIOR" }, -- Berserker Rage
    [23920] = { duration = 25, class = "WARRIOR" }, -- Spell Reflection
        [213915] = { parent = 23920, duration = 30 }, -- Mass Spell Reflection
        [216890] = { parent = 23920 }, -- Spell Reflection (Arms, Fury)
    [46968] = { duration = 40, class = "WARRIOR" }, -- Shockwave
    [107570] = { duration = 30, class = "WARRIOR" }, -- Storm Bolt
    [107574] = { duration = 90, class = "WARRIOR" }, -- Avatar
    [236077] = { duration = 45, class = "WARRIOR" }, -- Disarm
        [236236] = { parent = 236077 }, -- Disarm (Protection)

        -- Arms
        [5246] = { duration = 90, class = "WARRIOR", specID = { 71, 72 } }, -- Intimidating Shout
        [97462] = { duration = 180, class = "WARRIOR", specID = { 71, 72, 73 } }, -- Rallying Cry
        [118038] = { duration = 180, class = "WARRIOR", specID = { 71 } }, -- Die by the Sword
        [167105] = { duration = 45, class = "WARRIOR", specID = { 71 } }, -- Colossus Smash
            [262161] = { parent = 167105 }, -- Warbreaker
        [197690] = { duration = 10, class = "WARRIOR", specID = { 71 } }, -- Defensive Stance
        [198817] = { duration = 45, class = "WARRIOR", specID = { 71 } }, -- Sharpen Blade
        [227847] = { duration = 60, class = "WARRIOR", specID = { 71, 72 } }, -- Bladestorm (Arms)
            [46924] = { parent = 227847 }, -- Bladestorm (Fury)
            [152277] = { parent = 227847 }, -- Ravager
        [236273] = { duration = 60 , class = "WARRIOR", specID = { 71 } }, -- Duel

        -- Fury
        [184364] = { duration = 120, class = "WARRIOR", specID = { 72 } }, -- Enraged Regeneration
        [205545] = { duration = 45, class = "WARRIOR", specID = { 72 } }, -- Odyn's Fury

        -- Protection
        [871] = { duration = 240, class = "WARRIOR", specID = { 73 } }, -- Shield Wall
        [1160] = { duration = 45, class = "WARRIOR", specID = { 73 } }, -- Demoralizing Shout
        [12975] = { duration = 180, class = "WARRIOR", specID = { 73 } }, -- Last Stand
        [118000] = { duration = 35, class = "WARRIOR", specID = { 73 } }, -- Dragon Roar
        [198304] = { duration = 20, class = "WARRIOR", specID = { 73 }, charges = 2 }, -- Intercept
        [206572] = { duration = 20, class = "WARRIOR", specID = { 73 } }, -- Dragon Charge
        [213871] = { duration = 15, class = "WARRIOR", specID = { 73 } }, -- Bodyguard
        [228920] = { duration = 60, class = "WARRIOR", specID = { 73 } }, -- Ravager

    -- Warlock
    [1122] = { duration = 180, class = "WARLOCK" }, -- Summon Infernal
    [6358] = { duration = 30, class = "WARLOCK" }, -- Seduction
        [115268] = { parent = 6358 }, -- Mesmerize
    [6360] = { duration = 25, class = "WARLOCK" }, -- Whiplash
        [115770] = { parent = 6360 }, -- Fellash
    [6789] = { duration = 45, class = "WARLOCK" }, -- Mortal Coil
    --[18540] = { duration = 180, class = "WARLOCK" }, -- Summon Doomguard
    [20707] = { duration = 600, class = "WARLOCK" }, -- Soulstone
    [30283] = { duration = 60, class = "WARLOCK" }, -- Shadowfury
    [104773] = { duration = 180, class = "WARLOCK" }, -- Unending Resolve
    [108416] = { duration = 60, class = "WARLOCK" }, -- Dark Pact
    [108501] = { duration = 90, class = "WARLOCK" }, -- Grimoire of Service
    [111896] = { duration = 90, class = "WARLOCK" }, -- Grimoire: Succubus
    [119910] = { default = true, duration = 24, class = "WARLOCK" }, -- Spell Lock (Command Demon)
        [19647] = { parent = 119910 }, -- Spell Lock (Felhunter)
        [119911] = { parent = 119910 }, -- Optical Blast (Command Demon)
        [115781] = { parent = 119910 }, -- Optical Blast (Observer)
        [132409] = { parent = 119910 }, -- Spell Lock (Grimoire of Sacrifice)
        [171138] = { parent = 119910 }, -- Shadow Lock (Doomguard)
        [171139] = { parent = 119910 }, -- Shadow Lock (Grimoire of Sacrifice)
        [171140] = { parent = 119910 }, -- Shadow Lock (Command Demon)
    [171152] = { duration = 60, class = "WARLOCK" }, -- Meteor Strike
    [196098] = { duration = 120, class = "WARLOCK" }, -- Soul Harvest
    [199890] = { duration = 15, class = "WARLOCK" }, -- Curse of Tongues
    [199892] = { duration = 20, class = "WARLOCK" }, -- Curse of Weakness
    [199954] = { duration = 45, class = "WARLOCK" }, -- Curse of Fragility
    [212295] = { duration = 45, class = "WARLOCK" }, -- Nether Ward
    [221703] = { duration = 30, class = "WARLOCK" }, -- Casting Circle

        -- Affliction
        [5484] = { duration = 40, class = "WARLOCK", specID = { 265 } }, -- Howl of Terror
        [48181] = { duration = 15, class = "WARLOCK", specID = { 265 } }, -- Haunt
        [86121] = { duration = 20, class = "WARLOCK", specID = { 265 } }, -- Soul Swap
        [113860] = { duration = 120, class = "WARLOCK", specID = { 265 } }, -- Dark Soul: Misery
        [205179] = { duration = 45, class = "WARLOCK", specID = { 265 } }, -- Phantom Singularity

        -- Demonology
        [89751] = { duration = 45, class = "WARLOCK", specID = { 266 } }, -- Felstorm
            [115831] = { parent = 89751 }, -- Wrathstorm
        [89766] = { duration = 30, class = "WARLOCK", specID = { 266 } }, -- Axe Toss
        [201996] = { duration = 90, class = "WARLOCK", specID = { 266 } }, -- Call Observer
        [205180] = { duration = 24, class = "WARLOCK", specID = { 266 } }, -- Summon Darkglare
        [205181] = { duration = 14, class = "WARLOCK", specID = { 266 }, charges = 2 }, -- Shadowflame
        [211714] = { duration = 45, class = "WARLOCK", specID = { 266 } }, -- Thal'kiel's Consumption
        [212459] = { duration = 90, class = "WARLOCK", specID = { 266 } }, -- Call Fel Lord
        [212619] = { duration = 24, class = "WARLOCK", specID = { 266 } }, -- Call Felhunter
        [212623] = { duration = 15, class = "WARLOCK", specID = { 266 } }, -- Singe Magic

        --  Destruction
        [17962] = { duration = 12, class = "WARLOCK", specID = { 267 }, charges = 2 }, -- Conflagrate
        [80240] = { duration = 30, class = "WARLOCK", specID = { 267 } }, -- Havoc
        [113858] = { duration = 120, class = "WARLOCK", specID = { 267 } }, -- Dark Soul: Instability
        [152108] = { duration = 45, class = "WARLOCK", specID = { 267 } }, -- Cataclysm
        [196447] = { duration = 15, class = "WARLOCK", specID = { 267 } }, -- Channel Demonfire
        [196586] = { duration = 45, class = "WARLOCK", specID = { 267 }, charges = 3 }, -- Dimensional Rift
        [212284] = { duration = 45, class = "WARLOCK", specID = { 267 } }, -- Firestone

    -- Shaman
    [2825] = { duration = 60, class = "SHAMAN" }, -- Bloodlust
        [32182] = { parent = 2825 }, -- Heroism
    [20608] = { duration = 1800, class = "SHAMAN" }, -- Reincarnation
    [51485] = { duration = 30, class = "SHAMAN" }, -- Earthgrab Totem
    [51514] = { duration = { default = 30, [264] = 10 }, class = "SHAMAN" }, -- Hex
        [196932] = { parent = 51514 }, -- Voodoo Totem
        [210873] = { parent = 51514 }, -- Hex (Compy)
        [211004] = { parent = 51514 }, -- Hex (Spider)
        [211010] = { parent = 51514 }, -- Hex (Snake)
        [211015] = { parent = 51514 }, -- Hex (Cockroach)
    [57994] = { default = true, duration = 12, class = "SHAMAN" }, -- Wind Shear
    [108271] = { duration = 90, class = "SHAMAN" }, -- Astral Shift
        [210918] = { parent = 108271, duration = 45 }, -- Ethereal Form
    [114049] = { duration = 180, class = "SHAMAN" }, -- Ascendance
        [114050] = { parent = 114050 }, -- Ascendance (Elemental)
        [114051] = { parent = 114050 }, -- Ascendance (Enhancement)
        [114052] = { parent = 114050 }, -- Ascendance (Restoration)
    [192058] = { duration = 60, class = "SHAMAN" }, -- Capacitor
    [192077] = { duration = 120, class = "SHAMAN" }, -- Wind Rush Totem
    [204330] = { duration = 45, class = "SHAMAN" }, -- Skyfury Totem
    [204331] = { duration = 45, class = "SHAMAN" }, -- Counterstrike Totem
    [204332] = { duration = 30, class = "SHAMAN" }, -- Windfury Totem

        -- Elemental
        [16166] = { duration = 120, class = "SHAMAN", specID = { 262 } }, -- Elemental Mastery
        [51490] = { duration = 45, class = "SHAMAN", specID = { 262 } }, -- Thunderstorm
        [108281] = { duration = 120, class = "SHAMAN", specID = { 262, 264 } }, -- Ancestral Guidance
        [192063] = { duration = 15, class = "SHAMAN", specID = { 262, 264 } }, -- Gust of Wind
        [192222] = { duration = 60, class = "SHAMAN", specID = { 262 } }, -- Liquid Magma Totem
        [198067] = { duration = 150, class = "SHAMAN", specID = { 262 } }, -- Fire Elemental
            [192249] = { parent = 198067 }, -- Storm Elemental
        [198103] = { duration = 120, class = "SHAMAN", specID = { 262 } }, -- Earth Elemental
        [204437] = { duration = 30, class = "SHAMAN", specID = { 262 } }, -- Lightning Lasso
        [191634] = { duration = 60, class = "SHAMAN", specID = { 262 } }, -- Stormkeeper

        -- Enhancement
        [58875] = { duration = 60, class = "SHAMAN", specID = { 263 } }, -- Spirit Walk
        [196884] = { duration = 30, class = "SHAMAN", specID = { 263 } }, -- Feral Lunge
        [197214] = { duration = 40, class = "SHAMAN", specID = { 263 } }, -- Sundering
        [201898] = { duration = 45, class = "SHAMAN", specID = { 263 } }, -- Windsong
        [204366] = { duration = 45, class = "SHAMAN", specID = { 263 } }, -- Thundercharge
        [204945] = { duration = 60, class = "SHAMAN", specID = { 263 } }, -- Doom Winds

        -- Restoration
        [5394] = { duration = 30, class = "SHAMAN", specID = { 264 }, charges = 30 }, -- Healing Stream Totem
        [79206] = { duration = 60, class = "SHAMAN", specID = { 264 } }, -- Spiritwalker's Grace
        [98008] = { duration = 180, class = "SHAMAN", specID = { 264 } }, -- Spirit Link Totem
            [204293] = { parent = 98008, duration = 60 }, -- Spirit Link
        [108280] = { duration = 180, class = "SHAMAN", specID = { 264 } }, -- Healing Tide Totem
        [157153] = { duration = 30, class = "SHAMAN", specID = { 264 } }, -- Cloudburst Totem
        [198838] = { duration = 60, class = "SHAMAN", specID = { 264 } }, -- Earthen Wall Totem
        [204336] = { duration = 30, class = "SHAMAN", specID = { 264 } }, -- Grounding Totem
        [207399] = { duration = 300, class = "SHAMAN", specID = { 264 } }, -- Ancestral Protection Totem
        [207778] = { duration = 45, class = "SHAMAN", specID = { 264 } }, -- Gift of the Queen

    -- Hunter
    [136] = { duration = 10, class = "HUNTER" }, -- Mend Pet
    [1543] = { duration = 20, class = "HUNTER" }, -- Flare
    [5384] = { duration = 30, class = "HUNTER" }, -- Feign Death
    [53480] = { duration = 60, class = "HUNTER" }, -- Roar of Sacrifice
    [109304] = { duration = 120, class = "HUNTER" }, -- Exhilaration (Beast Mastery, Survival)
    [131894] = { duration = 60, class = "HUNTER" }, -- A Murder of Crows (Beast Mastery, Marksmanship)
        [206505] = { parent = 131894 }, -- A Murder of Crows (Survival)
    [186257] = { duration = { default = 180, [253] = 120, [255] = 144 }, class = "HUNTER" }, -- Aspect of the Cheetah
    [186265] = { duration = { default = 180, [255] = 144 }, class = "HUNTER" }, -- Aspect of the Turtle
    [187650] = { duration = { default = 30, [255] = 20 }, class = "HUNTER" }, -- Freezing Trap
    [202914] = { duration = 60, class = "HUNTER" }, -- Spider Sting
    [209997] = { duration = 30, class = "HUNTER" }, -- Play Dead

        -- Beast Mastery
        [781] = { duration = 20, class = "HUNTER", specID = { 253, 254 } }, -- Disengage
        [19386] = { duration = 45, class = "HUNTER", specID = { 253, 254 } }, -- Wyvern Sting
        [19574] = { duration = 75, class = "HUNTER", specID = { 253 } }, -- Bestial Wrath
        [19577] = { duration = 60, class = "HUNTER", specID = { 253 } }, -- Intimidation
        [109248] = { duration = 45, class = "HUNTER", specID = { 253, 254 } }, -- Binding Shot
        [147362] = { default = true, duration = 24, class = "HUNTER", specID = { 253, 254 } }, -- Counter Shot
        [193530] = { duration = 120, class = "HUNTER", specID = { 253 } }, -- Aspect of the Wild
        [194386] = { duration = 90, class = "HUNTER", specID = { 253, 254 } }, -- Volley
        [201430] = { duration = 180, class = "HUNTER", specID = { 253 } }, -- Stampede
        [207068] = { duration = 60, class = "HUNTER", specID = { 253 } }, -- Titan's Thunder
        [208652] = { duration = 30, class = "HUNTER", specID = { 253 } }, -- Dire Beast: Hawk

        -- Marksmanship
        [34477] = { duration = 30, class = "HUNTER", specID = { 254 } }, -- Misdirection
        [186387] = { duration = 20, class = "HUNTER", specID = { 254 } }, -- Bursting Shot
        [199483] = { duration = 60, class = "HUNTER", specID = { 254, 255 } }, -- Camouflage
        [204147] = { duration = 20, class = "HUNTER", specID = { 254 } }, -- Windburst
        [206817] = { duration = 30, class = "HUNTER", specID = { 254 } }, -- Sentinel
        [209789] = { duration = 30, class = "HUNTER", specID = { 254 } }, -- Freezing Arrow
        [213691] = { duration = 20, class = "HUNTER", specID = { 254 } }, -- Scatter Shot

        -- Survival
        [53271] = { duration = 45, class = "HUNTER", specID = { 255 } }, -- Master's Call
        [186289] = { duration = 96, class = "HUNTER", specID = { 255 } }, -- Aspect of the Eagle
        [187698] = { duration = 20, class = "HUNTER", specID = { 255 } }, -- Tar Trap
        [187707] = { default = true, duration = 15, class = "HUNTER", specID = { 255 } }, -- Muzzle
        [190925] = { duration = 20, class = "HUNTER", specID = { 255 } }, -- Harpoon
        [191241] = { duration = 30, class = "HUNTER", specID = { 255 } }, -- Sticky Bomb
        [191433] = { duration = 20, class = "HUNTER", specID = { 255 } }, -- Explosive Trap
        [194407] = { duration = 90, class = "HUNTER", specID = { 255 } }, -- Spitting Cobra
        [201078] = { duration = 90, class = "HUNTER", specID = { 255 } }, -- Snake Hunter
        [203415] = { duration = 45, class = "HUNTER", specID = { 255 } }, -- Fury of the Eagle
        [205691] = { duration = 120, class = "HUNTER", specID = { 255 } }, -- Dire Beast: Basilisk
        [212640] = { duration = 25, class = "HUNTER", specID = { 255 } }, -- Mending Bandage
        [266779] = { duration = 20, class = "HUNTER", specID = { 255 } }, -- Coordinated Assault

    -- Mage
    [66] = { duration = 300, class = "MAGE" }, -- Invisibility
    [1953] = { duration = 15, class = "MAGE"}, -- Blink
        [212653] = { parent = 1953, duration = 20, charges = 2 }, -- Shimmer
    [2139] = { default = true, duration = 24, class = "MAGE" }, -- Counterspell
    [11426] = { duration = 25, class = "MAGE" }, -- Ice Barrier
    [45438] = { duration = 240, class = "MAGE" }, -- Ice Block
    [108839] = { duration = 20, class = "MAGE", charges = 3 }, -- Ice Floes
    [113724] = { duration = 45, class = "MAGE" }, -- Ring of Frost
    [116011] = { duration = 40, class = "MAGE", charges = 2 }, -- Rune of Power
    [198111] = { duration = 45, class = "MAGE" }, -- Temporal Shield

        -- Arcane
        [12042] = { duration = 90, class = "MAGE", specID = { 62 } }, -- Arcane Power
        [12051] = { duration = 90, class = "MAGE", specID = { 62 } }, -- Evocation
        [153626] = { duration = 20, class = "MAGE", specID = { 62 } }, -- Arcane Orb
        [157980] = { duration = 25, class = "MAGE", specID = { 62 } }, -- Supernova
        [195676] = { duration = 24, class = "MAGE", specID = { 62 } }, -- Displacement
        [198158] = { duration = 60, class = "MAGE", specID = { 62 } }, -- Mass Invisibility
        [205025] = { duration = 60, class = "MAGE", specID = { 62 } }, -- Presence of Mind
        [224968] = { duration = 60, class = "MAGE", specID = { 62 } }, -- Mark of Aluneth
        [110959] = { duration = 75, class = "MAGE", specID = { 62 } }, -- Greater Invisibility

        -- Fire
        [31661] = { duration = 18, class = "MAGE", specID = { 63 } }, -- Dragon's Breath
        [108853] = { duration = 8.4, class = "MAGE", specID = { 63 }, charges = 3 }, -- Fire Blast
        [153561] = { duration = 45, class = "MAGE", specID = { 63 } }, -- Meteor
        [157981] = { duration = 25, class = "MAGE", specID = { 63 } }, -- Blast Wave
        [190319] = { duration = 120, class = "MAGE", specID = { 63 } }, -- Combustion

        -- Frost
        [122] = { duration = 30, class = "MAGE", specID = { 64 }, charges = 2 }, -- Frost Nova
        [12472] = { duration = 180, class = "MAGE", specID = { 64 } }, -- Icy Veins
            [198144] = { parent = 12472, duration = 45 }, -- Ice Form
        [31687] = { duration = 60, class = "MAGE", specID = { 64 } }, -- Summon Water Elemental
        [84714] = { duration = 60, class = "MAGE", specID = { 64 } }, -- Frozen Orb
        [153595] = { duration = 30, class = "MAGE", specID = { 64 } }, -- Comet Storm
        [157997] = { duration = 25, class = "MAGE", specID = { 64 } }, -- Ice Nova
        [205021] = { duration = 75, class = "MAGE", specID = { 64 } }, -- Ray of Frost
        [214634] = { duration = 45, class = "MAGE", specID = { 64 } }, -- Ebonbolt

    -- Rogue
    [1725] = { duration = 30, class = "ROGUE" }, -- Distract
    [1766] = { default = true, duration = 15, class = "ROGUE" }, -- Kick
    [1856] = { duration = { default = 120, [261] = 30 }, class = "ROGUE" }, -- Vanish
    [2983] = { duration = { default = 60, [259] = 51 }, class = "ROGUE" }, -- Sprint
    [31224] = { duration = { default = 90, [259] = 81 }, class = "ROGUE" }, -- Cloak of Shadows
    [57934] = { duration = 30, class = "ROGUE" }, -- Tricks of the Trade
    [137619] = { duration = 40, class = "ROGUE" }, -- Marked for Death
    [152150] = { duration = 20, class = "ROGUE" }, -- Death from Above

        -- Assassination
        [408] = { duration = 20, class = "ROGUE", specID = { 259, 261 } }, -- Kidney Shot
        [703] = { duration = 6, class = "ROGUE", specID = { 259 } }, -- Garrote
        [5277] = { duration = 120, class = "ROGUE", specID = { 259, 261 } }, -- Evasion
        [36554] = { duration = 30, class = "ROGUE", specID = { 259, 261 } }, -- Shadowstep
        [79140] = { duration = 120, class = "ROGUE", specID = { 259 } }, -- Vendetta
        [192759] = { duration = 45, class = "ROGUE", specID = { 259 } }, -- Kingsbane
        [200806] = { duration = 45, class = "ROGUE", specID = { 259 } }, -- Exsanguinate
        [206328] = { duration = 25, class = "ROGUE", specID = { 259 } }, -- Shiv

        -- Outlaw
        [1776] = { duration = 15, class = "ROGUE", specID = { 260 } }, -- Gouge
        [2094] = { duration = 120, class = "ROGUE", specID = { 260, 261 } }, -- Blind
            [199743] = { parent = 2094, duration = 20 }, -- Parley
        [13750] = { duration = 150, class = "ROGUE", specID = { 260 } }, -- Adrenaline Rush
        [51690] = { duration = 120, class = "ROGUE", specID = { 260 } }, -- Killing Spree
        --[185767] = { duration = 60, class = "ROGUE", specID = { 260 } }, -- Cannonball Barrage
        [195457] = { duration = 30, class = "ROGUE", specID = { 260 } }, -- Grappling Hook
        [198529] = { duration = 120, class = "ROGUE", specID = { 260 } }, -- Plunder Armor
        [199754] = { duration = 120, class = "ROGUE", specID = { 260 } }, -- Riposte
        [199804] = { duration = 30, class = "ROGUE", specID = { 260 } }, -- Between the Eyes
        [202665] = { duration = 90, class = "ROGUE", specID = { 260 } }, -- Curse of the Dreadblades
        [207777] = { duration = 45, class = "ROGUE", specID = { 260 } }, -- Dismantle

        -- Subtlety
        [121471] = { duration = 180, class = "ROGUE", specID = { 261 } }, -- Shadow Blades
        [185313] = { duration = 60, class = "ROGUE", specID = { 261 }, charges = 3 }, -- Shadow Dance
        [207736] = { duration = 120, class = "ROGUE", specID = { 261 } }, -- Shadowy Duel
        [209782] = { duration = 60, class = "ROGUE", specID = { 261 } }, -- Goremaw's Bite
        [212182] = { duration = 180, class = "ROGUE", specID = { 261 } }, -- Smoke Bomb
        [213981] = { duration = 45, class = "ROGUE", specID = { 261 } }, -- Cold Blood

    -- Monk
    [109132] = { duration = 15, class = "MONK", charges = 3 }, -- Roll
        [115008] = { parent = 109132 }, -- Chi Torpedo
    [115078] = { duration = 45, class = "MONK" }, -- Paralysis
    [116841] = { duration = 30, class = "MONK" }, -- Tiger's Lust
    [116844] = { duration = 45, class = "MONK" }, -- Ring of Peace
    [119381] = { duration = 60, class = "MONK" }, -- Leg Sweep
    [119996] = { duration = 45, class = "MONK" }, -- Transcendence: Transfer
    [122278] = { duration = 120, class = "MONK" }, -- Dampen Harm
    [122783] = { duration = 120, class = "MONK" }, -- Diffuse Magic
    [123986] = { duration = 30, class = "MONK" }, -- Chi Burst
    --[137648] = { duration = 120, class = "MONK" }, -- Nimble Brew

        -- Brewmaster
        [115203] = { duration = 105, class = "MONK", specID = { 268 } }, -- Fortifying Brew
        [115399] = { duration = 90, class = "MONK", specID = { 268 } }, -- Black Ox Brew
        [116705] = { default = true, duration = 15, class = "MONK", specID = { 268, 269 } }, -- Spear Hand Strike
        [132578] = { duration = 180, class = "MONK", specID = { 268 } }, -- Invoke Niuzao, the Black Ox
        [202162] = { duration = 45, class = "MONK", specID = { 268 } }, -- Guard
        [202272] = { duration = 45, class = "MONK", specID = { 268 } }, -- Incendiary Brew
        [202370] = { duration = 60, class = "MONK", specID = { 268 } }, -- Mighty Ox Kick

        -- Windwalker
        [101545] = { duration = 25, class = "MONK", specID = { 269 }, charges = 2 }, -- Flying Serpent Kick
        [113656] = { duration = 24, class = "MONK", specID = { 269 } }, -- Fists of Fury
        [115080] = { duration = 120, class = "MONK", specID = { 269 } }, -- Touch of Death
            [152173] = { parent = 137639 }, -- Serenity
        [115176] = { duration = 150, class = "MONK", specID = { 269 } }, -- Zen Meditation
            [201325] = { parent = 115176, 180 }, -- Zen Meditation (Windwalker)
        [115288] = { duration = 60, class = "MONK", specID = { 269 } }, -- Energizing Elixir
        [122470] = { duration = 90, class = "MONK", specID = { 269 } }, -- Touch of Karma
        [123904] = { duration = 120, class = "MONK", specID = { 269 } }, -- Invoke Xuen, the White Tiger
        [137639] = { duration = 90, class = "MONK", specID = { 269 }, charges = 2 }, -- Storm, Earth, and Fire
        [152175] = { duration = 24, class = "MONK", specID = { 269 } }, -- Whirling Dragon Punch
        [201318] = { duration = 90, class = "MONK", specID = { 269 } }, -- Fortifying Elixir

        -- Mistweaver
        [115310] = { duration = 180, class = "MONK", specID = { 270 } }, -- Revival
        [116680] = { duration = 30, class = "MONK", specID = { 270 } }, -- Thunder Focus Tea
        [116849] = { duration = 120, class = "MONK", specID = { 270 } }, -- Life Cocoon
        [197908] = { duration = 90, class = "MONK", specID = { 270 } }, -- Mana Tea
        --[197945] = { duration = 20, class = "MONK", specID = { 270 }, charges = 2 }, -- Mistwalk
        [198898] = { duration = 30, class = "MONK", specID = { 270 } }, -- Song of Chi-Ji

}

--Check cooldown remaining on unit's ability
function UnitCooldown(unit,spell)
	if type(spell) == "number" then
		if SpellTracker[spell] and unit_is_unit(unit, SpellTracker[spell].pointer) then
			return max(0, SpellTracker[spell].expires - GetTime())
		end
	end
	if type(spell) == "string" then
  		for k,v in pairs(SpellTracker) do 
	  		if v.name == spell and unit_is_unit(unit,v.pointer) then
		    	return max(0, v.expires - GetTime())
		  	end 
	 	end
	end
	return 0;
end

function _rakePower(unit)
	for i=1,#dotTracker do
  		if unit_is_unit(dotTracker[i].rakepointer,unit) and dotTracker[i].rakePower then
    		return dotTracker[i].rakePower;
  		end
	end
	return 0;
end

function _ripPower(unit)
	for i=1,#dotTracker do
  		if unit_is_unit(dotTracker[i].rippointer,unit) and dotTracker[i].ripPower then
    		return dotTracker[i].ripPower;
  		end
	end
	return UnitDebuffID(unit,1079,"player") and 1 or 0;
end

function _garrotePower(unit)
	for i=1,#dotTracker do
  		if unit_is_unit(dotTracker[i].garrotepointer,unit) and dotTracker[i].garrotePower then
    		return dotTracker[i].garrotePower;
  		end
	end
	return 0;
end

local bCC = {
-- DEATH KNIGHT
-- DRUID
99,   -- Disorienting Roar
236025,	--Enraged Maim
-- HUNTER
3355,  -- Freezing Trap
187650,	--Freezing Trap
19386,  -- Wyvern Sting
-- MAGE
28272,		-- Pig
118,		-- Sheep
277792,		-- Bee
161354,		-- Monkey
277787,		-- Direhorn
161355,		-- Penguin
161353,		-- Polar Bear
120140,		-- Porcupine
61305,		-- Cat
61721,		-- Rabbit
61780,		-- Turkey
28271,		-- Turtle
-- 113724,		-- Ring of Frost
-- 136511,		-- Ring of Frost
-- 140384,		-- Ring of Frost
82691,		-- Ring of Frost (I think this is actually it)
31661,		-- Dragon's Breath
-- MONK
115078,  -- Paralysis
-- PALADIN
105421,  -- Blinding Light
20066,  -- Repentance
-- PRIEST
9484,  -- Shackle Undead
-- ROGUE
2094,  -- Blind
1776,  -- Gouge
6770,  -- Sap
-- SHAMAN
51514,  -- Hex
211015,	--hex cockroach
210873,	--hex compy
211010,	--hex snake
211004,	--hex spider
277784,	--hex wicker mongrel
277778,	--hex zandalari tendonripper
309328,	--hex living honey
269352,	--hex skeletal raptor
-- WARLOCK
115268,  -- Mesmerize
6358,  -- Seduction
-- RACIALS
107079,  -- Quaking Palm
238559,	--Bursting Shot
--DEMON HUNTER
217832,	-- Imprison
}

breakable_cc_cache = {}

function _breakableCC(unit,breakfears)
	if breakable_cc_cache[unit] ~= nil then return breakable_cc_cache[unit] end
	local cctable = {unpack(bCC)}
	if breakfears then
		for i=1,#cctable do if cctable[i] == 118699 then
			table.remove(cctable,i)
		end end
	end
	local hasdebuff,debuff = _debuffFromTable(unit,cctable);
	if hasdebuff then
		breakable_cc_cache[unit] = true
		return true; 
	else
		breakable_cc_cache[unit] = false
	end
end

function bcc_remains(unit)
	local bcc = {}
	local debuffs = _debuffFromTable(unit,bCC,true)
	table.sort(debuffs,function(x,y) return x > y end)
	local ccr = debuffs[1]
	if ccr == math.huge then ccr = 0 end
	if not ccr then ccr = 0 end
	return ccr
end

function _bccAM(dist)
	for i=1,#Enemies do
		if _distance(Enemies[i]) <= dist then
			if _breakableCC(Enemies[i]) then
				return true;
			end
		end
	end
end

function breakable_cc_around(unit,dist)
	for i=1,#Enemies do
		if _distance(unit,Enemies[i]) <= dist then
			if bcc_remains(Enemies[i]) > squid_avg_latency + .25 then
				return true;
			end
		end
	end
end

function bcc_facing(unit,range,angle)
	for i=1,#Enemies do
		if _breakableCC(Enemies[i]) then
			if _distance(Enemies[i]) <= range
			and UnitIsFacing("player", unit, angle) then
				return true
			end
		end
	end
end

local disarms = {
236077,	--Disarm
207777,	--Dismantle
233759, --Grapple weapon
209749, --Faerie Swarm
}

function disarm_check(unit)
	local debuffs = _debuffFromTable(unit,disarms)
	if debuffs then return true end
end

function explosive_trap_knock(unit)

	if not UnitIsVisible(unit) then return end

	if IsPlayerSpell(236776) and _spellCooldown(236776) <= .5 and not _rootCheck(unit) then

		local my_trap

		for i=1,#AreaTriggers do if ObjectID(AreaTriggers[i]) == 9170 then
			my_trap = AreaTriggers[i]
		end end

		if my_trap then

			local ux,uy,uz = ObjectPosition(unit)
			local px,py,pz = GetPlayerPosition()
			local x,y,z = ObjectPosition(my_trap)

			local direction = math.atan2(uy-y, ux-x)

			if aoe_cast(236776,ux + 1.5 * math.cos(direction), uy + 1.5 * math.sin(direction), uz) then return end

		else

			--explosive trap away from team

			local mapid = GetMapId()

			local dist = 18 -- knock distance?

			local px,py,pz = GetPlayerPosition()
			local ux,uy,uz = ObjectPosition(unit)

			local points = {}

			local meshloaded = IsMeshLoaded(mapid)

			local step = (math.pi*2) / 20
			for i=0,math.pi*2,step do
				local x,y,z = ux + dist * math.cos(i), uy + dist * math.sin(i), uz
				if x and y and z and not TraceLine(ux, uy, uz+1.5, x, y, z+.5, collisionflags) then
					local gx,gy,gz = GroundZ(x,y,z)
					local zdif = z - gz
					-- if zdif > 1 then -- Maybe don't check z dif so if player just wants to knock away (out of earthen or bomb?) they can
						local ex,ey,ez = GroundZ(ux - 1.5 * math.cos(i), uy - 1.5 * math.sin(i), uz)
						if not TraceLine(px,py,pz+1.7,ex,ey,ez+1.7,losflags) then
							local pdist
							local hit,bcc,avg = Enemies_Around_Point(x,y,z,60,unit)
							table.insert(points,{x=ex,y=ey,z=ez,zdif=(zdif * 3.5)+avg,avg=avg})
						end
					-- end
				end
			end

			table.sort(points,function(x,y) return x.zdif > y.zdif or (x.zdif == y.zdif and x.avg > y.avg) end)

			if #points > 0 then
				SquidPause()
				local tx,ty,tz = points[1].x,points[1].y,points[1].z
				if aoe_cast(236776,tx,ty,tz) then return end
			end

		end

	end

end

function PlayerZDiff()
	local x,y,z = GetPlayerPosition()
	local _,_,gz = GroundZ(x,y,z)
	return z - gz
end

local function AnyKeyPressed()
	if GetKeyState(0x01)
	or GetKeyState(0x02)
	or GetKeyState(0x04)
	or GetKeyState(0x05)
	or GetKeyState(0x06)
	or GetKeyState(0x09)
	or GetKeyState(0x10)
	or GetKeyState(0x11)
	or GetKeyState(0x12)
	or GetKeyState(0x31)
	or GetKeyState(0x32)
	or GetKeyState(0x33)
	or GetKeyState(0x34)
	or GetKeyState(0x35)
	or GetKeyState(0x36)
	or GetKeyState(0x37)
	or GetKeyState(0x38)
	or GetKeyState(0x39)
	or GetKeyState(0x41)
	or GetKeyState(0x42)
	or GetKeyState(0x43)
	or GetKeyState(0x44)
	or GetKeyState(0x45)
	or GetKeyState(0x46)
	or GetKeyState(0x47)
	or GetKeyState(0x48)
	or GetKeyState(0x49)
	or GetKeyState(0x51)
	or GetKeyState(0x52)
	or GetKeyState(0x53)
	or GetKeyState(0x54)
	or GetKeyState(0x56)
	or GetKeyState(0x57)
	or GetKeyState(0x58)
	or GetKeyState(0x5A)
	or GetKeyState(0x60)
	or GetKeyState(0x61)
	or GetKeyState(0x62)
	or GetKeyState(0x63)
	or GetKeyState(0x64)
	or GetKeyState(0x65)
	or GetKeyState(0x66)
	or GetKeyState(0x67)
	or GetKeyState(0x68)
	or GetKeyState(0x69) then
		return true
	end
end

function should_feign()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
	local frame_buffer = 3 / GetFramerate()
	local latency = squid_avg_latency + squid_avg_home_latency
	local falling_val = (IsFalling() and PlayerZDiff() * .5 or 0)
	local buffer = frame_buffer + latency + .1 + falling_val
	local spec = GetSpecialization()
	local my_kick = (spec == 3 and 187707 or 147362)
	local kick_cd = _spellCooldown(my_kick)
	local kick_base_cd = GetSpellBaseCooldown(my_kick)/1000
	local feign_cd = _spellCooldown(5384)
	local gcd_remains = GetGCD()
	if feign_cd <= gcd_remains and kick_cd < kick_base_cd - .3 then
		--feignable debuffs
		if IsPlayerSpell(202746) then
			--touch of death
			local tod_remains = _debuffRemains("player",115080)
			if tod_remains > 0 then
				if tod_remains < gcd+gcd_remains+buffer then
					if tod_remains < 1.5 then
						return 115080
					end
					return "wait"
				end
			end
			--obsidian claw
			--maledict
		end
		--enemy casts
		for i=1,#Enemies do 
			local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i])
			if cast then
				local target = UnitSpellTarget(Enemies[i])
				if unit_is_unit("player",target) then
					local timeleft = _castTimeLeft(Enemies[i])
					--incapacitates
					if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") >= lowestEnemy / 100 or _drRemains("player","incapacitate") < timeleft) then
						if timeleft <= gcd+gcd_remains+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--big dmg
					if tContains(castedDMG,cast) then
						if timeleft <= gcd+gcd_remains+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--disorients
					if tContains(csCCdisorient,cast) and (_disorientDR("player") >= lowestEnemy / 100 or _drRemains("player","disorient") < timeleft) then
						if timeleft <= gcd+gcd_remains+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
				end
			end
		end
	end
end

function should_ward()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
	local latency = (select(4,GetNetStats())/1000)+.13
	local buffer = fps+latency
	for i=1,#Enemies do 
		local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i]) --spellID of the cast
		if cast then
			local target = UnitSpellTarget(Enemies[i])
			if unit_is_unit("player",target) then
				local timeleft = _castTimeLeft(Enemies[i])
				--incapacitates
				if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") == 1 or _drRemains(unit,"incapacitate") < timeleft or lowestEnemy < 65) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (_spellCooldown(19647) > timeleft) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
				--big dmg
				if tContains(castedDMG,cast) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
				--disorients
				if tContains(csCCdisorient,cast) and (_disorientDR("player") == 1 or _disorientDR(unit) == 1) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
			end
		end
	end
end

function should_reflect()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
	local latency = (select(4,GetNetStats())/1000)+.13
	local buffer = fps+latency
	for i=1,#Enemies do 
		local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i]) --spellID of the cast
		if cast then
			local target = UnitSpellTarget(Enemies[i])
			if unit_is_unit("player",target) then
				local timeleft = _castTimeLeft(Enemies[i])
				--incapacitates
				if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") == 1 or _drRemains(unit,"incapacitate") < timeleft or lowestEnemy < 65) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
				--big dmg
				if tContains(castedDMG,cast) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
				--disorients
				if tContains(csCCdisorient,cast) and (_disorientDR("player") == 1 or _disorientDR(unit) == 1) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
			end
		end
	end
end

function should_intervene()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
	local latency = (select(4,GetNetStats())/1000)+.13
	local buffer = fps+latency
	for i = 1, #Enemies do
		local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i]) --spellID of the cast
		if cast then
			local target = UnitSpellTarget(Enemies[i])
			if unit_is_unit(ourHealer, target) then
				local timeleft = _castTimeLeft(Enemies[i])
				--check for OverWatch 329035 before intervening spells
				if IsPlayerSpell(329035) then
					--incapacitates
					if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") == 1 or _drRemains(unit,"incapacitate") < timeleft or lowestEnemy < 65) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--big dmg
					if tContains(castedDMG,cast) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--disorients
					if tContains(csCCdisorient,cast) and (_disorientDR("player") == 1 or _disorientDR(unit) == 1) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
				end
			end
		end
	end
	--reflect trap on healer
	if not UnitDebuffID(unit,187650) and _incapacitateDR(unit) == 1 then
		if lastTrapPointer and UnitIsVisible(lastTrapPointer) and unit_can_attack("player",lastTrapPointer) then
			if lastTrap and GetTime()-lastTrap < 1.5 then
				return 3355
			end
		end
	end
end

function should_ground()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
	local latency = (select(4,GetNetStats())/1000)+.13
	local buffer = fps+latency
	for i=1,#Enemies do 
		local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i])
		if cast then
			local target = UnitSpellTarget(Enemies[i])
			if unit_is_unit("player",target) or UnitIsFriend("player",target) then
				local timeleft = _castTimeLeft(Enemies[i])
				--incapacitates
				if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") == 1 or _drRemains(unit,"incapacitate") < timeleft or lowestEnemy < 65) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
				--big dmg
				if tContains(castedDMG,cast) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
				--disorients
				if tContains(csCCdisorient,cast) and (_disorientDR("player") == 1 or _disorientDR(unit) == 1) then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
			end
		end
	end
end

function should_banner(unit)
	if not UnitIsVisible(unit) or _distance(unit) > 28 then return false end
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local fps = (1/GetFramerate())*18 --ms per frame * 18 (18 fps buffer)
	local latency = (select(4,GetNetStats())/1000)+.13
	local buffer = fps+latency
	for i=1,#Enemies do 
		local cast = unit_casting_info(Enemies[i])
		if cast then
			local target = UnitSpellTarget(Enemies[i])
			if unit_is_unit(unit,target) then
				local timeleft = _castTimeLeft(Enemies[i])
				--incapacitates
				if tContains(csCCincapacitate,cast) and _incapacitateDR(unit) == 1 then
					if timeleft <= gcd+GetGCD()+buffer then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
			end
		end
	end
	--traps
	--if intervene is on cooldown
	if _spellCooldown(3411) > .5 and not UnitDebuffID(unit,187650) and _incapacitateDR(unit) == 1 then
		if lastTrapPointer and UnitIsVisible(lastTrapPointer) and unit_can_attack("player",lastTrapPointer) then
			if lastTrap and GetTime()-lastTrap < 1.5 then
				return 3355
			end
		end
	end
end

function should_ground(unit)
	if not UnitIsVisible(unit) or _distance(unit) > 28 then return false end
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local fps = ((1000/GetFramerate())/1000)*18 --ms per frame * 18 (18 fps buffer)
	local latency = (select(4,GetNetStats())/1000)+.1
	local buffer = fps+latency
	for i=1,#Enemies do
		local cast = unit_casting_info(Enemies[i])
		if cast then
			local target = UnitSpellTarget(Enemies[i])
			if unit_is_unit(unit,target) then
				local timeleft = _castTimeLeft(Enemies[i])
				--incapacitates
				if tContains(csCCincapacitate,cast) and (_incapacitateDR(unit) == 1 or _drRemains(unit,"incapacitate") < timeleft) then
					if timeleft <= gcd+GetGCD()+buffer then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end

			end
		end
	end
	--traps
	if not UnitDebuffID(unit,187650) and _incapacitateDR(unit) == 1 then
		if lastTrapPointer and UnitIsVisible(lastTrapPointer) and unit_can_attack("player",lastTrapPointer) then
			if lastTrap and GetTime()-lastTrap < 1.7 then
				return 3355
			end
		end
	end
end

function should_death()
	local time = GetTime()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
	local latency = (select(4,GetNetStats())/1000)
	local buffer = fps+latency+.05
	local incapdr = _incapacitateDR("player")
	local incapdr_remains = _drRemains("player","incapacitate")
	for i=1,#Enemies do 
		local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i])
		if cast then
			local target = UnitSpellTarget(Enemies[i])
			if unit_is_unit("player",target) then
				local timeleft = _castTimeLeft(Enemies[i])
				--incapacitates
				if tContains(csCCincapacitate,cast) and incapdr_remains <= timeleft then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
				--disorients
				if tContains(csCCdisorient,cast) and cast ~= 33786 and cast ~= 205367 and _disorientDR("player") == 1 then
					if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
						if timeleft <= buffer then
							return cast
						end
						return "wait"
					end
				end
			end
		end
	end
	--traps
	if not UnitDebuffID(unit,187650) and _incapacitateDR(unit) == 1 then
		if lastTrapPointer and UnitIsVisible(lastTrapPointer) and unit_can_attack("player",lastTrapPointer) then
			if lastTrap and GetTime()-lastTrap < 1.7 then
				return 3355
			end
		end
	end
end

function EnemiesAroundMe(dist)
	local count=0
	for i=1,#Enemies do
		if _distance(Enemies[i]) <= dist then
			count=count+1;
		end
	end
	return count
end

function AllEnemiesAroundMe(dist)
	local count=0
	for i=1,#Pets do if UnitCreatureType(Pets[i]) ~= "Totem" then
		if _realDistance(Pets[i]) <= dist then
			count=count+1;
		end
	end end
	return count
end

function Enemies_Around_Point(x,y,z,dist,unit)
	local avgdist=0
	local totalcount=0
	local totaldist=0.00001 -- sometimes will end up dividing by zero if this started at zero
	local count=0
	local bcc=0
	for i=1,#Enemies do 
		if not unit or not unit_is_unit(Enemies[i],unit) then
			local ex,ey,ez = ObjectPosition(Enemies[i])
			local distance_from_pos = GetDistanceBetweenPositions(x,y,z,ex,ey,ez)
			if distance_from_pos <= dist then
				count=count+1;
				if _breakableCC(Enemies[i]) then
					bcc=bcc+1
					--prio bcc units in avg dist
					if distance_from_pos < dist*1.75 then
						totaldist = totaldist + distance_from_pos
					end
				end
			end
			--units within 2x the given dist
			if distance_from_pos < dist*1.75 then

				totalcount=totalcount+1

				totaldist=totaldist+distance_from_pos

			end
		end
	end
	avgdist = totaldist/totalcount
	return count,bcc,avgdist
end

function Enemies_Around_Unit(unit,dist,realdist)
	
	if not UnitIsVisible(unit) then return 0,0,0 end

	local count = 0
	local bcc = 0
	local avg = 0

	for i=1,#Enemies do
		if not unit_is_unit(Enemies[i],unit) then
			if realdist and _realDistance(unit,Enemies[i]) <= dist or not realdist and _distance(unit,Enemies[i]) <= dist then--and _LoS(unit,Enemies[i]) then
				if _breakableCC(Enemies[i]) then
					bcc = bcc + 1
				end
				count = count+1;
			end 
		end 
	end

	return count,bcc,avg

end

function GroundZ(X,Y,Z)
	local x,y,z = TraceLine(X,Y,Z+4,X,Y,-10000,collisionflags)--GetGroundZ(X,Y,0x100111)
	if not z then z = Z end
	return x,y,math.min(z,Z)
end

function point_between_points(points)

	local valid_points = {}

	for i=1,#points do
		local point = points[i]
		local x,y = point[1],point[2]
		table.insert(valid_points,{x=x,y=y})
	end
	
	local total_x = 0
	local total_y = 0
	for i=1,#valid_points do
		total_x = total_x + valid_points[i].x
		total_y = total_y + valid_points[i].y
	end
	
	local x = total_x / #valid_points
	local y = total_y / #valid_points

	return TraceLine(x,y,-10000,x,y,10000,collisionflags)

end

function point_between_units(units)
	local points = {}
	for i=1,#units do
		local x,y,z = ObjectPosition(units[i])
		table.insert(points,{x,y,z})
	end
	return point_between_points(points)
end

--param unit, unit to check
--param elapsed, time of moving to predict position after
--returns x,y,z, the grounded position of the unit after the given time
function PredictUnitPosition(unit,elapsed)

	if not unit then return false end

	if not elapsed then elapsed = 1 end

	local x,y,z

	if unit_is_unit(unit,"player") then
		x,y,z = GetPlayerPosition()
	else
		x,y,z = ObjectPosition(unit)
	end

	if x and y and z then

		local direction = GetMovingDirection(unit)

		local distance = GetUnitSpeed(unit) * elapsed

		local px=x + distance * math.cos(direction);
		local py=y + distance * math.sin(direction);
		local pz=z;

		local tx,ty,tz = TraceLine(x,y,z+2,px,py,pz+2,collisionflags)

		if not tx then

			return GroundZ(px,py,pz)

		else

			return GroundZ(tx,ty,tz)

		end

	end

end

function _anglesBetweenObjects(unit1,unit2)
	return GetAnglesBetweenObjects (unit1,unit2)
end

function _findCorner(fx,fy,fz,diameter,flags,dist)
	
	if not fz then
		fx,fy,fz = ObjectPosition(fx);
		diameter = fy;
	end
	local sx,sy,sz = GetPlayerPosition()
	local radius = diameter/2 or 0
	local diameter = diameter or 0
	if not dist then dist=10000 end

	if not TraceLine(sx,sy,sz+2,fx,fy,fz+2,0x10) then
		return fx,fy,fz
	end

	if TraceLine(sx,sy,sz,fx,fy,fz,0x10) then
		
		for i=0,radius,2 do
		
			if not TraceLine(sx,sy,sz+2,fx+i,fy,fz+2,0x10) and not TraceLine(fx+i,fy,fz+4,fx,fy,fz+4,0x10) then
				return fx+i,fy,fz
			end
			
			if not TraceLine(sx,sy,sz+2,fx,fy+i,fz+2,0x10) and not TraceLine(fx,fy+i,fz+4,fx,fy,fz+4,0x10) then
				return fx,fy+i,fz
			end
			
			if not TraceLine(sx,sy,sz+2,fx-i,fy,fz+2,0x10) and not TraceLine(fx-i,fy,fz+4,fx,fy,fz+4,0x10) then
				return fx-i,fy,fz
			end
			
			if not TraceLine(sx,sy,sz+2,fx,fy-i,fz+2,0x10) and not TraceLine(fx,fy-i,fz+4,fx,fy,fz+4,0x10) then
				return fx,fy-i,fz
			end
			
			if not TraceLine(sx,sy,sz+2,fx-i,fy-i,fz+2,0x10) and not TraceLine(fx,fy-i,fz+4,fx,fy,fz+4,0x10) then
				return fx-i,fy-i,fz
			end
			
			if not TraceLine(sx,sy,sz+2,fx+i,fy+i,fz+2,0x10) and not TraceLine(fx,fy-i,fz+4,fx,fy,fz+4,0x10) then
				return fx+i,fy+i,fz
			end
			
		end
	end
	return fx,fy,fz
end

function position_after_blink(direction)
	local px,py,pz = GetPlayerPosition()
	--ideal blink position (no obstacles)
	local bx,by,bz = GroundZ(px + 20 * math.cos(direction), py + 20 * math.sin(direction), pz)
	local x,y,z = px,py,pz
	
	if bx and by and bz then
		for i=1,20,.5 do
			local nx,ny,nz = GetPositionBetweenPositions(px,py,pz,bx,by,bz,i)
			nx,ny,nz = GroundZ(nx,ny,nz)
			local zdif = nz - z
			if zdif > .5 or zdif < -.5 then
				local lx,ly,lz = x,y,z--GetPositionBetweenPositions(x,y,z,px,py,pz,min(2,i))
				return lx,ly,lz
			else
				x,y,z = nx,ny,nz
			end
		end
	end
	
	-- local stuff = {bx,by,bz,x,y,z}
	-- local str = ""
	-- for i=1,#stuff do
	-- 	if stuff[i] then
	-- 		str = str .. stuff[i] .. " "
	-- 	else
	-- 		str = str .. i .. " "
	-- 	end
	-- end
	-- squid_print("Unable to determine GroundZ position in blink pos: "..direction.." "..str)
	-- x,y,z = bx,by,bz

	return x,y,z
end

--using position_after_blink (resource heavy higher accuracy)
-- function blink_los_point(unit,maxdist,x,y,z)
	
-- 	if not unit then return end
	
-- 	if not x or not y or not z then
-- 		x, y, z = ObjectPosition(unit)
-- 	end
	
-- 	local px, py, pz = GetPlayerPosition()
	
-- 	maxdist = maxdist or 100

-- 	-- local player_interruptable = PlayerCanBeKicked()

-- 	--update - check player los to blink pos and z dif before tracline from blink pos to unit
-- 	--thoughts - prio blink pos change: furthest from all units with interrupts > lowest z dif
-- 	local points = {}
-- 	for i=0,math.pi*2,.1256 do
-- 		local bx, by, bz = position_after_blink(i)--GroundZ ( px + 20 * math.cos(i), py + 20 * math.sin(i), pz )
-- 		if bx and by and bz and not TraceLine( px, py, pz + 1.3, bx, by, bz + 1.3, 0x100111 ) then
-- 			if not TraceLine( bx, by, bz + 1.6, x, y, z + 1.6, 0x100111 ) then
-- 				local dist = GetDistanceBetweenPositions(x,y,z,bx,by,bz) - UnitCombatReach("player") - UnitCombatReach(unit)
-- 				-- print(dist)
-- 				if dist < maxdist then
-- 					table.insert(points,{x=bx,y=by,z=bz,dist=dist})
-- 				end
-- 			end
-- 		end
-- 	end

-- 	table.sort(points,function(x,y) return x.dist < y.dist end)

-- 	if #points > 0 then

-- 		if #points == 1 then
-- 			return points[1].x,points[1].y,points[1].z
-- 		else
-- 			local index = math.ceil(#points/4)
-- 			local a,b,c = points[index].x,points[index].y,points[index].z
-- 			return a,b,c,points[index].dist
-- 		end
-- 	end

-- 	-- if #points > 0 then
-- 	-- 	if #points == 1 then
-- 	-- 		local a,b,c = GroundZ(points[1].x,points[1].y,points[1].z)
-- 	-- 		return a,b,c,points[1].dist
-- 	-- 	else
-- 	-- 		local index = math.ceil(#points/3)
-- 	-- 		local a,b,c = GroundZ(points[index].x,points[index].y,points[index].z)
-- 	-- 		return a,b,c,points[index].dist
-- 	-- 	end
-- 	-- end

-- end

-- using zdif at end of assumed blink pos and choosing the safest out of possible points (previous version)
function blink_los_point(unit,maxdist,x,y,z)
	
	if not unit then return end

	if not x and not y and not z then
		x, y, z = ObjectPosition(unit)
	end
	
	local px, py, pz = GetPlayerPosition()
	
	maxdist = maxdist or 100

	--update - check player los to blink pos and z dif before tracline from blink pos to unit
	--thoughts - prio blink pos change: furthest from all units with interrupts > lowest z dif
	local all_checks = {}
	local points = {}
	for i=0,math.pi*2,.1256 do
		local bx, by, bz = GroundZ ( px + 20 * math.cos(i), py + 20 * math.sin(i), pz )
		if bx and by and bz and not TraceLine( px, py, pz + 1.2, bx, by, bz + 1.2, collisionflags ) then
			all_checks[i] = true
			local zdif = pz - bz
			--max z dif of 1 yd
			if zdif < 1.25 and zdif > -1.25 then
				--make negative zdif positive for proper sorting (don't want climbing angle too high or too low)
				if zdif < 0 then zdif = -zdif end
				if not TraceLine( bx, by, bz + 1.5, x, y, z + 1.5, losflags ) then
					local dist_to_unit = GetDistanceBetweenPositions(x,y,z,bx,by,bz) - UnitCombatReach("player") - UnitCombatReach(unit)
					if dist_to_unit < maxdist then
						table.insert(points,{x=bx,y=by,z=bz,dist=dist_to_unit,zdif=math.floor(zdif)})
					end
				end
			end
		else
			all_checks[i] = false
		end
	end

	table.sort(points,function(x,y) return x.zdif < y.zdif or ( x.zdif == y.zdif and x.dist < y.dist ) end)

	if #points > 0 then
		if #points == 1 then
			return points[1].x,points[1].y,points[1].z
		else
			local index = math.ceil(#points/4)
			local a,b,c = points[index].x,points[index].y,points[index].z
			return a,b,c,points[index].dist
		end
	end

	-- if #points > 0 then
	-- 	if #points == 1 then
	-- 		local a,b,c = GroundZ(points[1].x,points[1].y,points[1].z)
	-- 		return a,b,c,points[1].dist
	-- 	else
	-- 		local index = math.ceil(#points/3)
	-- 		local a,b,c = GroundZ(points[index].x,points[index].y,points[index].z)
	-- 		return a,b,c,points[index].dist
	-- 	end
	-- end

end

function africa_blink()

	local px, py, pz = GetPlayerPosition()

	local points = {}
	for i=0,math.pi*2,.1256 do
		local bx, by, bz = GroundZ ( px + 20 * math.cos(i), py + 20 * math.sin(i), pz )
		if bx and by and bz and not TraceLine( px, py, pz + 1.2, bx, by, bz + 1.2, collisionflags ) then
			local zdif = pz - bz
			--max z dif of 1 yd
			if zdif < 1.25 and zdif > -1.25 then
				--make negative zdif positive for proper sorting (don't want climbing angle too high or too low)
				if zdif < 0 then zdif = -zdif end
				local _,_,avg_dist = Enemies_Around_Point(bx,by,bz,50)
				if avg_dist then
					table.insert(points,{x=bx,y=by,z=bz,dist=avg_dist,zdif=math.floor(zdif)})
				end
			end
		end
	end

	table.sort(points,function(x,y) return x.dist > y.dist end)

	if #points > 0 then
		if #points == 1 then
			return points[1].x,points[1].y,points[1].z
		else
			local index = math.ceil(#points/8)
			local a,b,c = points[index].x,points[index].y,points[index].z
			return a,b,c,points[index].dist
		end
	end

end

function best_meteor_point(unit,keypress,override)
	
	if not unit then return end
	
	-- local ux,uy,uz = ObjectPosition(unit)
	local ux,uy,uz = PredictUnitPosition(unit,.45)
	if not ux then
		ux,uy,uz = ObjectPosition(unit)
	end

	local px,py,pz = GetPlayerPosition()

	local points = {}

	local base_speed = select(2,GetUnitSpeed(unit))
	local current_speed = GetUnitSpeed(unit)
	local moving = current_speed > 0 or _isMoving(unit)

	local cc = _CCremains(unit)

	local meteor_impact_diameter = 8.75

	--maximum distance from unit that meteor will be placed
	local true_max_dist = 7
	true_max_dist = true_max_dist + (cc > 0 and not moving and round(min(1.5, cc)*.33, 1) or 0) -- true max dist can be complete edge if they will be cc'd in place for the entire 1.5 sec

	local dist = true_max_dist

	if cc > 1.5 and not moving then	
		-- everything is good
	elseif cc > 1.5 then
		dist = dist - (current_speed / 2)
	elseif moving then
		dist = dist - (current_speed / 1.2) - 1 + (keypress and .5 or 0)
	else
		dist = dist - (base_speed / (2.5 + Enemies_Around_Point(x,y,z,meteor_impact_diameter*1.5))) + min(1.5,_rootRemains(unit)) + (keypress and .5 or 0) + (unit_casting_info(unit) and 1 or 0) + (_isDummy(unit) and 2 or 0)
	end

	if override then dist = override end

	-- if keypress then dist = dist * 1.15 end
	if dist < 0 then dist = 0 end
	if dist > true_max_dist then dist = true_max_dist end

	local flamecannon_stacks = _buffStacks("player",203285)
	local flamecannon_value = (flamecannon_stacks * 3)	

	local meteor_range = 39.5 + flamecannon_value

	local circ = ( override and (math.pi*2) / 4 or (math.pi*2) / 16 )
	for d=.3,dist,((dist-.3)/9) do
		for i=0,math.pi*2,circ do
			local x,y,z = GroundZ (ux + d * math.cos(i), uy + d * math.sin(i), uz+2)
			if x and y and z and not TraceLine(x, y, z+1.7, px, py, pz+1.7, losflags) and not TraceLine(x, y, z+1.1, ux, uy, uz+1.1, losflags) and GetDistanceBetweenPositions(x,y,z,px,py,pz) < meteor_range then
				local hit,bcc,avg = Enemies_Around_Point(x,y,z,meteor_impact_diameter,unit)
				if bcc == 0 then
					local zdif = z - uz
					zdif = math.abs(zdif)
					if d+zdif <= true_max_dist then
						table.insert(points,{x=x,y=y,z=z,hit=hit,avg=avg})
					end
				end
			end
		end
	end

	table.sort(points,function(x,y) return x.hit < y.hit or (x.hit == y.hit and x.avg > y.avg) end)

	if #points > 0 then
		local x,y,z = points[1].x,points[1].y,points[1].z
		if points[1].hit > 0 and not override then
			return best_meteor_point(unit,keypress,0)
		end
		return x,y,z,points[1].hit,points[1].avg
	elseif keypress then
		Squid_Alert_Big("No viable meteor point",nil,nil,nil,153561)
	end

end

-- function best_meteor_point(unit,keypress)
-- 	if not unit then return end
-- 	local ux,uy,uz 
-- 	if keypress then
-- 		ux,uy,uz = PredictUnitPosition(unit,.3)
-- 	else
-- 		ux,uy,uz = ObjectPosition(unit)
-- 	end

-- 	local px,py,pz = GetPlayerPosition()

-- 	local cc = _CCremains(unit)

-- 	local speed = select(4,GetUnitSpeed(unit))
-- 	local actualspeed = GetUnitSpeed(unit)

-- 	local points = {}

-- 	local meteor_impact_diameter = 8.75

-- 	--max dist from target to place meteor
-- 	local dist = 7.5

-- 	local is_slowed, slow_percent = unit_is_slowed(unit)

-- 	local minmaxdist = (slow_percent >= 60 and 6 
-- 					or slow_percent >= 40 and 5 
-- 					or slow_percent >= 30 and 4.5 
-- 					or slow_percent >= 20 and 4
-- 					or GetUnitSpeed(unit) > 12 and (2 - (_isMoving(unit) and 2 or 0))
-- 					or GetUnitSpeed(unit) > 9 and (2.6 - (_isMoving(unit) and 2 or 0))
-- 					or not _isMoving(unit) and (5.25 + ((unit_casting_info(unit) or _rootCheck(unit)) and 2 or 0))
-- 					or 3)

-- 	-- reduce max dist based on target cc remaining
-- 	if cc < 1 then
-- 		if cc > 0 then
-- 			local reduc = (7-(cc*8))
-- 			if reduc > 0 then
-- 				dist = dist - reduc
-- 			end
-- 			if _isMoving(unit) and dist > 0 then
-- 				dist = dist - (actualspeed/2)
-- 			end
-- 			if dist < 0 then dist = .3 end
-- 		else
-- 			if _isMoving(unit) then
-- 				dist = minmaxdist
-- 			else
-- 				if not unit_casting_info(unit) and not _rootCheck(unit) and not _isDummy(unit) then
-- 					dist = minmaxdist - .3
-- 				else
-- 					dist = minmaxdist + .6
-- 				end
-- 			end
-- 		end
-- 	end

-- 	if keypress and dist < minmaxdist then dist = minmaxdist end -- minimum max dist when pressed manually
-- 	if dist < 0 then dist = 0 end

-- 	if _isMoving(unit) then
-- 		if dist > 7 then dist = 7 end
-- 	else
-- 		if dist > 7.5 then dist = 7.5 end
-- 	end

-- 	local flamecannon_stacks = _buffStacks("player",203285)
		
-- 	local flamecannon_value = (flamecannon_stacks * 3)	

-- 	local meteor_range = 39.5 + flamecannon_value

-- 	local circ = (math.pi*2) / 14

-- 	if cc <= 0 then
-- 		if GetUnitSpeed(unit) >= 8 then
-- 			local ux,uy,uz = PredictUnitPosition(unit,.75)
-- 			for d=.3,dist,((dist-.3)/10) do
-- 				for i=0,math.pi*2,circ do
-- 					local x,y,z = GroundZ (ux + d * math.cos(i), uy + d * math.sin(i), uz+2)
-- 					if x and y and z and not TraceLine(x, y, z+1.7, px, py, pz+1.7, losflags) and not TraceLine(x, y, z+1.5, ux, uy, uz+1.5, losflags) and GetDistanceBetweenPositions(x,y,z,px,py,pz) < meteor_range then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
-- 						local mx = x
-- 						local my = y
-- 						local mz = z
-- 						-- local dist = GetDistanceBetweenPositions(px,py,pz,mx,my,mz)
-- 						local hit,bcc,avg = Enemies_Around_Point(mx,my,mz,meteor_impact_diameter,unit)
-- 						if bcc == 0 and (d >= 6.5 or hit == 0 or keypress) then
-- 							local zdif = mz - uz
-- 							zdif = math.abs(zdif)
-- 							if d+zdif <= 7.5 then
-- 								table.insert(points,{xx=mx,yy=my,zz=mz,hit=hit,avg=avg})
-- 							end
-- 						end
-- 					end
-- 				end
-- 			end
-- 		else
-- 			for d=.3,dist,((dist-.3)/10) do
-- 				for i=0,math.pi*2,circ do
-- 					local x,y,z = GroundZ (ux + d * math.cos(i), uy + d * math.sin(i), uz+2)
-- 					if x and y and z and not TraceLine(x, y, z+1.7, px, py, pz+1.7, losflags) and not TraceLine(x, y, z+1.5, ux, uy, uz+1.5, losflags) and GetDistanceBetweenPositions(x,y,z,px,py,pz) < meteor_range then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
-- 						local mx = x
-- 						local my = y
-- 						local mz = z
-- 						-- local dist = GetDistanceBetweenPositions(px,py,pz,mx,my,mz)
-- 						local hit,bcc,avg = Enemies_Around_Point(mx,my,mz,meteor_impact_diameter,unit)
-- 						print(dist)
-- 						if bcc == 0 and (d >= 6.5 or hit == 0 or keypress) then
-- 							local zdif = mz - uz
-- 							zdif = math.abs(zdif)
-- 							if d+zdif <= 7.5 then
-- 								table.insert(points,{xx=mx,yy=my,zz=mz,hit=hit,avg=avg})
-- 							end
-- 						end
-- 					end
-- 				end
-- 			end
-- 		end
-- 	else
-- 		for d=dist,.3,-((dist-.3)/10) do
-- 			for i=0,math.pi*2,circ do
-- 				local x,y,z = GroundZ (ux + d * math.cos(i), uy + d * math.sin(i), uz+2)
-- 				if x and y and z and not TraceLine(x, y, z+1.7, px, py, pz+1.7, losflags) and not TraceLine(x, y, z+1.5, ux, uy, uz+1.5, losflags) and GetDistanceBetweenPositions(x,y,z,px,py,pz) < meteor_range then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
-- 					local mx = x
-- 					local my = y
-- 					local mz = z
-- 					-- local dist = GetDistanceBetweenPositions(px,py,pz,mx,my,mz)
-- 					local hit,bcc,avg = Enemies_Around_Point(mx,my,mz,meteor_impact_diameter,unit)
-- 					if bcc == 0 and (d >= 6.5 or hit == 0 or keypress) then
-- 						local zdif = mz - uz
-- 						zdif = math.abs(zdif)				
-- 						if d+zdif <= 7.5 then
-- 							table.insert(points,{xx=mx,yy=my,zz=mz,hit=hit,avg=avg})
-- 						end
-- 					end
-- 				end
-- 			end
-- 		end
-- 	end

-- 	table.sort(points,function(x,y) return x.hit < y.hit or (x.hit == y.hit and x.avg > y.avg) end)

-- 	if #points > 0 then
-- 		local a,b,c = points[1].xx,points[1].yy,points[1].zz
-- 		print (points[1].hit)
-- 		return a,b,c,points[1].hit
-- 	elseif keypress then
-- 		Squid_Alert_Big("No viable meteor point",nil,nil,nil,153561)
-- 	end

-- end

function Queue_Trap(unit)
	if unit == "focus" then
		focus_trap_queued = GetTime()
	elseif unit == "healer" then
		healer_trap_queued = GetTime()
	end
end

function rop_unit_to_unit(unit,unit2)
	if not unit or not unit2 then return end
	local x,y,z = ObjectPosition(unit)
	local x2,y2,z2 = ObjectPosition(unit2)

	-- x,y,z = GroundZ(x,y,z)

	local points = {}

	local direction
	for i=0,math.pi*2,.4 do
		local x,y,z = GroundZ (x + 2 * math.cos(i), y + 2 * math.sin(i), z)
		if not TraceLine(x, y, z+2, x2, y2, z2+2, losflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
			direction = i
			local mx = x --+ 7.25 * math.cos(direction)
			local my = y --+ 7.25 * math.sin(direction)
			local mz = z
			local dist = GetDistanceBetweenPositions(x2,y2,z2,mx,my,mz)
			table.insert(points,{x=mx,y=my,z=mz,dist=dist})
		end
	end

	table.sort(points,function(x,y) return x.dist > y.dist end)

	if #points > 0 then
		local a,b,c = points[1].x,points[1].y,points[1].z
		return a,b,c,points[1].dist
	end

end

local CameraOrSelectOrMoveStart_OG
CreateFrame("Frame"):SetScript("OnUpdate",function()
	if not IsHackEnabled then return end
	if not CameraOrSelectOrMoveStart_OG then CameraOrSelectOrMoveStart_OG = CameraOrSelectOrMoveStart end
end)

function ring_of_frost(unit, player_forced)
	if not IsPlayerSpell(113724) or not UnitExists(unit) then return end
	local ring_cd = _spellCooldown(113724)
	local buffer = (select(4,GetNetStats())/1000)+(2/GetFramerate())+.05
	local ring_range = 30 + (_buffStacks("player",203285) * 3)
	if ring_cd <= buffer and ( not UnitCastingInfo("player") or _castTimeLeft("player") <= buffer*1.5 ) then
		local x,y,z = ObjectPosition(unit)
		local px,py,pz = GetPlayerPosition()
		
		-- to the right or left side of them
		local moving_direction = GetMovingDirection(unit) 
		moving_direction = mod(moving_direction + math.pi, math.pi * 1.5)
		local moving_direction_right = mod(moving_direction + math.pi, math.pi * .5)

		local step = (math.pi*2) / 12

		local direction

		if _isMoving(unit) then
			local directions = {}
			for i=0,math.pi*2,step do
				if GetDistanceBetweenPositions(x-5*math.cos(i),y-5*math.sin(i),z,px,py,pz) < ring_range and not TraceLine(x-5*math.cos(i),y-5*math.sin(i),z+1,px,py,pz+1,losflags) then
					table.insert(directions,i)
				end
			end
			local function sort_directions(dir1, dir2)
				return abs(moving_direction-dir1) < abs(moving_direction-dir2)
			end
			table.sort(directions, sort_directions)
			direction = directions[1]
		else
			for i=0,math.pi*2,step do
				if GetDistanceBetweenPositions(x-5*math.cos(i),y-5*math.sin(i),z,px,py,pz) < ring_range and not TraceLine(x-5*math.cos(i),y-5*math.sin(i),z+1,px,py,pz+1,losflags) then
					direction = i
					break
				end
			end
		end

		if direction then

			if not _isMoving("player") then
				
				local t = current_target
				
				x = x - 5 * math.cos(direction)
				y = y - 5 * math.sin(direction)

				local dir = _getMovingDirection(unit)
				local dist = ( not _CCcheck(unit) and GetUnitSpeed(unit) * (squid_avg_latency + (_castTime(113724)/4) + .25) or ( UnitDebuffID(unit,118699) or UnitDebuffID(unit,8122) ) and GetUnitSpeed(unit) * ( _castTime(113724) + squid_avg_latency + squid_avg_home_latency + (1/GetFramerate()) ) or GetUnitSpeed(unit)/5.6 )
				x = x + dist * math.cos(dir)
				y = y + dist * math.sin(dir)

				if not SQUID.streaming_mode or player_can_see_coords(x,y,z) then

					local target_existed = UnitExists("target")

					CameraOrSelectOrMoveStop()

					CameraOrSelectOrMoveStart = function() end

				 	SQ_CastSpellByID(113724)

					ClickPosition(x, y, z)

					Squid_Alert_Big("Ring of Frost",UnitClass(unit),nil,nil,113724)

					if target_existed then _targetLastTarget() end

					C_Timer.After(.1,function() CameraOrSelectOrMoveStart = CameraOrSelectOrMoveStart_OG; if target_existed then _targetLastTarget() end end)
				end
			end

			if IsAoEPending() then
				CancelPendingSpell();
			end

			return true

		else
			CancelPendingSpell()
		end
	end
end

function door_of_shadows(unit)

	local x,y,z = PredictUnitPosition(unit,.4)
	local px,py,pz = GetPlayerPosition()

	if not _isMoving("player") and _spellCooldown(300728) == 0 then
		if GetDistanceBetweenPositions(px,py,pz,x,y,z) < 35 then
			if not SQUID.streaming_mode or player_can_see_coords(x,y,z) then

				local target_existed = UnitExists("target")

				CameraOrSelectOrMoveStop()
				CameraOrSelectOrMoveStart = function() end

			 	SQ_CastSpellByID(300728)
				ClickPosition(x, y, z)
				Squid_Alert_Big("Door of Shadows",UnitClass(unit),nil,nil,300728)

				if target_existed then _targetLastTarget() end
				C_Timer.After(.1,function() CameraOrSelectOrMoveStart = CameraOrSelectOrMoveStart_OG; if target_existed then _targetLastTarget() end end)

				door_of_shadows_pos = {unit,x,y,z,GetTime()}

				if IsAoEPending() then
					CancelPendingSpell();
				end

			end
		end
	end

end

function blink_db_point(unit)

	if not UnitIsVisible(unit) then return false end
	local x,y,z = ObjectPosition(unit)
	local px,py,pz = GetPlayerPosition()

	-- local step = (math.pi*2) / 8
	-- for n=3,8 do
	-- 	for i=0,math.pi*2,step do
	-- 		if not TraceLine(x - n * math.cos(i), y - n * math.sin(i), z+2, px, py, pz+2, 0x100111) then

	local maxdist = 10.5

	local points = {}

	local step = (math.pi*2) / 12
	local direction
	for i=0,math.pi*2,step do
		local bx, by, bz = GroundZ ( px + 20 * math.cos(i), py + 20 * math.sin(i), pz )
		if bx and by and bz and not TraceLine(px, py, pz+1.2, bx, by, bz+1.2, collisionflags) then
			local zdif = pz - bz
			if zdif < 1.5 and zdif > -1.5 then
				if zdif < 0 then zdif = -zdif end
				if not TraceLine( bx, by, bz + 1.7, x, y, z + 1.7, losflags ) then
					local dist = GetDistanceBetweenPositions(x,y,z,bx,by,bz)
					if dist < maxdist then
						table.insert(points,{x=bx,y=by,z=bz,dist=dist,zdif=math.floor(zdif)})
					end
				end
			end
		end
	end

	table.sort(points,function(x,y) return x.zdif < y.zdif or ( x.zdif == y.zdif and x.dist < y.dist ) end)

	if #points > 0 then
		if #points == 1 then
			local a,b,c = points[1].x,points[1].y,points[1].z
			return a,b,c,points[1].dist
		else
			-- local a,b,c = GroundZ(points[1].x,points[1].y,points[1].z)
			-- return a,b,c,points[1].dist
			local index = math.ceil(#points/4)
			local a,b,c = points[index].x,points[index].y,points[index].z
			return a,b,c,points[index].dist
		end
	end

end

function blink_to_db(unit)

	local time = GetTime()

	if not Squid_DB then return false end

	if _spellCooldown(31661) > GetGCD()+.1 then return false end

	if not UnitIsVisible(unit) then return false end

	local px,py,pz = GetPlayerPosition()

	local x,y,z = blink_db_point(unit)

	if _realDistance(unit) > 10.5 then
		if x and y and z and _spellCooldown(212653) == 0 and (not player_blink or time - player_blink > .65) then
			local dir = GetAnglesBetweenPositions(px,py,pz,x,y,z)
			FaceDirection(dir,true)
			SQ_CastSpellByID(1953)
			player_blink = time
			return true
		end
	end

end

function blink_db(unit)

	local time = GetTime()

	if not Squid_DB then return false end

	if _spellCooldown(31661) > .1 then return false end

	if not UnitIsVisible(unit) then return false end

	local px,py,pz = GetPlayerPosition()

	local x,y,z = blink_db_point(unit)

	if _distance(unit) > 12.5 then
		if x and y and z and _spellCooldown(212653) == 0 and (not player_blink or time - player_blink > squid_avg_latency + .5) then
			local dir = GetAnglesBetweenPositions(px,py,pz,x,y,z)
			FaceDirection(dir,true)
			local c = ObjectFacing("player") 
			if abs( c - dir ) < .1 then
				SQ_CastSpellByID(1953)
				player_blink = time
				return true
			end
		end
	else 
		x,y,z = PredictUnitPosition(unit,.08)
		if GetDistanceBetweenPositions(x,y,z,px,py,pz) < 9.25 and not TraceLine(x,y,z+1.6,px,py,pz+1.6,losflags) then
			if unit_casting_info("player") ~= "Greater Pyroblast" then
				SpellStopCasting()
			end
			return Squid_DB(unit)
		end
	end

end

function RopPosition(x,y,z)
	if _Cast(116844) then
		ClickPosition(x,y,z)
		Squid_Alert_Big("Ring of Peace","(Double Stun)",1,nil,116844)
	end
	CancelPendingSpell()
end

function MaxDistLoS(unit,distance)

	local px,py,pz=GetPlayerPosition();
	
	if not distance then return; end
	if not ObjectIsVisible(unit) then return; end

	local ux,uy,uz=ObjectPosition(unit);

	local distanceToUnit = _distance(unit);

	local coords = {};

	for i=1,math.pi*2,.05 do
		local x = px + distance * math.cos(i);
		local y = py + distance * math.sin(i);
		local newx,newy,newz=x,y,pz
		local z = newz or pz
		local dist = _distanceToCoord(x,y,z,ux,uy,uz);
		local zdiff = z-pz
		local los = not TraceLine(x,y,z+2,ux,uy,uz+2,0x10) and 1 or 0;
		local lospoint = not TraceLine(x,y,z+2,px,py,pz+2,0x10) and 1 or 0;
		-- print("Grounded: "..z)
		-- print("Current: "..pz)
		if los == 1 and lospoint == 1 and zdiff < 7 and zdiff > -7 then
			table.insert(coords,{x=x,y=y,z=z,dist=dist,los=los})
		end
	end
	table.sort(coords,function(x,y) return x.los > y.los or (x.los == y.los and x.dist > y.dist) end);

	--mid
	local num=#coords
	-- print(num)
	if #coords > 0 then
		--further we are away, the wider the angle.
		local mod = distanceToUnit/distance
		if mod > 1 then mod=1; end
		if mod < .01 then mod=.01; end
		num=math.ceil(#coords*mod);
	end

	if coords[1] and coords[num].los == 1 then
		return coords[num].x,coords[num].y,coords[num].z;
	end

end

-- Turn the player towards a point
function _faceLocation(X,Y,Z)
	local PlayerX, PlayerY, PlayerZ = GetPlayerPosition();

	-- if rad(atan2(Y - PlayerY, X - PlayerX)) < 0 then
	local dir = GetAnglesBetweenPositions(PlayerX,PlayerY,PlayerZ,X,Y,Z)
	FaceDirection(dir,true)
		-- FaceDirection(rad(atan2(Y - PlayerY, X - PlayerX) + 360),true);
	-- end
	return;
end

function _faceAwayFrom(X,Y)
	local PlayerX, PlayerY = GetPlayerPosition();
	if rad(atan2(Y - PlayerY, X - PlayerX)) < 0 then
		FaceDirection(rad(atan2(Y - PlayerY, X - PlayerX) + 360));
	else
		FaceDirection(rad(atan2(Y - PlayerY, X - PlayerX)));
	end
	FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
	return;
end

function _faceAwayFromUnit(unit)
	if not ObjectIsVisible(unit) then return false; end
	_faceAwayFrom(ObjectPosition(unit));
end

function _faceUnit(unit)
	FaceDirection(_anglesBetweenObjects("player",unit),true)	
end

local beastbuff			=
{
5487,		-- Bear
768,		-- Cat
783,		-- Travel
33891, 		-- Tree
24858,		-- Moonkin
197625,		-- Balance Affinity Moonkin
-- 171746,		-- Claws of Shirvallah Cat
}
function _isBeast(unit)
	for i=1,#beastbuff do
		if UnitBuffID(unit,beastbuff[i]) then
			return true;
		end
	end
end

--retreat forward (for macro)
function RetreatForward()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	if _spellCooldown(198793) <= gcd then

		if unit_casting_info("player") then
			SpellStopCasting();
			RunMacroText("/stopcasting")
			return
		end

		if _spellCooldown(198793) == 0 then

			if not IsFlying() and not IsSwimming() then
			if not IsFalling() then JumpOrAscendStart(); end
			JumpOrAscendStart();
			end
			TurnOrActionStart();
			FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
			_Cast(198793);
			Squid_Alert("Retreat Forward",nil,nil,nil,198793)
			C_Timer.After(0.4 + (select(4,GetNetStats())/1000), function()
				TurnOrActionStart()
				FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
			end)
			PauseGCD = GetTime()
			C_Timer.After(.8, function()
			if IsMouselooking() and not IsMouseButtonDown(2) then
				MouselookStop()
			end end)
			return;
		end

	end
end

function RetreatToUnit(unit,los,close)
	if not UnitIsVisible(unit) then return false; end
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local facing = ObjectFacing("player");
	if _spellCooldown(198793) == 0 and not UnitBuffID("player",209426) then
		--closest possible point
		if close then
			local x,y,z = _findCorner(unit,15);
			if x and y and z then
				return RetreatToCoords(x,y,z);
			end
			return;
		end
		--directly towards
		if not los then
			if not IsFlying() and not IsSwimming() and not IsFalling() then
				JumpOrAscendStart();
			end
			TurnOrActionStart();
			_faceAwayFromUnit(unit);
			_Cast(198793);
			C_Timer.After(0.4 + ((select(4,GetNetStats())/1000)+.025), 
			function()
				TurnOrActionStart();
				FaceDirection(facing,true); 
				end)
			C_Timer.After(1, 
			function()
				if IsMouselooking() and not IsMouseButtonDown(2) then
					MouselookStop();
				end 
			end)
			return true;
		else
			--into their LoS
			local x,y,z=MaxDistLoS(unit,15);
			if x and y and z then
				return RetreatToCoords(x,y,z);
			end
		end
	end
end

function RetreatToCoords(x,y,z)
	if _spellCooldown(198793) == 0 then
		local facing=ObjectFacing("player");
		if not IsFlying() and not IsSwimming() and not IsFalling() then
			JumpOrAscendStart();
		end
		TurnOrActionStart();
		_faceAwayFrom(x,y);
		_Cast(198793);
		C_Timer.After(0.4 + ((select(4,GetNetStats())/1000)+.025), 
		function()
			TurnOrActionStart();
			FaceDirection(facing,true); 
			end)
		C_Timer.After(1, 
		function()
			if IsMouselooking() and not IsMouseButtonDown(2) then
				MouselookStop();
			end 
		end)
		return true;
	end
end

--Disengage to a target
function _disengageToUnit(unit,los,close)
	if not UnitIsVisible(unit) then return false end
	local facing = ObjectFacing("player")
	if _spellCooldown(781) == 0 then
		--closest possible point
		if close then
			local x,y,z = _findCorner(unit,15);
			if x and y and z then
				return _disengageToCoords(x,y,z)
			end
			return;
		end
		--directly towards
		if not los then
			if not IsFlying() and not IsSwimming() and not IsFalling() then
				JumpOrAscendStart()
			end
			TurnOrActionStart()
			_faceAwayFromUnit(unit)
			_Cast(781);
			C_Timer.After(0.4 + ((select(4,GetNetStats())/1000)+.025), 
			function()
				TurnOrActionStart()
				FaceDirection(facing,true)
				end)
			C_Timer.After(1, 
			function()
				if IsMouselooking() and not IsMouseButtonDown(2) then
					MouselookStop()
				end 
			end)
			return true;
		else
			--into their LoS
			local x,y,z=MaxDistLoS(unit,15);
			if x and y and z then
				return _disengageToCoords(x,y,z)
			end
		end
	end
end

disengage_to_unit = _disengageToUnit

function DisengageForward()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	if _spellCooldown(781) <= gcd then

		if unit_casting_info("player") then
			SpellStopCasting();
			RunMacroText("/stopcasting")
			return
		end

		if _spellCooldown(781) == 0 then

			if not IsFlying() and not IsSwimming() then
				if not IsFalling() then JumpOrAscendStart(); end
				JumpOrAscendStart();
			end
			TurnOrActionStart();
			FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
			_Cast(781);
			C_Timer.After(0.4 + (select(4,GetNetStats())/1000), function()
			TurnOrActionStart()
			FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true) end)
			C_Timer.After(1, function()
			if IsMouselooking() and not IsMouseButtonDown(2) then
				MouselookStop()
			end end)
			return;
		end

	end
end

function _disengageToCoords(x,y,z)
	if _spellCooldown(781) == 0 then
		local facing=ObjectFacing("player");
		if not IsFlying() and not IsSwimming() and not IsFalling() then
			JumpOrAscendStart();
		end
		TurnOrActionStart();
		_faceAwayFrom(x,y);
		_Cast(781);
		C_Timer.After(0.4 + ((select(4,GetNetStats())/1000)+.025), 
		function()
			TurnOrActionStart();
			FaceDirection(facing,true); 
			end)
		C_Timer.After(1, 
		function()
			if IsMouselooking() and not IsMouseButtonDown(2) then
				MouselookStop();
			end 
		end)
		return true;
	end
end


function basic_path_to_position(x,y,z)

	local px,py,pz = GetPlayerPosition()
	local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)

	local positions = {}
	for i=0,dist*2,1.5 do
		for n=0,math.pi*2,.78539816339745 do
			local nx,ny,nz = px + i * math.cos(n), py + i * math.sin(n), pz
			if not TraceLine(nx, ny, nz+2, px, py, pz+2, collisionflags) and not TraceLine(nx, ny, nz+2, x, y, z+2, collisionflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
				local dist = GetDistanceBetweenPositions(nx,ny,nz,x,y,z)
				table.insert(positions, {nx,ny,nz,dist=dist} )
			end
		end
	end

	table.sort(positions,function(x,y) return x.dist < y.dist end)

	if #positions > 0 then
		return positions[1][1],positions[1][2],positions[1][3]
	end

end

--arena map ids
--Dalaran Sewers - 617
--Robodrome - 2167
function basic_path_to_unit(unit)
	if not UnitIsVisible(unit) then return false end
	local px,py,pz = ObjectPosition("player")
	local x,y,z = ObjectPosition(unit)
	x,y,z = GroundZ(x,y,z)
	px,py,pz = GroundZ(px,py,pz)

	local zdif = z - pz

	--hardcode coords to reach high ground
	local map_id = GetMapId()

	--dalaran sewers
	if map_id == 617 then
		local corner_ramps = {
			{1316.4604,815.6157,6.3605},
			{1316.4291,766.1436,6.3000},
			{1267.0081,766.3588,6.3912},
			{1267.4458,815.8305,6.4436}
		}
		if zdif > .95 then
			local cache = 9999
			local closest
			for i=1,#corner_ramps do
				local c = corner_ramps[i]
				local cx,cy,cz = c[1],c[2],c[3]
				local dist = GetDistanceBetweenPositions(px,py,pz,cx,cy,cz)
				if dist < cache then
					cache = dist
					closest = i
				end
			end
			if closest then
				return unpack( corner_ramps[closest] )
			end
		end
	elseif map_id == 1672 then
		local ramps = {
				--base of ramp                         top of ramp
			{ {2805.7695,5983.1801,-4.2972}, {2793.9577,5997.3959,4.8389} },
			{ {2768.8527,5955.9843,-3.6616}, {2757.9562,5970.0986,4.7787} },
			{ {2737.4426,5995.3120,-3.4376}, {2749.0620,5981.2573,4.2135} },
			{ {2770.2729,6026.2255,-3.773}, {2781.1542,6012.4321,4.7856} },
			{ {2803.1135,6051.0087,-3.7833}, {2815.1135,6035.5317,4.335} },
			{ {2836.7836,6011.1787,-3.8473}, {2824.0773,6026.0371,4.6} },
		}
		if zdif > 7.2 then
			local cache = 9999
			local closest
			for i=1,#ramps do
				local r = ramps[i]
				local bx,by,bz = r[1][1], r[1][2], r[1][3]
				local dist = GetDistanceBetweenPositions(px,py,pz,bx,by,bz)
				if dist < cache then
					cache = dist
					closest = i
				end
			end
			if closest then
				if cache > 1.5 then
					return basic_path_to_position ( unpack ( ramps[closest][1] ) )
				else
					return unpack ( ramps[closest][2] )
				end
			end
		else
			if zdif > 1 then
				local cache = 9999
				local closest
				for i=1,#ramps do
					local r = ramps[i]
					local bx,by,bz = r[2][1], r[2][2], r[2][3]
					local dist = GetDistanceBetweenPositions(px,py,pz,bx,by,bz)
					local los = not TraceLine(px,py,pz+2,bx,by,bz+2,collisionflags)
					if dist < cache and los then
						cache = dist
						closest = i
					end
				end
				if closest then
					return unpack ( ramps[closest][2] )
				end
			end
		end
	end

	if _LoS(unit) then
		return x,y,z
	else
		local x,y,z = ObjectPosition(unit)
		local px,py,pz = GetPlayerPosition()
		local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)
		-- i = dist, n = direction
		local positions = {}
		for i=0,dist,2 do
			for n=0,math.pi*2,.78539816339745 do
				local nx,ny,nz = px + i * math.cos(n), py + i * math.sin(n), pz
				if not TraceLine(nx, ny, nz+2, px, py, pz+2, collisionflags) and not TraceLine(nx, ny, nz+2, x, y, z+2, collisionflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
					local dist = GetDistanceBetweenPositions(nx,ny,nz,x,y,z)
					table.insert(positions, {nx,ny,nz,dist=dist} )
				end
			end
		end
		table.sort(positions,function(x,y) return x.dist < y.dist end)
		if #positions > 0 then
			return positions[1][1],positions[1][2],positions[1][3]
		end
	end
end

--mastery 10yd
--75 20yd
--25 30yd
--0 40yd

--(40 - _distance("target"))* 28 / 100
spell_effect_cache = {}

function GetSpellEffect(spellID)
	if not spellID then return end
	if spell_effect_cache[spellID] then return spell_effect_cache[spellID] end
	local desc = GetSpellDescription(spellID);
	local blocks = {};
	for n in desc:gmatch("%S+") do
		table.insert(blocks,n);
	end
	local good = {}
	for i=1,#blocks do
		local s = string.gsub(blocks[i],",","");
		table.insert(good,s);
	end
	local reallygood={};
	for i=1,#good do if tonumber(good[i]) then table.insert(reallygood,tonumber(good[i])); end end
	table.sort(reallygood, function(x,y) return x > y end)
	spell_effect_cache[spellID] = reallygood[1]
	return reallygood[1]
end

local CostTip = CreateFrame('GameTooltip')
local CostText = CostTip:CreateFontString()
CostTip:AddFontStrings(CostTip:CreateFontString(), CostTip:CreateFontString())
CostTip:AddFontStrings(CostText, CostTip:CreateFontString())
function PowerCostFromTooltip(spellID) -- returns the value of the second line of the tooltip
	if not spellID then return end
	CostTip:SetOwner(WorldFrame, 'ANCHOR_NONE')
	CostTip:SetSpellByID(spellID)
	return CostText:GetText()
end

--Get the cost (number)
function GetSpellCost(spellID)
	local costText = PowerCostFromTooltip(spellID) -- get the line out of the tooltip
	local costString = {};
	for w in costText:gmatch("%S+") do if tonumber(w) then table.insert(costString,w) end end
	local cost=costString[1];
	if cost == nil then cost = -1 end
	return tonumber(cost);
end

function squid_cast(castinfo,unit)
	local name = castinfo.name
	local id = castinfo.id
	local cd = castinfo.cd
	local facing = castinfo.facing
	local immunetype = castinfo.immunetype

	local latency = (select(4,GetNetStats())/1000)
	local update = (1/GetFramerate())*2
	local spellwindow = .1

	local gcdbuffer = latency+update+spellwindow

	--dont cast spells on cd
	if cd > gcdbuffer then return false end

	--dont cast while casting, unless it's a spell that can do that
	local castable_while_casting = {
	"Fire Blast",
	"Enveloping Mist",
	"Vivify",
	"Surging Mist",
	}

	local cast = unit_casting_info("player")
	local channel = UnitChannelInfo("player")

	if (cast or channel) and not tContains(castable_while_casting,name) then return false end

	--check facing if required
	if unit and facing == true and not am_i_facing(unit) then return false end

	--check immunities
	if immunetype and unit then
		if immunetype == "magic" and _immuneMagic(unit) then return false end
		if immunetype == "physical" and _immunePhysical(unit) then return false end
	end

	--casts with designated unit
	if unit then
		if _spellInRange(id,unit) and _LoS(unit) then
			--force facing the unit
			if facing == "force" then
				if IsUsableSpell(name) then
					local facing = ObjectFacing("player");
					FaceDirection(_anglesBetweenObjects("player",unit))	
					SQ_CastSpellByName(name,unit)
					FaceDirection(facing)
				end
			else
				SQ_CastSpellByName(name,unit)
			end
			return true
		end
		SQ_CastSpellByName(name,"");
		if IsPlayerSpell(id) then return true; end
	end
end

local only_by_id = {
	[118] = true,		-- Sheep
	[28272] = true,		-- Pig
	[277792] = true,		-- Bee
	[161354] = true,		-- Monkey
	[277787] = true,		-- Direhorn
	[161355] = true,		-- Penguin
	[161353] = true,		-- Polar Bear
	[120140] = true,		-- Porcupine
	[61305] = true,		-- Cat
	[61721] = true,		-- Rabbit
	[61780] = true,		-- Turkey
	[28271] = true,		-- Turtle
}

next_cast_attempt = {}
function _Cast(spell,unit,requiresfacing,forcefacing,ignorecc,forcequeue)

	local spell_string = tostring(spell)
	local unit_string = tostring(unit)
	local rf_string = tostring(requiresfacing)
	local ff_string = tostring(forcefacing)
	local icc_string = tostring(ignorecc)
	
	local arg_string = spell_string..unit_string..rf_string..ff_string..icc_string

	local latency = select(4,GetNetStats())/1000
	local update = 1/GetFramerate()
	local time = GetTime()

	if next_cast_attempt[arg_string] and time < next_cast_attempt[arg_string] and IsSpellOnGCD(spell) then
		return true
	end

	if dumpstuff then
		local cd,unit,spellid,req,facing,ignorecc = _spellCooldown(spell),unit or "No Unit",(spell or "No Spell"),(requiresfacing and "Yes" or "No"),(forcefacing and "Yes" or "No"),(ignorecc and "No" or "Yes")
		if spellid and (spell_logged ~= spellid) then
			spell_logged = spellid
			WriteFile("SquidDump.txt", "SpellID = "..spellid..", Target = "..unit..", ReqFacing = "..req.. ", ForceFacing = " ..facing.. ", IgnoreControl = " ..ignorecc .."\n", true)
        end
    end

	if unit and (UnitIsDeadOrGhost(unit) or UnitIsDead(unit)) then return false end

	local spellName = GetSpellInfo(spell)
	if not spellName then return end
	
	local buffer = latency+update+.25

	-- no stupid rune of powers
	if spell == 116011 then
		--devour magic (Nya - Maut)
		if UnitDebuffID("player",307806) then return false end
	end

	if spell == 223829 and not IsPlayerSpell(spell) then
		spell=55090;
	end
	
	if _spellCooldown(spell) > buffer then return false; end

	if AlwaysFacing and unit then forcefacing=true end

	--do not begin casts with quaking debuff
	local quaking_remains = _debuffRemains("player",240447)
	if quaking_remains > 0 and _castTime(spell) > 0 and _castTime(spell) > quaking_remains - 0.5 then return false end

	if UnitBuffID("player",227847) then
		if spellid ~= 97462 then return false; end
	end

	if not player_has_control() and not ignorecc then return false end

	local castableWhileCasting = {
		"Fire Blast",
		"Enveloping Mist",
		"Vivify",
		"Surging Mist",
		"Touch of Karma",
		"Combustion",
	}

	local queueSpells = {
		"Pyroblast",
		"Breath of the Dying",
		-- "Frost Nova",
	}

	if (UnitChannelInfo("player") or unit_casting_info("player") and (not tContains(queueSpells,spellName) and not forcequeue or _castTimeLeft("player") > buffer * 1.45)) and not tContains(castableWhileCasting,spellName) then 
		return false; 
	end

	if forcefacing then

	else
		if requiresfacing and not _amIfacing(unit) then return false; end
	end

	local casttime = _castTime(spell)

	if casttime > 0 then
		if current_cast_delay and time - current_cast_delay < .13 then
			return false
		end
	end

	local moving_spells = {
		2948,		--scorch
	}
	
	local min = 10
	local max = 60
	local delay = math.random(min,max) / 1000

	if unit then

		if IsPlayerSpell(spell) then
			if _castTime(spell) <= 0 or tContains(moving_spells,spell) or not _isMoving("player") or UnitBuffID("player",79206) or UnitBuffID("player",12042) or UnitBuffID("player",108839) then
				if _spellInRange(spell,unit) and _LoS(unit) then
					if forcefacing then
						local facing = ObjectFacing("player");
						FaceDirection(_anglesBetweenObjects("player",unit),true);
						if only_by_id[spell] then
							SQ_CastSpellByID(spell,unit)
						else
							SQ_CastSpellByName(spellName,unit)
						end
						FaceDirection(facing,true);
						next_cast_attempt[arg_string] = time + delay
						if spell == 257541 then
							pf_flying = time
						end
						if spell == 11366 then
							pyro_flying = time
						end
					else
						if only_by_id[spell] then
							SQ_CastSpellByID(spell,unit)
						else
							SQ_CastSpellByName(spellName,unit)
						end
						next_cast_attempt[arg_string] = time + delay
						if spell == 257541 then
							pf_flying = time
						end
						if spell == 11366 then
							pyro_flying = time
						end
					end
					return true;
				end
			end
		end
	else
		-- SQ_CastSpellByName(spellName,"");
		if only_by_id[spell] then
			SQ_CastSpellByID(spell,"")
		else
			SQ_CastSpellByName(spellName,"")
		end
		next_cast_attempt[arg_string] = time + delay
		if spell == 257541 then
			pf_flying = time
		end
		if spell == 11366 then
			pyro_flying = time
		end
		if IsPlayerSpell(spell) then return true; end
	end
end

function aoe_cast(spell,x,y,z)

	if not x or not y or not z then return false end 

	--do not begin casts with quaking debuff
	local quaking_remains = _debuffRemains("player",240447)
	if quaking_remains > 0 and _castTime(spell) > 0 and _castTime(spell) > quaking_remains - 0.5 then return false end

	local waslooking = IsMouselooking()

	CameraOrSelectOrMoveStop()

	local CameraOrSelectOrMoveStart_OG

	if not CameraOrSelectOrMoveStart_Altered then
		CameraOrSelectOrMoveStart_OG = CameraOrSelectOrMoveStart
		CameraOrSelectOrMoveStart_Altered = true
		C_Timer.After(.05,function() CameraOrSelectOrMoveStart = CameraOrSelectOrMoveStart_OG CameraOrSelectOrMoveStart_Altered = nil if waslooking and GetKeyState(0x02) == true then MouselookStart() end end)
	end

	CameraOrSelectOrMoveStart = function() end

	if type(spell) == "number" then spell = GetSpellInfo(spell) end

 	SQ_CastSpellByName(spell)

	ClickPosition(x, y, z)

	_targetLastTarget()

	if IsAoEPending() then
		CancelPendingSpell();
	end

end

function aoe_cast2(spell,x,y,z,nomoving,max_dist)

	local px,py,pz = GetPlayerPosition()

	if GetDistanceBetweenPositions(px,py,pz,x,y,z) > max_dist then return false end

	if TraceLine(px,py,pz+2,x,y,z+2,losflags) then return false end

	local waslooking = IsMouselooking()

	CameraOrSelectOrMoveStop()

	local CameraOrSelectOrMoveStart_OG

	if not CameraOrSelectOrMoveStart_Altered then
		CameraOrSelectOrMoveStart_OG = CameraOrSelectOrMoveStart
		CameraOrSelectOrMoveStart_Altered = true
		C_Timer.After(.05,function() CameraOrSelectOrMoveStart = CameraOrSelectOrMoveStart_OG CameraOrSelectOrMoveStart_Altered = nil _targetLastTarget() if waslooking and GetKeyState(0x02) == true then MouselookStart() end end)
	end

	CameraOrSelectOrMoveStart = function() end

	if type(spell) == "number" then spell = GetSpellInfo(spell) end

 	SQ_CastSpellByName(spell)

 	last_flamestrike_pos = {x = x, y = y, z = z}

	ClickPosition(x, y, z)

	_targetLastTarget()

	if IsAoEPending() then
		CancelPendingSpell();
	end

end

function _AeCast(spellid,unit,maxRange,diameter,nomoving,predictmovement)

	local latency = squid_avg_latency
	local update = 2/GetFramerate()

	local buffer = latency+update+.1

	if _spellCooldown(spellid) > buffer then return false end

	--do not begin casts with quaking debuff
	local quaking_remains = _debuffRemains("player",240447)
	if quaking_remains > 0 and _castTime(spellid) > 0 and _castTime(spellid) > quaking_remains - 0.5 then return false end

	local time = GetTime()

	local diameter = diameter or 0
	local radius = diameter / 2

	if type(spellid) == "number" then spellid = GetSpellInfo(spellid) end
	
	if nomoving and _isMoving("player") then return false end

	if IsUsableSpell(spellid) and UnitIsVisible(unit) then
		
		local px,py,pz = GetPlayerPosition()

		local X,Y,Z = ObjectPosition(unit)

		if not unit_casting_info("player") and not UnitChannelInfo("player") then

			local blacklisted_unit

			local name = UnitName(unit)

			local blacklist = {
			"Blackwater Behemoth",
			"Radiance of Azshara",
			"Raal the Gluttonous",
			"Slagmaw",
			"Drest'agath",
			"Horrific Hemorrhage",
			"Synthesis Growth",
			"Corrupted Neuron",
			"N'Zoth the Corruptor",
			"Omega Buster",
			"Demolishing Terror",
			"Gripping Terror",
			"Crackling Shard",
			}
			if tContains(blacklist,name) then blacklisted_unit = true end

			if blacklisted_unit then

				local points = {}

				local closest = 0

				local reach = not unit_is_player(unit) and max ( 1.5, UnitCombatReach(unit) ) or 0

				closest = max ( reach - 10, 0)

				for n=closest,reach do
					for i=0,math.pi*2 do
						local x,y,z = GroundZ ( X + ( radius + n ) * math.cos(i), Y + ( radius + n ) * math.sin(i), Z )
						if x and y and z then
							local dist = GetDistanceBetweenPositions(px,py,pz,x,y,z)
							if dist < maxRange then
								if not TraceLine(x, y, z+2, px, py, pz+2, losflags) then
									table.insert(points,{x=x,y=y,z=z,dist=dist})
								end
							end
						end
					end
				end

				table.sort(points,function(x,y) return x.dist < y.dist end)

				if #points > 0 then
					aoe_cast(spellid,points[1].x,points[1].y,points[1].z)
					return true
				end
			end

			if _realDistance(unit) <= maxRange then

				if _LoS(unit) then

					local x,y,z = GroundZ(X,Y,Z)

					aoe_cast(spellid,x,y,z)

					return true;

				elseif diameter > 0 then

					local px,py,pz = GetPlayerPosition()

					local nx,ny,nz


					for i=0,math.pi*2 do
						local x,y,z = X + radius * math.cos(i), Y + radius * math.sin(i), Z
						if not TraceLine(x, y, z+2, px, py, pz+2, losflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
							nx = x --+ 7.25 * math.cos(direction)
							ny = y --+ 7.25 * math.sin(direction)
							nz = z
							break
						end
					end

					if nx and ny and nz then

						aoe_cast(spellid,nx,ny,nz)

						return true;

					end

				end

			else

				local points = {}

				local reach = not unit_is_player(unit) and max ( UnitCombatReach(unit) - 1.5, 0 ) or 0

				for n=0,reach do
					for i=0,math.pi*2 do
						local x,y,z = GroundZ ( X + ( radius + n ) * math.cos(i), Y + ( radius + n ) * math.sin(i), Z )
						if x and y and z then
							local dist = GetDistanceBetweenPositions(px,py,pz,x,y,z)
							if dist < maxRange then
								if not TraceLine(x, y, z+2, px, py, pz+2, losflags) then
									table.insert(points,{x=x,y=y,z=z,dist=dist})
								end
							end
						end
					end
				end

				table.sort(points,function(x,y) return x.dist < y.dist end)

				if #points > 0 then
					aoe_cast(spellid,points[1].x,points[1].y,points[1].z)
					return true
				end

			end

		end
			
	end
end

function _AeCastPosition(spellid,X,Y,Z,maxRange)

	maxRange = maxRange or 40

	local aeCd = _spellCooldown(spellid)
	
	if aeCd > (select(4,GetNetStats())/1000)+.025 then return false; end

	if type(spellid) == "number" then spellid = GetSpellInfo(spellid) end
	
	if IsUsableSpell(spellid) then
		
		local px,py,pz = GetPlayerPosition()

		if not unit_casting_info("player") and not UnitChannelInfo("player") and GetDistanceBetweenPositions(X,Y,Z,px,py,pz) <= maxRange then

			if not TraceLine(px,py,pz+2,X,Y,Z+2,losflags) then

				SQ_CastSpellByName(spellid,"")
				if IsAoEPending() then
					local waslooking = IsMouselooking()
					X,Y,Z = GroundZ(X,Y,Z) -- ground z
					ClickPosition(X,Y,Z)
					_targetLastTarget()
					C_Timer.After(.05,CancelPendingSpell)
					CancelPendingSpell()
					if waslooking then MouselookStart() end
				end
				_targetLastTarget()
				CancelPendingSpell()
				return true;

			end

		end
			
	end
end

function _aeCastInMovingDirection(spellid,unit,distance,range,radius)
	
	if not spellid then return false; end

	range = range or 100

	local scriptUpdate = 4/GetFramerate()

	if _spellCooldown(spellid) > squid_avg_latency + scriptUpdate then return false; end

	if type(spellid) == "number" then 
		spellid = GetSpellInfo(spellid) 
	end

	local X, Y, Z = ObjectPosition(unit);
	local direction = _getMovingDirection(unit);

	if UnitIsVisible(unit) then
		local px,py,pz=GetPlayerPosition();
		local x = X + distance * math.cos(direction);
		local y = Y + distance * math.sin(direction);
		local z = Z;

		if not unit_casting_info("player") and not UnitChannelInfo("player") and not TraceLine(px,py,pz+2,x,y,z+2,losflags) and _distanceToCoord(x,y,z) <= range then

 			x,y,z = GroundZ(x,y,z)

 			if not TraceLine(px,py,pz+1.7,x,y,z+1.7,losflags) then
 				aoe_cast(spellid,x,y,z)
 			elseif radius then
 				local found
 				for i=0,math.pi*2,.5 do
					local nx,ny,nz = GroundZ(x + radius * math.cos(i), y + radius * math.sin(i), z)
					if nx and ny and nz 
					and not TraceLine(x, y, z+1.7, nx, ny, nz+1.7, losflags) 
					and not TraceLine(px, py, pz+1.7, nx, ny, nz+1.7, losflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
						x,y,z = nx,ny,nz
						found = true
						break
					end
				end
				if found then
					aoe_cast(spellid,x,y,z)
				end
 			end

			LastAttemptedSpellUnit = unit or "player";

			return true;

		end

 	end

end

function valid_aoe(unit)
	local blacklist = {
		[120651] = true,	-- Explosives
		[161895] = true,    -- Thing From Beyond
		[158041] = true, 	-- N'Zoth
		[135903] = true,	-- Manifestation of the Deep (SoTS Last Boss)
	}
	local id = ObjectID(unit)
	if blacklist[id] then return false end
	return true
end

function get_enemies(thisUnit,radius,checkNoCombat,facing,aoe)
	
	local radius = tonumber(radius)
	local enemyTable = Enemies
	local enemiesTable = {}
	local e, distance
	
	if checkNoCombat == nil then checkNoCombat = false end
	if facing == nil then facing = false end

	for i=1,#enemyTable do
		e = enemyTable[i]
		distance = _distance(thisUnit,e)
		if distance < radius and (not facing or _amIfacing(e)) and valid_attackable(e) and (not aoe or valid_aoe(e)) then
			tinsert(enemiesTable,e)
		end
    end

	if #enemiesTable == 0 and UnitIsVisible(current_target) and _distance(current_target) < radius and UnitAffectingCombat(current_target) and (not facing or _amIfacing(current_target)) then
		tinsert(enemiesTable,current_target)
	end

    return enemiesTable
end

function get_future_position(unit, castTime)
    local distance = min ( 5, GetUnitSpeed(unit) ) * castTime
    if distance > 0 then
        local x,y,z = ObjectPosition(unit)
        local angle = _getMovingDirection(unit)--ObjectFacing(unit)
        --If Unit have a target, let's make sure they don't collide
        local unitTarget = UnitTarget(unit)
        local unitTargetDist = 0
        if unitTarget ~= nil then
            local tX, tY, tZ = ObjectPosition(unitTarget)
            --Lets get predicted position of unit target aswell
            if GetUnitSpeed(unitTarget) > 0 then
                local tDistance = ( GetUnitSpeed(unitTarget) * castTime ) / 1.7
                local tAngle = GetAnglesBetweenObjects(unit,unitTarget) -- _getMovingDirection(unitTarget)
                tX = tX + cos(tAngle) * tDistance
                tY = tY + sin(tAngle) * tDistance
                unitTargetDist = sqrt(((tX-x)^2) + ((tY-y)^2) + ((tZ-z)^2)) - ((UnitCombatReach(unit) or 0) + (UnitCombatReach(unitTarget) or 0))
                if unitTargetDist < distance then distance = unitTargetDist end
            else
                unitTargetDist = _distance(unitTarget, unit)
                if unitTargetDist < distance then distance = unitTargetDist end
            end
            -- calculate angle based on target position/future position
            angle = rad(atan2(tY - y, tX - x))
            if angle < 0 then
                angle = rad(360 + atan2(tY - y, tX - x))
            end
        end
        x = x + cos(angle) * distance
        y = y + sin(angle) * distance
        return x, y, z
    end
    return ObjectPosition(unit)
end

-- aoe_cast_best_position( 2120, 8, 2, 40, nil, _castTime(2120) )
function aoe_cast_best_position(spellID, radius, minUnits, maxRange, minRange, castTime, nomoving, minttd)

    if radius == nil then radius = maxRange end
    if maxRange == nil then maxRange = radius end
   	
   	local latency = squid_avg_latency
	local update = 3/GetFramerate()

	local buffer = latency+update+.1025

	if _spellCooldown(spellID) > buffer then return false end

	--do not begin casts with quaking debuff
	local quaking_remains = _debuffRemains("player",240447)
	if quaking_remains > 0 and _castTime(spellID) > 0 and _castTime(spellID) > quaking_remains - 0.5 then return false end

	if nomoving and _isMoving("player") then return false end

	if unit_casting_info("player") and ( castTime > 0 or _castTimeLeft("player") > buffer*1.5 ) then return false end
	if UnitChannelInfo("player") then return false end

    -- return table with combination of every 2 units
    local function getAllCombinationsOfASet(arr, r)
        if(r > #arr) then
            return {}
        end
        if(r == 0) then
            return {}
        end
        if(r == 1) then
            local return_table = {}
            for i=1,#arr do
                table.insert(return_table, {arr[i]})
            end
            return return_table
        else
            local return_table = {}
            local arr_new = {}
            for i=2,#arr do
                table.insert(arr_new, arr[i])
            end
            for i, val in pairs(getAllCombinationsOfASet(arr_new, r-1)) do
                local curr_result = {}
                table.insert(curr_result, arr[1]);
                for j,curr_val in pairs(val) do
                    table.insert(curr_result, curr_val)
                end
                table.insert(return_table, curr_result)
            end
            for i, val in pairs(getAllCombinationsOfASet(arr_new, r)) do
                table.insert(return_table, val)
            end
            return return_table
        end
    end

    --check if unit is inside of a circle
    local function unitInCircle(unit, cx, cy, radius, castTime)
        local uX, uY = 0, 0
        if castTime == nil or castTime == 0 then
          uX, uY = ObjectPosition(unit)
        else
          uX, uY = get_future_position(unit, castTime)
        end
        local rUnit = UnitBoundingRadius(unit)
        return math.abs((uX - cx) * (uX - cx) + (uY - cy) * (uY - cy)) <= (rUnit + radius) * (rUnit + radius);
    end

    --distance from center to unit
    local function unitDistanceCenter(unit, cx, cy, castTime)
        local uX, uY = 0, 0
        if castTime == nil or castTime == 0 then
            uX, uY = ObjectPosition(unit)
        else
            uX, uY = get_future_position(unit, castTime)
        end
        local rUnit = UnitBoundingRadius(unit)
        return sqrt(((uX-cx)^2) + ((uY-cy)^2))
    end

    if minRange == nil then minRange = 0 end
    local allUnitsInRange = {}
    allUnitsInRange = get_enemies("player",maxRange,false,nil,true)

    -- print(#allUnitsInRange)

    local testCircles = {}
    --for every combination of units make 2 circles, and put in testCircles
    if #allUnitsInRange >= 2 then
        local combs = getAllCombinationsOfASet(allUnitsInRange, 2)
        for i, val in pairs(combs) do
            local temp = {}
            for j, combination in pairs(val) do
                local tX, tY, tZ = 0,0,0
                if castTime == nil or castTime == 0 then
                  tX, tY, tZ = ObjectPosition(combination)
                else
                  tX, tY, tZ = get_future_position(combination, castTime)
                end
                if(j==#val) and temp.xi ~= nil then
                    temp.xii = tX;
                    temp.yii = tY;
                    temp.zii = tZ;
                    --distance
                    temp.q = sqrt((temp.xii-temp.xi)^2 + (temp.yii-temp.yi)^2)
                    --check to calculation. if result < 0 math.sqrt will give error
                    local calc = ((radius^2)-((temp.q/2)^2))
                    if calc <=0 then break end
                    --x3
                    temp.xiii = (temp.xi+temp.xii)/2
                    --y3
                    temp.yiii = (temp.yi+temp.yii)/2
                    --first circle
                    temp.xfc = temp.xiii + sqrt(calc)*((temp.yi-temp.yii)/temp.q)
                    temp.yfc = temp.yiii + sqrt(calc)*((temp.xii-temp.xi)/temp.q)
                    --second circle
                    temp.xsc = temp.xiii - sqrt(calc)*((temp.yi-temp.yii)/temp.q)
                    temp.ysc = temp.yiii - sqrt(calc)*((temp.xii-temp.xi)/temp.q)
                    --
                    temp.z = tZ
                    tinsert(testCircles, temp)
                else
                    temp.xi = tX;
                    temp.yi = tY;
                    temp.zi = tZ;
                end
            end
        end
    end

    local bestCircle = {}
    bestCircle.x = 0
    bestCircle.y = 0
    bestCircle.z = 0
    bestCircle.q = 0
    bestCircle.nro = 0
    --for every circle in testCircles, get units inside this circle, and return the circle with most units inside
    for i=1, #testCircles do
        local thisCircle = testCircles[i]
        local temp1 = 0
        local temp2 = 0
        local temp1Units = { }
        local temp2Units = { }
        for j=1, #allUnitsInRange do
            if unitInCircle(allUnitsInRange[j],thisCircle.xfc,thisCircle.yfc, radius, castTime) then
                temp1 = temp1 + 1
                tinsert(temp1Units,allUnitsInRange[j])
            end
            if unitInCircle(allUnitsInRange[j],thisCircle.xsc,thisCircle.ysc, radius, castTime) then
                temp2 = temp2 + 1
                tinsert(temp2Units,allUnitsInRange[j])
            end
        end
        if temp1 > temp2 and temp1 > bestCircle.nro then
            bestCircle.x = thisCircle.xfc
            bestCircle.y = thisCircle.yfc
            bestCircle.z = thisCircle.z
            bestCircle.nro = temp1
            bestCircle.units = {}
            for p = 1, #temp1Units do tinsert(bestCircle.units,temp1Units[p]) end
        elseif temp2 > temp1  and temp2 > bestCircle.nro then
            bestCircle.x = thisCircle.xsc
            bestCircle.y = thisCircle.ysc
            bestCircle.z = thisCircle.z
            bestCircle.nro = temp2
            bestCircle.units = {}
            for p = 1, #temp2Units do tinsert(bestCircle.units,temp2Units[p]) end
        elseif temp2 == temp1 and temp2 > bestCircle.nro then
            bestCircle.x = thisCircle.xsc
            bestCircle.y = thisCircle.ysc
            bestCircle.z = thisCircle.z
            bestCircle.nro = temp2
            bestCircle.units = {}
            for p = 1, #temp2Units do tinsert(bestCircle.units,temp2Units[p]) end
        end
    end
    -- print(#bestCircle.units)

    -- check if units of the best circle is equal of circle of unit, if it is, then cast on this unit
    -- for i=1,#allUnitsInRange do
    --     local thisUnit = allUnitsInRange[i]
    --     nmro = getUnits(thisUnit,allUnitsInRange, radius - 3)
    --     if nmro >= bestCircle.nro and nmro >= minUnits then
    --         if castGround(thisUnit,spellID,maxRange,minRange,radius,castTime) then return true else return false end
    --     end
    -- end

    --check with minUnits
    -- if minUnits == 1 and bestCircle.nro == 0 and GetUnitExists("target") then
    --     if _AeCast("target",spellID,maxRange,minRange,radius,castTime) then return true else return false end
    -- end
    if bestCircle.nro < minUnits then return false end

    if bestCircle.x ~= 0 and bestCircle.y ~= 0 and bestCircle.z ~= 0 then
        --Calculate x/y position with shortest dist to units
        local shortestDistance = 999
        local newBestCircleX, newBestCircleY = 0,0
        for x = bestCircle.x - radius, bestCircle.x + radius do
            for y = bestCircle.y - radius, bestCircle.y + radius do
                local totalDistance = 0
                for i = 1, #bestCircle.units do
                    totalDistance = totalDistance + unitDistanceCenter(bestCircle.units[i], x, y, castTime)
                end
                if totalDistance < shortestDistance then
                    shortestDistance = totalDistance
                    newBestCircleX, newBestCircleY = x, y
                end
            end
        end
        bestCircle.x, bestCircle.y = (newBestCircleX + math.random() * 2), (newBestCircleY + math.random() * 2)
        -- print ( bestCircle.x, bestCircle.y )
        if aoe_cast2(spellID, bestCircle.x,bestCircle.y,bestCircle.z, nomoving, maxRange) then return true else return false end
    end
end

local PvPslows 	=
{
	45524,          -- Chains of Ice
	50435,          -- Chilblains
	115000,         -- Remorseless Winter
	50259,          -- Dazed
	58180,          -- Infected Wounds
	61391,          -- Typhoon
	127797,         -- Ursol's Vortex
	5116,           -- Concussive Shot
	61394,          -- Frozen Wake (glyph of freezing trap)
	50433,          -- Ankle Crack
	54644,          -- Frost Breath
	120,            -- Cone of Cold
	116,            -- Frostbolt
	44614,          -- Frostfire Bolt
	113092,         -- Frost Bomb
	31589,          -- Slow
	116095,         -- Disable
	118585,         -- Leer of the Ox
	123586,         -- Flying Serpent Kick
	110300,         -- Burden of Guilt
	63529,          -- Dazed - Avenger's Shield
	20170,          -- Seal of Justice
	15407,          -- Mind Flay
	3409,           -- Crippling Poison
	26679,          -- Deadly Throw
	119696,         -- Debilitation
	3600,           -- Earthbind
	77478,          -- Earthquake
	8056,           -- Frost Shock
	51490,          -- Thunderstorm
	47960,          -- Shadowflame
	1715,           -- Hamstring
	12323,          -- Piercing Howl
	129923,         -- Sluggish
	81281,          -- Wild Mushroom
	--1604          -- Dazed
}
function _slowCheck(unit)
	local debuffs = _debuffFromTable(unit,PvPslows);
	if debuffs then
		return true;
	end
end

function _isSlowed(unit)
	local current_speed,_,_,swim_speed = GetUnitSpeed(unit)
	if swim_speed < 4 and current_speed < 7 then return true; end
	if _slowCheck(unit) then return true; end
end

function unit_is_slowed(unit)
	
	local unit_tag
	if unit_is_unit(unit,"target") then unit_tag = "target" end
	if unit_is_unit(unit,"focus") then unit_tag = "focus" end
	if unit_is_unit(unit,"arena1") then unit_tag = "arena1" end
	if unit_is_unit(unit,"arena2") then unit_tag = "arena2" end
	if unit_is_unit(unit,"arena3") then unit_tag = "arena3" end
	if not unit_tag then return false end
		
	local desc = squid_debuff_descriptions[unit_tag]

	local amount = 0
	local is_slowed = false

	for i=1,#desc do
		local str = desc[i]
		if strmatch(str, "slowed by") or strmatch(str, "Movement slowed") then
			is_slowed = true
			amount = string.match(str, "%d+")
			if amount and amount ~= 0 then
				amount = tonumber(amount)
			else
				amount = 0
			end
		end
	end

	return is_slowed, amount

end

function WorldPositionFromCursor()
	local x,y = GetMousePosition()
	return ScreenToWorld(x,y)
end

local immuneToSlowID =
{
	54216, --Master's Call
	-- 19574, --Bestial Wrath
	45438, --IceBlock
	1044, --HandOfFreedom
	1022, --HandOfProt
	642,  --DivineShield
	47585, --Dispersion
	-- 114896, --Windwalk Totem
	227847, --Bladestorm
	114239, --Phantasm
	79438,	--Soulburn Port
	-- 115018,  --Desecrated ground
	216113,	--Way of the Crane
	2645,	--Ghost Wolf
	305395,	--cancerous undispellable freedom
}

function _slowImmuneCheck(unit)
	local buffs = _buffFromTable(unit,immuneToSlowID);
	if buffs then return true; end
end

local immuneToRoot =
{
	54216, --Master's Call
	-- 19574, --Bestial Wrath
	45438, --IceBlock
	1044, --HandOfFreedom
	1022, --HandOfProt
	642,  --DivineShield
	47585, --Dispersion
	-- 114896, --Windwalk Totem
	227847, --Bladestorm
	-- 114239, --Phantasm
	-- 79438,	--Soulburn Port
	-- 115018,  --Desecrated ground
	216113,	--Way of the Crane
	305395,	--cancerous undispellable freedom
	-- 2645,	--Ghost Wolf
}

function _rootImmuneCheck(unit)
	local buffs = _buffFromTable(unit,immuneToRoot);
	if buffs then return true; end
end

function PvE_Spellsteal(unit)
	if UnitIsCharmed(unit) then return false end
	local blacklist = {
	269935,		--Bound by Shadows Shit from KR
	270920,		--Mind Control from KR https://www.wowhead.com/spell=270920/seduction
	278567,		-- soul fetish, not stealable
	333553,		-- Breaht of Coldheart (Torghast) Apparently some buff that gives 15% health and returns as stealable but isnt? Reported by @_cxmplex
	344739,		--Spectral buff will kill you
	}
	if _buffFromTable(unit,blacklist) then return false end
	if _purgeCount(unit) > 0 then return true end
end

function Basic_Spellsteal(unit)
	if IsPlayerSpell(198100) then return end
	local spec = GetSpecialization()
	local SSBuffs = {
	210294,		--Divine Favor
	1022, 		--BOP
	213610,		--Holy Ward
	774,		--Rejuv
	155777,		--Rejuv Germ
	-- 33763,		--Lifebloom
	286342,		--Safeguard
	198111,		--Temp
	124682,		--Enveloping
	305497,		--Thorns
	2645,		--Ghostwolf
	974,		--Riptide?
	61295,		--Earthshield?
	190319,		--Combust
	1022,		--Bop
	17,			--Pw:s
	48108,		--Hotstreak
	1459,		--Intellect
	21562,		--Fortitude
	216328,		--Light's Grace (dmg reduction)
	139,		--Renew
	235313,		--Blazing Barrier
	235450,		--Prismatic Barrier
	11426,		--Ice Barrier
	12472,		--Icy Veins
	12042,		--Arcane Power
	48108,		--Hot Streak
	}
	if unit_is_unit(unit,current_target) then
		local hasbuff,buffid = _buffFromTable(unit,SSBuffs)
		if hasbuff then return buffid end
	end
end

function Prio_Spellsteal(unit)
	if IsPlayerSpell(198100) then return end
	local spec = GetSpecialization()
	local SSBuffs = {
	210294,		-- Divine Favor
	1022, 		-- BOP
	213610,		-- Holy Ward
	10060,	    -- Power Infusion
	113858,		-- Dark Soul: Instability
	113860,		-- Dark Soul: Misery
	}
	for i=1,#SSBuffs do
		local buff = SSBuffs[i]
		if UnitBuffID(unit,buff) then
			return buff;
		end
	end
	local purge_count = _purgeCount(unit)
	--target only
	if unit_is_unit(unit,current_target) then
		if not UnitBuffID("player",190319) then
			--enveloping mist
			if purge_count <= 3 or spec == 1 and purge_count <= 3 then
				if _buffRemains(unit,124682) >= 3.75 then
					return 124682
				end
			end
			--temp long duration
			if purge_count <= 3 or spec == 1 and purge_count <= 3 then
				if _buffRemains(unit,198111) >= 2 then
					return 198111
				end
			end
		end
		--safeguard
		if purge_count <= 3 or spec == 1 and purge_count <= 3 then
			--286342
			local buff,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID(unit,286342)
			if buff and absorb > 13000 * (purge_count) then
				return 286342
			end
		end
		--nword
		if purge_count <= 2 or spec == 1 and purge_count <= 3 then
			if _buffRemains(unit,212295) > 1 then
				return 212295
			end
		end
	end
	--combust
	if purge_count <= 3 or spec == 1 then
		if _buffRemains(unit,190319) > 3 then
			return 190319
		end
	end
end

local hots = {
	774, --rejuv
	155777, --rejuv germ
	33763, --bloom
	305497, --thorns
	124682,	--enveloping mist
}

function Arcane_Spellsteal(unit)
	if IsPlayerSpell(198100) then return end
	local mana = (100 * UnitPower("player") / UnitPowerMax("player"));
	
	if unit_is_unit(unit,current_target) then
		if mana > lowestEnemy+20 or mana > 75 or load_mode_active then
			for i=1,#hots do
				local d = hots[i]
				if _buffRemains(unit,d) > 4 then
					return d
				end
			end
			local pws,_,_,_,_,_,_,_,_,_,_,_,_,_,_,pws_absorb = UnitBuffID(unit,17)
			if pws and pws_absorb >= 15000 then
				return 17
			end
		end
	end
end

function Arcane_Spellsteal_Two(unit)
	if IsPlayerSpell(198100) then return end
	local mana = (100 * UnitPower("player") / UnitPowerMax("player"));
	
	if unit_is_unit(unit,current_target) then
		if mana > lowestEnemy+10 or mana > 75 or load_mode_active then
			for i=1,#hots do
				local d = hots[i]
				if _buffRemains(unit,d) > 4 then
					return d
				end
			end
			local pws,_,_,_,_,_,_,_,_,_,_,_,_,_,_,pws_absorb = UnitBuffID(unit,17)
			if pws and pws_absorb >= 15000 then
				return 17
			end
		end
	end
end

function dispel_magic(unit)
	local SSBuffs = {
	210294,		--Divine Favor
	1022, 		--BOP
	305497,		--Thorns
	}
	if _purgeCount(unit) <= 3 and lowestFriend > 55 then
		for i=1,#SSBuffs do
			local debuff = SSBuffs[i]
			if UnitBuffID(unit,debuff) then
				return debuff;
			end
		end
	end
	--temp long duration
	if _purgeCount(unit) <= 3 and lowestFriend > 65 then
		if _buffRemains(unit,198111) >= 2 then
			return 198111
		end
	end
	--combust
	if (_purgeCount(unit) <= 3 and lowestFriend > 55) or lowestFriend > 75 then
		if _buffRemains(unit,190319) > 3 then
			return 190319
		end
	end
	--their healer cc and not in trouble
	if lowestFriend > 70 and (not theirHealer or _CCcheck(theirHealer)) then

	end
end

function table.clone(org)
  return {unpack(org)}
end

function urlencode(str)
   if (str) then
      str = string.gsub (str, "\n", "\r\n")
      str = string.gsub (str, "([^%w ])",
         function (c) return string.format ("%%%02X", string.byte(c)) end)
      str = string.gsub (str, " ", "+")
   end
   return str
end

-- this breaks skada lol
-- function string.split(inputstr, sep)
--     if sep == nil then
--         sep = "%s"
--     end
--     local t={}
--     for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
--         table.insert(t, str)
--     end
--     return t
-- end

squid_combat_tracker = {}
squid_klepto_tracker = {}

--Squid Events
function Squid_CombatLog(self,event,...)

	if event == "COMBAT_LOG_EVENT_UNFILTERED" then
		
		local _, subEvent, _, sourceGUID, sourceName, _, _, destGUID, destName, destFlags, destRaidFlags, spellID, spellName, _, auraType, extraSpellName, auraType2 = CombatLogGetCurrentEventInfo()

		local sourcePointer
		local destPointer

		if not IsHackEnabled then return; end

		for i=1,#Enemies do
			local guid = UnitGUID(Enemies[i])
			if destGUID == guid then
				destPointer = Enemies[i];
			end
			if sourceGUID == guid then
				sourcePointer = Enemies[i];
			end
		end

		for i=1,#Friends do
			local guid = UnitGUID(Friends[i])
			if destGUID == guid then
				destPointer = Friends[i];
			end
			if sourceGUID == guid then
				sourcePointer = Friends[i];
			end
		end

		if not sourcePointer and sourceGUID then
			sourcePointer = GetObjectWithGUID(sourceGUID)
		end

		if not destPointer and destGUID then
			destPointer = GetObjectWithGUID(destGUID)
		end

		local time = GetTime()

		--player casts
		if subEvent == "SPELL_CAST_SUCCESS" and sourcePointer then

			local stealth_ids = {
				[115191] = 115191,		-- Rogue Stealth
				[1856] = 11327,			-- Rogue Vanish
				[5215] = 5215, 			-- Druid Prowl	
				-- 66    - going invis 
				-- 32612 - actually invis
				[66] = 32612,			-- Mage Invis
			}
			if stealth_ids[spellID] and UnitCanAttack("player",sourcePointer) then
				Squid_Alert("Tracking " .. UnitClass(sourcePointer), spellName, nil, nil, spellID)
				local x,y,z = ObjectPosition(sourcePointer)
				local info = {
					speed = GetUnitSpeed(sourcePointer),
					direction = GetMovingDirection(sourcePointer),
					x = x,
					y = y,
					z = z,
					time = GetTime(),
					pointer = sourcePointer,
					id = stealth_ids[spellID],
					name = spellName,
				}
				table.insert(stealth_tracker,info)
			end

			--player is source
	  		if unit_is_unit(sourcePointer,"player") then

	  			-- print(destFlags, destRaidFlags, spellID, spellName, auraType, extraSpellName, auraType2) 

	  			if spellID == 153595 and destPointer then
	  				comet_target = destPointer
	  			end

	  			if IsPlayerSpell(spellID) then
	  				if spellID ~= 169223 and spellID ~= 318378 then
	  					-- print(spellID)
	  					table.insert(PlayerSpellCasts,{name=spellName,id=spellID,time=time})
	  				end
	  			end

	  			if spellID == 127140 then
	  				if not UnitBuffID("player",110909) then
	  					squid_alter = {}
	  					squid_alter["start_hp"] = _HP("player")
	  					squid_alter["start_pos"] = {ObjectPosition("player")}
	  					Squid_Alert_Big("Alter Time",round(_HP("player"),2) .. "%", nil, nil, 108978)
	  				end
	  			end

	  			if spellID == 116011 then
	  				player_rop = time
	  			end

	  			if spellID == 133 then
	  				-- fireball_thrown = time
	  				-- fireball_target_dist = _distance(destPointer)
	  				fb_flying = time
	  				fb_really_flying = time
	  			end

	  			if spellID == 11366 then
	  				-- pyro_thrown = time
	  				-- pyro_target_dist = _distance(destPointer)
	  				pyro_flying = time
	  				pyro_really_flying = time
	  			end

	  			if spellID == 203286 then
	  				gpy_flying = time
	  				gpy_start_dist = _distance(destPointer)
	  				gpy_est_hit_time = time + ( gpy_start_dist / 8.9 )
	  			end

	  			if spellID == 257541 then
	  				-- pf_thrown = time
	  				-- pf_target_dist = _distance(destPointer)
	  				pf_flying = time
	  				pf_really_flying = time
	  			end

	  			if spellID == 36554 then
	  				lastShadowStep = time
	  				player_step = time
	  			end

	  			if spellID == 1943 then
	  				lastRupture = time
	  			end

	  			if spellID == 100 --charge
	  			or spellID == 6544 --heroic leap
	  			or spellID == 102401 --wild charge 
	  			or spellID == 106839 --skull bash
	  			or spellID == 781	--Disengage
	  			or spellID == 195072--fel rush
	  			or spellID == 198793 
	  			or spellID == 109132 --roll
	  			or spellID == 101545 --fsk
	  			or spellID == 119996 -- monk port
	  			then
	  				lastGapClose = time
	  			end
	  			if spellID == 187650 then
	  				trapthrown = time
	  			end
	  			if spellID == 210643 then
	  				totem_mastery_placed = time
	  			end
	  			if spellID == 1784
	  			or spellID == 5215 then
	  				if Squid_Last_Morph then
	  					C_Timer.After(.025,function()
	  						SquidMorph(Squid_Last_Morph[1],Squid_Last_Morph[2])
	  					end)
	  				end
	  			end
	  			if spellID == 109132 then
	  				player_roll=time
	  			end
	  			if spellID == 101545 then
	  				player_fsk = time
	  			end
	  			if spellID == 101643 or spellID == 119996 then
	  				portcoords = {}
	  				portcoords.x,portcoords.y,portcoords.z = GetPlayerPosition()
	  				portcoords.situated = true
	  			end
	  			if spellID == 212653 or spellID == 1953 then
	  				player_blink = time
	  				-- local x,y,z = GetPlayerPosition()
	  				-- last_blink_coords = {x,y,z}
	  			end
	  			if spellID == 203286 then
	  				player_gpy = time
	  			end
	  			if spellID == 33786 then
	  				player_clone = time
	  			end

	  		end -- end casts by player

	  		if spellID == 153561 then
	  			lastMeteor = time
	  			lastMeteorSource = sourcePointer
	  		end
			
	  		--enemy spellcasts
	  		if sourcePointer and unit_can_attack("player",sourcePointer) then
	  			-- if UnitClass(sourcePointer) == "Priest" then
	  			-- 	print(spellID, spellName)
	  			-- end
	  			--premonition
	  			if spellID == 32379 then
		  			premonitionUsed = time
		  			premonitionPointer = sourcePointer
		  			local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
		  			local player_cast_target = UnitSpellTarget("player")
		  			if (player_casting_sheep or player_cast_id == 118) and unit_is_unit(player_cast_target,sourcePointer) then
		  				Squid_Alert_Big("Stopcasting","(Death)",4,3,32379)
						SpellStopCasting()
					end
				end
				--coil
				if spellID == 6789 then
					enemy_coil = time
					enemy_coil_pointer = sourcePointer
				end
				-- chain harvest
				if spellID == 320674 then
					enemy_chain_harvest = time
					chain_harvest_pointer = sourcePointer
				end
				
				-- Kleptomania Tracking
				if spellID == 30449 then
					if squid_klepto_tracker[sourcePointer] == nil then
						squid_klepto_tracker[sourcePointer] = {}
						squid_klepto_tracker[sourcePointer]["running_klepto"] = true
					end

					if squid_klepto_tracker[sourcePointer]["running_klepto"] == true then
						if squid_klepto_tracker[sourcePointer]["last_cast"] ~= nil and (time - squid_klepto_tracker[sourcePointer]["last_cast"] < 27) then
							squid_klepto_tracker[sourcePointer]["running_klepto"] = false
						end

						squid_klepto_tracker[sourcePointer]["last_cast"] = time
					end
				end

				-- Shifting Power Tracking for Kleptomania CD( The assumption is that they got a full 4s cast off, even if they did not. We'd rather assume that they have Klepto and be wrong than vice versa. )
				if spellID == 314791 then
					if squid_klepto_tracker[sourcePointer] and squid_klepto_tracker[sourcePointer]["running_klepto"] == true and squid_klepto_tracker[sourcePointer]["last_cast"] then
						squid_klepto_tracker[sourcePointer]["last_cast"] = (squid_klepto_tracker[sourcePointer]["last_cast"] - 10)
					end
				end
	  		end

	  		if spellID == 208683 or spellID == 195710 or spellID == 208683 or spellName == "Sinful Gladiator's Medallion" or spellName == "Sinful Aspirant's Medallion" then
		  		table.insert(TrinketTracker,{expires=time+120,pointer=sourcePointer,time=time})
	  			print(UnitName(sourcePointer) .. " used " .. spellName .. " (Trinket) - Added to trinket tracker!")
	  		end

	  		-- if spellName == "Feign Death" and unit_can_attack("player",sourcePointer) then
	  		-- 	if last_target and unit_is_unit(sourcePointer,last_target) and not current_target then
	  		-- 		Squid_Alert("Re-Target Hunter","(Feign Death)",1)
	  		-- 		TargetUnit(sourcePointer)
	  		-- 	end
	  		-- end

	  		if spellID == 781 --disengage
	  		or spellID == 109132 --roll
	  		or spellID == 101545 then --fsk
	  			gap_opener_used = time
				gap_opener_pointer = sourcePointer
	  		end

	  		if spellID == 152175 then
	  			last_wdp = time
	  		end

	  		-- step wild charge, hmmm i'm sure this can be bad sometimes but i can't think of when.
	  		if spellID == 49376 and sourcePointer and unit_can_attack("player",sourcePointer) and unit_is_unit(destPointer,"player") then
	  			last_wc = time
	  			last_wc_pointer = sourcePointer
	  			if select(2,UnitClass("player")) == "ROGUE" then
	  				if unit_is_unit(sourcePointer,current_target) and _Cast(36554,sourcePointer) then
	  					Squid_Alert("Shadowstep","(".. GetSpellInfo(spellID) ..")",1,3.5,36554)
	  				end
	  			end
	  		end

	  		if (spellID == 100 --charge
  			or spellID == 6544 --heroic leap
  			or spellID == 102401 --wild charge 
  			or spellID == 106839 --skull bash
  			or spellID == 781	--Disengage
  			or spellID == 195072 --fel rush
  			or spellID == 198793 -- ???
  			or spellID == 109132 --roll
  			or spellID == 101545) --fsk
  			and sourcePointer
  			and unit_can_attack("player",sourcePointer) then
  				enemy_gapclose = time
  				enemy_gapclose_pointer = sourcePointer
  			end

  			if spellID == 36554 then
  				if unit_is_unit("player",destPointer) then
  					local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
  					if (player_cast_id == 203286 or player_cast_id == 133 or player_cast_id == 11366) then
  						local player_target = UnitSpellTarget("player")
  						if player_target and unit_is_unit(player_target,sourcePointer) then
		  					pause_auto_facing = time
			  				FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
			  				Squid_Alert_Big("Face Rogue","Shadowstep",4,3,36554)
			  			end
		  			end
	  			end
  			end

	  	end -- end spell casts with sourcepointer

	  	if subEvent == "SPELL_AURA_APPLIED" and auraType == "DEBUFF" and spellID == 187650 then
	  		traplanded = time
	  	end

	  	if subEvent == "SPELL_AURA_REMOVED" and auraType == "BUFF" then
	  		if spellID == 110909 and unit_is_unit("player",sourcePointer) and squid_alter then

	  			local hp_change = round ( squid_alter["start_hp"] - _HP("player"), 2)

				if hp_change == 0 then
					Squid_Alert("Alter Didn't Affect HP", nil, nil, nil, 108978)
				elseif hp_change > 25 then
					Squid_Alert_Big("Alter |cFFa9d271Healed",hp_change .. "%", nil, nil, 108978)
				elseif hp_change > 0 then
					Squid_Alert("Alter |cFFa9d271Healed",hp_change .. "%", nil, nil, 108978)
				elseif hp_change < 25 then
					Squid_Alert_Big("Alter |cffff6060Damaged",hp_change .. "%", nil, nil, 108978)
				else
					Squid_Alert("Alter |cffff6060Damaged",hp_change .. "%", nil, nil, 108978)
				end

				squid_alter = nil

			end

	  		if (spellID == 1784 or spellID == 5215) then
		  		if Squid_Last_Morph then
					C_Timer.After(.025,function()
						SquidMorph(Squid_Last_Morph[1],Squid_Last_Morph[2])
					end)
				end
			end
			if spellID == 210294 and select(2,UnitClass("player")) == "PALADIN" and not unit_is_unit(sourcePointer,"player") and unit_is_unit(destPointer,"player") then
				SpellStopCasting()
				Squid_Alert("Stopcasting","(Divine Favor Stolen)",2,nil,210294)
			end
		end

	  	--Track all abiliies used
	  	-- if arena then
		  	if subEvent == "SPELL_CAST_SUCCESS" and sourcePointer then
			    local id = spellID
			    local name = spellName
			    local cd = GetSpellBaseCooldown(id)/1000
			    if name == "Death Grip" then cd = 25 end
			    
			    if cd and cd > 0 then
			      	SpellTracker[id] = {expires=time+cd,pointer=sourcePointer,name=name};
			    end

			    --other things
			    if id == 36554 and sourcePointer and unit_can_attack("player",sourcePointer) then
			    	enemy_shadowstep = time
			    	enemy_shadowstep_pointer = sourcePointer
			    	enemy_shadowstep_target = destPointer
			    end
			    if id == 187650 and sourcePointer and unit_can_attack("player",sourcePointer) then
		  			lastTrapPointer = sourcePointer
		  			lastTrap = time
		  		end

		  		--shitty combo point tracker?

		  	end
		-- end

		if subEvent == "SPELL_CAST_SUCCESS" then

			if sourcePointer then

				-- cds reduced by other spellcasts (+required talents) (ONLY ON DAMAGE TAKEN!!!)
				local cd_reduc = {
					[85673] = {parent = 853, talent = 234299, amount = 6}, -- word of glory reduces hoj cd by 6 sec
					[53600] = {parent = 853, talent = 234299, amount = 6}, -- shield of the righteous reduces hoj cd by 6 sec
					[85222] = {parent = 853, talent = 234299, amount = 6}, -- light of dawn reduces hoj cd by 6 sec
					[85256] = {parent = 853, talent = 234299, amount = 6}, -- templar's verdict reduces hoj cd by 6 sec
					[53385] = {parent = 853, talent = 234299, amount = 6}, -- divine storm reduces hoj cd by 6 sec
				}
				if cd_reduc[spellID] then
					local spell = cd_reduc[spellID]
					if not spell.talent or unit_has_talent(sourcePointer,spell.talent) then
					  	if SpellTracker[spell.parent] and unit_is_unit(sourcePointer,SpellTracker[spell.parent].pointer) then
				    		SpellTracker[spell.parent].expires = SpellTracker[spell.parent].expires - 5
					  	end
				  	end
				end

			end

			local name = spellName
			local id = spellID

			if sourcePointer and unit_can_attack("player",sourcePointer) then
				local dispels = {
					88423,	--Nature's Cure (Druid)
					4987,	--Cleanse (Paladin)
					527,	--Purify (Priest)
					77130,	--Purify Spirit (Shaman)
					115450,	--Detox (Monk)
				}
				if tContains(dispels,id) and _isHealer(sourcePointer) then
					last_dispel = time
					last_dispel_pointer = sourcePointer
				end
			end

			if unit_is_unit("player",destPointer) then
				if id == 203286 then
					gpy_on_player = time
				end
			end

			if id == 30449 then
				spellsteal_used = time
			end

			--bigdmg flying on player
			if unit_is_unit("player",destPointer) then

				--big dmg
				if name == "Wildfire Bomb" --regular wfb
				-- or name == "Pheromone Bomb" --pheromone bomb
				or name == "Volatile Bomb" --volatile bomb
				or name == "Shrapnel Bomb" --shrap bomb
				or name == "Chaos Bolt" --bolt
				or name == "Demonfire" --demonic tyrant shit
				or name == "Remote Guidance Device" then --completely fucking retarded trinket
					big_dmg_inc = id
					big_dmg_inc_time = time
					if (name == "Chaos Bolt" and UnitBuffID(sourcePointer,113858))
					or name == "Remote Guidance Device" then
						rly_big_dmg_inc = true
					end
				end

				--cc
				if name == "Storm Bolt"
				or name == "Mortal Coil" then
					cc_flying_towards_player = id
					cc_flying_towards_player_time = time
				end

			end

		end

		if subEvent == "SPELL_HEAL" then
			if UnitIsVisible(sourcePointer) and UnitCanAttack("player",sourcePointer) and unit_is_player(sourcePointer) then
				if UnitIsVisible(destPointer) and not unit_is_unit(sourcePointer,destPointer) and UnitAffectingCombat(destPointer) then
					squid_combat_tracker[sourcePointer] = GetTime() + .3
				end
			end
		end

		if subEvent == "SPELL_DAMAGE" or subEvent == "SWING_DAMAGE" or subEvent == "SPELL_MISSED" then

			if UnitIsVisible(sourcePointer) and UnitCanAttack("player",sourcePointer) and unit_is_player(sourcePointer) then
				squid_combat_tracker[sourcePointer] = GetTime() + .3
			end

			if UnitIsVisible(destPointer) and UnitCanAttack("player",destPointer) and unit_is_player(destPointer) then
				squid_combat_tracker[destPointer] = GetTime() + .3
			end

			if subEvent == "SPELL_DAMAGE" then
				-- cds reduced by other spellcasts (+required talents) (ONLY ON DAMAGE TAKEN!!!)
				local cd_reduc = {
					[133] = {parent = 190319, talent = 203283, amount = 5}, -- fireball reduces combust cd by 5 sec per cast
				}
				if cd_reduc[spellID] then
					local spell = cd_reduc[spellID]
					if not spell.talent or unit_has_talent(sourcePointer,spell.talent) then
					  	if SpellTracker[spell.parent] and unit_is_unit(sourcePointer,SpellTracker[spell.parent].pointer) then
				    		SpellTracker[spell.parent].expires = SpellTracker[spell.parent].expires - 5
					  	end
				  	end
				end
			end

			if unit_is_unit("player", sourcePointer) then
				player_combat_tracker = GetTime() + .9
			elseif unit_is_unit("player",destPointer) then
				player_combat_tracker = GetTime() + .9
			end

			--bigdmg flying on player
			if unit_is_unit("player",destPointer) then
				local name=spellName
				if name == "Wildfire Bomb" --regular wfb
				-- or name == "Pheromone Bomb" --pheromone bomb
				or name == "Volatile Bomb" --volatile bomb
				or name == "Shrapnel Bomb" --shrap bomb
				or name == "Chaos Bolt" --bolt
				or name == "Demonfire" --demonic tyrant shit
				or name == "Remote Guidance Device" then --completely fucking retarded trinket
					big_dmg_inc = nil
					big_dmg_inc_time = nil
					rly_big_dmg_inc = nil
				end
			end
			if spellID == 203286 and unit_is_unit("player",destPointer) then
				gpy_on_player = nil
			end
			if spellID == 133 and unit_is_unit("player",sourcePointer) then
				C_Timer.After(.075,function() fb_flying = nil fb_really_flying = nil end)
			end
			if spellID == 11366 and unit_is_unit("player",sourcePointer) then
				C_Timer.After(.075,function() pyro_flying = nil pyro_really_flying = nil end)
			end
			if spellID == 203286 and unit_is_unit("player",sourcePointer) then
				gpy_flying = nil
				gpy_est_hit_time = nil
			end
			if spellID == 257541 and unit_is_unit("player",sourcePointer) then
				C_Timer.After(.145,function() pf_flying = nil pf_really_flying = nil end)
			end
		end

		if subEvent == "SPELL_AURA_APPLIED" and auraType == "DEBUFF" and unit_is_unit("player",destPointer) then
			local name = spellName
			--cc
			if name == "Storm Bolt"
			or name == "Mortal Coil" then
				cc_flying_towards_player = nil
				cc_flying_towards_player_time = nil
			end
		end

		--DR tracking
		if subEvent == "SPELL_AURA_APPLIED" and auraType == "DEBUFF" and _getDrSpellCategory(spellID) then
			debuffGained(spellID,destName,destPointer)
		end

		if subEvent == "SPELL_AURA_REFRESH" and auraType == "DEBUFF" and _getDrSpellCategory(spellID) then
			debuffRefresh(spellID,destName,destPointer)
		end

		if subEvent == "SPELL_AURA_REMOVED" and auraType == "DEBUFF" then
			if _getDrSpellCategory(spellID) then
				debuffFaded(spellID,destName,destPointer)
			end
			if unit_is_unit(sourcePointer,"player") 
			and (spellName == "Alliance Flag" or spellName == "Horde Flag" or spellName == "Horde Mine Cart" or spellName == "Alliance Mine Cart") then
				flag_drop_time = time
			end
		end

	    --dotTracker refresh
	    if subEvent == "SPELL_AURA_REFRESH" then

      		--Rake--
      		if unit_is_unit(sourcePointer,"player") and spellID == 155722 then
        		if #dotTracker > 0 then
          			for i=1,#dotTracker do
            			if dotTracker[i].rakepointer == destPointer then
              				dotTracker[i].rakePower = GetCurrentSnapshot(1822)
              				return
            			end
          			end
        		end
        		--refreshed rake, but not in dot tracker
        		table.insert(dotTracker,{rakepointer = destPointer, rakePower = GetCurrentSnapshot(1822), time=time})
      		end
	  

      		--Rip--
      		if unit_is_unit(sourcePointer,"player") and spellID == 1079 then
        		if #dotTracker > 0 then
          			for i=1,#dotTracker do
            			if dotTracker[i].rippointer == destPointer then
              				dotTracker[i].ripPower = GetCurrentSnapshot()
              				return
            			end
          			end
        		end
        		--refreshed rip, but not in dot tracker
        		table.insert(dotTracker,{rippointer = destPointer, ripPower = GetCurrentSnapshot(), time=time})
      		end
	  		
	  		--Garrote--
      		if unit_is_unit(sourcePointer,"player") and spellID == 703 then
        		if #dotTracker > 0 then
          			for i=1,#dotTracker do
            			if dotTracker[i].garrotepointer == destPointer then
              				dotTracker[i].garrotePower = GetCurrentSnapshot()
              				return
            			end
          			end
        		end
        		--refreshed garrote, but not in dot tracker
        		table.insert(dotTracker,{garrotepointer = destPointer, garrotePower = GetCurrentSnapshot(), time=time})
      		end

    	end

    	if (subEvent == "SPELL_AURA_APPLIED" or subEvent == "SPELL_CAST_SUCCESS") and unit_is_unit("player",sourcePointer) then
      		
      		--Rake--
      		if spellID == 155722 then
        		for i=1,#dotTracker do
          			if dotTracker[i].rakepointer == destPointer then
            			return false;
          			end
        		end
        		table.insert(dotTracker,{rakepointer = destPointer, rakePower = GetCurrentSnapshot(1822), time=time})
        		return
      		end
	 
	      	--Rip--
	      	if spellID == 1079 then
	        	for i=1,#dotTracker do
	          		if dotTracker[i].rippointer == destPointer then
	           			return false;
	          		end
        		end
	        	table.insert(dotTracker,{rippointer = destPointer, ripPower = GetCurrentSnapshot(), time=time})
	        	return
	      	end

	      	--Garrote--
	      	if spellID == 703 then
	        	for i=1,#dotTracker do
	          		if dotTracker[i].garrotepointer == destPointer then
	           			return false;
	          		end
        		end
	        	table.insert(dotTracker,{garrotepointer = destPointer, garrotePower = GetCurrentSnapshot(), time=time})
	        	return
	      	end

    	end

    	--dotTracker cleanup
		for i=1,#dotTracker do

			--Rake
      		if dotTracker[i] and dotTracker[i].rakepointer then
        		if time - dotTracker[i].time > .1 and not UnitDebuffID(dotTracker[i].rakepointer,155722,"player") then
			      	tremove(dotTracker,i);
        		end
     		 end

     		--Rip
      		if dotTracker[i] and dotTracker[i].rippointer then
        		if time - dotTracker[i].time > .1 and _debuffRemains(dotTracker[i].rippointer,1079,"player") == 0 then
          			tremove(dotTracker,i);
        		end
      	    end

      	    --Rip
      		if dotTracker[i] and dotTracker[i].garrotepointer then
        		if time - dotTracker[i].time > .1 and _debuffRemains(dotTracker[i].garrotepointer,703,"player") == 0 then
          			tremove(dotTracker,i);
        		end
      	    end

		end

		--dotTracker removal
		if subEvent == "SPELL_AURA_REMOVED" then

			--Rake--
			if spellID == 155722 then
			  	if #dotTracker > 0 then
			    	for i=1,#dotTracker do
			      		if dotTracker[i].rakepointer == destPointer then tremove(dotTracker,i) return true end
		    		end
			  	end
			end

        	--Rip--
        	if spellID == 1079 then
          		if #dotTracker > 0 then
            		for i=1,#dotTracker do
              			if dotTracker[i].rippointer == destPointer then tremove(dotTracker,i) return true end
            		end
          		end
    		end

    		--Garrote--
        	if spellID == 703 then
          		if #dotTracker > 0 then
            		for i=1,#dotTracker do
              			if dotTracker[i].garrotepointer == destPointer then tremove(dotTracker,i) return true end
            		end
          		end
    		end

    		--slow out of block
    		if spellID == 45438 then
    			if select(2,UnitClass("player")) == "WARRIOR" then
    				if _Cast(1715,destPointer,true) then
    					Squid_Alert("Hamstring","Ice Block",3)
    				end
    			end
    			if select(2,UnitClass("player")) == "MONK" then
    				if _Cast(116095,destPointer,true) then
    					Squid_Alert("Disable","Ice Block",3)
    				end
    			end
    		end

    	end

    	local interrupts = {
    	183752,--"Disrupt",
    	6552,--"Pummel",
    	96231,--"Rebuke",
    	147362,--"Counter Shot",
    	1766,--"Kick",
    	47528,--"Mind Freeze",
    	57994,--"Wind Shear",
    	119911,--"Optical Blast",
    	115781,--"Optical Blast",
    	19647,--"Spell Lock",
    	132409,--"Spell Lock",
    	251523,--"Spell Lock",
    	119910,--"Spell Lock",
    	171138,--"Shadow Lock",
    	2139,--"Counterspell",
    	116705,--"Spear Hand Strike",
    	106839,--"Skull Bash",
    	93985,--"Skull Bash"
    	78675,--"Solar Beam",
    	187707,--"Muzzle",
		91802,--"Shambling Rush"
    	}
		if subEvent == "SPELL_INTERRUPT" then
			if tContains(interrupts,spellID) then
				for i=1,#Enemies do
					local e=Enemies[i]
					if unit_is_unit(e,destPointer) then
						local cast=extraSpellName
						local school=CombatLog_String_SchoolString(auraType2)
						if cast then
							table.insert(kickTable, {unit=e, time=time+LockoutDuration(spellName), kick=spellName, kickID=spellID, cast=cast, school=school})
						end
					end
				end
			end
			-- print(CombatLog_String_SchoolString(auraType2))
			-- print(subEvent, sourceGUID, sourceName, destGUID, destName, destFlags, destRaidFlags, spellID, spellName, auraType, extraSpellName, auraType2)
		end
		if subEvent == "SPELL_CAST_SUCCESS" then
			if tContains(interrupts,spellName) then
				for i=1,#Enemies do
					local e=Enemies[i]
					if unit_is_unit(e,destPointer) then
						local cast = unit_casting_info(e)
						local channel = UnitChannelInfo(e)
						if not cast and not channel then
							table.insert(kickTable, {unit=e, time=time+1.2, kick=spellName, kickIcon=GetSpellTexture(spellID), juked=true})
						elseif channel == "Penance" then
							table.insert(kickTable, {unit=e, time=time+LockoutDuration(spellName), kick=spellName, kickID=spellID, cast=channel})
						-- elseif extraSpellName then
						-- 	table.insert(kickTable, {unit=e, time=time+LockoutDuration(spellName), kick=spellName, kickIcon=GetSpellTexture(spellID), cast=extraSpellName})
						end
					end
				end
			end
		end

	    local rootEvents = {
		6544, --Heroic Leap
		100, --Charge
		781, --Disengage
		101545, --Flying Serpent Kick
		109132, --Monk Roll
		-- 108212, --Burst of Speed
		108843, --Blazing Speed (Cauterize)
		115008, -- Chi Torpedo
		195457, -- Grappling Hook
		190925, -- Harpoon
		195072, -- Fel Rush
		198793, -- Vengeful Retreat
		102401, -- Wild Charge
		102417, -- Wild Charge
		49376,  -- Wild Charge
		190784, -- Divine Steed
		192063, -- Gust of Wind
		768, -- Cat Form
		212552, -- Wraith Walk
		}
  		if subEvent == "SPELL_CAST_SUCCESS" and UnitIsVisible(sourcePointer) then
	    	if tContains(rootEvents,spellID) and unit_can_attack("player",sourcePointer) then
	      		if (spellID ~= 768 or _isMeleeDps(sourcePointer)) and (spellID ~= 190784 or _buffRemains(sourcePointer,190784) <= 3) then
	        		if spellID == 100 or spellID == 102401 then
	          			time=time-.3;
	        		end
	        		shouldRootUnit,shouldRootTime,shouldRootReason = sourcePointer,time,GetSpellInfo(spellID);
	      		end
    		end
	  	end

	  	local debuffcd = {
		79140,	--Vendetta
		131894,	--Murder of Crows
		308498,	--Resonating Arrow
		-- 305483,	--Lightning Lasso
		}

		if subEvent == "SPELL_CAST_SUCCESS" and UnitIsVisible(sourcePointer) then
			if tContains(debuffcd,spellID) then
				table.insert(BigCDTable,{unit=sourcePointer,dest=destPointer,time=time,spell=spellID})
			end
		end
		
		--Track Kick Cooldowns--
		if subEvent == "SPELL_CAST_SUCCESS" and sourcePointer then
			--Pummel
			if spellName == "Pummel" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
			--Rebuke
			if spellName == "Rebuke" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
			--Counter Shot
			if spellName == "Counter Shot" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+23.8}); end 
			--Kick
			if spellName == "Kick" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
			--Mind Freeze
			if spellName == "Mind Freeze" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
			--Wind Shear
			if spellName == "Wind Shear" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+11.8}); end
			--Disrupt
			if spellName == "Disrupt" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
			--Optical Blast
			if spellName == "Optical Blast" then
		  		for i=1,#Enemies do if UnitIsPet(Pets[i]) and select(2,UnitClass(Pets[i])) == "WARLOCK" then
					table.insert(kickCooldowns,{pointer=Pets[i],expire=GetTime()+23.8});
	  			end end
			end
			--SpellLock
			if spellName == "Spell Lock" then
 		 		if UnitBuffID(sourcePointer,108503) then
					table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+23.8});
	  			else
					for i=1,#Pets do if UnitIsPet(Pets[i]) and select(2,UnitClass(Pets[i])) == "WARLOCK" then
				  		table.insert(kickCooldowns,{pointer=Pets[i],expire=GetTime()+23.8});
					end end
	  			end
			end
			--Shadow Lock
			if spellName == "Shadow Lock" then
		  		for i=1,#Enemies do if UnitIsPet(Pets[i]) and select(2,UnitClass(Pets[i])) == "WARLOCK" then
					table.insert(kickCooldowns,{pointer=Pets[i],expire=GetTime()+23.8});
		  		end end
			end
			--Counterspell
			if spellName == "Counterspell" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+23.95}); end
			--Spear Hand Strike
			if spellName == "Spear Hand Strike" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.95}); end
			--Skull Bash
			if spellName == "Skull Bash" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.95}); end
			--Solar Beam
			if spellName == "Solar Beam" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+59.95}); end
		end

	end--end of combat log

end
combo_point_tracker = {}
BigCDTable = {}
PlayerSpellCasts = {}
SpellTracker = {}
TrinketTracker = {}
dotTracker = {}
kickTable = {}
kickCooldowns = {}
SquidEvents = CreateFrame("Frame")
SquidEvents:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
SquidEvents:SetScript("OnEvent",Squid_CombatLog)

local function update_target_pointer(self,event,test,nigga)
	if not IsHackEnabled then return false end
	if event == "PLAYER_FOCUS_CHANGED" then
		current_focus = ObjectPointer("focus")
	end
	if event == "PLAYER_TARGET_CHANGED" then
		current_target = ObjectPointer("target")
	end
end

local TPFrame = CreateFrame("Frame")
TPFrame:RegisterEvent("PLAYER_TARGET_CHANGED")
TPFrame:RegisterEvent("PLAYER_FOCUS_CHANGED")
TPFrame:SetScript("OnEvent",update_target_pointer)

function UnitCanKick(unit,otherUnit)
  
	local class = select(2,UnitClass(unit))

	if UnitIsPet(unit) then
		-- imp: 416 felhunter: 417 succ: 1863 felimp: 58959 observer: 58964
		if class ~= "WARLOCK" then return false end
		local object_id = ObjectID(unit)
		if object_id ~= 58964 and object_id ~= 417 then return false end
	end

	if not unit_is_player(unit) and not UnitIsPet(unit) then return false end

	if class == "WARLOCK" and not UnitIsPet(unit) and UnitName(unit) ~= "Felhunter" then return false end

	if _CCremains(unit) >= .15 then return false; end

	local role = GetUnitRole(unit)

	--classes that cannot interrupt while silenced
	if class == "MAGE" or class == "DEATHKNIGHT" or class == "SHAMAN" or (class == "DRUID" and role == "ranged") then
		if _silenceCheck(unit) then
			return false
		end
	end

	--classes that cannot interrupt while locked out
	local locked,remaining,school = UnitIsLocked(unit)
	if locked and remaining > .15 then
		if ( class == "MAGE" and school == "Arcane" )
		or ( class == "SHAMAN" and school == "Nature" ) then
			return false
		end
	end

	for i=1,#kickCooldowns do if unit_is_unit(kickCooldowns[i].pointer,unit) then return false end end

	if _LoS(unit,otherUnit) then

		local px,py,pz
		if unit_is_unit(otherUnit,"player") then
			px,py,pz = GetPlayerPosition()
		else
			px,py,pz = ObjectPosition(otherUnit)
		end

		local x,y,z = PredictUnitPosition(unit,.2)

		local dist = GetDistanceBetweenPositions(px,py,pz,x,y,z) - UnitCombatReach(unit) - UnitCombatReach(otherUnit)

		local has_bop = UnitBuffID(otherUnit,1022)

		if (class == "MAGE" or class == "WARLOCK" or class == "HUNTER" and _isRangedDps(unit)) and dist <= 40 then
			if class ~= "HUNTER" or not has_bop then
				return true
			end
		end

		if class == "SHAMAN" and dist <= 30 then
	 		return true
		end

		if class == "DRUID" then
			if role == "melee" and dist <= 13 and _isBeast(unit) and not has_bop then return true end
	  		-- if role == "ranged" and dist <= 45 then return true end
		end

		if (class == "WARRIOR" or (class == "MONK" and role == "melee") or (class == "PALADIN" and role == "melee") or class == "ROGUE") and dist <= 6 and not has_bop then
			return true
		end

		if class == "DEATHKNIGHT" and dist <= 15 then
			return true
		end

		if class == "DEMONHUNTER" and dist <= 11 then
			return true
  		end

	end

	return false

end

function UnitCanBeKicked(unit)
	for i=1,#Pets do 
		if unit_can_attack(Pets[i],unit) and UnitCanKick(Pets[i],unit) then 
			return true
  		end
  	end
  	for i=1,#Friends do
  		if unit_can_attack(Friends[i],unit) and UnitCanKick(Friends[i],unit) then
  			return true
  		end
  	end
	return false;
end

function PlayerCanBeKicked()
	return UnitCanBeKicked("player")
end

function SquidMessageHandler(self,event,prefix,text,author)

	local name,prefix = strsplit(" ", prefix)

	if string.lower(UnitName("player")) ~= name then return false end

	--move char
	if prefix == "SM" then
		x,y,z = strsplit(",",text)
		if x and y and z then
			x=tonumber(x)
			y=tonumber(y)
			z=tonumber(z)
			ExecutingPlayerMovementCommand = GetTime()
			Squid_Alert("Moving To Coords:","(" .. math.floor(x) .. ") , (" .. math.floor(y) .. ") , (" .. math.floor(z) .. ")")
			MoveTo(x,y,z,true)
		end
	end
	--run command
	if prefix == "SC" then
		RunScript(text)
		Squid_Alert("Remote Command:",text)
	end
	--interactmouseover
	if prefix == "SI" then
		
		local unitsnearby = {}

		for i=1,#Objects do
			local d = _realDistance(Objects[i])
			table.insert(unitsnearby,{unit=Objects[i],d=d})
		end
		table.sort(unitsnearby,function(x,y) return x.d < y.d end)

		local match
		for i=1,#unitsnearby do
			if UnitName(unitsnearby[i].unit) == text then
				match=unitsnearby[i].unit
				break
			end
		end

		if match then
			InteractUnit(match)
		else
			InteractUnit(text)
		end
		Squid_Alert("Interacting with object:",text)
	end
end

SquidMessage = CreateFrame("Frame")
SquidMessage:RegisterEvent("CHAT_MSG_ADDON")
SquidMessage:SetScript("OnEvent",SquidMessageHandler)
C_ChatInfo.RegisterAddonMessagePrefix(string.lower(UnitName("player")) .. " SM")
C_ChatInfo.RegisterAddonMessagePrefix(string.lower(UnitName("player")) .. " SC")
C_ChatInfo.RegisterAddonMessagePrefix(string.lower(UnitName("player")) .. " SI")

function SendMovementCommand(unit)
	unit = string.lower(unit)
	local x,y,z = WorldPositionFromCursor()
	if x and y and z then
		local success = C_ChatInfo.SendAddonMessage(unit .. " SM", x .. "," .. y .. "," .. z , "WHISPER" , unit)
	end
end

function SendInteractCommand(unit)
	local success
	local command

	unit = string.lower(unit)

	if GameTooltip:IsShown() and GameTooltipTextLeft1 then
		command = GameTooltipTextLeft1:GetText()
	end
	if command then
		success = C_ChatInfo.SendAddonMessage(unit .. " SI", command, "RAID" , unit)
	end
	if not success then
		command = UnitTarget("player")
		if command then
			success = C_ChatInfo.SendAddonMessage(unit .. " SI", command, "RAID" , unit)
		end
	end
end

function SendSquidCommand(unit,command)
	unit = string.lower(unit)
	return C_ChatInfo.SendAddonMessage(unit .. " SC", command, "PARTY")
end

local sq_whispers = CreateFrame("FRAME", "MsgFrame");
sq_whispers:RegisterEvent("CHAT_MSG_WHISPER");
local function handle_whispers(self, event, ...)
	local message = select(1,...)
	local author = select(2,...)
	local authorGUID = select(12,...)
	
	--fruit platter wongo bongo invite
	if SQUID.cap_bot and (message == "wongo bongo" or message == "fruit platters") then
		RunMacroText("/inv " .. author);
		print("Invited " .. author)
	end
end
sq_whispers:SetScript("OnEvent", handle_whispers);

function SquidMorph(unit,displayid)
	if not displayid then displayid=unit; unit="player"; end
	UnitSetDisplayID (unit,displayid)
	UnitUpdateModel (unit)
	Squid_Last_Morph={unit,displayid}
	--49 LMAO
	--47931 SQUID ROFL
	--3037 dino with cleavers
end

function SquidPause()
	SquidPaused = GetTime();
end

function squid_queue_focus_maim()
	squid_maim_queued = GetTime();
	squid_maim_target = "focus"
	Squid_Alert("Focus Maim Queued",nil,nil,3.5,22570)
end

function squid_queue_target_maim()
	squid_maim_queued = GetTime();
	squid_maim_target = "target"
	Squid_Alert("Target Maim Queued",nil,nil,3.5,22570)
end

function squid_queue_healer_maim()
	for i=1,#Enemies do
		if _isHealer(Enemies[i]) then
			squid_maim_queued = GetTime();
			squid_maim_target = Enemies[i]
			Squid_Alert("Healer Maim Queued",nil,nil,3.5,22570)
			return true
		end
	end
	Squid_Alert("|cFFc31d39No Healers Found, Maim Not Queued",nil,nil,nil,22570)
end

function GetPortCoords()
	if portcoords then
		return portcoords.x,portcoords.y,portcoords.z
	end
end

player_can_see_cache = {}

function player_can_see(unit)

	if player_can_see_cache[unit] then return player_can_see_cache[unit] end
	
	local x,y,z = ObjectPosition(unit)

	local see = WorldToScreen(x,y,z)

	if see then
		if see > 1300 then
			-- print("TOO FAR TO RIGHT "..math.random(1,10))
			see = nil
		elseif see < 30 then
			-- print("TOO FAR TO LEFT"..math.random(1,10))
			see = nil
		end
	end

	see = see and true or false

	player_can_see_cache[unit] = see

	return see

end

function player_can_see_coords(x,y,z)

	if not x or not y or not z then return end

	if player_can_see_cache[{x,y,z}] then return player_can_see_cache[{x,y,z}] end

	local see,zee = WorldToScreen(x,y,z)

	if see then
		if see > 1250 then
			-- print("TOO FAR TO RIGHT "..math.random(1,10))
			see = nil
		elseif see < 30 then
			-- print("TOO FAR TO LEFT"..math.random(1,10))
			see = nil
		end
	end

	if zee then
		if zee > 800 then
			-- print("TOO FAR UP "..math.random(1,10))
			zee = nil
		elseif zee < 90 then
			-- print("TOO FAR DOWN "..math.random(1,10))
			zee = nil
		end
	end

	see = see and true or false
	zee = zee and true or false

	player_can_see_cache[{x,y,z}] = (see and zee)

	return (see and zee)

end

-- needs to also blink into enemy smoke bomb when possible (instead of just not using a blink, check if we could blink into the smoke bomb?)
function blink_to_unit(unit,maxdist,predict)
	if not maxdist then maxdist = 30 end
	local time = GetTime()
	if player_blink and time - player_blink < .35 then return false end

	--Displacement Position
	if UnitBuffID("player",212799) and _spellCooldown(212801) == 0 then
		if not _LoS(unit,nil,true) or _distance(unit) > maxdist then
			local displacement_position = {}
			for i=1,#AreaTriggers do if ObjectID(AreaTriggers[i]) == 11513 then
				local x,y,z = ObjectPosition(AreaTriggers[i])
				displacement_position = {x,y,z}
				break
			end end
			local dx,dy,dz = unpack(displacement_position)
			local x,y,z
			if dx and dy and dz then
				x,y,z = GroundZ(dx,dy,dz)
			end
			if x and y and z and dz-z < .05 then
				local ux,uy,uz = ObjectPosition(unit)
				if not TraceLine(ux,uy,uz+2,dx,dy,dz+2,losflags) then
					SQ_CastSpellByName("Displacement")
					player_blink = time
					return true
				end
			end
		end
	end
	if not UnitDebuffID(unit,212183) and not UnitBuffID(unit,212183) then
		if not _LoS(unit,nil,true) or _distance(unit) > maxdist then
			local x,y,z
			if predict then
				local px,py,pz = PredictUnitPosition(unit,(player_cast_time_left or .15))
				if px and py and pz then
					x,y,z = blink_los_point(unit,maxdist,px,py,pz)
				else
					x,y,z = blink_los_point(unit,maxdist)
					squid_print("Unable to predict movement blinking to unit")
				end
			else
				x,y,z = blink_los_point(unit,maxdist)
			end
			local px,py,pz = GetPlayerPosition()
			if x and y and z and _spellCooldown(212653) == 0 then
				local dir = GetAnglesBetweenPositions(px,py,pz,x,y,z)
				FaceDirection(dir,true)
				SQ_CastSpellByID(1953)
				player_blink = time
				return true
			end
		end
	end
end

function blink_to_pos(x,y,z)
	local px,py,pz = GetPlayerPosition()
	if x and y and z and _spellCooldown(212653) == 0 then
		local dir = GetAnglesBetweenPositions(px,py,pz,x,y,z)
		FaceDirection(dir,true)
		SQ_CastSpellByID(1953)
		player_blink = GetTime()
		return true
	end
end

function roll_to_unit(unit)
	local time=GetTime()
	if IsFalling() then return false end
	if _spellCooldown(109132) == 0 and _spellCooldown(101545) < 23.5 and (not last_wdp or time-last_wdp > 1.5) then
		local x,y,z = ObjectPosition(unit)
		StopMoving()
		SetMovementLocked(true)
		MoveTo(x,y,z,true)
		SQ_CastSpellByID(109132)
		Squid_Alert("Roll to "..UnitClass(unit),nil,nil,nil,109132)
		C_Timer.After(.1,function() 
			SetMovementLocked(false)
		end)
	end
end

function fsk_to_unit(unit)
	local time=GetTime()
	if player_fsk and time-player_fsk < 1.5 then return end
	if _spellCooldown(101545) == 0 and (not last_wdp or time-last_wdp > 1.5) then
		StopMoving()
		local x,y,z=ObjectPosition(unit)
		local ml = IsMouselooking()

		if ml then
			C_Timer.After(.5,function() 
				if player_fsk and time-player_fsk < 2 then MouselookStart() end
				_targetLastTarget()
			end)
			MouselookStop() 
		end
		StrafeLeftStop()
		StrafeRightStop()
		MoveForwardStop()
		MoveTo(x,y,z,true)
		C_Timer.After(.5,function() 
			RunMacroText("/console AutoInteract false")
			RunMacroText("/console AutoInteract 0")
		end)
		local flags = UnitMovementFlags("player")
		if flags == 1 then
			MoveTo(x,y,z,true)
			SQ_CastSpellByID(101545)
			forced_fsk=time
			return true
		end
	end
end

function squid_ttd(unit,playerdps)
	
	if not UnitIsVisible(unit) then return 999 end
	
	if _isDummy(unit) then return 999 end

	local time = GetTime()
	local player_hp = UnitHealthMax("player")
	local groupsize = GetNumGroupMembers()
	if groupsize == 0 then groupsize = 1 end

	--units that will not be dpsing
	local useless_count = 0
	for i=1,#Friends do if _isHealer(Friends[i]) or not UnitIsVisible(Friends[i]) then
		useless_count = useless_count + 1
	end end
	groupsize = groupsize - useless_count

	local unit_hp = UnitHealth(unit)

	local avgdps

	if UnitLevel("player") >= 50 then
		avgdps = player_hp / 9
	else
		avgdps = player_hp / 18
	end

	local totaldps = ( ( avgdps / 2 ) * groupsize ) + ( avgdps * UnitEnemiesAttacking(unit) ) 

	local ttd = unit_hp / totaldps

	return ttd

end

function squid_ttp(unit,percentage,playerdps)
	
	local time = GetTime()
	local player_hp = UnitHealthMax("player")
	local groupsize = GetNumGroupMembers()
	if groupsize == 0 then groupsize = 1 end

	--units that will not be dpsing
	local useless_count = 0
	for i=1,#Friends do if _isHealer(Friends[i]) or not UnitIsVisible(Friends[i]) then
		useless_count = useless_count + 1
	end end
	groupsize = groupsize - useless_count

	local unit_hp = UnitHealth(unit)
	local avgdps = player_hp / 8
	local totaldps = avgdps * groupsize
	local unit_hp_percentage = 100 * UnitHealth(unit) / UnitHealthMax(unit)
	local unit_hp_deficit = unit_hp_percentage - percentage

	if unit_hp_deficit > 0 then
		local pct_per_second = 100 * totaldps / UnitHealthMax(unit)
		local time_till_pct = unit_hp_deficit / pct_per_second
		return time_till_pct
	else
		return 0
	end

	-- if shitty_ttd[unit] then
	-- 	local time_combat_started = shitty_ttd[unit]
	-- 	local time_in_combat = time - time_combat_started
	-- 	local seconds_in_combat = time_in_combat
	-- 	local hp = _HP(unit)
	-- 	local hp_d = 100 - hp
	-- 	local hp_loss_per_second = hp_d / seconds_in_combat
	-- 	local time_til_zero = hp / hp_loss_per_second
	-- 	return time_til_zero
	-- end
end

-- function get_shell_offset()
-- 	local shell = {}

-- 	for i=1,#Squid_OM do if ObjectName(Squid_OM[i]) == "Shell" then
-- 		local o = Squid_OM[i]
-- 		for n=1,2600 do
-- 			local descriptor = bit.rshift(ObjectDescriptor(o,n,"ushort"),6)
-- 			if descriptor > 0 then
-- 				table.insert(shell,{shell=o,offset=n,descriptor=descriptor,deficit=0})
-- 			end
-- 		end
-- 	end end

-- 	local offsets = {}
-- 	for i=1,#shell do

-- 	end

-- end
-- local deficit = 0 for i=1,#Squid_OM do local o = Squid_OM[i] if ObjectName(Squid_OM[i]) == "Shell" then 

local AutoLagTolerance = CreateFrame("Frame", "AutoLagTolerance")
local GetNetStats = GetNetStats
local min = math.min
local SetCVar = SetCVar

AutoLagTolerance.cache = GetCVar("SpellQueueWindow")
AutoLagTolerance.timer = 0

local function AutoLagTolerance_OnUpdate(self, elapsed)
	self.timer = self.timer + elapsed

	if self.timer < 1.0 then
		return
	end

	self.timer = 0

	local latency = min(400, select(4, GetNetStats()))
	
	local scriptUpdate = ((1/GetFramerate())*8)*1000
	
	latency = latency + scriptUpdate;

	if latency == 0 then
		return
	end

	if latency == self.cache then
		return
	end

	SetCVar("SpellQueueWindow", latency)

	self.cache = latency
end

AutoLagTolerance:SetScript("OnUpdate", AutoLagTolerance_OnUpdate)


-- LubDraw by docbrown on fh-wow.com
local LibDraw
local sin, cos, atan, atan2, sqrt, rad = math.sin, math.cos, math.atan, math.atan2, math.sqrt, math.rad
local tinsert, tremove = tinsert, tremove

local function WorldToScreen (wX, wY, wZ)
    local sX, sY = _G.WorldToScreen(wX, wY, wZ);
    if sX and sY then
        return sX, -(WorldFrame:GetTop() - sY);
    else
        return sX, sY;
    end
end

-- if LibStub then
--     -- LibStub version control
--     LibDraw = LibStub:NewLibrary("LibDraw-1.0", 3)
--     if not LibDraw then return end
-- else
    -- Pretty much LibStub
    LibDraw = {
        version = 69.0
    }
    _G['LibDraw'] = LibDraw
-- end

LibDraw.line = LibDraw.line or { r = 0, g = 1, b = 0, a = 1, w = 1 }
LibDraw.level = "BACKGROUND"
LibDraw.callbacks = { }

if not LibDraw.canvas then
    LibDraw.canvas = CreateFrame("Frame", WorldFrame)
    LibDraw.canvas:SetAllPoints(WorldFrame)
    LibDraw.lines = { }
    LibDraw.lines_used = { }
    LibDraw.textures = { }
    LibDraw.textures_used = { }
    LibDraw.fontstrings = { }
    LibDraw.fontstrings_used = { }
end

function LibDraw.SetColor(r, g, b, a)
    LibDraw.line.r = r * 0.00390625
    LibDraw.line.g = g * 0.00390625
    LibDraw.line.b = b * 0.00390625
    if a then
        LibDraw.line.a = a * 0.01
    else
        LibDraw.line.a = 1
    end
end

function LibDraw.SetColorRaw(r, g, b, a)
    LibDraw.line.r = r
    LibDraw.line.g = g
    LibDraw.line.b = b
    LibDraw.line.a = a
end

SQUID.line_scale = SQUID.line_scale or 1
function LibDraw.SetWidth(w)
    LibDraw.line.w = w * SQUID.line_scale
end

function LibDraw.Line(sx, sy, sz, ex, ey, ez)
    if not WorldToScreen then return end

    local sx, sy = WorldToScreen(sx, sy, sz)
    local ex, ey = WorldToScreen(ex, ey, ez)

    LibDraw.Draw2DLine(sx, sy, ex, ey)
end

function LibDraw.rotateX(cx, cy, cz, px, py, pz, r)
    if r == nil then return px, py, pz end
    local s = sin(r)
    local c = cos(r)
    -- center of rotation
    px, py, pz = px - cx,  py - cy, pz - cz
    local x = px + cx
    local y = ((py * c - pz * s) + cy)
    local z = ((py * s + pz * c) + cz)
    return x, y, z
end

function LibDraw.rotateY(cx, cy, cz, px, py, pz, r)
    if r == nil then return px, py, pz end
    local s = sin(r)
    local c = cos(r)
    -- center of rotation
    px, py, pz = px - cx,  py - cy, pz - cz
    local x = ((pz * s + px * c) + cx)
    local y = py + cy
    local z = ((pz * c - px * s) + cz)
    return x, y, z
end

function LibDraw.rotateZ(cx, cy, cz, px, py, pz, r)
    if r == nil then return px, py, pz end
    local s = sin(r)
    local c = cos(r)
    -- center of rotation
    px, py, pz = px - cx,  py - cy, pz - cz
    local x = ((px * c - py * s) + cx)
    local y = ((px * s + py * c) + cy)
    local z = pz + cz
    return x, y, z
end

function LibDraw.Array(vectors, x, y, z, rotationX, rotationY, rotationZ)
    for _, vector in ipairs(vectors) do
        local sx, sy, sz = x+vector[1], y+vector[2], z+vector[3]
        local ex, ey, ez = x+vector[4], y+vector[5], z+vector[6]

        if rotationX then
            sx, sy, sz = LibDraw.rotateX(x, y, z, sx, sy, sz, rotationX)
            ex, ey, ez = LibDraw.rotateX(x, y, z, ex, ey, ez, rotationX)
        end
        if rotationY then
            sx, sy, sz = LibDraw.rotateY(x, y, z, sx, sy, sz, rotationY)
            ex, ey, ez = LibDraw.rotateY(x, y, z, ex, ey, ez, rotationY)
        end
        if rotationZ then
            sx, sy, sz = LibDraw.rotateZ(x, y, z, sx, sy, sz, rotationZ)
            ex, ey, ez = LibDraw.rotateZ(x, y, z, ex, ey, ez, rotationZ)
        end

        local sx, sy = WorldToScreen(sx, sy, sz)
        local ex, ey = WorldToScreen(ex, ey, ez)
        LibDraw.Draw2DLine(sx, sy, ex, ey)
    end
end

function LibDraw.Draw2DLine(sx, sy, ex, ey)

    if not WorldToScreen or not sx or not sy or not ex or not ey then return end

    local L = tremove(LibDraw.lines) or false
    if L == false then
        L = CreateFrame("Frame", LibDraw.canvas)
    L.line = L:CreateLine()
        L.line:SetDrawLayer(LibDraw.level)
    end
    tinsert(LibDraw.lines_used, L)

  L:ClearAllPoints()

  if sx > ex and sy > ey or  sx < ex and sy < ey  then
    L:SetPoint("TOPRIGHT", LibDraw.canvas, "TOPLEFT", sx, sy)
    L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", ex, ey)
    L.line:SetStartPoint('TOPRIGHT')
    L.line:SetEndPoint('BOTTOMLEFT')
  elseif sx < ex and sy > ey then
    L:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
    L:SetPoint("BOTTOMRIGHT", LibDraw.canvas, "TOPLEFT", ex, ey)
    L.line:SetStartPoint('TOPLEFT')
    L.line:SetEndPoint('BOTTOMRIGHT')
  elseif sx > ex and sy < ey then
    L:SetPoint("TOPRIGHT", LibDraw.canvas, "TOPLEFT", sx, sy)
    L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", ex, ey)
    L.line:SetStartPoint('TOPLEFT')
    L.line:SetEndPoint('BOTTOMRIGHT')
  else
    -- wat, I don't like this, not one bit
    L:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
    L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", sx, ey)
    L.line:SetStartPoint('TOPLEFT')
    L.line:SetEndPoint('BOTTOMLEFT')
  end

  L.line:SetThickness(LibDraw.line.w)
    L.line:SetColorTexture(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

    L:Show()

end

local full_circle = rad(365)
local small_circle_step = rad(3)

function LibDraw.Circle(x, y, z, size)
    local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
    for v=0, full_circle, small_circle_step do
        nx, ny = WorldToScreen( (x+cos(v)*size), (y+sin(v)*size), z )
        LibDraw.Draw2DLine(lx, ly, nx, ny)
        lx, ly = nx, ny
    end
end

local flags = bit.bor(collisionflags)

function LibDraw.GroundCircle(x, y, z, size)
	size = size / 2
    local lx, ly, nx, ny, fx, fy, fz = false, false, false, false, false, false, false
    for v=0, full_circle, small_circle_step*6 do
        fx, fy, fz = TraceLine(  (x+cos(v)*size), (y+sin(v)*size), z+4, (x+cos(v)*size), (y+sin(v)*size), z-100, flags )
        if fx == nil then
            fx, fy, fz = (x+cos(v)*size), (y+sin(v)*size), z
        end
        nx, ny = WorldToScreen( (fx+cos(v)*size), (fy+sin(v)*size), fz )
        LibDraw.Draw2DLine(lx, ly, nx, ny)
        lx, ly = nx, ny
    end
end

function LibDraw.Arc(x, y, z, size, arc, rotation)
    local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
    local half_arc = arc * 0.5
    local ss = (arc/half_arc)
    local as, ae = -half_arc, half_arc
    for v = as, ae, ss do
        nx, ny = WorldToScreen( (x+cos(rotation+rad(v))*size), (y+sin(rotation+rad(v))*size), z )
        if lx and ly then
            LibDraw.Draw2DLine(lx, ly, nx, ny)
        else
            fx, fy = nx, ny
        end
        lx, ly = nx, ny
    end
    local px, py = WorldToScreen(x, y, z)
    LibDraw.Draw2DLine(px, py, lx, ly)
    LibDraw.Draw2DLine(px, py, fx, fy)
end

function LibDraw.Texture(config, x, y, z, alphaA, texts)

    local texture, width, height = config.texture, config.width, config.height
    local left, right, top, bottom, scale =  config.left, config.right, config.top, config.bottom, config.scale
    local ULx,ULy,LLx,LLy,URx,URy,LRx,LRy = config.ULx, config.ULy, config.LLx, config.LLY, config.URx, config.URy, config.LRx, config.LRy
    local alpha = config.alpha or alphaA

    if not WorldToScreen or not texture or not width or not height or not x or not y or not z then return end
    if not left or not right or not top or not bottom then
        left = 0
        right = 1
        top = 0
        bottom = 1
    end
    if not scale then
        local cx, cy, cz = GetCameraPosition()
        scale = width / LibDraw.Distance(x, y, z, cx, cy, cz)
    end

    local sx, sy = WorldToScreen(x, y, z)
    if not sx or not sy then return end
    local w = width * scale
    local h = height * scale
    sx = sx - w*0.5
    sy = sy + h*0.5
    local ex, ey = sx + w, sy - h

    local T = tremove(LibDraw.textures) or false
    if T == false then
        T = LibDraw.canvas:CreateTexture(nil, "BACKGROUND")
        T:SetDrawLayer(LibDraw.level)
        T:SetTexture(LibDraw.texture)
    end
    tinsert(LibDraw.textures_used, T)
    T:ClearAllPoints()
    if ULx then
    	T:SetTexCoord(ULx,ULy,LLx,LLy,URx,URy,LRx,LRy)
    else
    	T:SetTexCoord(left, right, top, bottom)
    end
    T:SetTexture(texture)
    T:SetWidth(width)
    T:SetHeight(height)
    T:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
    T:SetPoint("BOTTOMRIGHT", LibDraw.canvas, "TOPLEFT", ex, ey)
    T:SetVertexColor(1, 1, 1, 1)
    if alpha then T:SetAlpha(alpha) else T:SetAlpha(1) end
    T:Show()

    if texts then
    	for i=1,#texts do

    		local text = texts[i].text
    		local font = texts[i].font
    		local offsetY = texts[i].offsetY or 0
    		local offsetX = texts[i].offsetX or 0

	        local F = tremove(LibDraw.fontstrings) or LibDraw.canvas:CreateFontString(nil, "BACKGROUND")

	        F:SetFontObject(font)
	        F:SetText(text)
	        F:SetTextColor(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

	        if p then
	            local width = F:GetStringWidth() - 4
	            local offsetX = width*0.5
	            local offsetY = F:GetStringHeight() + 3.5
	            local pwidth = width*p*0.01
	            FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX), sy-offsetY, 4, r, g, b, 0.25)
	            FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX)-(width-pwidth), sy-offsetY, 4, r, g, b, 1)
	        end

	        F:SetPoint("TOPLEFT", UIParent, "TOPLEFT", sx-(F:GetStringWidth()*0.5)+offsetX, sy+offsetY)
	        F:Show()

	        tinsert(LibDraw.fontstrings_used, F)

	   	end
    end

end

function LibDraw.Text(text, font, x, y, z)

    local sx, sy = WorldToScreen(x, y, z)

    if sx and sy then

        local F = tremove(LibDraw.fontstrings) or LibDraw.canvas:CreateFontString(nil, "BACKGROUND")

        F:SetFontObject(font)
        F:SetText(text)
        F:SetTextColor(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

        if p then
            local width = F:GetStringWidth() - 4
            local offsetX = width*0.5
            local offsetY = F:GetStringHeight() + 3.5
            local pwidth = width*p*0.01
            FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX), sy-offsetY, 4, r, g, b, 0.25)
            FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX)-(width-pwidth), sy-offsetY, 4, r, g, b, 1)
        end

        F:SetPoint("TOPLEFT", UIParent, "TOPLEFT", sx-(F:GetStringWidth()*0.5), sy)
        F:Show()

        tinsert(LibDraw.fontstrings_used, F)

    end

end

local rad90 = math.rad(-90)

function LibDraw.Box(x, y, z, width, height, rotation, offset_x, offset_y)

    if not offset_x then offset_x = 0 end
    if not offset_y then offset_y = 0 end

    if rotation then rotation = rotation + rad90 end

    local half_width = width * 0.5
    local half_height = height * 0.5

    local p1x, p1y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y - half_width + offset_y, z, rotation)
    local p2x, p2y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y - half_width + offset_y, z, rotation)
    local p3x, p3y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y + half_width + offset_y, z, rotation)
    local p4x, p4y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y - half_width + offset_y, z, rotation)
    local p5x, p5y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y + half_width + offset_y, z, rotation)
    local p6x, p6y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y - half_width + offset_y, z, rotation)
    local p7x, p7y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y + half_width + offset_y, z, rotation)
    local p8x, p8y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y + half_width + offset_y, z, rotation)

    LibDraw.Line(p1x, p1y, z, p2x, p2y, z)
    LibDraw.Line(p3x, p3y, z, p4x, p4y, z)
    LibDraw.Line(p5x, p5y, z, p6x, p6y, z)
    LibDraw.Line(p7x, p7y, z, p8x, p8y, z)

end

local deg45 = math.rad(45)
local arrowX = {
    { 0  , 0, 0, 1.5,  0,    0   },
    { 1.5, 0, 0, 1.2,  0.2, -0.2 },
    { 1.5, 0, 0, 1.2, -0.2,  0.2 }
}
local arrowY = {
    { 0, 0  , 0,  0  , 1.5,  0   },
    { 0, 1.5, 0,  0.2, 1.2, -0.2 },
    { 0, 1.5, 0, -0.2, 1.2,  0.2 }
}
local arrowZ = {
    { 0, 0, 0  ,  0,    0,   1.5 },
    { 0, 0, 1.5,  0.2, -0.2, 1.2 },
    { 0, 0, 1.5, -0.2,  0.2, 1.2 }
}

function LibDraw.DrawHelper()
    local playerX, playerY, playerZ = ObjectPosition("player")
    local old_red, old_green, old_blue, old_alpha, old_width = LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a, LibDraw.line.w

    -- X
    LibDraw.SetColor(255, 0, 0, 100)
    LibDraw.SetWidth(1)
    LibDraw.Array(arrowX, playerX, playerY, playerZ, deg45, false, false)
    LibDraw.Text('X', "GameFontNormal", playerX + 1.75, playerY, playerZ)
    -- Y
    LibDraw.SetColor(0, 255, 0, 100)
    LibDraw.SetWidth(1)
    LibDraw.Array(arrowY, playerX, playerY, playerZ, false, -deg45, false)
    LibDraw.Text('Y', "GameFontNormal", playerX, playerY + 1.75, playerZ)
    -- Z
    LibDraw.SetColor(0, 0, 255, 100)
    LibDraw.SetWidth(1)
    LibDraw.Array(arrowZ, playerX, playerY, playerZ, false, false, false)
    LibDraw.Text('Z', "GameFontNormal", playerX, playerY, playerZ + 1.75)

    LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a, LibDraw.line.w = old_red, old_green, old_blue, old_alpha, old_width
end

function LibDraw.Distance(ax, ay, az, bx, by, bz)
    return math.sqrt(((bx-ax)*(bx-ax)) + ((by-ay)*(by-ay)) + ((bz-az)*(bz-az)))
end

function LibDraw.Camera()
    local fX, fY, fZ = ObjectPosition("player")
    local sX, sY, sZ = GetCameraPosition()
    return sX, sY, sZ, atan2(sY - fY, sX - fX), atan((sZ - fZ) / sqrt(((fX - sX) ^ 2) + ((fY - sY) ^ 2)))
end

function LibDraw.Sync(callback)
    tinsert(LibDraw.callbacks, callback)
end

function LibDraw.clearCanvas()
    -- LibDraw.stats = #LibDraw.textures_used
    for i = #LibDraw.textures_used, 1, -1 do
        LibDraw.textures_used[i]:Hide()
        tinsert(LibDraw.textures, tremove(LibDraw.textures_used))
    end
    for i = #LibDraw.fontstrings_used, 1, -1 do
        LibDraw.fontstrings_used[i]:Hide()
        tinsert(LibDraw.fontstrings, tremove(LibDraw.fontstrings_used))
    end
  for i = #LibDraw.lines_used, 1, -1 do
        LibDraw.lines_used[i]:Hide()
        tinsert(LibDraw.lines, tremove(LibDraw.lines_used))
    end
end

local function OnUpdate()
    LibDraw.clearCanvas()
    for _, callback in ipairs(LibDraw.callbacks) do
        callback()
        if LibDraw.helper then
            LibDraw.DrawHelper()
        end
        LibDraw.helper = false
    end
end

function LibDraw.Enable(interval)
    local timer
    if not interval then
        timer = C_Timer.NewTicker(interval, OnUpdate)
    else
        timer = C_Timer.NewTicker(interval, OnUpdate)
    end
    return timer
end

function LibDraw.DeSync(index)
  tremove(LibDraw.callbacks, index)
end
--LibDraw.canvas:SetScript("OnUpdate", OnUpdate)

--START WAELITE 

local function Line(sx, sy, sz, ex, ey, ez)
    local function WorldToScreen (wX, wY, wZ)
        local sX, sY = _G.WorldToScreen(wX, wY, wZ);
        if sX and sY then
            return sX, -(WorldFrame:GetTop() - sY);
        else
            return sX, sY;
        end
    end
    local startx, starty = WorldToScreen(sx, sy, sz)
    local endx, endy = WorldToScreen(ex, ey, ez)
    if (endx == nil or endy == nil) and startx then
        local i = 1
        while ( endx == nil or endy == nil ) and i < 200 do
            endx, endy = WorldToScreen(GetPositionBetweenPositions(ex, ey, ez, sx, sy, sz, i))
            i = i + 1 
        end
    end
    if (startx == nil or starty == nil) and endx then
        local i = 1
        while ( startx == nil or starty == nil ) and i < 200 do
            startx, starty = WorldToScreen(GetPositionBetweenPositions(sx, sy, sz, ex, ey, ez, i))
            i = i + 1 
        end
    end
    if startx and starty and endx and endy then
        LibDraw.Draw2DLine(startx, starty, endx, endy)
    end
end

SLASH_trackQuests1 = "/trackquests"
SlashCmdList["trackQuests"] = function(msg)
    if trackQuests == false then
        trackQuests = true
        print("Tracking Quest Objectives")
    else
        trackQuests = false
        print("Not Tracking Quest Objectives")
    end
end

SLASH_trackObjects1 = "/trackobjects"
SlashCmdList["trackObjects"] = function(msg)
    if trackObjects == false then
        trackObjects = true
        print("Tracking Quest Objects")
    else
        trackObjects = false
        print("Not Tracking Quest Objects")
    end
end

SLASH_drawcleave1 = "/drawcleave"
SlashCmdList["drawcleave"] = function(msg)
    if drawCleave == false then
        drawCleave = true
        print("Cleave Draw On")
    else
        drawCleave = false
        print("Cleave Draw Off")
    end
end

SLASH_dumpstuff1 = "/dumpstuff"
SlashCmdList["dumpstuff"] = function(msg)
    if dumpstuff == false then
        dumpstuff = true
        print("dumpstuff On")
    else
        dumpstuff = false
        print("dumpstuff Off")
    end
end

local cleaveCasts = Squid_cleaveCasts

--
local function Debug_Print(strName, tData) 
    if ViragDevTool_AddData then 
        ViragDevTool_AddData(tData, strName) 
    end
end

local areaTrigger = Squid_areaTrigger

local function distance(unit1, unit2)
    local x1, y1, z1
    local unit1CR
    if unit1 == "player" then
        x1, y1, z1 = pX, pY, pZ
        unit1CR = playerCR
    else
        x1, y1, z1 = ObjectPosition(unit1)
        unit1CR = UnitCombatReach(unit1)
    end
    local x2, y2, z2 = ObjectPosition(unit2)
    if not x2 or not y2 or not z2 then om[unit2] = nil; return 0; end
    if not x1 or not y1 or not z1 then om[unit1] = nil; return 0; end
    return sqrt(((x2 - x1) ^ 2) + ((y2 - y1) ^ 2) + ((z2 - z1) ^ 2)) -
        ((unit1CR or 0) + (UnitCombatReach(unit2) or 0)), z2 - z1
end

--Quest stuff
-- local questPlateTooltip = CreateFrame('GameTooltip', 'QuestPlateTooltip', nil, 'GameTooltipTemplate')
local myName = UnitName("player")
local function isQuestUnit(unit)
    if trackQuests or SQUID.track_quests then
    	local objectID = ObjectID(unit)
    	local known = {
    	[101518] = true,
    	[156335] = true,
    	}
    	if known[objectID] then return true end
        local guid = ObjectGUID(unit)
        -- questPlateTooltip:SetOwner(WorldFrame, 'ANCHOR_NONE')
        -- questPlateTooltip:SetHyperlink('unit:' .. guid)
        -- for i = 3, questPlateTooltip:NumLines() do
        --     local str = _G['QuestPlateTooltipTextLeft' .. i]
        --     local text = str and str:GetText()
        --     if not text then 
        --         return false 
        --     end
        --     local playerName, progressText = strmatch(text, '^ ([^ ]-) ?%- (.+)$')
        --     if (playerName == "" or playerName == myName) and progressText ~= nil then
        --         local x, y = strmatch(progressText, '(%d+)/(%d+)')
        --         if x ~= nil and y ~= nil and y - x > 0 then
        --             local killQuest = false
        --             if (GetLocale() == "ruRU") then
        --                 killQuest = strfind(progressText, "") ~= nil
        --             else
        --                 killQuest = strfind(progressText, "slain") ~= nil
        --             end
        --             if not UnitIsDeadOrGhost(unit) or (not killQuest and UnitCanBeLooted(unit)) then
        --                 return true
        --             end
        --         end
        --     end
        -- end
    end
 	-- if IsQuestObject(unit) then return true end
    return false
end

local function isQuestObject(object) --Ty Ssateneth
    local objectID = ObjectID(object)
    -- if IsQuestObject(objectID) then return true end
    local known = {
    [290542] = true,
    [113768] = true,
    [113771] = true,
    [113769] = true,
    [113769] = true,
    [113770] = true,
    [325397] = true,
    [325996] = true,
    [341554] = true,
    [341606] = true,
    [341470] = true,
    [330543] = true,
    [330572] = true,
	}
    if known[objectID] then return true end
    -- local glow = ObjectDescriptor(object,GetOffset("CGObjectData__DynamicFlags"),"uint")
    if glow and (bit.band(glow,0x4)~=0 or bit.band(glow,0x20)~=0) then
        return true
    end
    return false
end

local function BasicLine(sx, sy, sz, ex, ey, ez)
	local function WorldToScreen (wX, wY, wZ)
        local sX, sY = _G.WorldToScreen(wX, wY, wZ);
        if sX and sY then
            return sX, -(WorldFrame:GetTop() - sY);
        else
            return sX, sY;
        end
    end
    local startx, starty = WorldToScreen(sx, sy, sz)
    local endx, endy = WorldToScreen(ex, ey, ez)
    if (endx == nil or endy == nil) and startx then
        local i = 1
        while endx == nil or endy == nil do
        	local zdif = ez - sz
        	if zdif > 0 then ez = ez - zdif end
            endx, endy = WorldToScreen(GetPositionBetweenPositions(ex, ey, ez, sx, sy, sz, i))
            i = i + 1 
        end
    end
    if (startx == nil or starty == nil) and endx then
        local i = 1
        while startx == nil or starty == nil do
        	local zdif = sz - ez
        	if zdif > 0 then sz = sz - zdif end
            startx, starty = WorldToScreen(GetPositionBetweenPositions(sx, sy, sz, ex, ey, ez, i))
            i = i + 1 
        end
    end
    LibDraw.Draw2DLine(startx, starty, endx, endy)
end

local function getRectUnit(width,length,unit,startingpoint,movingdir,extra,forcedangle)
	extra = extra or 0
	extra = extra * math.pi / 180
	startingpoint = startingpoint or 0
    width = width or 3
    length = length or 30
    local x, y, z = ObjectPosition(unit)
    local facing = not movingdir and ObjectFacing(unit) or _getMovingDirection(unit) or 0
    facing = facing + extra

    if forcedangle then
    	facing = forcedangle
    end

    x = x + startingpoint * math.cos(facing)
    y = y + startingpoint * math.sin(facing)

    local halfWidth = width/2
    -- Near Left
    local nlX, nlY, nlZ = GetPositionFromPosition(x, y, z, halfWidth, facing + rad(90), 0)
    -- Near Right
    local nrX, nrY, nrZ = GetPositionFromPosition(x, y, z, halfWidth, facing + rad(270), 0)
    -- Far Left
    local flX, flY, flZ = GetPositionFromPosition(nlX, nlY, nlZ, length, facing, 0)
    -- Far Right
    local frX, frY, frZ = GetPositionFromPosition(nrX, nrY, nrZ, length, facing, 0)

    return nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ
end

local special_areatriggers = {
	
	--tests
	[12740] = true, -- test orb

	-- KINGS REST
	-- [17843] = true, -- KR Last Boss Tornadoes
	-- [17933] = true, -- KR Mob Tornadoes
	[17625] = true, -- KR Swirly Blade Boss

	-- MECHAGON WORKSHOP
	[19968] = true, -- Swirly Gears

	-- FREEHOLD
	-- [16776] = true, -- turtle shells
	[24078] = true, -- torg orb
	[165532] = true, -- plaguefall tentac
}

local player_class = select(2,UnitClass("player"))
local function drawTriggers()
	if SQUID.streaming_mode then return end
	local px,py,pz = GetPlayerPosition()
    for _, v in pairs(areaTriggers) do
        if (trackQuests or SQUID.track_quests or trackObjects) and ( v.objectType == "GameObject" or v.objectType == "Unit" ) and isQuestObject(v.objectPointer) then
            
            local x,y,z = ObjectPosition(v.objectPointer)
            local s = v.size
            LibDraw.SetColor(255,0,0)
            LibDraw.SetWidth(4)
            local name = ObjectName(v.objectPointer)

            --trackquests waypoint
            -- if GetDistanceBetweenPositions(px,py,pz,x,y,z) > 4 then

            	local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

            	local wf_top = WorldFrame:GetTop()
            	local scx,scy = GetCursorPosition()
				local sx,sy = WorldToScreen(x,y,z)

				local a = (100-(30-dist)) / 100
				if dist < 14 then
					a = a * (dist/14)
					if dist < 10 then
						a = a * (dist/32)
						if dist < 8 then
							a = a * (dist/32)
						end
					end
				end
				if a > 1 then a = 1 end
				if a < .3 then a = .3 end

				local dist_def = dist/4.5

				LibDraw.SetColorRaw(212/255,175/255,85/255,1)

				local mouse_in_range
				if sx and sy then
					if scx and scy then
						sy = sy + wf_top
						local d = sqrt( math.pow(scx - sx, 2) + math.pow(scy - sy, 2) )
						if d < max(80 - dist, 25) then
							if name and SQUID.mouseover_names then
								-- LibDraw.Text(name, "GameFontNormal", x, y, z+3)
								mouse_in_range=true
							end
							if d < max(80 - dist, 5) then
								-- local def = abs(5/(d-5))
								-- local fade = max(0,def)
								-- a = a - fade
								-- a = max(0.3,a)
							end
							-- InteractUnit(v.objectPointer)
						end
					end
				end

				local texture
				if UnitCanBeLooted(v.objectPointer)  then
					if mouse_in_range and dist < 5 then
						if GetKeyState(0x02) == true then
							InteractUnit(v.objectPointer)
							Squid_Alert("Helping you click the "..name, ":)")
						end
					end
					texture = {
						texture = 133784,
						width = 18+dist_def, height = 18+dist_def,
						alpha = a,
					}
				else
					texture = {

						texture = 3308452,
						width = 22 + (dist_def*.65), height = 41 + dist_def,
						alpha = a,

						left = 0.5,
						right = 1,
						top = 0,
						bottom = 1,

					}
				end


				local texts
				if mouse_in_range then
					texts = {
						[1] = {text=name, font="GameFontNormalSmall", offsetY=20, offsetX=7},
						[2] = {text=dist .. " yds", font="GameFontNormalSmall", offsetY=-23+(dist_def-12), offsetX=7}
					}
				end
				LibDraw.Texture(texture,x,y,z,nil,texts);

	        -- end

	        if SQUID.draw_line_to_objects and name ~= "Vault Door" then
	        	local dist = GetDistanceBetweenPositions(px,py,pz,x,y,z)
	        	local a = (100 - dist) / 100
			 	local g = a
				if a > .85 then a = .85 end
				if a < .3 then a = .3 end
				if g > 1 then g = 1 end
				if g < .75 then g = .75 end
				if SQUID.draw_line_to_objects and GetDistanceBetweenPositions(px,py,pz,x,y,z) <= SQUID.max_object_finder_dist then
					local w = 2.5 + (a * 3.5)
					LibDraw.SetWidth(w)
					local r = 1
					LibDraw.SetColorRaw(r, g, 0, a)
					BasicLine(px,py,pz,x,y,z)
				end
			end

        elseif v.objectType == "AreaTrigger" and v.distance <= 60 then

        	local circle_draw

            local x,y,z = ObjectPosition(v.objectPointer)

            local s = v.size
            local dont_draw

            --if object.objectPointer == "player" or not TraceLine(pX, pY, pZ, x, y, z, 0x10) then
            LibDraw.SetWidth(4)
            if v.good == "owner" then
            	
            	local parents = {}
            	if Squid_OM and v.parent then
            		for i=1,#Squid_OM do
            			if ObjectIsVisible(Squid_OM[i]) and ObjectID(Squid_OM[i]) == v.parent then
            				table.insert(parents,Squid_OM[i])
            			end
            		end
            	end

            	local good_creator
            	for i=1,#parents do
            		local creator = ObjectCreator(parents[i])
            		if creator then
            			if UnitIsVisible(creator) and UnitIsFriend("player",creator) and not unit_can_attack("player",creator) then
            				local ox,oy,oz = ObjectPosition(parents[i])
            				if GetDistanceBetweenPositions(ox,oy,oz,x,y,z) < 1 then
            					good_creator = true
            				end
            			end
            		end
            	end

            	if good_creator then
               		LibDraw.SetColor(100,255,0)
               	else
               		LibDraw.SetColor(255,255,80)
               	end

            elseif type(v.good) == "function" then
            	if v.good(v.objectPointer) then
	            	circle_draw = true
	            	LibDraw.SetColorRaw(.788, .96, .929, .3)
	            else
	            	dont_draw = true
	            end
            elseif v.good then
            	LibDraw.SetColor(100,255,0)
            else
                LibDraw.SetColor(255,0,0)
            end

            local objectID = v.objectID
            local thisUnit = v.objectPointer

            if dumpstuff and not areaTrigger[objectID] then
                LibDraw.SetColor(255,255,255)
                LibDraw.Text(ObjectID(v.objectPointer), "GameFontNormal", x, y, z+5)
                --facing arrow
	            local angle = ObjectFacing(v.objectPointer)
	            if angle then
	            	LibDraw.SetColor(200,255,100)
					local arrow_size = 0.3
					local arrow_shape = {
					  {-arrow_size, -arrow_size, 0, 0, 0, 0},
					  {arrow_size, -arrow_size, 0, 0, 0, 0},
					}
				    LibDraw.SetWidth(2)
				    LibDraw.Array(arrow_shape, x + 3.5 * math.cos(angle), y + 3.5 * math.sin(angle), z, math.rad(180), math.rad(180), math.rad(90) + angle)
	                angle = nil
	            end
	            --moving direction arrow
	            local angle = _getMovingDirection(v.objectPointer)
	            if angle then
	            	LibDraw.SetColor(80,255,100)
					local arrow_size = 0.5
					local arrow_shape = {
					  {-arrow_size, -arrow_size, 0, 0, 0, 0},
					  {arrow_size, -arrow_size, 0, 0, 0, 0},
					}
				    LibDraw.SetWidth(2)
				    LibDraw.Array(arrow_shape, x + 4.5 * math.cos(angle), y + 4.5 * math.sin(angle), z, math.rad(180), math.rad(180), math.rad(90) + angle)
				end
            end

            if circle_draw ~= false then
	            if circle_draw then
	            	LibDraw.GroundCircle(x, y, z, s)
	            elseif dont_draw then
	            	-- nope
	            elseif areaTrigger[objectID] or dumpstuff then
		            Line(x, y, z+s*1.75, x, y, z)
		            Line(x-s, y, z, x+s, y, z)
		            Line(x, y-s, z, x, y+s, z)
	            end

	        end

            LibDraw.SetColor(255,150,0)

            -- TESTS
            if dumpstuff and objectID == 12740 then --orb test
            	if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(8,12,thisUnit,2.5)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
            -- KING'S REST
            elseif objectID == 17843 then -- KR last boss tornadoes
            	if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3,4,thisUnit,1,nil,(ObjectFacing(thisUnit) * 180 / math.pi)-45)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
            elseif objectID == 17933 then -- KR mob nados
            	if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(2.5,3.5,thisUnit,1)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
            elseif objectID == 17625 then -- kr swirly blade axe
            	if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end 
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(9,14,thisUnit,-5)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)

          	elseif objectID == 24078 and v.distance < 18 then -- torghast orb shit

            	local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(1.8,6,thisUnit,-1)
                Line(flX, flY, pZ, nlX, nlY, pZ)
                Line(frX, frY, pZ, nrX, nrY, pZ)
                Line(frX, frY, pZ, flX, flY, pZ)
                Line(nlX, nlY, pZ, nrX, nrY, pZ)

            elseif objectID == 165532 then --plaguefall 40y range 25 deg cone tentacles on last boss

            	if WAe.waUnitTimers[thisUnit] == nil then
            		WAe.waUnitTimers[thisUnit] = GetTime()
                end
                local x,y,z = ObjectPosition(thisUnit)
                local facing = ObjectFacing(thisUnit)
                -- if GetTime() - WAe.waUnitTimers[thisUnit] > 4 then
                	LibDraw.Arc(x, y, z, 40, 25, facing)
                -- end

            end

        end
    end
    for k, v in pairs(om) do
        if v.pulseTime == nil or GetTime() >= v.pulseTime then
            local pointerDistance = distance("player", k)
            if pointerDistance > 50 then
                v.pulseTime = GetTime() + 0.25
            else
                v.pulseTime = GetTime() + 0.1
            end
            local thisType = v.objectType
            if thisType == "AreaTrigger" then
            	-- local objectID = ObjectID(k)
                local insertObject = {}
                insertObject.objectID = v.objectID
                insertObject.objectPointer = k
                insertObject.distance = pointerDistance
                insertObject.objectType = thisType
                if areaTrigger[v.objectID] then
                    insertObject.size = areaTrigger[v.objectID].size
                    insertObject.good = areaTrigger[v.objectID].good
                    insertObject.parent = areaTrigger[v.objectID].parent
                else
                    insertObject.size = 2
                    insertObject.good = false
                end
                areaTriggers[k] = insertObject
            elseif thisType == "Unit" or not inInstance and thisType == "Player" then
                wa_CheckUnit(k, pointerDistance)
            elseif not inInstance and thisType == "GameObject" and isQuestObject(k) then
                local insertObject = {}
                insertObject.objectPointer = k
                insertObject.distance = pointerDistance
                insertObject.objectType = thisType
                insertObject.size = 1.5
                areaTriggers[k] = insertObject
            end
        end
    end
    if dumpstuff and not IsMouselooking() then
        local cx,cy,cz = WorldPositionFromCursor()
        for k, v in pairs(om) do
            local thisUnit = k
            local objectID = v.objectID
            if not areaTrigger[objectID] then --and ( v.objectType == "GameObject" or v.objectType == "Unit" or )
                local x,y,z = ObjectPosition(thisUnit)
                if cx and cy and cz and x and y and z and ( GetDistanceBetweenPositions(cx,cy,cz,x,y,z) < 5 or unit_is_unit(thisUnit,"mouseover") ) then
                    LibDraw.SetWidth(4)
                    LibDraw.SetColor(0,255,100)
                    LibDraw.Text(objectID, "GameFontNormal", x, y, z+4)
                    LibDraw.SetColor(255,255,0)
                    if v.objectType == "GameObject" then
                        LibDraw.SetColor(255,0,255)
                    elseif v.objectType == "Unit" then
                        LibDraw.SetColor(100,255,0)
                    elseif v.objectType == "AreaTrigger" then
                        LibDraw.SetColor(255,255,255)
                    end
                    Line(x, y, z+2, x, y, z)
                    Line(x-3, y, z, x+3, y, z)
                    Line(x, y-3, z, x, y+3, z)
                    if unit_can_attack("player",thisUnit) then
	                    local cast,_,_,_,_,_,_,_,castid = unit_casting_info(thisUnit)
	                    local channel,_,_,_,_,_,_,channelid = UnitChannelInfo(thisUnit)
	                    if cast or channel then
		                    if not cast_id_printed or GetTime() - cast_id_printed > .5 then
			                    if cast then print("Cast: " .. cast .. " ID: " .. castid) cast_id_printed = GetTime() end
			                    if channel then print("Channel: " .. channel .. " ID: " .. channelid) cast_id_printed = GetTime() end
			                end
			            end
			        end
			        --facing arrow
	                local angle = ObjectFacing(v.objectPointer)
	                if angle then
	                	LibDraw.SetColor(200,255,100)
						local arrow_size = 0.3
						local arrow_shape = {
						  {-arrow_size, -arrow_size, 0, 0, 0, 0},
						  {arrow_size, -arrow_size, 0, 0, 0, 0},
						}
					    LibDraw.SetWidth(2)
					    LibDraw.Array(arrow_shape, x + 3.5 * math.cos(angle), y + 3.5 * math.sin(angle), z, math.rad(180), math.rad(180), math.rad(90) + angle)
		                angle = nil
		            end
		            --moving direction arrow
	                local angle = _getMovingDirection(v.objectPointer)
	                if angle then
	                	LibDraw.SetColor(80,255,100)
						local arrow_size = 0.5
						local arrow_shape = {
						  {-arrow_size, -arrow_size, 0, 0, 0, 0},
						  {arrow_size, -arrow_size, 0, 0, 0, 0},
						}
					    LibDraw.SetWidth(2)
					    LibDraw.Array(arrow_shape, x + 4.5 * math.cos(angle), y + 4.5 * math.sin(angle), z, math.rad(180), math.rad(180), math.rad(90) + angle)
					end
                end
            end
        end
    end
end

local defensives = {
	
	-- Flat Walls
	{id = 212800, dr = 35}, -- Blur (35% DMG REDUC)
	{id = 209426, dr = 100}, -- Darkness (Just calling it 100%)
	{id = 498, dr = 20}, -- Divine Protection (20% wall)
	{id = 31821, dr = 20}, -- Aura Mastery (20% wall)
	{id = 243435, dr = 20}, -- Fort Brew (20% wall)
	{id = 125174, dr = 100}, -- Karma (100% absorb that doesn't show up in absorbs)
	{id = 122278, dr = 50}, -- Diffuse Magic (20-50% wall based on damage of incoming attack, calling it 50 for the sake of botd)
	{id = 61336, dr = 50}, -- Survival Instincts (50% wall)
	{id = 22812, dr = 20}, -- Barkskin (20% wall)
	{id = 102342, dr = 20}, -- Ironbark (20% wall)
	{id = 201633, dr = 7}, -- Earthen Wall (~7% of botd dmg absorbed)
	{id = 108271, dr = 40}, -- Astral Shift (40% wall)
	{id = 104773, dr = 40}, -- Unending Resolve (40% wall)
	{id = 1966, dr = 30}, -- Feint (30% wall)
	{id = 33206, dr = 40}, -- Pain Supp (40% wall)
	{id = 81782, dr = 40}, -- Barrier (25-50% wall depending on talent)
	{id = 47585, dr = 75}, -- Dispersion (75% wall)
	{id = 213602, dr = 100}, -- Greater Fade (100% wall)
	{id = 197690, dr = 20}, -- Defensive Stance (20% wall)
	{id = 118038, dr = 30}, -- Parry (30% wall)
	{id = 48792, dr = 30}, -- IBF (30% wall)
	{id = 287081, dr = 30}, -- Lichborne (30% wall)
	{id = 186265, dr = 100}, -- Turtle (hunter det)
	{id = 45438, dr = 100}, -- Ice Block

	-- Magic Walls (AMS shows up in UnitGetTotalAbsorbs so not putting here)
	{id = 122783, dr = 60}, -- Diffuse Magic (60% mwall)
	{id = 31224, dr = 100}, -- Cloak of Shadows (100% magic immune)
	{id = 198065, dr = 50}, -- Prismatic Cloak Mage Blink Shit
	
}

local function isJainaSnow(unit)
    if ObjectID(unit) ~= 146409 then return false end
    local unitHP = 100*UnitHealth(unit)/UnitHealthMax(unit)
    if unitHP > 58 and unitHP < 61 then return true end
    return false
end

local function isJainaClone(unit)
    if ObjectID(unit) == 149535 then return true end
    return false
end

local function wa_CheckUnit(unit, unitDistance)

	if not dumpstuff and unit_is_player(unit) and not unit_can_attack("player", unit) then
		if waUnits[unit] ~= nil then
			waUnits[unit] = nil
			return false
		end
	end

    local function isCritter(Unit)
        local unitType = UnitCreatureType(Unit)
        local types = {
            ["Critter"] = true,
            ["Kleintier"] = true,
            ["Bestiole"] = true,
            [""] = true,
            ["Alma"] = true,
            ["Bicho"] = true,
            ["Animale"] = true,
            [""] = true,
            [""] = true,
            [""] = true,
            ["Wild Pet"] = true,
            ["Ungezhmtes Tier"] = true,
            ["Mascotte sauvage"] = true,
            [" "] = true,
            ["Mascota salvaje"] = true,
            ["Mascta Salvaje"] = true,
            ["Mascote Selvagem"] = true,
            ["Creatura Selvaggia"] = true,
            [""] = true,
            [""] = true
        }
        if types[unitType] ~= nil then
            return true
        end
        return false
    end
    if unitDistance == nil then
        unitDistance = distance("player", unit)
    end
    if unitDistance > 50 and not isJainaSnow(unit) and not isJainaClone(unit) and not isQuestUnit(unit) then
        if waUnits[unit] ~= nil then
            waUnits[unit] = nil
        end
        if WAe.waUnitTimers[unit] ~= nil then
            WAe.waUnitTimers[unit] = nil
        end
        return false
    end
    if not isCritter(unit) then
        if waUnits[unit] == nil then
            waUnits[unit] = true
        end
        return true
    end
    return false
end

function UnitIsFacingExtra(unit,otherunit,angle,extra)
	if not extra or extra == 0 then return UnitIsFacing(unit,otherunit,angle) end
	local x,y = ObjectPosition(unit)
	local tX,tY = ObjectPosition(otherunit)
	local rotation = ObjectFacing(unit) + extra
	return ((x-tX)*math.cos(-rotation))-((y-tY)*math.sin(-rotation)) < ( angle * math.pi/180 )
end

local function checkCleave(unit, spellID)
    local function isInside(x,y,ax,ay,bx,by,dx,dy)
        local bax = bx - ax
        local bay = by - ay
        local dax = dx - ax
        local day = dy - ay
        if ((x - ax) * bax + (y - ay) * bay <= 0.0) then return false end
        if ((x - bx) * bax + (y - by) * bay >= 0.0) then return false end
        if ((x - ax) * dax + (y - ay) * day <= 0.0) then return false end
        if ((x - dx) * dax + (y - dy) * day >= 0.0) then return false end
        return true
    end
    --Cleave casts
    if spellID == nil then
        spellID = select(9,unit_casting_info(unit))
    end
    if spellID == nil then
        spellID = select(8,UnitChannelInfo(unit))
    end
    if spellID ~= nil and cleaveCasts[spellID] ~= nil then
        if cleaveCasts[spellID].type == "cone" then
            if UnitIsFacingExtra(unit, "player", (cleaveCasts[spellID].angle/2), cleaveCasts[spellID].direction) and distance("player", unit) <= cleaveCasts[spellID].range then
                return true
            end
        elseif cleaveCasts[spellID].type == "rect" then
        	if cleaveCasts[spellID].targeted == true then
            	return true
            end
            local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(cleaveCasts[spellID].width,cleaveCasts[spellID].range,unit,cleaveCasts[spellID].startingpoint)
            --local pX, pY, zY = ObjectPosition("player")
            if isInside(pX,pY,nlX,nlY,nrX,nrY,frX,frY) then
                return true
            end
        end
    end
    --Units/Objects
    local objectID = ObjectID(unit)
    --Volcanic
    if objectID == 105877 then
        if WAe.waUnitTimers[unit] == nil then
            WAe.waUnitTimers[unit] = GetTime()
        end
        if (GetTime() - WAe.waUnitTimers[unit]) <= 2 then
            if distance("player", unit) <= 2.5 then
                return true
            end
        end

    elseif objectID == 148881 then --Jaina ice spear thing
        if WAe.waUnitTimers[unit] == nil then
            WAe.waUnitTimers[unit] = GetTime()
        end
        if (GetTime() - WAe.waUnitTimers[unit]) <= 10 then
            local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(1.5,40,unit)
            if isInside(pX,pY,nlX,nlY,nrX,nrY,frX,frY) then
                return true
            end
        end
    end
    return false
end

-- test fix
local squid_evade = true

local function CleaveDraw()
    --local pX, pY, zY = ObjectPosition("player")
    local tX, tY, tZ, s
    for thisUnit in pairs(waUnits) do
        if wa_CheckUnit(thisUnit) then

        	local channel
            local endtime, _, _, _, spellID = select(5,unit_casting_info(thisUnit))
            if spellID == nil then
                endtime, _, _,spellID = select(5,UnitChannelInfo(thisUnit))
                channel = spellID
            end

            if dumpstuff then
                local spell, channel, castobj, channobj = UnitCastID(thisUnit)
                castobj = castobj and ObjectName(castobj) or ""
                channobj = channobj and ObjectName(channobj) or ""
                -- local channelLogged
                if channel ~= 0 and (channelLogged ~= channel) and channel ~= nil then
                    channelLogged = channel
                    WriteFile("WAEliteDump.txt", "Name = "..ObjectName(thisUnit)..", CastID = ".. channel .. ", CastName = "..GetSpellInfo(channel)..", Target = "..channobj .. "\n", true)
                elseif spell ~= 0 and (spellloged ~= spell) and spell ~= nil then
                    spellloged = spell
                    WriteFile("WAEliteDump.txt", "Name = "..ObjectName(thisUnit)..", CastID = ".. spell .. ", CastName = "..GetSpellInfo(spell)..", Target = "..castobj .. "\n", true)
                end
            end

            if spellID ~= nil and cleaveCasts[spellID] ~= nil then
            	--only draw player spells if you can attack the unit
            	if not cleaveCasts[spellID].player or dumpstuff or unit_can_attack("player",thisUnit) then
            		local check = checkCleave(thisUnit, spellID)
	                if check then

	                	if channel then
	                		LibDraw.SetColorRaw(1, 0, 0, 1)
	                	else
		                    local r = 1 + ( 1.75 - _castTimeLeft(thisUnit) ) / 2.75
		                    local g = 1 - r
		                    local b = 0
		                    local a = .55 + ( min(.45,r / 2.2222222) )
		                    LibDraw.SetColorRaw(r, g, b, a)
		                    --squid evade
		               	end
	                    
	                elseif not channel and _castTimeLeft(thisUnit) <= 2.75 then
	                    local r = ( 2.75 - _castTimeLeft(thisUnit) ) / 2.75
	                    local g = 1 - r
	                    local b = 0
	                    local a = .55 + ( min(.45,r / 2.2222222) )
	                    LibDraw.SetColorRaw(r, g, b, a)
	                elseif channel then
	                	LibDraw.SetColorRaw(1, .25, 0, .8)
	                else
	                    LibDraw.SetColorRaw(0, 1, 0, .55)
	                end
	                if cleaveCasts[spellID].type == "rect" then
	                	local rotation
	                	if cleaveCasts[spellID].targeted == true then
            				local unit_target = UnitSpellTarget(thisUnit)
			            	if not unit_target then unit_target = UnitTarget(thisUnit) end
			            	if unit_target and UnitIsVisible(unit_target) then
			            		local pX, pY, pZ = ObjectPosition(unit_target)
			            		local tX,tY,tZ = ObjectPosition(thisUnit)
			            		rotation = GetAnglesBetweenPositions(tX,tY,tZ,pX,pY,pZ) + cleaveCasts[spellID].direction
			            	else
			            		rotation = ObjectFacing(thisUnit) + cleaveCasts[spellID].direction
			            	end
			            end
	                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(cleaveCasts[spellID].width,cleaveCasts[spellID].range,thisUnit,cleaveCasts[spellID].startingpoint,nil,nil,rotation)
	                    Line(flX, flY, pZ, nlX, nlY, pZ)
	                    Line(frX, frY, pZ, nrX, nrY, pZ)
	                    Line(frX, frY, pZ, flX, flY, pZ)
	                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
	                elseif cleaveCasts[spellID].type == "cone" then
	                    tX, tY, tZ = ObjectPosition(thisUnit)

	                    local rotation
	                    if cleaveCasts[spellID].targeted == true then
	                    	local unit_target = UnitSpellTarget(thisUnit)
	                    	if not unit_target then unit_target = UnitTarget(thisUnit) end
	                    	if unit_target and UnitIsVisible(unit_target) then
	                    		local pX, pY, pZ = ObjectPosition(unit_target)
	                    		rotation = GetAnglesBetweenPositions(tX,tY,tZ,pX,pY,pZ) + cleaveCasts[spellID].direction
	                    	else
	                    		rotation = ObjectFacing(thisUnit) + cleaveCasts[spellID].direction
	                    	end
	                    else
	                    	rotation = ObjectFacing(thisUnit) + cleaveCasts[spellID].direction
	                    end

	                    LibDraw.Arc(tX, tY, tZ, cleaveCasts[spellID].range, cleaveCasts[spellID].angle, rotation)
	                end
	            end
            end

            local objectID = ObjectID(thisUnit)
            if objectID == 105877 then -- Volcanic
                if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                if (GetTime() - WAe.waUnitTimers[thisUnit]) <= 2 then
                    tX, tY, tZ = ObjectPosition(thisUnit)
                    s = 1.5

                    LibDraw.SetWidth(5)

                    LibDraw.SetColorRaw(1, 0, 0, 1)

                    Line(tX, tY, tZ+s*2, tX, tY, tZ)
                    Line(tX-s, tY, tZ, tX+s, tY, tZ)
                    Line(tX, tY-s, tZ, tX, tY+s, tZ)
                end
            elseif objectID == 129747 then -- FH Harlan's shits

                local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(2.5,20,thisUnit)
                Line(flX, flY, pZ, nlX, nlY, pZ)
                Line(frX, frY, pZ, nrX, nrY, pZ)
                Line(frX, frY, pZ, flX, flY, pZ)
                Line(nlX, nlY, pZ, nrX, nrY, pZ)

            elseif objectID == 165532 then --plaguefall 40y range 25 deg cone tentacles on last boss

            	if WAe.waUnitTimers[thisUnit] == nil then
            		WAe.waUnitTimers[thisUnit] = GetTime()
                end
                local x,y,z = ObjectPosition(thisUnit)
                local facing = ObjectFacing(thisUnit)
                -- if GetTime() - WAe.waUnitTimers[thisUnit] > 4 then
                	LibDraw.Arc(x, y, z, 40, 25, facing)
                -- end

            elseif objectID == 157314 or objectID == 168539 or objectID == 174803 then

            	local x,y,z=ObjectPosition(thisUnit)
            	local px,py,pz=GetPlayerPosition()
            	if GetDistanceBetweenPositions(x,y,z,px,py,pz) < 30 then
            		if GetDistanceBetweenPositions(x,y,z,px,py,pz) < 20 then
            			LibDraw.Text("Axe Swing", "GameFontNormalSmall", x, y, z+4)
            		end
	            	local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(2,20,thisUnit,-10)
	                Line(flX, flY, pZ, nlX, nlY, pZ)
	                Line(frX, frY, pZ, nrX, nrY, pZ)
	                Line(frX, frY, pZ, flX, flY, pZ)
	                Line(nlX, nlY, pZ, nrX, nrY, pZ)
	            end

            elseif objectID == 126841 then -- FH Bird Charge
                if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                if GetUnitSpeed(thisUnit) < 3 or GetUnitSpeed(thisUnit) > 24 then
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(6,60,thisUnit)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
                end
            elseif objectID == 129448 then -- FH Shark1
                if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3,5,thisUnit)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
            elseif objectID == 129359 then -- FH Shark2
                if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3,5,thisUnit)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
            elseif objectID == 161019 then -- n'yalotha hivemind rollies
            	if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3.5,20,thisUnit)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
            elseif objectID == 159173 then -- n'yalotha hivemind rollies alt id
            	if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3.5,20,thisUnit)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
            elseif isJainaSnow(thisUnit) then -- Find jaina
                tX, tY, tZ = ObjectPosition(thisUnit)
                s = 3
                LibDraw.SetColor(255,0,0)
                LibDraw.SetWidth(4)
                Line(tX, tY, tZ+s*1.75, tX, tY, tZ)
                Line(tX-s, tY, tZ, tX+s, tY, tZ)
                Line(tX, tY-s, tZ, tX, tY+s, tZ)
            elseif objectID == 149535 then -- Find jaina clone
                tX, tY, tZ = ObjectPosition(thisUnit)
                s = 2
                LibDraw.SetColor(0,128,0)
                LibDraw.SetWidth(4)
                Line(tX, tY, tZ+s*1.75, tX, tY, tZ)
                Line(tX-s, tY, tZ, tX+s, tY, tZ)
                Line(tX, tY-s, tZ, tX, tY+s, tZ)
            elseif objectID == 148881 then --Jaina ice spear thing
                if WAe.waUnitTimers[thisUnit] == nil then
                    WAe.waUnitTimers[thisUnit] = GetTime()
                end
                if (GetTime() - WAe.waUnitTimers[thisUnit]) <= 10 then
                    local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(1.5,40,thisUnit)
                    Line(flX, flY, pZ, nlX, nlY, pZ)
                    Line(frX, frY, pZ, nrX, nrY, pZ)
                    Line(frX, frY, pZ, flX, flY, pZ)
                    Line(nlX, nlY, pZ, nrX, nrY, pZ)
                end
            elseif ( trackQuests or SQUID.track_quests ) and isQuestUnit(thisUnit) then
                tX, tY, tZ = ObjectPosition(thisUnit)
                local px,py,pz = GetPlayerPosition()
                local dist = GetDistanceBetweenPositions(px,py,pz,tX,tY,tZ)
                local dist_def = dist/10
                if UnitCanAttack("player",thisUnit) then
                	if not UnitIsDeadOrGhost(thisUnit) then
                		if dist > 5 then
		                	local texture = {
								texture = 236188,
								width = 22+dist_def, height = 22+dist_def,
								alpha = 1,
							}
							LibDraw.Texture(texture,tX,tY,tZ,nil,texts);
						end
		            elseif UnitCanBeLooted(thisUnit) then
		            	local texture = {
							texture = 133784,
							width = 18+dist_def, height = 18+dist_def,
							alpha = 1,
						}
						LibDraw.Texture(texture,tX,tY,tZ,nil,texts);
		            else
		            	local texture = {

							texture = 3308452,
							width = 22 + (dist_def*.65), height = 41 + dist_def,
							alpha = a,

							left = 0,
							right = 0.5,
							top = 0,
							bottom = 1,

						}
						LibDraw.Texture(texture,tX,tY,tZ,nil,texts);
		            end
                else
                	dist_def=dist_def*2
                	texture = {

						texture = 3308452,
						width = 29 + (dist_def*.65), height = 53 + dist_def,
						alpha = a,

						left = 0.5,
						right = 1,
						top = 0,
						bottom = 1,

					}
	               
	                LibDraw.Texture(texture,tX,tY,tZ,nil,texts);
	                -- s = 1.5
	                -- LibDraw.SetColor(255,0,0)
	                -- LibDraw.SetWidth(4)
	                -- Line(tX, tY, tZ+s*1.5, tX, tY, tZ)
	                -- Line(tX-s, tY, tZ, tX+s, tY, tZ)
	                -- Line(tX, tY-s, tZ, tX, tY+s, tZ)
	            end

				LibDraw.SetColor(0,255,0)
				local name = ObjectName(thisUnit)
                if SQUID.mouseover_names then
                	local wf_top = WorldFrame:GetTop()
                	local scx,scy = GetCursorPosition()
					local sx,sy = WorldToScreen(tX,tY,tZ)
					local dist = math.floor(_distance(thisUnit))
					if sx and sy then
						if scx and scy then
							sy = sy + wf_top
							local d = sqrt( math.pow(scx - sx, 2) + math.pow(scy - sy, 2) )
							if d < max(80 - dist, 25) then
								LibDraw.Text(name, "GameFontNormalSmall", tX, tY, tZ+2)
							end
						end
					end
				else
					local dist = math.floor(_distance(thisUnit))
					LibDraw.Text(name .. " - " .. dist, "GameFontNormalSmall", tX, tY, tZ+4)
				end

            elseif objectID == 135636 and not UnitIsDeadOrGhost(thisUnit) then --TD Intellect
                tX, tY, tZ = ObjectPosition(thisUnit)
                LibDraw.Text("Intellect", "GameFontNormal", tX, tY, tZ+2)
            elseif objectID == 135634 and not UnitIsDeadOrGhost(thisUnit) then --TD Wisdom
                tX, tY, tZ = ObjectPosition(thisUnit)
                LibDraw.Text("Wisdom", "GameFontNormal", tX, tY, tZ+2)
            elseif objectID == 135630 and not UnitIsDeadOrGhost(thisUnit) then --TD Stamina
                tX, tY, tZ = ObjectPosition(thisUnit)
                LibDraw.Text("Stamina", "GameFontNormal", tX, tY, tZ+2)
            elseif objectID == 135628 and not UnitIsDeadOrGhost(thisUnit) then --TD Attack
                tX, tY, tZ = ObjectPosition(thisUnit)
                LibDraw.Text("Attack", "GameFontNormal", tX, tY, tZ+2)
            end
        end
    end
end

function WAe:CheckCleave()
    for thisUnit in pairs(waUnits) do
        if wa_CheckUnit(thisUnit) then
            if checkCleave(thisUnit) then
                return true
            end
        end
    end
    return false
end

local function checkOM()
    for k, v in pairs(om) do
        if v.pulseTime == nil or GetTime() >= v.pulseTime then
            local pointerDistance = distance("player", k)
            if pointerDistance > 50 then
                v.pulseTime = GetTime() + 0.25
            else
                v.pulseTime = GetTime() + 0.1
            end
            local thisType = v.objectType
            if thisType == "AreaTrigger" then
            	-- local objectID = ObjectID(k)
                local insertObject = {}
                insertObject.objectPointer = k
                insertObject.objectID = v.objectID
                insertObject.distance = pointerDistance
                insertObject.objectType = thisType
                if areaTrigger[v.objectID] then
                    insertObject.size = areaTrigger[v.objectID].size
                    insertObject.good = areaTrigger[v.objectID].good
                    insertObject.parent = areaTrigger[v.objectID].parent
                else
                    insertObject.size = 2
                    insertObject.good = false
                end
                areaTriggers[k] = insertObject
            elseif thisType == "Unit" or not inInstance and thisType == "Player" then
                wa_CheckUnit(k, pointerDistance)
            elseif not inInstance and thisType == "GameObject" and isQuestObject(k) then
                local insertObject = {}
                insertObject.objectPointer = k
                insertObject.distance = pointerDistance
                insertObject.objectType = thisType
                insertObject.size = 1.5
                areaTriggers[k] = insertObject
            end
        end
    end
end


--OM
local function wa_OM(updated,added,removed)
    pX, pY, pZ = GetPlayerPosition("player")
    playerCR = UnitCombatReach("player")
    local instance_type = select(2,IsInInstance())
    inInstance = instance_type ~= "none" and instance_type ~= "scenario"
    --Objects function
    local function objectCheck(thisObject)
        if om[thisObject] == nil then
            local internalObjectType = ObjectRawType(thisObject)
            if internalObjectType ~= 1 and internalObjectType ~= 9 and internalObjectType ~= 12 or dumpstuff then
                local guid = UnitGUID(thisObject)
                local objectType, _, _, _, _, objectID, _ = strsplit("-", guid)
                objectID = tonumber(objectID)
                -- if distance("player", thisObject) < 1 then print(objectType) end
                --Area triggers
                if objectType == "AreaTrigger" and (areaTrigger[objectID] ~= nil or dumpstuff or special_areatriggers[objectID]) or dumpstuff then
                    local insertObject = {}
                    insertObject.objectPointer = thisObject
                    insertObject.objectID = objectID
                    insertObject.objectType = objectType
                    om[thisObject] = insertObject
                    --print(insertObject.objectPointer)
                elseif (objectType == "Creature" or objectType == "Vehicle") then
                    local insertObject = {}
                    insertObject.objectPointer = thisObject
                    insertObject.objectID = objectID
                    insertObject.objectType = "Unit"
                    om[thisObject] = insertObject
                elseif not inInstance and ( objectType == "GameObject" or objectType == "Unit" ) then
                    local insertObject = {}
                    insertObject.objectPointer = thisObject
                    insertObject.objectID = objectID
                    insertObject.objectType = objectType  	
                    om[thisObject] = insertObject
                elseif objectType == "Player" then
                    local insertObject = {}
                    insertObject.objectPointer = thisObject
                    insertObject.objectID = objectID
                    insertObject.objectType = objectType
                    om[thisObject] = insertObject
                end
            end
        end
    end
    -- local _, updated, added, removed = GetObjectCount(true)
    if #removed > 0 then
        for _, v in pairs(removed) do
            if om[v] ~= nil then
                om[v] = nil
            end
            if areaTriggers[v] ~= nil then
                areaTriggers[v] = nil
            end
            if waUnits[v] ~= nil then
                waUnits[v] = nil
            end
        end
    end
    if #added > 0 then
        for _, v in pairs(added) do
            objectCheck(v)
        end
    end
end

-- END WAELITE

function SQ_CastSpellByName(spell, target)
	if IsHackEnabled then
		CastSpellByName(spell, target)
	elseif __LB__ then
		lb.UnitTagHandler(CastSpellByName, spell, target)
	end
end

function SQ_CastSpellByID(spell, target)
	if IsHackEnabled then
		CastSpellByID(spell, target)
	elseif __LB__ then
		lb.UnitTagHandler(CastSpellByID, spell, target)
	end
end

function GetActiveMover()
	return "player"
end

--OnUpdate Frame
CreateFrame("Frame"):SetScript("OnUpdate",function()

	if not (wmbapi or __LB__) or stop_doing_shit then return end

	-- if UnitExists("target") then
	-- 	local x,y,z = ObjectPosition("player")
	-- 	local tx,ty,tz = ObjectPosition("target")
	-- 	Draw2DLine("player","target",15)
	-- 	Draw3DText(tx,ty,tz+2,"hello",25)
	-- end

	-- if nil==nil then return;end
 	
 	-- convert minibot api
 	if not __LB__ and not minibot_api_converted then
 		convert_mb_api()
 		minibot_api_converted = true
 	end

	--luabox api ( lb funcs lb api )
	if __LB__ and not lb_funcs_init then

		function GetMapId()
			return lb.GetMapId()
		end

		function IsMeshLoaded()
			return true
		end

		function GetWoWDirectory()
			return lb.GetGameDirectory()
		end

		function GetSubdirectories(path)
			return lb.GetDirectories(path)
		end

		function ObjectPosition(unit)
			return lb.ObjectPosition(unit)
		end

		function ObjectPointer(unit)
			-- return lb.ObjectPointer(unit) -- can't pass this to any api ???
			if not unit then return end
			return UnitGUID(unit)
		end

		function UnitCastID(unit)
			local castID,castTarget = lb.unit_casting_info(unit)
			local channelID,channelTarget = lb.UnitChannelInfo(unit)
			if castID ~= 0 then
				return castID, 0, castTarget, nil
			end
			if channelID ~= 0 then
				return 0, channelID, nil, channelTarget
			end
			return 0, 0, nil, nil
		end

		function IsForeground()
			return true
		end

		function GetDistanceBetweenPositions(sx, sy, sz, ex, ey, ez)
			return lb.GetDistance3D(sx, sy, sz, ex, ey, ez)
		end

		function GetDistanceBetweenObjects(object1, object2)
			return lb.GetDistance3D(object1, object2)
		end

		function UnitCombatReach(unit)
			return lb.UnitCombatReach(unit)
		end

		function ObjectID(unit)
			return lb.ObjectId(unit)
		end

		lb_funcs_init = true

	end

	is_in_instance,instance_type = IsInInstance()

	arena = instance_type == "arena"
	--testing
	-- arena = true
	-- Mage_Rotation_Override="PvP"
	dungeon = instance_type == "party"

	--wipe path out of instance
	if UnitIsDeadOrGhost("player") or instance_type == "none" then
		if _isMoving("player") and squid_path then Squid_StopNav() end
	end

	Squid_UpdateNav()

	local InteractUnit = InteractUnit
	local _LoS = _LoS
	local _isHealer = _isHealer
	-- local GetItemInfo = GetItemInfo
	-- local GetItemCount = GetItemCount
	-- local UnitIsFriend = UnitIsFriend
	-- local UnitInParty = UnitInParty
	local unit_is_unit = unit_is_unit
	local _HP = _HP
	local _CCremains = _CCremains
	local _breakableCC = _breakableCC
	local unit_is_unit = unit_is_unit
	local IsSpellOnGCD = IsSpellOnGCD
	local UnitEnemiesAttacking = UnitEnemiesAttacking
	local Interrupt = Interrupt
	local PhysicalInterrupt = PhysicalInterrupt
	local _Cast = _Cast
	local _distance = _distance
	local GetGCD = GetGCD
	local _castTimeLeft = _castTimeLeft
	local _isHealer = _isHealer
	local PVE_Interrupt = PVE_Interrupt
	local _immuneMagic = _immuneMagic
	local UnitBuffID = UnitBuffID
	local UnitDebuffID = UnitDebuffID
	local _meleeRange = _meleeRange

	unit_buff_cache = {}
	unit_debuff_cache = {}

	local time = GetTime()
	local latency = select(4,GetNetStats())/1000
	local home_latency = select(3,GetNetStats())/1000

	squid_player_class = select(2,UnitClass("player"))

	-- if gpy_est_hit_time then print( gpy_est_hit_time - time ) end

	local frame_buffer = 1/GetFramerate()

	-- Example using InitializeNavigation and CalculatePath:
	-- local initNavigation = false
	-- local ewtPath = nil
	-- local pathIndex = 1
	-- local stuckCount = 0
	-- local lastX, lastY, lastZ = 0, 0, 0
	-- local f = CreateFrame('frame')
	-- f:SetScript("OnUpdate", function (self, event, addon)
	--     if ewtPath ~= nil then
	--         local PlayerX, PlayerY, PlayerZ = ObjectPosition("Player");
	--         local destX = ewtPath[pathIndex][1]
	--         local destY = ewtPath[pathIndex][2]
	--         local destZ = ewtPath[pathIndex][3]
	--         if GetDistanceBetweenPositions(PlayerX, PlayerY, PlayerZ, destX, destY, destZ) < 1 then
	--             pathIndex = pathIndex + 1
	--             -- print('Moving to next coordinates')
	--             if pathIndex > #ewtPath then
	--                 pathIndex = 1
	--                 ewtPath = nil
	--             end
	--         else
	--             if lastX == PlayerX and lastY == PlayerY and lastZ == PlayerZ then
	--                 stuckCount = stuckCount + 1
	--                 if stuckCount > 100 then
	--                     -- print('Stuck jumping...')
	--                     JumpOrAscendStart()
	--                     stuckCount = 0
	--                 end
	--             end
	--             MoveTo(destX, destY, destZ)
	--             lastX = PlayerX
	--             lastY = PlayerY
	--             lastZ = PlayerZ
	--         end
	--     end
	-- end)

	-- run ewt callbacks
	if IsHackEnabled and ewt_callbacks then
		for i=1,#ewt_callbacks do
			ewt_callbacks[i]()
		end
		ewt_callbacks = nil
	end

	-- function GoTo(toX, toY, toZ)
	--     if initNavigation == false then
	--         print('Loading meshes... please wait.')
	--         InitializeNavigation(function(result, extra) 
	--             if result == true then
	--                 print('Initialized meshes') 
	--                 initNavigation = true 
	--                 GoTo(toX, toY, toZ) 
	--             else
	--                 print('Failed to initialize meshes.')
	--                 print(extra)
	--             end
	--         end)
	--     else
	--         pathIndex = 1
	--         ewtPath = nil
	--         local PlayerX, PlayerY, PlayerZ = ObjectPosition("Player");
	--         ewtPath, totalDist = CalculatePath(GetMapId(), PlayerX, PlayerY, PlayerZ, toX, toY, toZ, true, false, 1.5)
	--         print('Created path ' .. #ewtPath)
	--     end
	-- end

	-- load mesh for current map
	squid_nav_init = squid_nav_init or {}
	local map_id = GetMapId()
	local bla = IsMeshLoaded(map_id) -- does this need to be a string no
	-- print(bla)
	-- if squid_nav_init[map_id] == nil and not bla then
	-- 	if not mesh_load_attempt or time - mesh_load_attempt > 30 then
	-- 		squid_print("Loading Navigation Mesh For Map " .. map_id)-- .. " (" .. GetZoneText() .. ")")
	-- 		local maps = tostring(map_id)
	-- 		InitializeNavigation( 
	-- 			function(x)
	-- 				if x == true then
	-- 					squid_print("Navigation Mesh Loaded For Map " .. map_id)-- .. " (" .. GetZoneText() .. ")" )
	-- 					squid_nav_init[map_id] = true
	-- 				else
	-- 					squid_print('Failed to load Navigation Meshes, please type "/squid mesh" for the link to download them.')
	-- 					squid_nav_init[map_id] = false
	-- 				end
	-- 			end,
	-- 			maps
	-- 		)
	-- 		mesh_load_attempt = time
	-- 	end
	-- end

	--track avg world latency
	squid_latency_tracker = squid_latency_tracker or {}

	if #squid_latency_tracker == 0 then
		if latency ~= 0 then
			table.insert(squid_latency_tracker,latency)
		end
	else
		local index = #squid_latency_tracker
		if latency ~= squid_latency_tracker[index] then
			table.insert(squid_latency_tracker,latency)
		end
	end

	local total_latency = 0
	for i=1,#squid_latency_tracker do
		total_latency = total_latency + squid_latency_tracker[i]
	end

	squid_avg_latency = total_latency / #squid_latency_tracker

	--use avg latency only if it is higher than current latency to account for fluctuation
	if not squid_avg_latency or squid_avg_latency == 0 or squid_avg_latency < latency then squid_avg_latency = latency end

	--track avg home latency
	squid_home_latency_tracker = squid_home_latency_tracker or {}

	if #squid_home_latency_tracker == 0 then
		if home_latency ~= 0 then
			table.insert(squid_home_latency_tracker,home_latency)
		end
	else
		local index = #squid_home_latency_tracker
		if home_latency ~= squid_home_latency_tracker[index] then
			table.insert(squid_home_latency_tracker,home_latency)
		end
	end

	local total_latency = 0
	for i=1,#squid_home_latency_tracker do
		total_latency = total_latency + squid_home_latency_tracker[i]
	end

	squid_avg_home_latency = total_latency / #squid_home_latency_tracker

	--use avg latency only if it is higher than current latency to account for fluctuation
	if not squid_avg_home_latency or squid_avg_home_latency == 0 or squid_avg_home_latency < home_latency then squid_avg_home_latency = home_latency end

	-- 10-20 ms per update for me
	-- squid_update_time = squid_update_time or time

	-- if time > squid_update_time then
	-- 	print(time - squid_update_time)
	-- 	squid_update_time = time
	-- end

	squid_conquest_earned = 0
	if ConquestFrame then
		local bar = ConquestFrame.ConquestBar
		if bar then
			local label = bar.Label
			if label then
				local txt = label:GetText()
				if txt then
					txt = string.gsub(txt,"Conquest","")
					txt = string.gsub(txt," / 500","")
					local amount = txt and tonumber(txt) or 0
					squid_conquest_earned = amount
				end
			end
		end
	end

	C_Timer.After(1.6,function()
		if not ChatFrame_Hooked and Hook_ChatFrame then
			Hook_ChatFrame()
		end
	end)

	if block_key then
		local spec = GetSpecialization()

		--snap
		-- if spec == 3 and _spellCooldown(45438) > GetGCD() + 2 then
		-- 	if _spellCooldown(235219) == 0 then
		-- 		SQ_CastSpellByID(235219)
		-- 		Squid_Alert("Cold Snap",nil,nil,nil,235219)
		-- 	end
		-- end

		--dont block in starting zone
		if UnitBuffID("player",32727) then Squid_Alert("Not Blocking","(Starting Room)",2,nil,45438) return end

		--block
		if _spellCooldown(45438) <= 2.15 then
			--hypo
			if UnitDebuffID("player",41425) and not UnitBuffID("player",45438) then
				Squid_Alert("Can't Block","(Hypothermia)",nil,nil,41425)
				return
			end
			SpellStopCasting()
			Squid_Alert_Big("Ice Block","(Manual)",nil,3,45438)
			SQ_CastSpellByID(45438)
			SQ_CastSpellByName("Ice Block")
			return

		--block not ready
		elseif not UnitBuffID("player",45438) then
			local str = "|cFFa665cdIce Block Not Ready Yet"
			Squid_Alert(str,nil,nil,nil,45438)
		end

	end

	--they have healer?
	theirHealer=nil
	for i=1,#Enemies do if _isHealer(Enemies[i]) then theirHealer=Enemies[i] end end

	for i=1,GetNumArenaOpponents() do
		local unit = "arena"..i
		if UnitIsVisible(unit) and _isHealer(unit) then
			theirHealer = ObjectPointer(unit)
		end
	end

	if not Squid_Dir then
		Squid_Dir = Squid_Directory()
	end

	--grab flags
	if SQUID.flag_pick and instance_type == "pvp" then
		if not flag_drop_time or time - flag_drop_time > 5 then
			if not flag_interact or time - flag_interact > .05 then
				local flags = {"Alliance Flag", "Horde Flag", "Alliance Mine cart", "Horde Mine Cart"}
				for i=1,#flags do InteractUnit(flags[i]) end
				flag_interact = time
			end
		end
	end

	--clear caches

	if not los_cache_cleared or time - los_cache_cleared > .1 then
		los_cache = {}
		los_cache_cleared = time
	end

	-- unit_is_unit_cache = {}

	if not object_id_cache_cleared or time - object_id_cache_cleared > .5 then
		object_id_cache = {}
		object_id_cache_cleared = time
	end

	cc_remains_cache = {}

	breakable_cc_cache = {}

	object_position_cache = {}

	if not unit_can_attack_cache_cleared or time - unit_can_attack_cache_cleared > .4 then
		unit_can_attack_cache = {}
		unit_can_attack_cache_cleared = time
	end

	-- if not unit_creature_type_cache_cleared or time - unit_creature_type_cache_cleared > 1.5 then
		unit_creature_type_cache = {}
	-- 	unit_creature_type_cache_cleared = time
	-- end

	unit_casting_info_cache = {}

	unit_channel_info_cache = {}

	if not unit_is_player_cache_cleared or time - unit_is_player_cache_cleared > .3 then
		unit_is_player_cache = {}
		unit_is_player_cache_cleared = time
	end

	unit_name_cache = {}

	unit_target_cache = {}

	if not spell_effect_cache or not spell_effect_cache_wiped or time - spell_effect_cache_wiped > .3 then
		spell_effect_cache = {}
		spell_effect_cache_wiped = time
	end

	-- if not unit_target_cache or not unit_target_cache_wiped or time - unit_target_cache_wiped > .3 then
		
	-- 	unit_target_cache_wiped = time
	-- end

	if not unit_combat_reach_cache or not unit_combat_reach_cache_wiped or time - unit_combat_reach_cache_wiped > 15 then
		unit_combat_reach_cache = {}
		unit_combat_reach_cache_wiped = time
	end

	if not unit_role_cache_cleared or time - unit_role_cache_cleared > .5 then
		unit_role_cache = {}
		unit_role_cache_cleared = time
	end

	if not unit_creature_id_cache_cleared or time - unit_creature_id_cache_cleared > 30 then
		unit_creature_id_cache = {}
		unit_creature_id_cache_cleared = time
	end

	if not is_dummy_cache_cleared or time - is_dummy_cache_cleared > 30 then
		is_dummy_cache = {}
		is_dummy_cache_cleared = time
	end

	if not azerite_power_rank_cache_cleared or time - azerite_power_rank_cache_cleared > 5 then
		azerite_power_rank_cache = {}
		azerite_power_rank_cache_cleared = time
	end

	if not azerite_power_cache_cleared or time - azerite_power_cache_cleared > 5 then
		azerite_power_cache = {}
		azerite_power_cache_cleared = time
	end

	if not player_can_see_cache_cleared or time - player_can_see_cache_cleared > .3 then
		player_can_see_cache = {}
		player_can_see_cache_cleared = time
	end

	hp_cache = {}

	if gpy_on_player and time - gpy_on_player > 3 or UnitBuffID("player",45438) then
		gpy_on_player = nil
	end

	if focus_trap_queued and time - focus_trap_queued > 6 then
		focus_trap_queued = nil
	end

	if healer_trap_queued and time - healer_trap_queued > 6 then
		healer_trap_queued = nil
	end

	local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")

	if player_cast then
		current_cast_delay = time
		current_cast_delay_cast = player_cast_id
	end

	if not movement_lock_commands then
		movement_lock_commands = {}
	end

	for i=1,#movement_lock_commands do
		if movement_lock_commands[i] and movement_lock_commands[i] - time <= 0 then
			table.remove(movement_lock_commands,i)
		end
	end

	squid_missiles = {}
	local count = GetMissileCount()
	for i=1,count do
		local spellid, visualid, x, y, z, caster, sx, sy, sz, target, tx, ty, tz = GetMissileWithIndex(i)
		table.insert(squid_missiles,{spellid=spellid,visualid=visualid,pos={x,y,z},caster=caster,source={sx,sy,sz},dest={tx,ty,tz}})
    end
    -- eat_trap_test=true

    -- eat trap if close
    for i=1,#squid_missiles do
    	local missile = squid_missiles[i]
    	if missile.spellid == 187650 and UnitCanAttack("player",missile.caster) then
    		local x,y,z = unpack(missile.dest)
    		local cx,cy,cz = unpack(missile.pos)
    		local px,py,pz = GetPlayerPosition()
    		local angle = GetAnglesBetweenPositions(px,py,pz,x,y,z)

    		-- local fx=x
    		-- local fy=y
    		local dist = GetDistanceBetweenPositions(fx,fy,z,px,py,pz)

    		local fx = (dist > .5 and x + .5 * math.cos(angle) or x)
    		local fy = (dist > .5 and y + .5 * math.sin(angle) or y)

    		dist = GetDistanceBetweenPositions(fx,fy,z,px,py,pz)

    		local ourHealer = ourHealer

    		if eat_trap_test then
				-- if dist <= 5.5 then
	   --  			if not eat_trap or time - eat_trap > 1 then
	   --  				SetMovementLocked(false)
		  --   			MoveTo(fx,fy,z)
		  --   			Squid_Alert_Big("Eating Trap",nil,2,4,187650)
		  --   			StopMovingAndLock()
		  --   			table.insert(movement_lock_commands,time+1)
		  --   			eat_trap = time
		  --   		end
		  --   	end
		  		ourHealer="focus"
		    end

			if UnitIsVisible(ourHealer) then
				local hx,hy,hz = ObjectPosition(ourHealer)
				local healer_dist = GetDistanceBetweenPositions(hx,hy,hz,fx,fy,z)
				local current_healer_dist = GetDistanceBetweenPositions(hx,hy,hz,cx,cy,cz)
				if healer_dist <= 4.25 then
					if dist <= 5.5 then
		    			if not eat_trap or time - eat_trap > 1 then
		    				SetMovementLocked(false)
			    			MoveTo(fx,fy,z)
			    			Squid_Alert_Big("Eating Trap",nil,2,4,187650)
			    			StopMovingAndLock()
			    			C_Timer.After(1,function() SetMovementLocked(false) end)
			    			eat_trap = time
			    		end
			    	end
		    		if select(2,UnitClass("player")) == "MAGE" then
						local bx,by,bz = position_after_blink(angle)
						local blink_trap_dist = GetDistanceBetweenPositions(bx,by,bz,fx,fy,z)
		    			if GetSpellCharges(212653) > 0 and blink_trap_dist <= 4 and current_healer_dist > 4 and (not player_blink or time - player_blink > 1) then
		    				if current_healer_dist > 8 or blink_trap_dist < 2 then
			    				FaceDirection(angle,true)
			    				if ObjectIsFacingPosition("player",x,y) then
			    					StopMovingAndLock()
			    					CastSpellByID(1953)
			    					player_blink = time
			    					Squid_Alert("Blink","(Eat Trap)",nil,nil,212653)
			    				end
			    			end
		    			end
		    		end
		    	elseif dist <= 5.5 and not eat_trap_test then
		    		local dx,dy,dz = GroundZ(fx - 5 * math.cos(angle), fy - 5 * math.sin(angle), z)
		    		if dx and dy and dz then
		    			MoveTo(dx,dy,dz)
		    			Squid_Alert_Big("Dodging Trap",nil,2,4,187650)
		    		end
		    	end
		    elseif dist <= 5.5 and not eat_trap_test then
		    	local dx,dy,dz = GroundZ(fx - 5 * math.cos(angle), fy - 5 * math.sin(angle), z)
	    		if dx and dy and dz then
	    			MoveTo(dx,dy,dz)
	    			Squid_Alert_Big("Dodging Trap",nil,2,4,187650)
	    		end
	    	end
    	end
    end

	if IsHackEnabled and not ewt_api_hooked then

		-- unit_name_cache = {}
		-- local og = UnitName
		-- function UnitName(unit)
		-- 	local cache = unit_name_cache[unit]
		-- 	if cache ~= nil then return cache end
		-- 	local name = og(unit)
		-- 	if unit then
		-- 		unit_name_cache[unit] = name
		-- 	end
		-- 	return name
		-- end

		-- unit_is_player_cache = {}
		-- local og = unit_is_player
		-- function unit_is_player(unit)
		-- 	local cache = unit_is_player_cache[unit]
		-- 	if cache ~= nil then return cache end
		-- 	local isplayer = og(unit)
		-- 	unit_is_player_cache[unit] = isplayer
		-- 	return isplayer 
		-- end

		local og = ObjectName
		ObjectName=function(unit)
			local cache = unit_name_cache[unit]
			if cache ~= nil then return cache end
			local name = og(unit)
			unit_name_cache[unit] = name
			return name
		end

		local og = UnitCreatureType
		UnitCreatureType=function(unit)
			local cache = unit_creature_type_cache[unit]
			if cache ~= nil then return cache end
			local t = og(unit)
			unit_creature_type_cache[unit] = t
			return t
		end

		local og = ObjectPosition
		ObjectPosition = function(unit)
			local cache = object_position_cache[unit]
			if cache ~= nil then return unpack( object_position_cache[unit] ) end
			local pos = { og(unit) }
			if #pos > 0 then 
				object_position_cache[unit] = pos
				return unpack( pos )
			else
				return nil
			end
		end

		local og = ObjectID
		ObjectID=function(unit)
			if not unit then return end
			local cache = object_id_cache[unit]
			if cache then
				return cache
			else
				local id = og(unit)
				object_id_cache[unit] = id
				return id
			end
		end

		local og = UnitTarget
		UnitTarget=function(unit)
			local cache = unit_target_cache[unit]
			if cache then 
				return cache 
			else
				local t = og(unit) 
				unit_target_cache[unit] = t
				return t
			end
		end

		local og = UnitCombatReach
		UnitCombatReach=function(unit)
			if not unit then return end
			local cache = unit_combat_reach_cache[unit]
			if cache then 
				return cache 
			else
				local cr = og(unit) 
				unit_combat_reach_cache[unit] = cr
				return cr
			end
		end

		local og = MoveTo
		MoveTo=function(x,y,z,directly)
			if x and y and z then
				local state = GetCVar("AutoInteract")
				if directly then
					SetCVar("AutoInteract",true)
					_faceLocation(x,y,z)
					og(x,y,z)
				else
					SetCVar("AutoInteract",true)
					og(x,y,z)
				end
				SetCVar("AutoInteract",state)
			end
		end

		local og = MoveTo
		JesusMoveTo=function(x,y,z,directly)
			if x and y and z then
				if not player_has_control() then return false end
				local state = GetCVar("AutoInteract")
				if directly then
					_faceLocation(x,y,z)
					og(x,y,z)
				else
					og(x,y,z)
				end
				SetCVar("AutoInteract",state)
			end
		end

		local og = TraceLine
		TraceLine=function(x,y,z,X,Y,Z,flags)
			if x and y and z and X and Y and Z and flags then
				return og(x,y,z,X,Y,Z,flags)
			else

			end
		end

		local og = FaceDirection
		FaceDirection=function(unit,update)
			if player_has_control() then
				og(unit,update)
			end
		end

		local og = GetDistanceBetweenPositions
		GetDistanceBetweenPositions=function(X1,Y1,Z1,X2,Y2,Z2)
			if X1 and Y1 and Z1 and X2 and Y2 and Z2 then return og(X1,Y1,Z1,X2,Y2,Z2) else return 0 end
		end

		function StopMoving()
			MoveForwardStop()
			MoveBackwardStop()
			StrafeLeftStop()
			StrafeRightStop()
			TurnLeftStop()
			TurnRightStop()
			AscendStop()
			CameraOrSelectOrMoveStop()
			local x,y,z = GetPlayerPosition()
			MoveTo(x,y,z)
			if squid_path then Squid_StopNav() end
		end

		function StopMovingAndLock()
			MoveForwardStop()
			MoveBackwardStop()
			StrafeLeftStop()
			StrafeRightStop()
			TurnLeftStop()
			TurnRightStop()
			AscendStop()
			CameraOrSelectOrMoveStop()
			local x,y,z = GetPlayerPosition()
			MoveTo(x,y,z)
			SetMovementLocked(true)
			if squid_path then Squid_StopNav() end
		end

		ewt_api_hooked=true
	end

	if IsHackEnabled and not movement_hooked then
		local MoveForwardStart_OG = MoveForwardStart
		local MoveBackwardStart_OG = MoveBackwardStart
		local StrafeLeftStart_OG = StrafeLeftStart
		local StrafeRightStart_OG = StrafeRightStart
		local JumpOrAscendStart_OG = JumpOrAscendStart
		local CameraOrSelectOrMoveStart_OG = CameraOrSelectOrMoveStart
		local MoveTo_OG = MoveTo
		-- can't make this, throws protected function error :(
		function SetMovementLocked(bool)
			if bool == true then
				MoveForwardStart=function() end
				MoveBackwardStart=function() end
				StrafeLeftStart=function() end
				StrafeRightStart=function() end
				JumpOrAscendStart=function() end
				CameraOrSelectOrMoveStart=function() end
				MoveTo=function() end
				squid_movement_locked=true
			else
				MoveForwardStart=MoveForwardStart_OG
				MoveBackwardStart=MoveBackwardStart_OG
				StrafeLeftStart=StrafeLeftStart_OG
				StrafeRightStart=StrafeRightStart_OG
				JumpOrAscendStart=JumpOrAscendStart_OG
				CameraOrSelectOrMoveStart=CameraOrSelectOrMoveStart_OG
				MoveTo=MoveTo_OG
				squid_movement_locked=false
			end
		end
		function IsMovementLocked()
			return squid_movement_locked
		end
		movement_hooked=true
	end

	if __LB__ then 
		SetMovementLocked=function() end 
	end

	player_position = {}
    player_position.x,player_position.y,player_position.z = ObjectPosition("player")

	_pulseResetDR()
	Squid_GUI_Update()

	if SQUID.cap_bot then
		if squid_conquest_earned == 500 then
			Squid_Alert_Big("You're capped!","Turn it in!",nil,nil,23335)
		elseif squid_conquest_earned >= 465 then
			Squid_Alert_Big("You're almost capped!","Get ready to turn it in!",nil,nil,23333)
		end
	end

	-- Squid_Alerts_Unlocked=true -- testing
	if Squid_Alerts_Unlocked then
		if not AlertFrames_Anchor:IsShown() then
			AlertFrames_Anchor:Show()
		end
		if not BigAlertFrames_Anchor:IsShown() then
			BigAlertFrames_Anchor:Show()
		end
		if not Squid_Alert_Test or time - Squid_Alert_Test > .5 then
			if not Squid_StopSpamming then
				local spell
				for i=1,100 do
					local r = math.random(1,99999)
					if GetSpellInfo(r) then
						spell=r
						break
					end
				end
				if not spell then spell = 118 end
				Squid_Alert("Testing",math.random(1,99999),nil,nil,spell) 
				Squid_Alert_Big("Testing",math.random(1,99999),nil,nil,spell)
				Squid_Alert_Test=time
			end
		end
	else
		if AlertFrames_Anchor:IsShown() then
			AlertFrames_Anchor:Hide()
		end
		if BigAlertFrames_Anchor:IsShown() then
			BigAlertFrames_Anchor:Hide()
		end
	end

	if UnitBuffID("player",5215) or UnitBuffID("player",58984) or UnitBuffID("player",115191) or UnitBuffID("player",1784) then
		was_stealth=time
	end

	if was_stealth and time-was_stealth > .25 then
		was_stealth=nil
	end

	if Squid_Burst then
		if not squid_burst_enabled_msg or time - squid_burst_enabled_msg > .5 then
			Squid_Alert("Burst Mode Enabled",nil,nil,.5)
			squid_burst_enabled_msg=time
		end
	else
		squid_burst_enabled_msg = nil
	end

	if Squid_Burst and time - Squid_Burst > 2 then
		Squid_Burst = nil
	end

	if SQUID.anon then
		for i=1,40 do
			if _G["CompactRaidFrame"..i] then
				if _G["CompactRaidFrame"..i.."Name"] then
					local current = _G["CompactRaidFrame"..i.."Name"]:GetText()
					if current ~= nil and current ~= "The Squid" and current ~= "Friend of Squid" and current ~= "Squid?" then
						if unit_is_unit(current,"player") then
							_G["CompactRaidFrame"..i.."Name"]:SetText("The Squid")
						elseif UnitIsFriend("player",current) or UnitInParty(current) then
							_G["CompactRaidFrame"..i.."Name"]:SetText("Friend of Squid")
						else
							_G["CompactRaidFrame"..i.."Name"]:SetText("Squid?")
						end
					end
				end
			end
			if _G["PartyMemberFrame"..i] then
				if _G["PartyMemberFrame"..i.."Name"] then
					local current = _G["PartyMemberFrame"..i.."Name"]:GetText()
					if current ~= nil and current ~= "The Squid" and current ~= "Friend of Squid" and current ~= "Squid?" then
						if unit_is_unit(current,"player") then
							_G["PartyMemberFrame"..i.."Name"]:SetText("The Squid")
						elseif UnitIsFriend("player",current) or UnitInParty(current) then
							_G["PartyMemberFrame"..i.."Name"]:SetText("Friend of Squid")
						else
							_G["PartyMemberFrame"..i.."Name"]:SetText("Squid?")
						end
					end
				end
			end
		end
		if not anonymize_nameplates_hooked then
			hooksecurefunc("CompactUnitFrame_UpdateName",function(F)
				if F.unit:find("nameplate") and (UnitIsFriend("player", F.unit) or UnitInParty(F.unit)) then 
					if F:IsShown() then
						F.name:SetText("Friend of Squid")
					end
				end
			end)
			anonymize_nameplates_hooked = true
		end
	end

	things_from_beyond = {}

	if not checked_player_afk or time - checked_player_afk > .15 then
		if AnyKeyPressed() then
			player_last_button_press = time
		end
		checked_player_afk = time
	end

	--is the player afk?
	if not player_last_button_press or time - player_last_button_press > 6 then
		player_afk = true
	else
		player_afk = false
	end

	-- player afk short
	if not player_last_button_press or time - player_last_button_press > .5 then
		player_afk_short = true
	else
		player_afk_short = false
	end

	if not IsForeground() then 
		player_afk = true 
	end

	-- check if any button is being pressed, and record the time of last button press

	--streaming mode persistence
	if LibDraw then
		if SQUID.streaming_mode then
			if not squid_streaming_mode_enabled then 
				toggle_squid_streaming_mode()
			end
		else
			if squid_streaming_mode_enabled then 
				toggle_squid_streaming_mode()
			end 
		end
	end

	-- object manager

	--    local GetObjectWithIndex = GetObjectWithIndex
	--    local ObjectExists = ObjectExists
	-- local ObjectType = ObjectType
	-- local ObjectID = ObjectID
	-- local ObjectRawType = ObjectRawType
	-- local ObjectName = ObjectName
	-- local unit_is_player = unit_is_player
	-- local unit_can_attack = unit_can_attack
	-- local UnitAffectingCombat = UnitAffectingCombat
	-- local UnitIsDeadOrGhost = UnitIsDeadOrGhost
	-- local UnitIsDead = UnitIsDead
	-- local UnitIsFriend = UnitIsFriend
	-- local tremove = tremove
	-- if EWT then


		-- local total, updated, added, removed = GetObjectCount(true);

		--WAElite OM
		-- LibDraw.clearCanvas()
	 --    wa_OM(updated,added,removed)
	 --    checkOM()
	 --    if drawCleave then
	 --        CleaveDraw()
	 --    end
	 --    drawTriggers()

	    local function isCritter(Unit)
	        local unitType = UnitCreatureType(Unit)
	        local types = {
	            ["Critter"] = true,
	            ["Kleintier"] = true,
	            ["Bestiole"] = true,
	            [""] = true,
	            ["Alma"] = true,
	            ["Bicho"] = true,
	            ["Animale"] = true,
	            [""] = true,
	            [""] = true,
	            [""] = true,
	            ["Wild Pet"] = true,
	            ["Ungezhmtes Tier"] = true,
	            ["Mascotte sauvage"] = true,
	            [" "] = true,
	            ["Mascota salvaje"] = true,
	            ["Mascta Salvaje"] = true,
	            ["Mascote Selvagem"] = true,
	            ["Creatura Selvaggia"] = true,
	            [""] = true,
	            [""] = true
	        }
	        if types[unitType] ~= nil then
	            return true
	        end
	        return false
	    end

		-- if not Squid_OM then

			Squid_OM = {}
			Squid_ALL = {}

			Objects = {}
			Enemies = {}
			Friends = {}
			AreaTriggers = {}
			Pets = {}

			for i=1,GetObjectCount() do
				table.insert(Squid_ALL, GetObjectWithIndex(i))
			end

			for i=1,#Squid_ALL do

				local pointer = Squid_ALL[i]
				
				if ObjectTypeName(pointer) == "Unit" or ObjectTypeName(pointer) == "Player" or ObjectTypeName(pointer) == "ActivePlayer" then
					if not isCritter(pointer) then
		    			table.insert(Squid_OM,pointer)
		    		end
		    		if id == 416 or id == 58959 then
		    			imp_exists = pointer
		    		end
				end
				if ObjectTypeName(pointer) == "Unit" or  ObjectTypeName(pointer) == "Player" or  ObjectTypeName(pointer) == "ActivePlayer" or  ObjectTypeName(pointer) == "GameObject" then
					table.insert(Objects,pointer)
				end

				if ObjectTypeName(pointer) == "AreaTrigger" then
					table.insert(AreaTriggers,pointer)
				end

		    end
		    
		    for i=1,#Squid_OM do
		    	local pointer = Squid_OM[i]
				if unit_can_attack("player",pointer) and not UnitIsDeadOrGhost(pointer) then
					if arena then
						if unit_is_player(pointer) then
							table.insert(Enemies,pointer)
						end
						table.insert(Pets,pointer)
					else
						if UnitAffectingCombat(pointer) or unit_is_player(pointer) and (unit_is_unit(pointer,"target") or unit_is_unit(pointer,"focus") or unit_is_unit("player",UnitTarget(pointer)) or unit_is_unit("player",UnitSpellTarget(pointer))) or _isDummy(pointer) or UnitIsPet(pointer) or no_combat_debug then
							local objectid = ObjectID(pointer)
							local no_touch
							for i=1,#no_touch_units do
								local notouch = no_touch_units[i]
								if notouch.unitID == objectid then
									local buff = notouch.buff 
					        		if buff == nil then
					        			no_touch = true
					        		else
					        			if UnitBuffID(pointer,buff) then
					        				no_touch = true
					        			end
					        		end
					        	end
					        end
					        if not no_touch then
				        		table.insert(Enemies,pointer)
				   				table.insert(Pets,pointer)
				   			end
				        end
				    end
				   	local name = ObjectName(pointer)
				   	if name == "Thing From Beyond" then
						table.insert(things_from_beyond,pointer)
					end
		        end
		        if unit_is_player(pointer) and UnitIsFriend("player",pointer) and not UnitIsDeadOrGhost(pointer) then
		        	if arena or friend_debug or UnitInParty(pointer) or unit_is_unit("player",pointer) then
						table.insert(Friends,pointer)
					end
				end
				if unit_is_unit("target",pointer) then
					current_target = pointer
				end
				if unit_is_unit("focus",pointer) then
					current_focus = pointer
				end
				if arena then
					if unit_is_unit("arena1",pointer) then
						current_arena1 = ObjectPointer("arena1")
					end
					if unit_is_unit("arena2",pointer) then
						current_arena2 = ObjectPointer("arena2")
					end
					if unit_is_unit("arena3",pointer) then
						current_arena3 = ObjectPointer("arena3")
					end
				end
		    end

		    --remove dead objects
		    -- for i=1,#Enemies do if UnitIsDeadOrGhost(Enemies[i]) or UnitIsDead(Enemies[i]) then tremove(Enemies,i) end end
		    -- for i=1,#Friends do if UnitIsDeadOrGhost(Friends[i]) or UnitIsDead(Friends[i])  then tremove(Friends,i) end end
		    -- for i=1,#Pets do if UnitIsDeadOrGhost(Pets[i]) or UnitIsDead(Pets[i]) then tremove(Pets,i) end end

		-- else

		-- 	Enemies = {}
		-- 	Friends = {}
		-- 	Pets = {}

		-- 	for i=1,#added do

		-- 		local pointer = added[i]

		-- 		local id = ObjectID(pointer)
		-- 		local object_type = ObjectRawType(pointer)

		-- 		if id == 416 or id == 58959 then
	 --    			imp_exists = pointer
	 --    		end

		-- 		-- print(object_type)

		-- 		-- if object_type == 8 or object_type == 5 or object_type == 6 then
		-- 		-- 	table.insert(Squid_All,pointer)
		-- 		-- end

		-- 		if object_type == ObjectType.Unit or object_type == ObjectType.Player or object_type == ObjectType.ActivePlayer then
		-- 			if not isCritter(pointer) then
		--     			table.insert(Squid_OM,pointer)
		--     		end
		-- 		end
		-- 		if object_type == ObjectType.Unit or object_type == ObjectType.Player or object_type == ObjectType.ActivePlayer or object_type == ObjectType.GameObject then
		-- 			table.insert(Objects,pointer)
		-- 		end
		-- 		if object_type == ObjectType.AreaTrigger then
		-- 			table.insert(AreaTriggers,pointer)
		-- 		end

		--     end

		-- 	for i=1,#removed do
		-- 		if removed[i]==imp_exists then
		-- 			imp_exists = nil
		-- 		end
		--     	for n=1,#Squid_OM do if Squid_OM[n]==removed[i] then
		--     		table.remove(Squid_OM,n)
		--     	end end
		--     	for n=1,#Objects do if Objects[n]==removed[i] then
		--     		table.remove(Objects,n)
		--     	end end
		--     	for n=1,#AreaTriggers do if AreaTriggers[n]==removed[i] then
		--     		table.remove(AreaTriggers,n)
		--     	end end
		--     end

		-- 	for i=1,#Squid_OM do
		--     	local pointer = Squid_OM[i]
		--     	local player = unit_is_player(pointer)
		-- 		if unit_can_attack("player",pointer) and not UnitIsDeadOrGhost(pointer) then
		-- 			if arena then
		-- 				if player then
		-- 					table.insert(Enemies,pointer)
		-- 				end
		-- 				table.insert(Pets,pointer)
		-- 			else
		-- 				if UnitAffectingCombat(pointer) or unit_is_player(pointer) and (unit_is_unit(pointer,"target") or unit_is_unit(pointer,"focus") or unit_is_unit("player",UnitTarget(pointer)) or unit_is_unit("player",UnitSpellTarget(pointer))) or _isDummy(pointer) or UnitIsPet(pointer) or no_combat_debug then
		-- 					local objectid = ObjectID(pointer)
		-- 					local no_touch
		-- 					for i=1,#no_touch_units do
		-- 						local notouch = no_touch_units[i]
		-- 						if notouch.unitID == objectid then
		-- 							local buff = notouch.buff 
		-- 			        		if buff == nil then
		-- 			        			no_touch = true
		-- 			        		else
		-- 			        			if UnitBuffID(pointer,buff) then
		-- 			        				no_touch = true
		-- 			        			end
		-- 			        		end
		-- 			        	end
		-- 			        end
		-- 			        if not no_touch then
		-- 		        		table.insert(Enemies,pointer)
		-- 		   				table.insert(Pets,pointer)
		-- 		   			end
		-- 		        end
		-- 		    end
		-- 		    local name = ObjectName(pointer)
		-- 		   	if name == "Thing From Beyond" then
		-- 				table.insert(things_from_beyond,pointer)
		-- 			end
		--         end
		--         if player and UnitIsFriend("player",pointer) and not UnitIsDeadOrGhost(pointer) then
		--         	if arena or friend_debug or UnitInParty(pointer) or unit_is_unit("player",pointer) then
		-- 				table.insert(Friends,pointer)
		-- 			end
		-- 		end
		--     end
	 		
	 -- 		if arena then
		-- 		if UnitIsVisible("arena1") then
		-- 			current_arena1 = ObjectPointer("arena1")
		-- 		end
		-- 		if UnitIsVisible("arena2") then
		-- 			current_arena2 = ObjectPointer("arena2")
		-- 		end
		-- 		if UnitIsVisible("arena3") then
		-- 			current_arena3 = ObjectPointer("arena3")
		-- 		end
		-- 	end

		--     --move attackable units
		--     for i=1,#Friends do if unit_can_attack("player",Friends[i]) and not tContains(Enemies,Friends[i]) then
		--     	table.insert(Enemies,Friends[i])
		--     end end

		--     --remove non existent objects?
		--     -- for i=1,#Enemies do if not ObjectExists(Enemies[i]) then tremove(Enemies,i) end end
		--     -- for i=1,#Friends do if not ObjectExists(Friends[i]) then tremove(Friends,i) end end
		--     -- for i=1,#Pets do if not ObjectExists(Pets[i]) then tremove(Pets,i) end end

		--     --remove inapproprate units
		--     if instance_type ~= "none" then
		-- 	    for i=1,#Enemies do 
		-- 	    	if Enemies[i] and UnitIsFriend("player",Enemies[i]) and not valid_attackable(Enemies[i]) then 
		-- 	    		tremove(Enemies,i) 
		-- 	    	end 
		-- 	    end
		-- 	end

		--     --remove dead objects
		--     for i=1,#Enemies do if UnitIsDeadOrGhost(Enemies[i]) or UnitIsDead(Enemies[i]) then tremove(Enemies,i) end end
		--     for i=1,#Friends do if UnitIsDeadOrGhost(Friends[i]) or UnitIsDead(Friends[i])  then tremove(Friends,i) end end
		--     for i=1,#Pets do if UnitIsDeadOrGhost(Pets[i]) or UnitIsDead(Pets[i]) then tremove(Pets,i) end end

		-- end

		if not UnitExists("arena1") then
			current_arena1=nil
		end
		if not UnitExists("arena2") then
			current_arena2=nil
		end
		if not UnitExists("arena3") then
			current_arena3=nil
		end

		-- if arena and #Enemies == 0 then
		-- 	if current_arena1 then
		-- 		table.insert(Enemies,current_arena1)
		-- 	end
		-- 	if current_arena2 then
		-- 		table.insert(Enemies,current_arena2)
		-- 	end
		-- 	if current_arena3 then
		-- 		table.insert(Enemies,current_arena3)
		-- 	end
		-- end

		player_pointer = ObjectPointer("player")

		-- if not distance_cache_wiped or time-distance_cache_wiped > .04 then
			distance_cache = {}
		-- 	distance_cache_wiped = time
		-- end

		if UnitIsVisible("target") and not current_target then current_target = ObjectPointer("target") end
		if UnitIsVisible("focus") and not current_focus then current_focus = ObjectPointer("focus") end

		if current_focus and UnitIsDeadOrGhost(current_focus) then current_focus = nil end
		if current_target and UnitIsDeadOrGhost(current_target) then current_target = nil end

		if current_target and not UnitIsVisible("target") then current_target = nil end
		if current_focus and not UnitIsVisible("focus") then current_focus = nil end

		--end of ewt obj manager
	-- elseif __LB__ then -- LB object manager

	-- 	player_pointer = ObjectPointer("player")

	-- 	-- if not distance_cache_wiped or time-distance_cache_wiped > .04 then
	-- 		distance_cache = {}
	-- 	-- 	distance_cache_wiped = time
	-- 	-- end

	-- 	if UnitIsVisible("target") and not current_target then current_target = ObjectPointer("target") end
	-- 	if UnitIsVisible("focus") and not current_focus then current_focus = ObjectPointer("focus") end

	-- 	if current_focus and UnitIsDeadOrGhost(current_focus) then current_focus = nil end
	-- 	if current_target and UnitIsDeadOrGhost(current_target) then current_target = nil end

	-- 	if current_target and not UnitIsVisible("target") then current_target = nil end
	-- 	if current_focus and not UnitIsVisible("focus") then current_focus = nil end

	-- end

	-- assign vars to special area triggers
	-- for i=1,#AreaTriggers do
	-- 	local id = ObjectID(AreaTriggers[i])
	-- 	if id == 12740 then
	-- 		mage_orb = AreaTriggers[i]
	-- 	end
	-- end

	if current_focus then
		if squid_trap_focus and time - squid_trap_focus < .35 then
			_aeCastInMovingDirection(187650,current_focus,perfectTravelDist(current_focus))
		end
	end

	-- --self reliance stealth detection
	-- self_reliance_stealth = AzeritePowerTaken(87) and not UnitBuffID("player",270661) and AllEnemiesAroundMe(18) == 0

	-- if self_reliance_stealth then
	-- 	Squid_Alert_Big("Stealth Detected","Self Reliance",2,nil,270661)
	-- end

	alter_effect = 0
	if squid_alter then
		alter_effect = round ( squid_alter["start_hp"] - _HP("player"), 2)
	end

	--lowest enemy
	lowestEnemy = 100;
	for i=1,#Enemies do if unit_is_player(Enemies[i]) and _HP(Enemies[i]) < lowestEnemy then
		lowestEnemy=_HP(Enemies[i]);
		lowestEnemyName=Enemies[i];
	end end

	--lowest friend
	lowestFriend=100;
	for i=1,#Friends do 
		local friendhp = _HP(Friends[i]);
		if friendhp and friendhp <= lowestFriend then
			lowestFriend=_HP(Friends[i]);
			lowestFriendName=Friends[i];
		end 
	end

	--CAP BOT (auto arena afk arena arena bot auto queue) auto que
	local cap_bot = SQUID.cap_bot
	local auto_q = SQUID.auto_queue
	local only_skirms = SQUID.only_skirms
	local only_bgs = SQUID.only_bgs

	local groupsize = GetNumGroupMembers()
	local bf_status = GetBattlefieldStatus(1)

	local queue_pop
	for i=1,3 do
		if GetBattlefieldStatus(i) == "confirm" then
			queue_pop = i
		end
	end

	function queue_up(arena_type)
		if bf_status == "none" then
			if only_skirms then
				JoinSkirmish(4,true)
				queue_up_time = time
			elseif arena_type == "Arena" and not only_skirms then
				JoinArena()
				queue_up_time = time
			elseif arena_type == "Bg" then
				JoinBattlefield(32)
			end
		end
	end
	
	--release in bg
	if cap_bot and instance_type == "pvp" and StaticPopup1 and StaticPopup1:IsShown() then
		if StaticPopup1.which == "DEATH" then
			if not waiting_to_accept or time - waiting_to_accept > 10 then
				waiting_to_accept = time
			elseif time - waiting_to_accept > minDelayTime * 8 then
				StaticPopup1Button1:Click()
				waiting_to_accept = nil
			end
		end
	end

	--never miss queue
	if queue_pop then
		if not queue_pop_start then
			queue_pop_start = time
		else
			if time - queue_pop_start > 25 then
				AcceptBattlefieldPort(queue_pop,1)
				join_battle_time = time
			end
		end
	else
		queue_pop_start = nil
	end
	if queue_pop_start and time - queue_pop_start > 30 then queue_pop_start = nil end

	function friend_in_instance()
		if groupsize > 0 then
			for i=1,groupsize do
				local icon = _G["CompactRaidFrame"..i.."CenterStatusIcon"]
				if icon and icon:IsShown() then
					local texture =  _G["CompactRaidFrame"..i.."CenterStatusIcon"].texture
					if texture and texture:GetTexture() ~= "Interface\\TargetingFrame\\UI-PhasingIcon" then
						return true
					end
				end
			end
		end
	end

	-- being sucked by Ursol's?
	if UnitDebuffID("player",127797) then
		last_ursol = time
	end

	if last_ursol and time - last_ursol < .5 and GetUnitSpeed("player") > 30 then
		last_suck = time
	end

	-- if last_suck and time - last_suck < 1 then
	-- 	Squid_Alert("You've Been Sucked!")
	-- end

	-- if PVPMatchResults and PVPMatchResults.buttonContainer and PVPMatchResults.buttonContainer.leaveButton then
	-- 	local function leftbattle() join_battle_time = time end
	-- 	PVPMatchResults.buttonContainer.leaveButton:HookScript("OnClick", leftbattle)
	-- end

	--auto queue
	if auto_q then
		--join battle faster
		if queue_pop and queue_pop_start and time - queue_pop_start > minDelayTime*15 then
			if bf_status == "confirm" or arena and not arena_loading_screen and PVPReadyDialog and PVPReadyDialog:IsShown() then
				AcceptBattlefieldPort(queue_pop,true)
				join_battle_time = time
			end
		end
		--accept ready checks
		if LFDRoleCheckPopup:IsShown() then
			if not role_check_start then
				role_check_start = time
			else
				if time - role_check_start > 2.6 and (not player_last_button_press or time - player_last_button_press < 25 or not SQUID.safe_afk_q or cap_bot) then
					LFDRoleCheckPopupAcceptButton:Click()
				end
			end
		else
			role_check_start = nil
		end
		--queue up
		if not arena_loading_screen and not arena and bf_status == "none" and not friend_in_instance() and (not player_last_button_press or time - player_last_button_press < 25 or not SQUID.safe_afk_q or cap_bot) then
			if not queue_up_time or time - queue_up_time > 14 then
				if groupsize == 0 then
					if only_bgs then
						queue_up("Bg")
					else
						queue_up("Skirmish")
					end
				else
					if only_bgs then
						queue_up("Bg")
					elseif only_skrims then
						queue_up("Skirmish")
					else
						queue_up("Arena")
					end
				end
			end
		end
		--leave arena
		-- (REQUE SKIRMS WITH WINNING GRPS!!)
		if PVPMatchResults and PVPMatchResults:IsShown() then
			if not game_over_time then
				game_over_time = time
			else
				if time - game_over_time > 2.1 + ( not SQUID.cap_bot and 15 or 0 ) then
					local results = PVPMatchResults.header
					results = results and results:GetText()
					--attempt req on victory
					if results == "VICTORY" and GetNumGroupMembers() > 1 and PVPMatchResults.buttonContainer.requeueButton and PVPMatchResults.buttonContainer.requeueButton:IsShown() and not get_squid_var("Leave Skirms") then
						if not reque_attempt_time or time - reque_attempt_time > 14 then
							print("Attempting to re-queue with this team because we won.")
							PVPMatchResults.buttonContainer.requeueButton:Click()
							reque_attempt_time = time
						end
					else
						--leave if loss or teammates leave
						local reason
						if not PVPMatchResults.buttonContainer.requeueButton or not PVPMatchResults.buttonContainer.requeueButton:IsShown() then
							reason = "we must."
						elseif GetNumGroupMembers() <= 1 then
							reason = "everyone left."
						else
							reason = "this team is undesirable."
						end
						if not leave_attempt_time or time - leave_attempt_time > 6 then
							print("Leaving the game because "..reason)
							PVPMatchResults.buttonContainer.leaveButton:Click()
							leave_attempt_time = time
							join_battle_time = time
						end
					end
				end
			end
		else 
			game_over_time = nil
		end
	end

	arena_loading_screen = nil
	if join_battle_time and time - join_battle_time < 10 and not _isMoving("player") then
		arena_loading_screen=true
	end

	if game_over_time and time - game_over_time > 30 then game_over_time = nil end

	-- time in control?
	if not time_in_control or not player_has_control() then
		time_in_control = 0
		time_control_lost = time
	else
		time_in_control = time - time_control_lost
	end

	-- get healthstone
	if GetItemCount(5512) == 0 and UnitBuffID("player",32727) then
		if not soulwell_interact or time - soulwell_interact > 6 then
			InteractUnit("Soulwell");
			soulwell_interact = time
		end
	end

	healer_not_visible = false
	their_healer_hiding = false
	if arena then
		for i=1,GetNumArenaOpponents() do
			local specid = GetArenaOpponentSpec(i)
			if not specid then return nil end
			if select(5,GetSpecializationInfoByID(specid)) == "HEALER" and not UnitIsVisible("arena"..i) then
				healer_not_visible = true
				their_healer_hiding = true
			end
		end
	end

	--auto targeting
	if cap_bot and ( arena or instance_type == "pvp" ) then

		if not IsHackEnabled("AntiAFK") then
			if not afk_reset or time - afk_reset > 60 then
				ResetAfk()
				afk_reset = time
			end
			-- SetHackEnabled("AntiAFK",true)
		end

		local best_target
		local player_role = GetUnitRole("player")
		
		local cc_on_team
		for i=1,#Friends do
			local class = select(2,UnitClass(Friends[i]))
			if class == "MAGE" or class == "HUNTER" then
				cc_on_team=true
			end
		end

		local kill_healers = SQUID.kill_healers

		local possible_targets = {}
		if player_role ~= "healer" then
			--move to friend to get to enemy when we don't have mesh
			if instance_type == "pvp" and not arena and not squid_nav_init[map_id] then
				for i=1,#Friends do if not unit_is_unit("player",Friends[i]) then
						
					local prio = 0

					local actual_hp = UnitHealth(Friends[i])

					if _LoS(Friends[i]) then
						prio = prio + 750
						local dist_value = 0
						dist_value = math.max( 20 , _distance(Friends[i]) )
						dist_value = math.max( dist_value, 150 )
						prio = prio + dist_value
					end

					prio = prio + ( _isMoving(Friends[i]) and 1 or 0 )

					table.insert(possible_targets,{pointer=Friends[i],prio=prio,actual_hp=actual_hp});
					
				end end
			end
			local instance_type = instance_type
			--dps
			for i=1,#Enemies do if unit_is_player(Enemies[i]) and not _breakableCC(Enemies[i]) and not _immuneCheck(Enemies[i]) then
				
				local e = Enemies[i]
				local hp = _HP(e)
				local actual_hp = UnitHealth(e)

				local prio = 0

				if cc_on_team and _isHealer(e) then
					prio = prio - 1
				end

				local class = select(2,UnitClass(e))

				prio = prio + ( arena and UnitEnemiesAttacking(e) * 7 or UnitEnemiesAttacking(e) )
				prio = prio + (hp < 75 and 3 or 0)
				prio = prio + (hp < 50 and 4 or 0)
				prio = prio + (_LoS(e) and 3 or 0)
				
				prio = prio - (_isTank(e) and 3 or 0)
				prio = prio + (not _isHealer(e) and 1 or 0)
				prio = prio + (class ~= "DEATHKNIGHT" and 1 or 0)
				prio = prio + (kill_healers and _isHealer(e) and 10 or 0)
				prio = prio - (player_role == "melee" and _buffRemains(e,206804) > 1 and 100 or 0) -- rain from above

				--bg bot prio
				if instance_type == "pvp" and not arena then
					if not squid_nav_init[map_id] then
						prio = prio + (_LoS(e) and 1000 or 0)
						prio = prio + (_distance(e) < 40 and 9 or 0)
					else
						--target closest enemy
						prio = prio + (1000 - max(40,_distance(e)) )
					end
				end
				-- prio = prio - (class == "DEATHKNIGHT" and 10000000 or 0)
				-- prio = prio + (class == "DRUID" and 1 or 0)

				table.insert(possible_targets,{pointer=e,prio=prio,hp=hp,actual_hp=actual_hp})

			end end
		else
			--healing
			for i=1,#Friends do if not unit_is_unit("player",Friends[i]) then
					
				local prio = 0
				local hp = _HP(Friends[i])
				local actual_hp = UnitHealth(Friends[i])

				if hp < 50 then
					prio = prio + EnemiesAttacking(Friends[i])
				end

				if hp < 30 then
					prio = prio + 100
				end

				table.insert(possible_targets,{pointer=Friends[i],prio=prio,hp=hp,actual_hp=actual_hp});
				
			end end
		end

		table.sort(possible_targets,function(x,y) return x.prio > y.prio or (x.prio == y.prio and x.actual_hp < y.actual_hp) end)

		if #possible_targets > 0 then
			best_target = possible_targets[1].pointer
		end

		if not best_target then
			best_target = lowestEnemyName
		end

		if FLOWER_EXISTS then best_target = FLOWER_EXISTS end

		if best_target and UnitIsVisible(best_target) then
			TargetUnit(best_target)
		end

		--always face the target
		local target_in_range
		if player_role == "ranged" or player_role == "healer" then
			target_in_range = UnitIsVisible(current_target) and _LoS(current_target) and _distance(current_target) < 38
		elseif player_role == "melee" then
			target_in_range = UnitIsVisible(current_target) and _LoS(current_target) and _distance(current_target) < 6
		end
		if target_in_range and player_has_control() and not UnitIsDeadOrGhost("player") and not _isMoving("player") and UnitCanAttack("player",current_target) and not UnitBuffID("player",45438) and time_in_control > 1.5 then
			if not already_faced or time - already_faced > .5 then
				if not _amIfacing(current_target) then
					_faceUnit(current_target)
					already_faced = time
				end
			end
		end
	
	end
	
	--testing
	-- local map_id,sub_map_id,sub_map_id2 = GetMapId()
	-- maps_being_loaded = maps_being_loaded or false
	-- if not IsMeshLoaded(map_id) and not maps_being_loaded then
	-- 	InitializeNavigation(function(x) maps_being_loaded = true end, map_id.." "..sub_map_id.." "..sub_map_id2))
	-- end
	-- print(IsMeshLoaded(map_id))

	if arena_start_timer and arena_start_timer <= 5 then
		arena_just_starting = time
	end

	--torghast auto loot
	if GetMapId() == 2162 and not UnitAffectingCombat("player") and SQUID.auto_interact_objects then
		for i=1,#Squid_OM do
			local p = Squid_OM[i]
			if _distance(p) < 2.5 and UnitCanBeLooted(p) then
				if _isMoving("player") then
					--[[Squid_Alert("Stop Moving","LOOT!",2,nil,84766)--]]
					if _distance(p) < 2 and (not stopped_moving_for_loot or time - stopped_moving_for_loot > 2) then
						StopMoving()
						if not squid_auto_loot or time - squid_auto_loot > .25 then
							InteractUnit(p)
							Squid_Alert("Looting",ObjectName(p),nil,nil,84766)
							C_Timer.After(1,function() if LootFrameCloseButton:IsShown() then LootFrameCloseButton:Click() end end)
							squid_auto_loot = time
						end
						stopped_moving_for_loot = time
					end
				else
					if not squid_auto_loot or time - squid_auto_loot > .25 then
						InteractUnit(p)
						Squid_Alert("Looting",ObjectName(p),nil,nil,84766)
						C_Timer.After(1,function() if LootFrameCloseButton:IsShown() then LootFrameCloseButton:Click() end end)
						squid_auto_loot = time
					end
					C_Timer.After(1,function() if LootFrameCloseButton:IsShown() then LootFrameCloseButton:Click() end end)
				end
			end
		end
	end

	talent_info_updated = talent_info_updated or {}
	-- keep friends spec+talent info updated
	if LibInspect then
		for i=1,#Friends do if unit_is_player(Friends[i]) and UnitInParty(Friends[i]) then
			if not talent_info_updated[Friends[i]] or time - talent_info_updated[Friends[i]] > 5 then
				LibInspect:Rescan(Friends[i])
				talent_info_updated[Friends[i]] = time
			end
		end end
	end

	-- auto movement
	-- z dif hardcode paths for blades edgge and mugam
	local ready_for_combat
	local combat = UnitAffectingCombat("player")
	if cap_bot and ( arena or instance_type == "pvp" ) and not do_not_move then
		local map_id = GetMapId()
		local px,py,pz = GetPlayerPosition()
		--silvershard starting room                    -- this is ally starting zone
		if map_id == 727 and GetDistanceBetweenPositions(px,py,pz,851.57464,135.140,328.838) < 15 then
			--ally starting zone
			if GetDistanceBetweenPositions(px,py,pz,851.57464,135.140,328.838) < 15 and not UnitIsDeadOrGhost("player") then
				-- move out of starting room
				if not silvershard_move or time - silvershard_move > 12 then
					MoveTo(814.2376,158.4841,320.2999)
					silvershard_move = time
				end
			end
		else
			--without navmesh / arena just started ( mainly to get out of dalaran sewers pipe ) / BRH Arena (navmesh runs into gates)
			if not squid_nav_init[map_id] or (arena_just_starting and time - arena_just_starting < 5) or map_id == 1504 then
				local center_map = {
				robodrome = {-281.9567,-278.6942,70.4470},
				rol = {1293.8947,1678.3043,34.6745},
				}
				if not pause_auto_movement or time - pause_auto_movement > 20 then
					if (map_id == 2167 or map_id == 572) and ( IsMounted() or _stealthCheck("player") ) and not UnitBuffID("player",32727) and not _isMoving("player") and not UnitAffectingCombat("player") then
						if map_id == 2167 then
							local x,y,z = unpack ( center_map.robodrome )
							MoveTo(x,y,z)
							pause_auto_movement = time
						end
						if map_id == 572 then
							local x,y,z = unpack ( center_map.rol )
							MoveTo(x,y,z)
						end
					end
				end
				if UnitIsVisible(current_target) and (not pause_auto_movement or time - pause_auto_movement > 4.5) and not UnitIsDeadOrGhost("player") then
					local class = select(2,UnitClass("player"))
					local spec = GetSpecialization()
					local player_role = GetUnitRole("player")
					local attackable_target = current_target and unit_can_attack("player",current_target)
					local needs_to_mount = instance_type == "pvp" and not arena and not UnitAffectingCombat("player") and not IsIndoors() and not IsMounted() and (class ~= "ROGUE" and class ~= "DRUID" or not attackable_target) and (not attackable_target or _distance(current_target) > 42) and not _stealthCheck("player")
					if player_role == "ranged" then 
						if not unit_casting_info("player") then
							local dist = _distance(current_target)
							local los = _LoS(current_target)
							local bg_val = 30
							if (dist > 35 - ( UnitIsFriend("player",current_target) and bg_val or 0 ) or not los) and not needs_to_mount then
								if not recent_movement or time - recent_movement > .75 or not _isMoving("player") then
									--move into range / los
									local x,y,z = basic_path_to_unit(current_target)
									MoveTo(x,y,z)
									recent_movement = time
								end
							elseif dist <= 35 - ( UnitIsFriend("player",current_target) and bg_val or 0 ) and los or needs_to_mount then
								ready_for_combat = unit_can_attack("player",current_target) and not needs_to_mount
								--stop moving when in range
								if _isMoving("player") then
									if unit_can_attack("player",current_target) or needs_to_mount then
										local px,py,pz = GetPlayerPosition()
										StopMoving()
										MoveTo(px,py,pz)
										-- if needs_to_mount then
										-- 	CallCompanion("MOUNT",math.random(1,15))
										-- end
									end
								end
								--dismount when in range
								if IsMounted() and unit_can_attack("player",current_target) then
									Dismount()
								end
							end
						end
					elseif player_role == "melee" then
						local dist = _distance(current_target)
						local los = _LoS(current_target)
						if (dist > 2 or not los) and not needs_to_mount then
							if not recent_movement or time - recent_movement > .1 or not _isMoving("player") then
								--move into range / los
								local x,y,z = basic_path_to_unit(current_target)
								MoveTo(x,y,z)
								recent_movement = time
							end
						elseif dist <= 2 and los then
							ready_for_combat = unit_can_attack("player",current_target) and not needs_to_mount
							--dismount when in range
							if IsMounted() and unit_can_attack("player",current_target)  then
								Dismount()
							end
						end
					elseif player_role == "healer" then
						if not unit_casting_info("player") then
							local dist = _distance(current_target)
							local los = _LoS(current_target)
							if ( dist > 35 or not los) and not needs_to_mount then
								if not recent_movement or time - recent_movement > 1 or not _isMoving("player") then
									--move into range / los
									local x,y,z = basic_path_to_unit(current_target)
									MoveTo(x,y,z)
									recent_movement = time
								end
							elseif dist <= 35 and los or needs_to_mount then
								--stop moving when in range
								if _isMoving("player") then
									local px,py,pz = GetPlayerPosition()
									StopMoving()
									MoveTo(px,py,pz)
									-- if needs_to_mount then
									-- 	CallCompanion("MOUNT",math.random(1,15))
									-- end
								end
								ready_for_combat = unit_can_attack("player",current_target) and not needs_to_mount
								--dismount when in range
								if IsMounted() and unit_can_attack("player",current_target) then
									Dismount()
								end
							end
						end
					end
				end
			--with navmesh
			else
				if UnitIsVisible(current_target) and not UnitIsDeadOrGhost("player") and instance_type ~= "none" then
					local their_healer
					for i=1,#Enemies do if _isHealer(Enemies[i]) then
						their_healer = Enemies[i]
					end end
					local t 
					if their_healer and (_incapacitateDR(their_healer) == 1 or _drRemains(their_healer,"incapacitate") > 17.5 or _drRemains(their_healer,"incapacitate") < 5 or SQUID.mongo) and (not _LoS(their_healer) or _distance(their_healer) > 28) then
						t = their_healer
					else
						t = current_target
					end
					local class = select(2,UnitClass("player"))
					local spec = GetSpecialization()
					local dist = _distance(t)
					local los = _LoS(t)
					local player_role = GetUnitRole("player")
					local attackable_target = unit_can_attack("player",t)
					local role_min_mount_range = (player_role == "melee" and 11 or 42)
					local needs_to_mount = instance_type == "pvp" and not arena and not UnitAffectingCombat("player") and not IsIndoors() and not IsMounted() and (class ~= "ROGUE" and class ~= "DRUID" or not attackable_target) and (not attackable_target or dist > role_min_mount_range or not los)
					local needs_to_stealth
					if class == "ROGUE" or class == "DRUID" then
						needs_to_stealth = not combat and ( arena or instance_type == "pvp" and ready_for_combat )
					end
					if needs_to_stealh then needs_to_mount = nil end
					-- print(needs_to_mount)
					if player_role == "ranged" then 
						if not unit_casting_info("player") then
							
							ready_for_combat = attackable_target and dist < 35 - (unit_is_unit(t,their_healer) and 6.5 or 0) and los and not needs_to_mount

							--stop moving when in range
							if _isMoving("player") then
								if ready_for_combat then
									Squid_StopNav()
								end
							end
							--dismount when in range
							if IsMounted() and ready_for_combat then
								Dismount()
							end

							--move to target
							if not needs_to_mount then
								if not recent_movement or time - recent_movement > .75 then
									if dist > 28 or not los then
										local x,y,z = ObjectPosition(t)
										Squid_Nav(x,y,z)
										recent_movement = time
									end
								end
							end

						end
					elseif player_role == "melee" then
						ready_for_combat = attackable_target and dist < 2 and los and not needs_to_mount
						--stop moving when in range
						if _isMoving("player") then
							if ready_for_combat then
								Squid_StopNav()
							end
						end
						--dismount when in range
						if IsMounted() and ready_for_combat then
							Dismount()
						end
						--move to target
						if not needs_to_mount then
							if not recent_movement or time - recent_movement > .5 then
								if dist >= 2 or not los then
									local x,y,z = ObjectPosition(current_target)
									Squid_Nav(x,y,z)
									recent_movement = time
								end
							end
						end
					elseif player_role == "healer" then
						if not unit_casting_info("player") then
							
							ready_for_combat = dist < 35 and los and not needs_to_mount
							--stop moving when in range
							if _isMoving("player") then
								if ready_for_combat then
									Squid_StopNav()
								end
							end
							--dismount when in range
							if IsMounted() and ready_for_combat then
								Dismount()
							end
							--move to target
							if not needs_to_mount then
								if not recent_movement or time - recent_movement > .5 then
									if dist > 33 or not los then
										local x,y,z = ObjectPosition(current_target)
										Squid_Nav(x,y,z)
										recent_movement = time
									end
								end
							end
						end
					end
				end
			end
		end
		--mount up when out of combat
		-- if needs_to_mount then
			if not UnitAffectingCombat("player") and not IsMounted() and not _stealthCheck("player") and not ready_for_combat then
				if not arena_loading_screen and (not UnitBuffID("player",32727) or arena_start_timer and arena_start_timer <= 15) then
					if not attempted_mount or time - attempted_mount > .5 then
						Squid_StopNav()
						CallCompanion("MOUNT",math.random(1,15))
						attempted_mount = time
					end
				end
			end
		-- end
	end

	--enable the bot with cap bot on..................
	if cap_bot and ( arena or instance_type == "pvp" ) and not SquidLobster then SquidToggle() end

	--alternate between tanking / winning 
	-- if not tank_mmr_init then
	-- 	tank_mmr_init = time
	-- else
	-- 	if not UnitAffectingCombat("player") then
	-- 		if time - tank_mmr_init > 2400 or SQUID.tank_mmr and time - tank_mmr_init > 1200 then
	-- 			SQUID.tank_mmr = not SQUID.tank_mmr
	-- 			tank_mmr_init = time
	-- 		end
	-- 	end
	-- end

	--auto cooldowns
	if cap_bot and ( arena or instance_type == "pvp" ) then

		local class = select(2,UnitClass("player"))
		local spec = GetSpecialization()

		--trinket
		if UnitAffectingCombat("player") and _CCremains("player") >= 3.99 then
			-- if _spellCooldown(208683) == 0 or _spellCooldown(195710) == 0 then
			-- 	SQ_CastSpellByID(208683)
			-- 	SQ_CastSpellByID(195710)
			-- end
			if IsEquippedItem(184052) and GetItemCD(184052) == 0 then
				UseItemByName(tostring(GetItemInfo(184052)))
			end
			if IsPlayerSpell(59752) and _spellCooldown(59752) == 0 and _stunCheck("player") then
				SQ_CastSpellByName("Will to Survive")
			end
		end

		--human trinket
		if UnitAffectingCombat("player") and _stunRemains("player") >= 2.99 then
			SQ_CastSpellByID(59752)
		end

		-- Use bike
		if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and not _immunePhysical(current_target) and _LoS(current_target) then
			if IsEquippedItem(169769) and GetItemCD(169769) <= 1 then
				if _HP(current_target) < 90 then
					UseItemByName(tostring(GetItemInfo(169769)));
				end
			end
		end

		-- Use absorb shit
		if IsEquippedItem(159618) and GetItemCD(159618) <= 1 then
			if _HP("player") < 40 then
				UseItemByName(tostring(GetItemInfo(159618)));
			end
		end

		-- Tankerino
		if SQUID.tank_mmr then
			if UnitAffectingCombat("player") then
				C_Timer.After(1,function()
					join_battle_time = time
					RunMacroText("/afk")
				end)
			end
		end

		-- HUNTER AUTOBOT CDS
		if class == "HUNTER" then
			if time_in_control > .3 then

				-- go targ
				if UnitIsVisible(current_target) and _distance(current_target) > 10 then
					_Cast(190925,current_target)
				end

				-- det
				if _HP("player") < 15 + (10 * EnemiesAttacking("player")) - (_spellCooldown(109304) < 2 and 15 or 0) then
					_Cast(186265)
				end

				-- cds
				if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and not _immunePhysical(current_target) and _LoS(current_target) then
					if _HP(current_target) < 95 then
						_Cast(266779)
						if _distance(current_target) > 4.5 then
							_Cast(186289)
						end
					end
				end

				-- stun target
				if not IsMounted() or _distance(current_target) < 11 then
					if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and not _immunePhysical(current_target) and _LoS(current_target) and not _immuneStuns(current_target) and not _CCcheck(current_target) and _stunDR(current_target) == 1 then
						_Cast(19577,current_target)
					end
				end

				-- get pet
				if map_id ~= 2167 or UnitAffectingCombat("player") then
					if not UnitIsVisible("pet") then
						if not pet_res_attempt or time - pet_res_attempt > 5 then
							pet_res_count = pet_res_count or 0
							pet_res_count = pet_res_count + 1
							CastSpellByName("Revive Pet")
							if pet_res_count > 5 then
								pet_res_attempt = time
							end
						else
							pet_res_count = 0
							CastSpellByName("Call Pet 3")
						end
					end
				end

			end
		end

		-- MAGE AUTOBOT CDS
		if class == "MAGE" then

			if time_in_control > .3 and not UnitIsDeadOrGhost("player") then

				local their_healer = theirHealer
				local their_healer_cc
				local their_healer_cc_remains = 0
				local their_healer_incapacitate_dr
				local their_healer_incapacitate_dr_remains = 0
				local their_healer_disorient_dr
				local their_healer_disorient_dr_remains = 0
				local their_healer_important_lockout
				if their_healer then
					if not UnitIsDeadOrGhost(their_healer) then
						their_healer_cc_remains = _CCremains(their_healer)
						their_healer_cc = their_healer_cc_remains > 0
						their_healer_incapacitate_dr = _incapacitateDR(their_healer)
						their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
						their_healer_disorient_dr = _disorientDR(their_healer)
						their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

						local class = select(2,UnitClass(their_healer))

						local locked,remaining,school = UnitIsLocked(their_healer)

						if locked and remaining > .25 then
							if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
							or ( class == "SHAMAN" and school == "Nature" )
							or ( class == "PALADIN" and school == "Holy" )
							or ( class == "MONK" and school == "Nature" )
							or ( class == "DRUID" and school == "Nature" )  then
								their_healer_important_lockout = true
							end
						end
					else -- no healer if he dead
						their_healer = nil
					end
				end

				local target_attackable = UnitIsVisible(current_target) and unit_can_attack("player",current_target) and _LoS(current_target) and _distance(current_target) < 35
				local sheeped_target
				local sheeped_target_duration = 0
				for i=1,#Enemies do
					local remains = _debuffRemains(Enemies[i],118,"player")
					-- if _debuffRemains(Enemies[i],82691,"player") > remains then remains = _debuffRemains(Enemies[i],82691,"player") end
					if remains > 0 then
						sheeped_target = Enemies[i]
						sheeped_target_duration = remains
					end
				end

				--fire
				if spec == 2 then
					local combustion = UnitBuffID("player",190319)
					--combust
					if not arena_loading_screen and target_attackable and _spellCooldown(190319) <= .2 and not _immuneMagic(current_target) then
						if (load_mode_active or meteor_in_flight) and (not unit_casting_info("player") or _castTimeLeft("player") < .25) and (not theirHealer or _CCcheck(theirHealer)) then
							SquidBurst()
						end
					end
					-- db
					if Squid_DB and not SQUID.i_am_xen then
						if lowestFriend < 80 or lowestEnemy < 30 then
							for i=1,#Enemies do if unit_is_player(Enemies[i]) and not _CCcheck(Enemies[i]) and (not unit_is_unit(current_target,Enemies[i]) or _HP(Enemies[i]) < 30 or lowestFriend < 50) and _disorientDR(Enemies[i]) >= .5 then
								Squid_DB(Enemies[i])
							end end
						end
					end
					--blink away from melee if i dont have a healer
					if not ourHealer and select(2,EnemiesAttacking("player")) > 0 and _spellCooldown(212653) == 0 and not UnitBuffID("player",45438) and (not player_blink or GetTime() - player_blink > 3) then
						local x,y,z = africa_blink()
						if x and y and z then
							blink_to_pos(x,y,z)
							Squid_Alert("Blinking Away From Shit",nil,nil,nil,212653)
						end
					end
					--sheep target if they're full hp i guess?
					-- if not combustion then
					-- 	if target_attackable and ( not sheeped_target or unit_is_unit(current_target,sheeped_target) or sheeped_target_duration < _castTime(118) ) and _CCremains(current_target) < _castTime(118) + .2 then
					-- 		if _HP(current_target) > 90 and not _immuneMagic(current_target) and _incapacitateDR(current_target) >= .5 and UnitEnemiesAttacking(current_target) == 0 then
					-- 			_Cast(118,current_target)
					-- 		end
					-- 	end
					-- end
					--cook pies into bcc
					if target_attackable and not killshot_engaged and _breakableCC(current_target) then
						_Cast(203286,current_target)
					end
					--meteor
					if load_mode_active and target_attackable and not _immuneMagic(current_target) and (_isSlowed(current_target) or _CCcheck(current_target)) then
						Squid_Meteor(current_target)
					end
					--auto block
					local block_after_caut = true
					local block_hp = 20
					if (_HP("player") <= block_hp or block_after_caut and _debuffRemains("player",108843) >= 3.5 and _HP("player") < block_hp + 17.5) and _spellCooldown(45438) <= GetGCD()+.15 then
						if not block_after_caut or UnitDebuffID("player",86949) or UnitDebuffID("player",87024) then
							if unit_casting_info("player") or UnitChannelInfo("player") then SpellStopCasting() end
							SQ_CastSpellByID(45438)
							Squid_Alert_Big("Auto Block","(You're a bot!)",1,3,45438)
						end
					end
					--blink to targo to kill his ass
					if UnitIsVisible(current_target) and not _LoS(current_target) then
						if ( _HP(current_target) < ( 10 * GetSpellCharges(212653) ) + (_stunRemains(current_target) > 2.5 and their_healer_cc and 75 or 0) or combustion ) then
							blink_to_unit(current_target,25,true)
						end
					end
					if UnitIsVisible(theirHealer) and not unit_is_unit(theirHealer,current_target) then
						--blink to healer to cc
						if _CCremains(theirHealer) > 1.75 and _incapacitateDR(theirHealer) >= .5 and (not _LoS(theirHealer) or _distance(theirHealer) > 32) then
							blink_to_unit(theirHealer,30,true)
						end
						--blink db healer for sheep
						if _incapacitateDR(theirHealer) == 1 and _disorientDR(theirHealer) == 1 and not _CCcheck(theirHealer) then
							blink_db(theirHealer)
						end
					end
					--pre blaze
					if arena_start_timer and arena_start_timer <= 20 then
						_Cast(235313)
					end
				end

			end

		end

		if class == "ROGUE" then

			-- vanish when ded
			if _HP("player") < 20 then
				_Cast(1856)
			end

			--sprint
			if arena and not UnitBuffID("player",32727) and _isMoving("player") and UnitIsVisible(current_target) and not _meleeRange(current_target) and UnitAffectingCombat("player") then
				SQ_CastSpellByID(2983)
			end

			--blind
			if theirHealer and _CCremains(theirHealer) < .25 and _disorientDR(theirHealer) == 1 and not unit_is_unit(theirHealer, current_target) then
				_Cast(2094,theirHealer,nil,true)
			end

			--blind peel
			if lowestFriend < 60 and not theirHealer then
				for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) and not _CCcheck(Enemies[i]) and _disorientDR(Enemies[i]) == 1 then
					_Cast(2094,Enemies[i])
				end end
			end

		end

		if class == "DRUID" then

			--stamp roar
			if arena and not UnitBuffID("player",32727) and _isMoving("player") then
				if _Cast(106898) then
					Squid_Alert("Stampeding Roar","(Maximum Aggression!)",nil,nil,106898)
				end
			end

			--wall
			if _HP("player") < 15 + (35 * EnemiesAttacking("player")) then
				if _Cast(61336) then
					Squid_Alert("Survival Instincts","(Less Death)",nil,nil,106898)
				end
			end

		end

	end

	function DetermineActiveCovenantAndSoulbindAndConduits()
	  local covenantID = C_Covenants.GetActiveCovenantID();
	  if ( not covenantID or covenantID == 0 ) then 
	    return nil;
	  end
	  local covenantData = C_Covenants.GetCovenantData(covenantID);
	  if ( not covenantData ) then 
	    return nil;
	  end
	  local covenantName = covenantData.name;
	  local soulbindID = C_Soulbinds.GetActiveSoulbindID();
	  if ( not soulbindID or soulbindID == 0 ) then 
	    return nil;
	  end
	  local soulbindData = C_Soulbinds.GetSoulbindData(soulbindID);
	  if ( not soulbindData ) then 
	    return nil;
	  end
	  local id = soulbindData["ID"];
	  --local covenantID = soulbindData["covenantID"];
	  local soulbindName = soulbindData["name"];
	  local description = soulbindData["description"];
	  local tree = soulbindData["tree"];
	  local nodes = tree["nodes"];
	  --BA_Data["function LogTextLine"](string.format("covenant:[%s] - soulbind ID:[%d] - id:[%d] - covenantID:[%d] - name:[%s]",covenantName,soulbindID,id,covenantID,name));
	  --BA_Data["function LogTextLine"](string.format("nodes:-"));
	  local activeConduitsSpells = {};
	  activeConduitsSpells.covenantName = covenantName;
	  activeConduitsSpells.soulbindName = soulbindName;
	  activeConduitsSpells.conduits = {};
	  for _, ve in pairs(nodes) do
	    local node_id = ve["ID"];
	    local node_row = ve.row;
	    local node_column = ve.column;
	    local node_spellID = ve.spellID; -- this will be 0 for uninit spell, not nil
	    local node_conduitID = ve.conduitID; -- this will be 0 for uninit conduit, not nil
	    local node_conduitRank = ve.conduitRank;
	    local node_state = ve.state;
	    local node_conduitType = ve.conduitType; -- this can be nil
	    if ( node_state == 3 ) then
	      --[====[
	      BA_Data["function LogTextLine"](string.format("nodeid:[%s] - row:[%s] - col:[%s] - spellID:[%s] - conduitID:[%s] - conduitRank:[%s] - state:[%s][%s] - conduitType:[%s][%s]",
	          tostring(node_id),
	          tostring(node_row),
	          tostring(node_column),
	          tostring(node_spellID),
	          tostring(node_conduitID),
	          tostring(node_conduitRank),
	          tostring(node_state),
	          tostring(( node_state == 1 and "blank" or node_state == 3 and "used" or "unknown" )),
	          tostring(node_conduitType),
	          tostring(( node_conduitType == 1 and "Potency" or node_conduitType == 2 and "Endurance" or node_conduitType == 0 and "Finesse" or "Unknown"  ))
	        ));
	      --]====]
	      
	      local node_spellName;
	      if ( node_spellID ~= 0 ) then
	        node_spellName = GetSpellInfo(node_spellID);
	      elseif ( node_conduitID ~= 0 ) then
	        local conduitSpellID = C_Soulbinds.GetConduitSpellID(node_conduitID,node_conduitRank);
	        node_spellID = conduitSpellID;
	        node_spellName = GetSpellInfo(conduitSpellID);
	      else
	        node_spellID = nil;
	        node_spellName = nil;
	      end
	      if ( node_spellID ) then
	        activeConduitsSpells.conduits[#activeConduitsSpells.conduits + 1] = { spellID = node_spellID, spellName = node_spellName, rank = node_conduitRank };
	      end
	    end
	  end
	  for _, ve in pairs(activeConduitsSpells.conduits) do
	    -- BA_Data["function LogTextLine"](string.format("spellID:[%d] - spellName:[%s]",ve.spellID,tostring(ve.spellName)));
	  end
	  
	  --BA_Data["function LogTextLine"](string.format("-- end nodes"));
	  return activeConduitsSpells;
	end

	if not soulbinds_update or time - soulbinds_update > 120 then
		active_soulbinds = {DetermineActiveCovenantAndSoulbindAndConduits()}
		soulbinds_update = time
	end

	if not conduit_taken then 
		function conduit_taken(name, rank)
			for i=1,#active_soulbinds do
				local s = active_soulbinds[i]
				if s.conduits then
					for n=1,#s.conduits do
						if s.conduits[n] and (s.conduits[n].spellName == name or s.conduits[n].spellID == name) and (not rank or s.conduits[n].rank >= rank) then
							return true
						end
					end
				end
			end
		end
		function conduit_rank(name)
			for i=1,#active_soulbinds do
				local s = active_soulbinds[i]
				if s.conduits then
					for n=1,#s.conduits do
						if s.conduits[n] and (s.conduits[n].spellName == name or s.conduits[n].spellID == name) then
							return s.conduits[n].rank
						end
					end
				end
			end
			return 0
		end
	end 

	if player_cast then mount_cast_delay = time end

	local item_broken
	local current_durability = 0
	local max_durability = 0

	for i=1,10 do
		local current,max = GetInventoryItemDurability(i)
		if current then
			max_durability = max_durability + max
			current_durability = current_durability + current
			if current <= 5 then
				item_broken = true
			end
		end
	end

	local durability_pct = (100 * current_durability / max_durability)

	if item_broken then durability_pct = 0 end

	if cap_bot and GetMapId() == 2373 and not UnitAffectingCombat("player") then
		if UnitBuffID("player",32727) then
			has_prep = time
		end
		time_since_prep = has_prep and time - has_prep or 0
		if time_since_prep > .6 and time_since_prep < 7 then
			local best_enemy
			for i=1,#Enemies do
				best_enemy = Enemies[i]
			end
			if best_enemy then
				local x,y,z = ObjectPosition(best_enemy)
				MoveTo(x,y,z)
			end
		end
	end

	--auto repair
	if cap_bot and (not ( arena or instance_type == "pvp" ) or UnitBuffID("player",32727)) and durability_pct < 70 then
		if not recently_repaired or time - recently_repaired >= 600 then
			if not UnitAffectingCombat("player") then
				if IsUsableSpell("Grand Expedition Yak") then
					if not UnitBuffID("player",122708) then
						if not mount_cast_delay or time - mount_cast_delay > .25 then
							SQ_CastSpellByName("Grand Expedition Yak")
						end
					else
						InteractUnit("Cousin Slowhands")
						if MerchantFrame and MerchantFrame:IsShown() then
							if MerchantRepairAllButton and MerchantRepairAllButton:IsShown() then
								MerchantRepairAllButton:Click()
								C_Timer.After(3,function()
									recently_repaired = time
									Dismount()
								end)
							end
						end
					end
				elseif IsUsableSpell("Traveler's Tundra Mammoth") then
					if not ( UnitBuffID("player",61425) or UnitBuffID("player",61447) ) then
						if not mount_cast_delay or time - mount_cast_delay > .25 then
							SQ_CastSpellByName("Traveler's Tundra Mammoth")
						end
					else
						InteractUnit("Gnimo")
						InteractUnit("Drix Blackwrench")
						if MerchantFrame and MerchantFrame:IsShown() then
							if MerchantRepairAllButton and MerchantRepairAllButton:IsShown() then
								MerchantRepairAllButton:Click()
								C_Timer.After(3,function()
									recently_repaired = time
									Dismount()
								end)
							end
						end
					end
				end
			end
		end
	end

	--jack shit
	if SQUID.i_am_jack then
		if arena then
			local opponents = GetNumArenaOpponents()
			for i=1,#Enemies do if _isHealer(Enemies[i]) then
				opponents = opponents - 1
			end end
			if opponents > 0 then
				-- for i=1,#Friends do
				-- 	if EnemiesAttacking(Friends[i]) >= opponents then
				-- 		tX, tY, tZ = ObjectPosition(Friends[i])
	   --                  s = 1.5
	   --                  LibDraw.SetWidth(5)
	   --                  LibDraw.SetColorRaw(1, 0, 0, 1)
	   --                  Line(tX, tY, tZ+s*2, tX, tY, tZ)
	   --                  Line(tX-s, tY, tZ, tX+s, tY, tZ)
	   --                  Line(tX, tY-s, tZ, tX, tY+s, tZ)
				-- 	end
				-- end
			end
			for i=1,#Enemies do if not _isHealer(Enemies[i]) then
				local ut = UnitTarget(Enemies[i])
				if unit_is_unit("player",ut) then
					local x,y,z = ObjectPosition(Enemies[i])
					local px,py,pz = ObjectPosition("player")
					LibDraw.SetWidth(5)
	                LibDraw.SetColorRaw(1, .25, 0, 1)
					LibDraw.Line(x,y,z,px,py,pz)
				end
			end end
		end
	end

	PetPlayerEnabled=nil
	PetPlayerDraw=nil
	if PetPlayer and IsForeground() and UnitIsVisible(PetPlayer) then
		if GetKeyState(0x12) == true then
			if GetKeyState(0x01) == true then
				if not PetCommandSent or time-PetCommandSent > .5 then
					SendMovementCommand(PetPlayer)
					PetCommandSent=time
				end
				_targetLastTarget()
				C_Timer.After(.25,_targetLastTarget)
			end
			PetPlayerDraw=true
		end
	end

	--accept res
	if AutoFollow and StaticPopup1 and StaticPopup1:IsShown() then
		if StaticPopup1.which == "RESURRECT_NO_TIMER" then
			StaticPopup1Button1:Click()
		end
	end

	if big_dmg_inc and big_dmg_inc_time and time - big_dmg_inc_time > 3 then
		big_dmg_inc = nil
		big_dmg_inc_time = nil
	end

	if cc_flying_towards_player and cc_flying_towards_player_time and time - cc_flying_towards_player_time > 2.25 then
		cc_flying_towards_player = nil
		cc_flying_towards_player_time = nil
	end

	if current_target then
		if (not last_target or not unit_is_unit(last_target,current_target)) then
			last_target=current_target
		end
	else
		if last_target and UnitIsVisible(last_target) and UnitBuffID(last_target,5384) then
			TargetUnit(last_target)
			Squid_Alert("Re-Target Hunter","(Feign Death)")
		end
	end

	if SQUID.streaming_mode and player_afk then
		return
	end

	-- if IsHackEnabled then
	-- 	InteractUnit("Crackleclaw Crab")
	-- end

	if SQUID.anon then
		if GameTooltip:IsShown() and GameTooltipTextLeft1 then
			local name = GameTooltipTextLeft1:GetText()
			if name then
				if UnitIsFriend("player",name) or UnitInParty(name) then
					GameTooltipTextLeft1:SetText("Friend of Squid")
					-- GameTooltip:Hide()
				end
				if name == UnitPVPName("player") then
					GameTooltipTextLeft1:SetText("Squid")
					-- GameTooltip:Hide()
				end
			end
		end
	end

	if SQUID.anon then
		if CharacterFrameTitleText and CharacterFrameTitleText:GetText() == myName then
			CharacterFrameTitleText:SetText(custom_name)
		end
	end

	--default saved vars
	SQUID.min_combust_hp = SQUID.min_combust_hp or 40000
	
	if SQUID.auto_combust == nil then
		SQUID.auto_combust = false
	end

	if SQUID.solo_mode then
		local solo_instance = {
			[2192] = true, -- torghast
		}
		SQUID.solo_mode_enabled = not is_in_instance or GetNumGroupMembers() <= 1 or solo_instance[map_id]
	end

	if gpy_flying and time - gpy_flying > 4 then
		gpy_flying = nil
	end
	if (pyro_flying and time - pyro_flying > 2.5) or (pyro_flying and time - pyro_flying > .3 and not pyro_really_flying) then
		pyro_flying = nil
		pyro_really_flying = nil
	end

	if (fb_flying and time - fb_flying > 2.5) or (fb_flying and time - fb_flying > .3 and not fb_really_flying) then
		fb_flying = nil
		fb_really_flying = nil
	end

	if (pf_flying and time - pf_flying > 2.5) or (pf_flying and time - pf_flying > .3 and not pf_really_flying) then
		pf_flying = nil
		pf_really_flying = nil
	end
	
	--clear these tables
	--kickTable Alert / Clear
	if #kickTable > 0 then
		for i=1,#kickTable do
			if kickTable[i] then
				local spell = kickTable[i].cast
				local unit = kickTable[i].unit
				local class
				local name
				local school
				--alert
				if not kickTable[i].alert then
					if spell and UnitIsVisible(unit) then
						class = UnitClass(unit)
					end
					if spell and class then
						if locale == "zhCN" then
							Squid_Alert(" >>",class .." ("..spell..")",1,kickTable[i].time-time,kickTable[i].kickID)
						else
							Squid_Alert("Lockout on",class .." ("..spell..")",1,kickTable[i].time-time,kickTable[i].kickID)
						end
						kickTable[i].alert=true
					end
				end
				--remove
				if kickTable[i].time and time - kickTable[i].time > 0 then
					table.remove(kickTable,i);
				end
			end
		end
	end
	
	-- clear kick CD table
	if #kickCooldowns > 0 then
		for i=1,#kickCooldowns do if kickCooldowns[i] and kickCooldowns[i].expire - time < 0 then
	  		table.remove(kickCooldowns,i);
		end end
	end
	
	--BigCDTable Clear
	if #BigCDTable > 0 then
		for i=1,#BigCDTable do if BigCDTable[i] and BigCDTable[i].time and time - BigCDTable[i].time > 20 then
			table.remove(BigCDTable,i);
		end end
	end
	--TrinketTracker Clear
	if #TrinketTracker > 0 then
		for i=1,#TrinketTracker do if TrinketTracker[i] and TrinketTracker[i].expires and time - TrinketTracker[i].expires > 0 then
			table.remove(TrinketTracker,i);
		end end
	end
	--jukeList Clear
	for k,v in pairs(jukeList) do 
		if k then
      		local r = v["Reset"]
      		if r and r <= time then
         		jukeList[k] = {}
        	end
        end
    end 
	--SpellTracker Clear
	for k,v in pairs(SpellTracker) do 
		if v.expires and time > v.expires then
	      	SpellTracker[k] = nil
		end 
	end

	prev_gcd=nil
	table.sort(PlayerSpellCasts,function(x,y) return x.time > y.time end)
	--PlayerSpellCasts Clear
	if #PlayerSpellCasts > 0 then
		for i=1,#PlayerSpellCasts do
			if not prev_gcd and PlayerSpellCasts[i] and IsSpellOnGCD(PlayerSpellCasts[i].name) then prev_gcd=PlayerSpellCasts[i].name end
			--shove spells off gcd to bottom of table
			if PlayerSpellCasts[i] and time-PlayerSpellCasts[i].time > 120 then
	      		table.remove(PlayerSpellCasts,i);
			end
		end
	end

	if not last_combat_time then last_combat_time = time end
	if UnitAffectingCombat("player") then
		last_combat_time = time
		if not time_combat_started then
			time_combat_started=time
		else
			time_in_combat=time-time_combat_started
		end
	else
		time_since_combat = time - last_combat_time
		time_combat_started = nil
		time_in_combat=0
	end

	arena_start_timer = nil
	if arena then
		if UnitBuffID("player",32727) then
			if TimerTrackerTimer1 then
				if TimerTrackerTimer1.time then
					arena_start_timer = TimerTrackerTimer1.time
				end
			end
		end
	end

	all_opponents_visible = true
	if arena then
		for i=1,GetNumArenaOpponents() do
			if not UnitIsVisible("arena"..i) then
				all_opponents_visible = nil
			end
		end
	end

	--keybinds to run even with script disabled
	if ring_healer_key then
		if theirHealer then
			ring_of_frost(theirHealer)
		end
	end
	if ring_focus_key then
		if current_focus then
			ring_of_frost(current_focus)
		end
	end
	if ring_target_key then
		if current_target then
			ring_of_frost(current_target)
		end
	end

	--keep SQUID table updated in savedvars every update
	Squid_Savedvars.SQUID = SQUID

	--mage no suicide lmao
	-- if select(2,UnitClass("player")) == "MAGE" and not arena and IsFalling() and GetUnitSpeed("player") >= 14 then
	-- 	local x,y,z = GetPlayerPosition()
	-- 	local gz,gy,gz = GroundZ(x,y,z)
	-- 	if gz and z - gz <= GetUnitSpeed("player") then
	-- 		if not UnitBuffID("player",130) and _Cast(130,"player") then
	-- 			Squid_Alert("Slow Fall","(Saving Your Ass)",1,nil,130)
	-- 		end
	-- 	end
	-- end

	weird_ass_spells = {
		["alter time"] = true
	}

	-- squid queued spell
	if SQ_QueuedSpell then
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		if time - SQ_QueuedSpell.time > min(.35 + latency,gcd-.125) then 
			SQ_QueuedSpell = nil
		else
			if SQ_QueuedSpell.spell then
				local target = SQ_QueuedSpell.target ~= "healer" and SQ_QueuedSpell.target
				local spell = SQ_QueuedSpell.spell
				if SQ_QueuedSpell.target == "healer" then 
					for i=1,#Enemies do if _isHealer(Enemies[i]) then target = Enemies[i] end end
				elseif not target then
					target = "target"
				end
				if spell and (IsSpellOnGCD(spell) or weird_ass_spells[strlower(spell)]) then
					if target == "cursor" then
						RunMacroText("/cast [@cursor] " .. spell)
					else
						SQ_CastSpellByName(spell, target)
						if _spellCooldown(spell) <= .215 + latency then
							local spellname, _, _, _, _, _, spellid = GetSpellInfo(spell)
							spellname = string.gsub(" "..spellname, "%W%l", string.upper):sub(2)
							Squid_Alert(spellname, "(Manual)", nil, .5, spellid)
						end
					end
				end
			end
		end
	end

	--Script Enabled
	if not SquidLobster then SetMovementLocked(false); return; end

	if ExecutingPlayerMovementCommand and time - ExecutingPlayerMovementCommand > 4 then ExecutingPlayerMovementCommand = nil end

	--auto follow, for full afk
	local t
	if AutoAssist and UnitIsVisible(AutoAssist) then
		t=UnitTarget(AutoAssist)
	elseif not t and AutoFollow and UnitIsVisible(AutoFollow) then
		t=UnitTarget(AutoFollow)
	end
	if AutoFollow and UnitIsVisible(AutoFollow) then
		AlwaysFacing=true
		if not MountInteract or time-MountInteract > 1 then
			InteractUnit(AutoFollow)
			MountInteract=time
		end
		if IsMounted() then
			if t and unit_can_attack("player",t) and not UnitIsDeadOrGhost(t) and _distance(t) < 15 then
				Dismount()
			end
		end
		if _isMoving(AutoFollow) and not unit_casting_info("player") and not ExecutingPlayerMovementCommand then
			if not autofollow_automove or time - autofollow_automove > .65 then
				local x,y,z=ObjectPosition(AutoFollow)
				MoveTo(x,y,z)
				autofollow_automove = time
			end
		elseif t then
			if not UnitAffectingCombat("player") then
				if (not arena_start_timer or arena_start_timer <= 15) and not IsMounted() then
					CallCompanion("MOUNT",math.random(1,15))
				end
			else
				if not _isMoving("player") then
					_faceUnit(t)
				end
			end
		end
		if not hasjumped or time-hasjumped > 60 then
			if _isMoving("player") and not IsSwimming() and not IsFlying() then
				JumpOrAscendStart()
				AscendStop()
				hasjumped=time
			end
		end
	end

	if player_cast_id == 133 and _castTimeLeft("player") <= latency then
		fb_flying = time
	end

	if (AutoFollow or AutoAssist) and t and not unit_is_unit(t,current_target) then TargetUnit(t) end

	wait_for_interrupt = false

	player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
	player_cast_target = UnitSpellTarget("player")
	player_cast_time_left = _castTimeLeft("player")
	player_cast_percent_complete = _castPctDone("player")

	if player_cast_id == 2948 and player_cast_time_left <= .2 then
		fb_used = time - .1
	end 

	--Determine Player's Interrupt Ability
	local interrupts = {
	183752,--"Disrupt",
	6552,--"Pummel",
	96231,--"Rebuke",
	147362,--"Counter Shot",
	1766,--"Kick",
	47528,--"Mind Freeze",
	57994,--"Wind Shear",
	119911,--"Optical Blast",
	115781,--"Optical Blast",
	19647,--"Spell Lock",
	132409,--"Spell Lock",
	251523,--"Spell Lock",
	119910,--"Spell Lock",
	171138,--"Shadow Lock",
	2139,--"Counterspell",
	116705,--"Spear Hand Strike",
	106839,--"Skull Bash",
	-- 93985,--"Skull Bash"
	78675,--"Solar Beam",
	187707,--"Muzzle",
	91802,--"Shambling Rush"
	}

	for i=1,#interrupts do
		if IsPlayerSpell(interrupts[i]) then
			InterruptID = interrupts[i];
			InterruptName = GetSpellInfo(interrupts[i]);
			break
		end
	end

	--auto maledict
	if last_dispel and time - last_dispel < 4 or not theirHealer or UnitIsVisible(theirHealer) and _CCremains(theirHealer) >= 6 then
		
		--corrupted
		if (IsEquippedItem(GetItemInfo(172672)) and select(2,GetItemCooldown(172672)) <= GetGCD())
		--notorious
		or (IsEquippedItem(GetItemInfo(167383)) and select(2,GetItemCooldown(167383)) <= GetGCD())
		--sinister
		or (IsEquippedItem(GetItemInfo(165806)) and select(2,GetItemCooldown(165806)) <= GetGCD()) then
		
			if lowestEnemy < 80 then

				local best_target
				local most_targeted = 0

				for i=1,#Enemies do
					local a = UnitEnemiesAttacking(Enemies[i])
					if a > most_targeted then
						most_targeted = a
						best_target = Enemies[i]
					end
				end

				if not best_target then
					best_target = lowestEnemyName
					if not best_target then
						best_target = current_target
					end
				end

				if best_target and UnitIsVisible(best_target) and unit_is_player(best_target) then
					if not _immuneMagic(best_target) and not _breakableCC(best_target) then
						if _isHealer("player") or unit_is_unit(best_target,current_target) then
							if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,best_target) then
								if GetGCD() <= .01 and player_cast_id and player_cast_time_left > 1.25 and player_cast_id ~= 118 and (player_cast_id ~= 203286 or player_cast_time_left > 1.5) and player_cast_id ~= 113724 and player_cast_id ~= 33786 then
									SpellStopCasting()
								end
								UseItemByName(tostring(GetItemInfo(172672)),best_target);
								UseItemByName(tostring(GetItemInfo(167383)),best_target);
								UseItemByName(tostring(GetItemInfo(165806)),best_target);
								Squid_Alert_Big("Maledict " .. UnitClass(best_target),nil,1,3.25,305252)
							end
						end
					end
				end

			end

		end
		--claw
		if (IsEquippedItem(GetItemInfo(173944)) and select(2,GetItemCooldown(173944)) <= GetGCD()) then
		
			if lowestEnemy < 88 then
				local best_target
				local most_targeted = 0
				for i=1,#Enemies do
					local a = UnitEnemiesAttacking(Enemies[i])
					if a > most_targeted then
						most_targeted = a
						best_target = Enemies[i]
					end
				end
				if not best_target then
					best_target = lowestEnemyName
					if not best_target then
						best_target = current_target
					end
				end

				if best_target and UnitIsVisible(best_target) and unit_is_player(best_target) then
					if not _immuneMagic(best_target) and not _breakableCC(best_target) and not UnitBuffID(best_target,8178) then
						if _isHealer("player") or unit_is_unit(best_target,current_target) then
							if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,best_target) then
								if GetGCD() <= .01 and player_cast_id and player_cast_time_left > 1.25 and player_cast_id ~= 118 and (player_cast_id ~= 203286 or player_cast_time_left > 1.5) and player_cast_id ~= 113724 and player_cast_id ~= 33786 then
									SpellStopCasting()
								end
								UseItemByName(tostring(GetItemInfo(173944)),best_target);
								Squid_Alert_Big("Obsidian Claw " .. UnitClass(best_target),nil,1,3.25,313148)
							end
						end
					end
				end
			end

		end
		--voodoo doll 
		if (IsEquippedItem(GetItemInfo(159624)) and select(2,GetItemCooldown(159624)) <= GetGCD()) then
		
			if lowestEnemy < 80 then
				local best_target
				local most_targeted = 0
				for i=1,#Enemies do
					local a = UnitEnemiesAttacking(Enemies[i])
					if a > most_targeted then
						most_targeted = a
						best_target = Enemies[i]
					end
				end
				if not best_target then
					best_target = lowestEnemyName
					if not best_target then
						best_target = current_target
					end
				end

				if best_target and UnitIsVisible(best_target) and unit_is_player(best_target) then
					if not _immuneMagic(best_target) and not _breakableCC(best_target) then
						if _isHealer("player") or unit_is_unit(best_target,current_target) then
							if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,best_target) then
								if GetGCD() <= .01 and player_cast_id and player_cast_time_left > 1.25 and player_cast_id ~= 118 and (player_cast_id ~= 203286 or player_cast_time_left > 1.5) and player_cast_id ~= 113724 and player_cast_id ~= 33786 then
									SpellStopCasting()
								end
								UseItemByName(tostring(GetItemInfo(159624)),best_target);
								Squid_Alert_Big("Voodoo Doll " .. UnitClass(best_target),nil,1,3.25,271462)
							end
						end
					end
				end
			end

		end
	end

	--m+ affix
	--quaking
	local quaking_remains = _debuffRemains("player",240447)
	if quaking_remains > 0 and unit_casting_info("player") and _castTimeLeft("player") > quaking_remains - 0.5 then 
		SpellStopCasting() 
		Squid_Alert("Stopcasting","(Quaking)",nil,nil,240448)
	end

	--Utility Handler
	if InterruptID == 187707 then -- muzzle
		for i=1,#Enemies do
			local int = PhysicalInterrupt(Enemies[i])
			if int then
				_Cast(187707,Enemies[i],nil,true)
			end
		end
	end
	if InterruptID == 106839 then -- skull bash
		if not (UnitBuffID("player",5215) or UnitBuffID("player",102547) or UnitBuffID("player",58984)) then
			for i=1,#Enemies do
				if PhysicalInterrupt(Enemies[i]) then
					_Cast(106839,Enemies[i],nil,true);
				end
			end
		end
	end
	if InterruptID == 96231 then --rebuke
		for i=1,#Enemies do
			if PhysicalInterrupt(Enemies[i]) then
				_Cast(96231,Enemies[i],nil,true);
			end
		end
	end
	if InterruptID == 147362 then -- counter shot
		for i=1,#Enemies do
			if PhysicalInterrupt(Enemies[i]) then
				_Cast(147362,Enemies[i],nil,true);
			end
		end
	end

	if InterruptID == 2139 and not UnitIsDeadOrGhost("player") then
		local spec = GetSpecialization()
		local block_after_caut = SQUID.block_after_caut
		--auto block
		if SQUID.auto_block then
			if SQUID.auto_block > 0 then
		        --snap
				-- if spec == 3 and _spellCooldown(45438) > 2 + GetGCD() then
				-- 	if _spellCooldown(235219) == 0 then
				-- 		SQ_CastSpellByID(235219)
				-- 		Squid_Alert("Cold Snap",nil,nil,nil,235219)
				-- 	end
				-- end
				if (_HP("player") <= SQUID.auto_block or block_after_caut and _debuffRemains("player",108843) >= 3.5 and _HP("player") < SQUID.auto_block + 15 - (spec == 3 and 15 or 0)) and _spellCooldown(45438) <= GetGCD()+.15 then
					if not block_after_caut or spec ~= 2 or UnitDebuffID("player",86949) or UnitDebuffID("player",87024) then
						--hypo
						if UnitDebuffID("player",41425) and not UnitBuffID("player",45438) then
							Squid_Alert("Can't Block","(Hypothermia)",nil,nil,41425)
						else
							if unit_casting_info("player") or UnitChannelInfo("player") then SpellStopCasting() end
							SQ_CastSpellByID(45438)
							Squid_Alert_Big("Auto Block","(You asked for it.)",1,3,45438)
							return
						end
					end
				end
			end
		end
		--cold snap
		if spec == 3 and _spellCooldown(45438) > 30 then
			-- if _spellCooldown()
		end
	end

	if InterruptID == 2139 and not UnitIsDeadOrGhost("player") and player_has_control() then -- counterspell mage utility

		-- local displacement_position = {}
		-- for i=1,#AreaTriggers do if ObjectID(AreaTriggers[i]) == 11513 then
		-- 	local x,y,z = ObjectPosition(AreaTriggers[i])
		-- 	displacement_position = {x,y,z}
		-- 	break
		-- end end
		-- local dx,dy,dz = unpack(displacement_position)
		-- if dx and dy and dz then
		-- 	local x,y,z = GroundZ(dx,dy,dz)
		-- 	print(dz-z)
		-- end

		local spec = GetSpecialization()

		local klepto_enabled = IsPlayerSpell(198100)

		local their_healer_cc = (not theirHealer or _CCcheck(theirHealer))

		local cs_cd = _spellCooldown(2139)
		local db_cd = _spellCooldown(31661)

		local msperframe = (2/GetFramerate())
		local buffer = latency + msperframe + .1

		local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
		local player_cast_target = UnitSpellTarget("player")
		local player_cast_time_left = _castTimeLeft("player")
		local player_cast_percent_complete = _castPctDone("player")

		if player_cast_id == 118 then
			poly_cast_delay = time
			poly_cast_target = player_cast_target
		end

		local cc_casts = {118,28272,277792,161354,277787,161355,161353,120140,61305,61721,61780,28271,113724}
		local player_casting_cc = player_cast and tContains(cc_casts,player_cast_id)
		local player_casting_non_cc = not player_casting_cc
		
		local crit_casts = {2948,133}
		local player_casting_crittable_damage = player_cast and tContains(crit_casts,player_cast_id)
		
		local flamecannon_stacks = _buffStacks("player",203285)
		
		local flamecannon_value = (flamecannon_stacks * 3)	

		local gpy_range = 40

		local sheep_range = 30

		local ring_range = 30

		gpy_range = gpy_range + flamecannon_value

		sheep_range = sheep_range + flamecannon_value

		ring_range = ring_range + flamecannon_value

		blink_los_draw = nil	

		--auto jukes (egg) fake cast
		if SQUID.auto_juke then
			local player_interruptable = PlayerCanBeKicked()

			local function set_juke_delay()
				auto_juke_pct = math.random(SQUID.min_jukedelay,SQUID.max_jukedelay)
				--more instant jukes are good
				if auto_juke_pct < 12 then
					local seed = math.random(1,3)
					if seed <= 1 then
						auto_juke_pct = 0
					end
				end
				if auto_juke_pct <= 1 then auto_juke_pct = 0 end
			end

			local poly_cast_time = _castTime(118)

			if not auto_juke_pct then
				set_juke_delay()
			else
				if not juke_attempts then juke_attempts = 0 end
				if player_cast_id == 118 and player_interruptable then
					if juke_attempts < SQUID.max_juke_attempts and (not _CCcheck(player_cast_target) or _CCremains(player_cast_target) > poly_cast_time + latency + .4) and (not player_blink or time - player_blink > poly_cast_time - player_cast_time_left) then
						if player_cast_percent_complete >= auto_juke_pct or player_cast_time_left < buffer + .15 then
							SpellStopCasting()
							set_juke_delay()
							juke_attempts = juke_attempts + 1
							Squid_Alert("Attempting Fake Cast","("..GetSpellInfo(player_cast_id)..") [".. juke_attempts .."]",nil,nil,player_cast_id)
							SquidPaused = time - .225
							last_juke_attempt = time
						end
					end
				end
			end

			if last_juke_attempt and time - last_juke_attempt > 6 then
				juke_attempts = 0
			end
		end

		--don't give dk sheep or gpy (dark sim avoidance)
		if UnitDebuffID("player",77606) then
			
			local bad_steals = {
			118,	--poly
			203286,	--gpy
			}

			if spec == 2 then

				if player_cast and tContains(bad_steals,player_cast_id) and (player_cast_time_left < .75 or player_cast_id == 118 and player_cast_time_left < .95) then
					if GetSpellCharges(108853) > 0 then
						if UnitIsVisible(current_target) and unit_can_attack("player",current_target) and not _breakableCC(current_target) then
							if not fb_used or time - fb_used > .15 then
								if _Cast(108853,current_target,nil,true) then
									Squid_Alert("Fire Blast","(Dark Sim)",4,nil,77606)
									fb_used = time
								end
							end
						else
							for i=1,#Enemies do if not _breakableCC(Enemies[i]) then
								if not fb_used or time - fb_used > .15 then
									if _Cast(108853,Enemies[i],nil,true) then
										Squid_Alert("Fire Blast","(Dark Sim)",4,nil,77606)
										fb_used = time
									end
								end
							end end
						end
					else
						-- need good conditions where it's okay to let DK have seheep
						-- if player_cast_id ~= 118 then
							SpellStopCasting()
							Squid_Alert("Stopcasting","(Dark Sim)",nil,nil,77606)
						-- end
					end
				end

			else

				if player_cast and tContains(bad_steals,player_cast_id) and player_cast_time_left < .65 then
					SpellStopCasting()
					Squid_Alert("Stopcasting","(Dark Sim)",nil,nil,77606)
				end

			end

		end

		--blink into LoS for important casts (los blink)
		if player_cast and (player_cast_id == 118 or player_cast_id == 203286 or player_cast_id == 11366) and IsPlayerSpell(212653) and (GetSpellCharges(212653) > 0 or UnitBuffID("player",212799) and _spellCooldown(212801) == 0) then
			local t = player_cast_target
			if t and not _immuneMagic(t) and not UnitBuffID(t,8178) and (unit_is_player(t) or not arena) and (player_cast_id ~= 118 or not _isBeast(t)) then
				if player_cast_time_left < 1.15 then
					if not _LoS(t,nil,true) or _distance(t) > ( player_cast_id == 118 and sheep_range or gpy_range ) then
						blink_los_draw = t
					end
				end
				if player_cast_time_left <= latency + ((player_cast_id == 203286 or player_cast_id == 11366) and .325 or .3) and player_cast_time_left > latency + ((player_cast_id == 203286 or player_cast_id == 11366) and .165 or .025) then
					if player_cast_id == 118 then
						if blink_to_unit(t,sheep_range,true) then
							Squid_Alert_Big("Blink Sheep " .. UnitClass(t),"(LoS)",1,3.5,212653)
							return
						else
							-- Squid_Alert("No LoS Blink Possible",nil,nil,nil,212653)
						end
					end
					if player_cast_id == 203286 then
						if blink_to_unit(t,gpy_range,true) then
							Squid_Alert("Blink Gpy " .. UnitClass(t),"(LoS)",1,3.5,212653)
							return
						else
							-- Squid_Alert("No LoS Blink Possible",nil,nil,nil,212653)
						end
					end
					if player_cast_id == 11366 then
						if blink_to_unit(t,gpy_range,true) then
							Squid_Alert("Blink Pyro " .. UnitClass(t),"(LoS)",1,3.5,11366)
							return
						else
							-- Squid_Alert("No LoS Blink Possible",nil,nil,nil,212653)
						end
					end
				end
			end
		end

		--no stealth
		if not _stealthCheck("player") and not IsFlying() and player_has_control() then
			-- if not (cast_id == 203286 and cast_percent > 80) then
			-- if (not poly_cast_delay or time-poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,unit)) then
				local supernova_enabled = IsPlayerSpell(157980)
				local supernova_cd = _spellCooldown(157980)
				
				--mage interrupts

				--pvp interrupts
				if arena or Current_Mage_Rotation == "PvP" and Mage_Rotation_Override ~= "PvE" then
					for i=1,#Enemies do
						local e = Enemies[i]
						local los = _LoS(e)

						--supernova interrupts
						if supernova_enabled and not _immuneMagic(e) and los and (not poly_cast_delay or time-poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,e)) then
							if supernova_cd <= GetGCD() then
								local int = Interrupt(e,true,30,nil,nil,true)
								if int then
									local d = _distance(e)
									if (unit_casting_info("player") or UnitChannelInfo("player")) and GetGCD() == 0 then
										SpellStopCasting()
									end
									if _Cast(157980,e) then
										Squid_Alert("Interrupted " .. unit_casting_info(e),"(Supernova)",1,nil,157980)
										return
									end
								end
							end
						end

						if cs_cd == 0 then
							local interrupt = Interrupt(e)
							if interrupt then
								local cast,_,_,_,_,_,_,_,id = unit_casting_info(e)
								local d = _distance(e)
								local player_cast = player_cast_time_left - .15
								local enemy_cast = _castTimeLeft(e)
								-- if load_mode_active or (_isHealer(Enemies[i]) and lowestEnemy < 88) or lowestFriend < (ourHealer and _CCcheck(ourHealer) and 35 or 0) + 35 then
									--stopcasting to interrupt if: 1. cast would've interrupted you - 2. game winning healer interrupt
									if enemy_cast < player_cast and los and d < 39.5 then
										if player_cast_id == 203286 or player_casting_cc then
											
											local spell_target = UnitSpellTarget(e)
											local fcds = FrendlyCooldownsUp() + 1
											if (_isHealer(Enemies[i]) and lowestEnemy < 30 * fcds) or (cast and id and tContains(ccIDs,id) and unit_is_unit("player",spell_target)) then
												poly_cast_delay=nil
												SpellStopCasting()
											end
										elseif arena or current_target and unit_is_player(current_target) then
											poly_cast_delay=nil
											SpellStopCasting()
										end
									end
									if interrupt == "important" then
										if enemy_cast > .5 then
											if enemy_cast < player_cast and los and d < 39.5 and (not id or tContains(ccIDs,id)) then
												poly_cast_delay=nil
												SpellStopCasting()
											end
											if not los and blink_to_unit(e,gpy_range,true) then
												Squid_Alert("Blink","(CS)",nil,nil,212653)
											end
										end
									end
									if los and d < 39.5 and (not poly_cast_delay or time - poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,e)) then
										if not poly_cast_delay or time-poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,unit) then
											-- print("Interrupt at : " .. _castTimeLeft(e))
											SQ_CastSpellByName("Counterspell",e)
											SQ_CastSpellByID(2139,e)
										end
									end
								-- end
							else
								-- Dragon's breath interrupts?
								-- local d = _distance(e)

							end
						end
					end
				else
					--latency & travel time delay
					local frame_buffer = 2 / GetFramerate() -- 2 frame buffer
					local background_delay = (not IsForeground() and frame_buffer or 0)
					local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + .105 + (SQUID.extra_net_delay or 0) -- latency + frame buffer + interrupt travel time + 90 ms safety net

					local in_instance = IsInInstance()

					--Mage PvE Interrupts
					for i=1,#Enemies do
						local e = Enemies[i]
						local int,id = PvE_Interrupt(e)
						if int and not id then id = UnitClass(e) end

						if _LoS(e) then
							
							if int == "int" then

								if cs_cd == 0 then
									SpellStopCasting()
									SQ_CastSpellByID(2139,e)
								end

							elseif int == "int_late_or_cc" then

								local cast_time_left = _castTimeLeft(e) 

								if cs_cd <= max ( 0, cast_time_left - interruptNetDelay ) then
									if cast_time_left <= interruptNetDelay then
										SpellStopCasting()
										SQ_CastSpellByID(2139,e)
									end
								elseif db_cd == 0 and cs_cd < 23.8 and _distance(e) <= 8.5 then
									if player_cast_id and player_cast_time_left > cast_time_left - .5 then
										SpellStopCasting()
									end
									if not unit_casting_info("player") and not UnitChannelInfo("player") then	
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("Dragon's Breath",spell,nil,nil,31661)
										end
										local f = ObjectFacing("player")
										FaceDirection(GetAnglesBetweenObjects("player",e),true)
										SQ_CastSpellByID(31661)
										FaceDirection(f,true)
									end
								end

							elseif int == "int_early_or_cc" then

								local cast_time_complete = _castTimeComplete(e)

								if cs_cd == 0 then
									if cast_time_complete >= minDelayTime then
										SpellStopCasting()
										SQ_CastSpellByID(2139,e)
									end
								elseif db_cd == 0 and cs_cd < 23.8 and _distance(e) <= 8.5 then
									SpellStopCasting()
									if not unit_casting_info("player") and not UnitChannelInfo("player") then	
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("Dragon's Breath",spell,nil,nil,31661)
										end
										local f = ObjectFacing("player")
										FaceDirection(GetAnglesBetweenObjects("player",e),true)
										SQ_CastSpellByID(31661)
										FaceDirection(f,true)
									end
								end

							elseif int == "cc" then

								if db_cd == 0 and _distance(e) <= 8.5 then
									if player_cast_id and player_cast_time_left > _castTimeLeft(e) - .5 then
										SpellStopCasting()
									end
									if not unit_casting_info("player") and not UnitChannelInfo("player") then	
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("Dragon's Breath",spell,nil,nil,31661)
										end
										local f = ObjectFacing("player")
										FaceDirection(GetAnglesBetweenObjects("player",e),true)
										SQ_CastSpellByID(31661)
										FaceDirection(f,true)
									end
								end

							end

						end

					end
				end
			-- end
			-- end

		end

		--more pve shit
		if not arena and instance_type ~= "pvp" and instance_type ~= "none" and instance_type ~= "raid" and Current_Mage_Rotation ~= "PvP" and Mage_Rotation_Override ~= "PvP" then
			local function pve_decurse(unit)
				return PvE_Dispel(unit,{"Curse"})
			end
			--pve decurse
			if not UnitBuffID("player",190319) and not UnitBuffID("player",298357) then
				for i=1,#Friends do
					local f = Friends[i]
					local d = pve_decurse(f)
					if d and _Cast(475,f) then
						Squid_Alert("Decurse",GetSpellInfo(d),4,nil,475)
					end
				end
			end
			--pve spellsteal
			if not UnitBuffID("player",190319) and not UnitBuffID("player",298357) then
				for i=1,#Enemies do if not UnitIsCharmed(Enemies[i]) then
					local e = Enemies[i]
					local ss = PvE_Spellsteal(e)
					if ss then
						if _Cast(30449,e) then
							Squid_Alert("Spellsteal",UnitClass(e),nil,nil,30449)
						end
					end
				end end
			end
		end

		--face dest at end of cast (gpy only)
		if not pause_auto_facing or time - pause_auto_facing > .25 then
			if player_cast and (player_cast_id == 203286 or player_cast_id == 11366) then
				if player_cast_time_left <= latency+.255 then
					local dest = player_cast_target
					--no forced facing if we're already facing
					if dest and _LoS(dest) then
						FaceDirection(GetAnglesBetweenObjects("player",dest),true)
					end
				end
			end
		end

		--stop casting if it's going to be bad
		if player_cast then
			
			--stop casting cc
			if player_casting_cc then
				--premonition
				if premonitionUsed then
					local time_since_prem = time - premonitionUsed
					local time_til_prem_proc = 1.5-time_since_prem
					if player_cast_time_left < time_til_prem_proc then
						if premonitionPointer and UnitIsVisible(premonitionPointer) and unit_is_unit(player_cast_target,premonitionPointer) then
							Squid_Alert_Big("Stopcasting","(Death)",4,3,32379)
							SpellStopCasting()
						end
					end
				end

				--blessing of sac
				local sac_up
				local sac_source

				--small sac
				for i=1,#Enemies do 
					local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],6940)
					if buff then
						sac_up = true
						sac_source = source
					end
				end

				--big sac
				for i=1,#Enemies do 
					local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],199448)
					if buff then
						sac_up = true
						sac_source = source
					end
				end

				--casting on the healer
				if sac_up and unit_is_unit(player_cast_target,sac_source) then
					Squid_Alert_Big("Stopcasting","(Sac)",4,3,6940)
					SpellStopCasting()
				end

				--meteor
				if UnitDebuffID(player_cast_target,155158) then
					if player_cast_time_left < latency+.5 then
						
						Squid_Alert("Stopcasting " .. GetSpellInfo(player_cast_id),"(Meteor Burn)",nil,nil,player_cast_id)

						SpellStopCasting()

					end
				end

				--other cc applied while we were already casting sheep (blind, hoj etc)
				if UnitIsVisible(player_cast_target) then

					if _CCremains(player_cast_target) > 4 and player_cast_time_left < latency+.15 and _debuffRemains(player_cast_target,118) < 5 then

						Squid_Alert("Stopcasting " .. GetSpellInfo(player_cast_id),"(Too Much Overlap)",nil,nil,player_cast_id)

						SpellStopCasting()

					end

				end
				
				--war banner
				if UnitBuffID(player_cast_target,236321) then
					if _castTimeLeft("player") < latency+.45 then
						
						Squid_Alert("Stopcasting " .. GetSpellInfo(player_cast_id),"(War Banner)",nil,nil,player_cast_id)

						SpellStopCasting()

					end
				end

			end

			--stop casting dmg
			if arena and player_casting_crittable_damage then
				if UnitIsVisible(player_cast_target) and bcc_remains(player_cast_target) > 1.5 and player_cast_time_left < latency + .2 then

					Squid_Alert("Stopcasting " .. GetSpellInfo(player_cast_id),"(Breakable CC)",nil,nil,player_cast_id)

					SpellStopCasting()

				end

			end

		end

		--stop casting into immunities / reflects
		if player_cast then
			local t = player_cast_target
			local immune = {
			212295, -- Nether ward
			23920,	-- Spell Reflection
			-- 329035,	-- Overwatch (intervene reflect)
			330279,	-- Overwatch (intervene reflect?)
			213915, -- Mass Spell Reflection
			31224,  -- Cloak of Shadows
			642,	-- Divine Shield
			186265, -- Aspect of the Turtle
			-- 48707,  -- Anti-Magic Shield
			33786,  -- Cyclone
			}
			for i=1,#immune do
				local r = immune[i]
				local name = GetSpellInfo(r)
				local remains = _buffRemains(t,r)
				if remains > 0 and remains > player_cast_time_left+(latency*2) and player_cast_time_left > 0 then
					local uptime = _buffUptime(t,r)
					-- print(uptime)
					if uptime > minDelayTime + .1 or player_cast_time_left < latency + msperframe + .25 then
						-- print(remains,player_cast_time_left,player_cast_time_left+.745+latency)
						if r == 23920 and GetSpellCharges(108853) > 0 then
							if _Cast(108853, t, nil, true) then
								Squid_Alert("Fire Blast","(Spell Reflect)",4,nil,108853)
							end
						else
							-- print(remains,player_cast_time_left,player_cast_time_left+.745+latency)
							SpellStopCasting()
							Squid_Alert("Stop Casting","("..name..")",4,nil,r)
						end
					end
				end
			end
		end

	end
	if InterruptID == 47528 or InterruptID == 91802 then -- mind freeze / shambling rush
		--Mind Freeze
		if _spellCooldown(47528) == 0 then
			for i=1,#Enemies do
				if Interrupt(Enemies[i]) then
					if not waiting_for_sim or time - waiting_for_sim >= .75 or not unit_is_unit(Enemies[i],waiting_for_sim_unit) then
						_Cast(47528,Enemies[i],nil,true);
					end
				end
			end
		else
			--Shambling Rush
			if UnitExists("pet") and UnitBuffID("pet",63560) then
				for i=1,#Enemies do
					if PhysicalInterrupt(Enemies[i],nil,75,.45) then
						if not waiting_for_sim or time - waiting_for_sim >= .75 or not unit_is_unit(Enemies[i],waiting_for_sim_unit) then
							SQ_CastSpellByID(47482,Enemies[i]);
						end
					end
				end
			end
		end
	end
	if InterruptID == 1766 then
		local kick_cd = _spellCooldown(1766)
		if not UnitBuffID("player",115191) and not UnitBuffID("player",1784) then
			for i=1,#Enemies do
				local kick = PhysicalInterrupt(Enemies[i])
				if kick then
					if kick_cd == 0 then
						local melee_range=_meleeRange(Enemies[i])
						if melee_range then
							wait_for_interrupt=true
							_Cast(1766,Enemies[i],nil,true);
						end
						--step kick important
						if kick == "important" and not melee_range and not doing_execute then
							if _Cast(36554,Enemies[i]) then
								Squid_Alert("Step " .. UnitClass(Enemies[i]),"(Important Kick)",nil,nil,36554)
							end
						end
					end
				end
			end
		end
		-- shiv wild charge
		if last_wc and time - last_wc < .4 then
  			if UnitIsVisible(last_wc_pointer) and _Cast(5938,last_wc_pointer,nil,true) then
  				Squid_Alert("Shiv","(Wild Charge)",5,nil,5938)
  			end
  		end
	end
	if InterruptID == 116705 then -- windwalker monk utilities
		local interrupt_cd = _spellCooldown(116705)
		for i=1,#Enemies do
			local e = Enemies[i]
			local dist = _distance(e)
			if dist > 4.8 or (lastGapClose and time - lastGapClose < 1.8) then
				if PhysicalInterrupt(e,nil,0,0) then
					local x,y,z = GetPortCoords()
					_Cast(116705,e,nil,true);
					if dist < 4 and _spellCooldown(116705) <= .2 then
						CancelSpellByName("Roll")
					end
					if dist > 6.6 and dist <= 13.25 and interrupt_cd == 0 and (_castTimeLeft(e) > dist * .0289) then
						if roll_to_unit(e) then return end
					end
					if x and y and z and interrupt_cd == 0 and not _meleeRange(e) then
						local ex,ey,ez = ObjectPosition(e)
						if GetDistanceBetweenPositions(ex,ey,ez,x,y,z) <= 5 and _castTimeLeft(e) > .285 + GetGCD() then
							if _Cast(119996) then
								Squid_Alert_Big("Port to " .. UnitClass(e),"(Interrupt)",4,4,119996)
								return
							end
						end
					end
				end
			else
				if PhysicalInterrupt(e) then
					if dist < 5 and interrupt_cd <= .2 then
						CancelSpellByName("Roll")
					end
					_Cast(116705,e,nil,true);
				end
			end
			
		end
	end
	if InterruptID == 183752 then

		player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
		player_cast_target = UnitSpellTarget("player")
		player_cast_time_left = _castTimeLeft("player")
		player_cast_percent_complete = _castPctDone("player")

		--face dest at end of cast (bolt only)
		if not pause_auto_facing or time - pause_auto_facing > .25 then
			if player_cast and player_cast_id == 116858 then
				if player_cast_time_left <= latency+.255 then
					local dest = player_cast_target
					--no forced facing if we're already facing
					if dest and _LoS(dest) then
						FaceDirection(GetAnglesBetweenObjects("player",dest),true)
					end
				end
			end
		end

		--Disrupt
		if not UnitChannelInfo("player") then
			for i=1,#Enemies do
				if Interrupt(Enemies[i]) then
					_Cast(183752,Enemies[i],nil,true);
				end
			end
		end
		--Purge
		for i=1,#Enemies do if UnitBuffID(Enemies[i],210294) then
			_Cast(278326,Enemies[i])
		end end
	end
	if InterruptID == 57994 then --shaman util
		--shear
		for i=1,#Enemies do
			if Interrupt(Enemies[i]) then
				_Cast(57994,Enemies[i],nil,true)
			end
			local ss = Basic_Spellsteal(Enemies[i]) 
			if ss then
				if _Cast(370,Enemies[i],nil,true) then
					Squid_Alert("Purge " .. UnitClass(Enemies[i]),"(" .. GetSpellInfo(ss) .. ")",1,nil,370)
				end
			end
		end
		--ground
		local reflect = should_ground()
		if reflect then
			if reflect ~= "wait" then
				_Cast(204336)
			end
		end
	end
	if InterruptID == 6552 then
		--reflect
		local reflect_ready = _spellCooldown(23920) == 0 or UnitBuffID("player",23920)
		wait_for_reflect=false
		if reflect_ready then
			-- no_combat_debug = true --disable or enable this to test while dueling
			local reflect = should_reflect()
			if reflect then
				if reflect == "wait" then
					wait_for_reflect = true
				else
					reflect=GetSpellInfo(reflect)
					if _Cast(23920) then
						Squid_Alert("Spell Reflection","("..reflect..")",2)
					end
					wait_for_reflect = false
				end
			end
		end
		local intervene_ready = _spellCooldown(3411) == 0 or UnitBuffID(ourHealer, 147833)
		wait_for_intervene = false
		if intervene_ready then
			local intervene = should_intervene()
			if intervene and _LoS('player', ourHealer) and _distance('player', ourHealer) <= 25 then
				if intervene == 'wait' then
					wait_for_intervene = true
				else
					intervene = GetSpellInfo(intervene)
					if _Cast(3411, ourHealer) then
						Squid_Alert("Intervene","("..intervene..")",2)
					end
					wait_for_intervene = false
				end
			end
		end
		if SQUID.bs_cancel == nil then
			SQUID.bs_cancel = true
		end
		--pummel
		if not wait_for_reflect then
			for i=1,#Enemies do
				if PhysicalInterrupt(Enemies[i]) and _meleeRange(Enemies[i]) and _spellCooldown(6552) == 0 then
					if SQUID.bs_cancel then
						RunMacroText("/cancelaura bladestorm")
					end
					_Cast(6552,Enemies[i],nil,true);
				end
			end
		end
	end
	--Nether Ward
	if select(2, UnitClass('player')) == 'WARLOCK' and IsPlayerSpell(212295) and IsUsableSpell(212295) then
		local ward_ready = _spellCooldown(212295) == 0 or UnitBuffID("player", 212295)
		wait_for_ward = false
		if ward_ready then
			-- no_combat_debug = true --disable or enable this to test while dueling
			local ward = should_ward()
			if ward then
				if ward == "wait" then
					wait_for_ward = true
				else
					ward = GetSpellInfo(ward)
					if _Cast(212295) then
						Squid_Alert("Nether Ward","("..ward..")",2)
					end
					wait_for_ward = false
				end
			end
		end
	end
	if IsUsableSpell("Spell Lock") then
		--spell lock
		for i=1,#Enemies do
			if Interrupt(Enemies[i]) then
				SQ_CastSpellByName("Spell Lock",Enemies[i])
			end
			local ss = Basic_Spellsteal(Enemies[i]) 
			if ss then
				SQ_CastSpellByID(19505,Enemies[i])
			end
		end
	end
	--pala pve
	if select(2,UnitClass("player")) == "PALADIN" then
		if not arena and instance_type ~= "pvp" then

			--hpal pve
			if _isHealer("player") then

				local function pve_cleanse(unit)
					return PvE_Dispel(unit,{"Poison","Disease","Magic"})
				end

				-- hpal pve dispels
				for i=1,#Friends do
					local f = Friends[i]
					local d = pve_cleanse(f)
					if d and _Cast(4987,f) then
						Squid_Alert("Cleanse",GetSpellInfo(d),4,nil,4987)
					end
				end

				local cs_cd = _spellCooldown(96231)
				local hoj_cd = _spellCooldown(853)

				--latency & travel time delay
				local frame_buffer = 2 / GetFramerate() -- 2 frame buffer
				local background_delay = (not IsForeground() and frame_buffer or 0)
				local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + .1 -- latency + frame buffer + interrupt travel time + 90 ms safety net

				-- hpal pve interrupts
				for i=1,#Enemies do
					local e = Enemies[i]
					local int,id = PvE_Interrupt(e)
					if int and not id then id = UnitClass(e) end

					if _LoS(e) then
						
						if int == "int_late_or_cc" then

							local cast_time_left = _castTimeLeft(e) 

							if hoj_cd == 0 and _distance(e) <= 10 then
								SpellStopCasting()
								if not unit_casting_info("player") and not UnitChannelInfo("player") then	
									local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
									if spell and spell ~= "nil" then
										Squid_Alert_Big("HoJ",spell,nil,nil,853)
									end
									_Cast(853,e)
								end
							end

						elseif int == "int_early_or_cc" then

							local cast_time_complete = _castTimeComplete(e)

							if hoj_cd == 0 and _distance(e) <= 10 then
								SpellStopCasting()
								if not unit_casting_info("player") and not UnitChannelInfo("player") then	
									local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
									if spell and spell ~= "nil" then
										Squid_Alert_Big("HoJ",spell,nil,nil,853)
									end
									_Cast(853,e)
								end
							end

						elseif int == "cc" then

							if hoj_cd == 0 and _distance(e) <= 10 then
								SpellStopCasting()
								if not unit_casting_info("player") and not UnitChannelInfo("player") then	
									local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
									if spell and spell ~= "nil" then
										Squid_Alert_Big("HoJ",spell,nil,nil,853)
									end
									_Cast(853,e)
								end
							end

						end

					end
				end

			-- ret pve
			else
				local cs_cd = _spellCooldown(96231)
				local hoj_cd = _spellCooldown(853)

				--latency & travel time delay
				local frame_buffer = 2 / GetFramerate() -- 2 frame buffer
				local background_delay = (not IsForeground() and frame_buffer or 0)
				local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + .1 -- latency + frame buffer + interrupt travel time + 90 ms safety net

				local function pve_cleanse(unit)
					return PvE_Dispel(unit,{"Poison"})
				end

				-- ret pve dispels
				for i=1,#Friends do
					local f = Friends[i]
					local d = pve_cleanse(f)
					if d and _Cast(213644,f) then
						Squid_Alert("Cleanse",GetSpellInfo(d),4,nil,213644)
					end
				end

				--ret pve interrupts
				for i=1,#Enemies do
					local e = Enemies[i]
					local int,id = PvE_Interrupt(e)
					if int and not id then id = UnitClass(e) end

					if _LoS(e) then
						
						if int == "int" then

							if cs_cd == 0 then
								SpellStopCasting()
								SQ_CastSpellByID(96231,e)
							end

						elseif int == "int_late_or_cc" then

							local cast_time_left = _castTimeLeft(e) 

							if cs_cd <= max ( 0, cast_time_left - interruptNetDelay ) then
								if cast_time_left <= interruptNetDelay then
									SpellStopCasting()
									SQ_CastSpellByID(96231,e)
								end
							elseif hoj_cd == 0 and cs_cd < 14.8 and _distance(e) <= 10 then
								SpellStopCasting()
								if not unit_casting_info("player") and not UnitChannelInfo("player") then	
									local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
									if spell and spell ~= "nil" then
										Squid_Alert_Big("HoJ",spell,nil,nil,853)
									end
									_Cast(853,e)
								end
							end

						elseif int == "int_early_or_cc" then

							local cast_time_complete = _castTimeComplete(e)

							if cs_cd == 0 then
								if cast_time_complete >= minDelayTime then
									SpellStopCasting()
									SQ_CastSpellByID(96231,e)
								end
							elseif hoj_cd == 0 and cs_cd < 14.8 and _distance(e) <= 10 then
								SpellStopCasting()
								if not unit_casting_info("player") and not UnitChannelInfo("player") then	
									local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
									if spell and spell ~= "nil" then
										Squid_Alert_Big("HoJ",spell,nil,nil,853)
									end
									_Cast(853,e)
								end
							end

						elseif int == "cc" then

							if hoj_cd == 0 and _distance(e) <= 10 then
								SpellStopCasting()
								if not unit_casting_info("player") and not UnitChannelInfo("player") then	
									local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
									if spell and spell ~= "nil" then
										Squid_Alert_Big("HoJ",spell,nil,nil,853)
									end
									_Cast(853,e)
								end
							end

						end

					end
				end
			end
		end
	end

	--use healthstone
	if not SQUID.dont_healthstone and GetItemCount(5512) > 0 then
		if _HP("player") <= 22 and select(2,GetItemCooldown(5512)) == 0 then
			UseItemByName(tostring(GetItemInfo(5512)));
			Squid_Alert("Healthstone",nil,nil,nil,5512)
		end
	end

	local map_id = GetMapId()

	local horrific_vision
	if map_id == 2212 then
		horrific_vision = "Orgrimmar"
	elseif map_id == 2213 then
		horrific_vision = "Stormwind"
	end

	--use health pot
	if (GetNumGroupMembers() >= 5 or horrific_vision) and instance_type ~= "none" then
		if GetItemCount(169451) > 0 then
			if _HP("player") <= 35 and select(2,GetItemCooldown(169451)) == 0 then
				UseItemByName(tostring(GetItemInfo(169451)))
				Squid_Alert("Abyssal Healing Potion",nil,nil,nil,301308)
			end
		end
	end

	if SquidPaused and time-SquidPaused < .3 then return end

	--Define ourHealer
	ourHealer=nil
	for i=1,#Friends do
		if _isHealer(Friends[i]) then
			ourHealer = Friends[i]
		end
	end

	rogueExists=nil
	for i=1,3 do if UnitExists("arena"..i) and select(2,UnitClass("arena"..i)) == "ROGUE" then rogueExists="arena"..i end end 

	--Rotate
	if not SquidFrame then SquidFrame = 0 end
	if SquidFrame >= 2 and not UnitIsDeadOrGhost("player") then

		local class = select(2,UnitClass("player"))
		local spec = GetSpecialization()

		--Death Knight
		if class == "DEATHKNIGHT" then
			Squid_DeathKnight()
		end
		--Druid
		if class == "DRUID" then
			Squid_Druid()
		end
		--Paladin
		if class == "PALADIN" then
			Squid_Paladin()
		end
		--Rogue
		if class == "ROGUE" then
			local function is_charmed(unit)
				local charmbuffs = {
					269131,	-- SOTS 3rd boss MC
				}
				return _buffFromTable(unit,charmbuffs)
			end
			--player detected, combat happening
			local enemy_player_exists = arena
			if not enemy_player_exists and instance_type ~= "party" then
				for i=1,#Enemies do if unit_is_player(Enemies[i]) and not UnitIsCharmed(Enemies[i]) and not is_charmed(Enemies[i]) then
					if unit_is_unit(UnitTarget(Enemies[i]),"player") or unit_is_unit(Enemies[i],current_target) then
						enemy_player_exists = true
						break
					end
				end end
			end
			--alert user when rotation mode changes
			if Current_Rogue_Rotation then
				if not Last_Rogue_Rotation then
					Last_Rogue_Rotation = Current_Rogue_Rotation
					Squid_Alert_Big(Current_Rogue_Rotation .. " Rotation Loaded")
				else
					if Last_Rogue_Rotation ~= Current_Rogue_Rotation then
						Squid_Alert_Big(Current_Rogue_Rotation .. " Rotation Loaded")
						Last_Rogue_Rotation = Current_Rogue_Rotation
					end
				end
			end
			--Assa
			if spec == 1 then
				--run rotation
				if not Rogue_Rotation_Override then
					if enemy_player_exists then
						Current_Rogue_Rotation = "Assassination PvP"
						Squid_Rogue()
					else
						Current_Rogue_Rotation = "Assassination PvE"
						Squid_Rogue()
					end
				else
					if Rogue_Rotation_Override == "Assassination PvP" then
						Squid_Rogue()
					else
						Squid_Rogue()
					end
				end
			end
			--Outlaw
			if spec == 2 then
				--run rotation
				if not Rogue_Rotation_Override then
					if enemy_player_exists then
						Current_Rogue_Rotation = "Outlaw PvP"
						Squid_Rogue()
					else
						Current_Rogue_Rotation = "Outlaw PvE"
						Squid_Rogue()
					end
				else
					if Rogue_Rotation_Override == "Outlaw PvP" then
						Squid_Rogue()
					else
						Squid_Rogue()
					end
				end
			end
			--Sub
			if spec == 3 then
				--run rotation
				if not Rogue_Rotation_Override then
					if enemy_player_exists then
						Current_Rogue_Rotation = "Sub PvP"
						if not SQUID.i_am_xen then
							Squid_SubPvE()
						else
							Current_Rogue_Rotation = "Sub PvP"
							Squid_SubPvP()
						end
						-- Squid_SubPvE()
					else
						Current_Rogue_Rotation = "Sub PvE"
						if not SQUID.i_am_xen then
							Squid_SubPvE()
						else
							Current_Rogue_Rotation = "Sub PvP"
							Squid_SubPvP()
						end
					end
				else
					if Rogue_Rotation_Override == "PvP" then
						Squid_SubPvE()
					else
						Squid_SubPvE()
					end
				end
			end
		end
		--Demon Hunter
		if class == "DEMONHUNTER" then
			Squid_DemonHunter()
		end
		--Warrior
		if class == "WARRIOR" then
			Squid_Warrior()
		end
		--Hunter
		if class == "HUNTER" then
			Squid_Hunter()
		end
		--Shaman
		if class == "SHAMAN" then
			Squid_Shaman()
		end
		--Monk
		if class == "MONK" then
			Squid_Monk()
		end
		--Mage
		if class == "MAGE" then

			--Arcane Mage
			if spec == 1 then
				Squid_ArcaneMagePvP()
			end

			--Fire Mage
			if spec == 2 then

				local function is_charmed(unit)
					local charmbuffs = {
						269131,	-- SOTS 3rd boss MC
					}
					return _buffFromTable(unit,charmbuffs)
				end

				--player detected
				local enemy_player_exists = arena
				if not enemy_player_exists and instance_type ~= "party" then
					for i=1,#Enemies do if unit_is_player(Enemies[i]) and not UnitIsCharmed(Enemies[i]) and not is_charmed(Enemies[i]) then
						if unit_is_unit(UnitTarget(Enemies[i]),"player") or unit_is_unit(Enemies[i],current_target) then
							enemy_player_exists = true
							break
						end
					end end
				end

				--alert user when rotation mode changes
				if Current_Mage_Rotation then
					if not Last_Mage_Rotation then
						Last_Mage_Rotation = Current_Mage_Rotation
						Squid_Alert_Big(Current_Mage_Rotation .. " Rotation Loaded")
					else
						if Last_Mage_Rotation ~= Current_Mage_Rotation then
							Squid_Alert_Big(Current_Mage_Rotation .. " Rotation Loaded")
							Last_Mage_Rotation = Current_Mage_Rotation
						end
					end
				end

				--run rotation
				if not Mage_Rotation_Override then
					if enemy_player_exists or spec ~= 2 then
						Current_Mage_Rotation = "PvP"
						Squid_FireMagePvP()
					else
						Current_Mage_Rotation = "PvE"
						Squid_FireMagePvE()
					end
				else
					if Mage_Rotation_Override == "PvP" then
						Squid_FireMagePvP()
					else
						Squid_FireMagePvE()
					end
				end

			end

			--Frost Mage
			if spec == 3 then
				Squid_FrostMagePvP()
			end

		end
		--Priest
		if class == "PRIEST" then
			Squid_Priest()
		end
		--Warlock
		if class == "WARLOCK" then

	    --Affliction Warlock
			if spec == 1 then
				--player detected
				local enemy_player_exists = arena
				if not enemy_player_exists and instance_type ~= "party" then
					for i=1,#Enemies do if unit_is_player(Enemies[i]) and not UnitIsCharmed(Enemies[i]) and not is_charmed(Enemies[i]) then
						if unit_is_unit(UnitTarget(Enemies[i]),"player") or unit_is_unit(Enemies[i],current_target) then
							enemy_player_exists = true
							break
						end
					end end
				end

				--alert user when rotation mode changes
				if Current_Warlock_Rotation then
					if not Last_Warlock_Rotation then
						Last_Warlock_Rotation = Current_Warlock_Rotation
						Squid_Alert_Big(Current_Warlock_Rotation .. " Rotation Loaded")
					else
						if Last_Warlock_Rotation ~= Current_Warlock_Rotation then
							Squid_Alert_Big(Current_Warlock_Rotation .. " Rotation Loaded")
							Last_Warlock_Rotation = Current_Warlock_Rotation
						end
					end
				end

				--run rotation
				if not Warlock_Rotation_Override then
					if enemy_player_exists or spec ~= 2 then
						Current_Warlock_Rotation = "PvP"
						--Squid_AfflictionWarlockPvP()
						Squid_Warlock()
					else 
						Squid_Warlock()
					end
				else
					if Warlock_Rotation_Override == "PvP" then
						--Squid_AfflictionWarlockPvP()
						Squid_Warlock()
					else
						Squid_Warlock()
					end
				end

			end		
		end

		if IsEquippedItem(169311) and not _stealthCheck("player") and not UnitChannelInfo("player") and not unit_casting_info("player") and player_has_control() then	
			if UnitIsVisible(current_target) and unit_can_attack("player",current_target) then
				local stacks = _debuffStacks(current_target,303568,"player")
				if GetItemCD(169311) <= 1 then
					if stacks == 0 then
						UseItemByName(tostring(GetItemInfo(169311)),current_target)
					elseif (_CDcheck("player") and stacks >= 10) or _HP(current_target) < 35 then
						UseItemByName(tostring(GetItemInfo(169311)),current_target)
					end
				end
			end
		end

		SquidFrame=0;

	else
		SquidFrame=SquidFrame+1;
	end

end)

--Squid Trinket
function SquidTrinket()
	
	local ccr = _CCremains("player")
	local sr = _stunRemains("player")

	if sr >= max(1,ccr) and not _silenceCheck("player") then
		SQ_CastSpellByName("Will to Survive")
		Squid_Alert("Human Trinket","Manual")
	end

	if ccr >= .5 then
		UseItemByName(tostring(GetItemInfo(184052))) -- Sinful Aspirant's Medallion
		UseItemByName(tostring(GetItemInfo(181333))) -- Sinful Gladiator's Medallion

		Squid_Alert("Trinket","Manual")
	end
endfunction Squid_Rogue()
	
	if IsMounted() then return end
	local locale = GetLocale()
	local L = {}
	if locale == "zhCN" then
		L["Stealth"] = ""
	else
		L["Stealth"] = "Stealth"
	end

	local spec = GetSpecialization()

	--Assassination
	if spec == 1 then

		local time = GetTime()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
		local gcd_remains = GetGCD()
		local Energy = UnitPower("player")
		local EnergyDeficit = UnitPowerMax("player")-Energy
		local ComboPoints = UnitPower("player",4)
		local ComboPointsMax = UnitPowerMax("player",4)
		local ComboPointsDeficit = ComboPointsMax-ComboPoints
		local Stealth = UnitBuffID("player",115191) or UnitBuffID("player",1784)
		local IsSubterfuge = IsPlayerSpell(108208)
		local Subterfuge = UnitBuffID("player",115192)
		local SubterfugeRemains = _buffRemains("player",115192)
		local Vanish = UnitBuffID("player",11327)
		local Evasion = UnitBuffID("player",5277)
		local Cloak = UnitBuffID("player",31224)
		local Sprint = UnitBuffID("player",2983)
		local vendetta_cd = _spellCooldown(79140)
		local bcc = _bccAM(16)
		local fan_of_knives = EnemiesAroundMe(10)
		local marked_for_death = IsPlayerSpell(137619)
		local marked_for_death_cd = _spellCooldown(137619)
		local vanish_cd = _spellCooldown(1856)
		local blind_cd = _spellCooldown(2094)

		local S = Stealth or Subterfuge

		local function _valid(unit,immune) 
			return unit 
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit) 
			and not _breakableCC(unit)
			and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
			and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
		end

		local t = current_target 

		local valid_physical_target = _valid(t,1)
		local valid_magical_target = _valid(t,2)
		local valid_target = _valid(t,3)

		local target_kidney = valid_physical_target and _debuffRemains(t,408) > .3

		local moving_towards_time = moving_towards_unit_duration(t,.11)
		local moving_towards = _movingTowards(t,.11)
		local moving_towards_target = valid_physical_target and moving_towards and moving_towards_time > .135

		local target_hp = _HP(t)

		local enemy_player_around
		for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then
			enemy_player_around=true
			break;
		end end

		local poisoned_bleeds = 0
		local rupture_count = 0
		local garrote_count = 0
		for i=1,#Enemies do
			--poisoned
			if UnitDebuffID(Enemies[i],3409,"player") or UnitDebuffID(Enemies[i],2818,"player") or UnitDebuffID(Enemies[i],8680,"player") then
				--count each bleed
				--garrote
				if UnitDebuffID(Enemies[i],703,"player") then
					poisoned_bleeds=poisoned_bleeds+1
					garrote_count=garrote_count+1
				end
				--rupture
				if UnitDebuffID(Enemies[i],1943,"player") then
					poisoned_bleeds=poisoned_bleeds+1
					rupture_count=rupture_count+1
				end
				--internal bleeding
				if UnitDebuffID(Enemies[i],154953,"player") then
					poisoned_bleeds=poisoned_bleeds+1
				end
			end
		end

		local energy_regen_combined = GetPowerRegen()+poisoned_bleeds*7/(2*UnitSpellHaste("player"))

		local energy_time_to_max = EnergyDeficit / energy_regen_combined

		function Sappable(unit)
			return not _hasDot(unit) and not UnitAffectingCombat(unit) and _incapacitateDR(unit) >= .25
		end

		function CCAvailable(unit)
			local canblind
			local blind = blind_cd <= gcd
			local vanish = vanish_cd <= gcd
			local sap = S
			
			local cc = 0

			if blind and _disorientDR(unit) == 1 then
				canblind=true
				cc = cc + 8
			end

			if vanish then
				local stundr = _stunDR(unit)
				local silencedr = _silenceDR(unit)
				if stundr >= .5 then
					cc = cc + (stundr*4)
				end
				if silencedr >= .5 then
					cc = cc + (silencedr*3)
				end
			end

			if Sappable(unit) or (vanish and (canblind or UnitDebuffID(unit,2094))) then
				local dr = _incapacitateDR(unit)
				cc = cc + (dr*8)
			end

			return cc
		end

		-- function LockDown(unit)

		-- end

		--Stomp
		local function Stomp(totem,name)
			if S then return false; end
			local hp = UnitHealth(totem)
			local maxhp = UnitHealthMax(totem)
			if hp <= 1 then return false; end
			--Poisoned knife
			if hp <= 2000 then 
				if _Cast(185565,totem,nil,true) then
					Squid_Alert_Big(name .. " Stomped","(Throw)",1,3.5,185565)
				end
			else
			--mutilate
				if _Cast(1752,totem,nil,true) then
					Squid_Alert_Big(name .. " Stomped","(Mutilate)",1,3.5,1752)
				end
			end
		end

		local totems = {
		101398,	--Psyfiend
		119052,	--War Banner
		104818,	--Ancestral Protection Totem
		53006,	--Spirit Link Totem
		2630,	--Earthbind Totem
		60561,	--Earthgrab Totem
		-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
		5925,	--Grounding Totem
		105425,	--Skyfury Totem
		5913,	--Tremor Totem
		105451,	--Counterstrike Totem
		}

		if arena then
			for i=1,#Pets do
				local e = Pets[i]
				local name = UnitName(e);
				local id = UnitCreatureID(e)
				--only kill cap totems when they're casting
				if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
					Stomp(e,name)
				end
			end
		end

		local mainTarget = {};
		for i=1,#Enemies do
			local e=Enemies[i];
			if (arena or _isDummy(e) or UnitAffectingCombat(e))
			and not _breakableCC(e) then
				local priority=100;
				if unit_is_unit(e,"target") then
					priority=priority-1;
				end
				local d = _distance(e)
				--lowest dot duration
				local garrote = _debuffRemains(e,703,"player")
				local rupture = _debuffRemains(e,1943,"player")
				local dottime = garrote + rupture
				local gp = _garrotePower(e)
				priority = priority + dottime
				table.insert(mainTarget,{pointer=e,priority=priority,gp=gp,garrote=garrote,rupture=rupture,distance=d,hp=_HP(e)});
			end
		end
		table.sort(mainTarget, function(x,y) return x.priority < y.priority or (x.priority == y.priority and x.hp < y.hp) end)

		--Poisons
		local dp = _buffRemains("player",2823)
		local wp = _buffRemains("player",8679)
		local cp = _buffRemains("player",3408)

		local playercast = UnitCastingInfo("player")

		if playercast and strmatch(playercast,"poison") then
			poisonapplied=time
		end

		--generally doing pvp if internal bleeding
		if arena or IsPlayerSpell(154904) then
			if wp <= 3000 and dp <= 3000 then
				if not poisonapplied or time-poisonapplied > .3 then
					_Cast(8679)
					poisonapplied=time
				end
			end
		else
			if wp <= 3000 and dp <= 3000 then
				if not poisonapplied or time-poisonapplied > .3 then
					_Cast(2823)
					poisonapplied=time
				end
			end
		end

		if cp <= 120 then
			if not poisonapplied or time-poisonapplied > .3 then
				_Cast(3408)
				poisonapplied=time
			end
		end

		--CC Trinket
		local trinketPointer
		local recentTrinket
		for i=1,#TrinketTracker do
			local pointer = TrinketTracker[i].pointer
			local trinketTime = TrinketTracker[i].time
			if UnitIsVisible(pointer) and _isHealer(pointer) then
				recentTrinket = time-trinketTime <= gcd*2
				timeSinceTrinket = time-trinketTime
				trinketPointer = pointer
			end
		end

		if recentTrinket then
			if trinketPointer and not unit_is_unit(trinketPointer,"target") and _LoS(trinketPointer) and not DoNotBCC(trinketPointer) and gcd_remains <= .25 then
				--Blind
				if _spellCooldown(2094) <= gcd and _disorientDR(trinketPointer) == 1 then
					if _realDistance(trinketPointer) <= 15 then
						if _Cast(2094,trinketPointer,nil,true) then
							if locale == "zhCN" then
								Squid_Alert_Big(">>", UnitClass(trinketPointer).. " ()",2,3.5,2094)
							else
								Squid_Alert_Big("Blinded " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,2094)
							end
						end
						return
					else
						_Cast(36554,trinketPointer)
						C_Timer.After(.03,function() 
							if _Cast(2094,trinketPointer,nil,true) then 
								if locale == "zhCN" then
									Squid_Alert_Big(">>", UnitClass(trinketPointer).. " ()",2,3.5,2094)
								else
									Squid_Alert_Big("Blinded " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,2094)
								end
							end
						end)
					end
				end
				--Sap
				if (timeSinceTrinket <= gcd or S or Vanish) and Energy >= 35 and not UnitAffectingCombat(trinketPointer) and _incapacitateDR(trinketPointer) >= lowestEnemy / 100 and not _CCcheck(trinketPointer) then
					if vanish_cd == 0 or S or Vanish then
						if _realDistance(trinketPointer) <= 10 then
							if not S and _Cast(1856) then
								Squid_Alert("Vanish",nil,nil,nil,1856)
							end
							if S or Vanish then
								CastSpellByID(6770,trinketPointer)
								if _Cast(6770,trinketPointer,nil,true) then
									Squid_Alert_Big("Sapped " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,6770)
								end
							end
							return
						else
							_Cast(36554,trinketPointer)
							C_Timer.After(.03,function() 
								if _Cast(6770,trinketPointer,nil,true) then
									Squid_Alert_Big("Sapped " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,6770)
								end
							end)
						end
					end
				end
			end
		end

		-- if current_focus then
		-- 	if _distance(current_focus) <= 10 then
		-- 		_Cast(6770,current_focus,nil,true)
		-- 	else
		-- 		_Cast(36554,current_focus)
		-- 		C_Timer.After(.05,function() _Cast(6770,current_focus,nil,true) end)
		-- 	end
		-- end

		--sap followup
		if vanish_cd == 0 or S or Vanish then
			for i=1,#Enemies do if _isHealer(Enemies[i]) or not theirHealer then
				local cc = _CCremains(Enemies[i])
				if cc > 0 and not UnitAffectingCombat(Enemies[i]) and not _isDummy(Enemies[i]) then
					local dr = _incapacitateDR(Enemies[i])
					if cc < 1.1 and gcd_remains < cc and dr >= .25 then
						if _distance(Enemies[i]) <= 10 then
							if dr == 1 and not S 
							and (not mage_on_team_casting_cc or (mage_cc_tar and not unit_is_unit(mage_cc_tar,Enemies[i]))) then
								if _Cast(1856) then
									Squid_Alert("Vanish",nil,nil,3.5,1856)
								end
							end
							if S or Vanish then
								if _Cast(6770,Enemies[i],nil,true) then
									Squid_Alert_Big("Sapped " .. UnitClass(Enemies[i]),"(Followup)",nil,nil,6770)
								end
							end
							return
						else
							if dr == 1 then
								_Cast(36554,Enemies[i])
							end
						end
					end
				end
			end end
		end

		--Sap Stealth
		for i=1,#Enemies do
			if _stealthCheck(Enemies[i]) and Sappable(Enemies[i]) then
				if _Cast(6770,Enemies[i],nil,true) then
					Squid_Alert_Big("Sap " .. UnitClass(Enemies[i]),"(Stealth)",4,nil,6770)
				end
			end
		end

		local ourHealerCC
		if ourHealer and _CCcheck(ourHealer) then
			ourHealerCC=true
		end

		local total,melee,ranged,cds = EnemiesAttacking("player")
		local defensive_hp = 60
		defensive_hp=defensive_hp+(ourHealerCC and 35 or 0)
		local currenthp = _HP("player")

		--defensives
		local function defensives()
			if (not target_kidney or (currenthp < 25 and target_hp > 30)) and IsPlayerSpell(79008) and _spellCooldown(1966) <= gcd_remains and not _immuneCheck("player") and (currenthp < 30 or EnemiesAttacking("player") > 0) then
				if _Cast(1966) then
					Squid_Alert("Feint","Danger",2)
				end
			end
			defensive_hp=defensive_hp+10
			if currenthp < 80 and currenthp < defensive_hp then
				if _Cast(185311) then
					Squid_Alert("Crimson Vial",nil,nil,nil,185311)
				end
			end
			if AutoFollow and currenthp < 40 then
				_Cast(31224)
				_Cast(5277)
			end
		end

		if currenthp <= defensive_hp and not Stealth and not Vanish then
			if not Evasion and not Cloak then
				defensives()
			else
				local total,melee,ranged,cds = EnemiesAttacking("player")
				if (not Evasion or ranged > 0) and (not Cloak or melee > 0) then
					defensives()
				end
			end
		end

		--Stealth with enemy player around
		if enemy_player_around and IsUsableSpell("Stealth") then
			if not Stealth and (not UnitAffectingCombat("player") or Vanish) and _spellCooldown(1784) == 0 then
				if _spellCooldown(1784) == 0 and _Cast(1784) then
					Squid_Alert("Stealth",nil,nil,nil,1784)
				end
				return
			end
		end

		if valid_target then

			--Stealth
			if not Stealth and IsUsableSpell(L["Stealth"]) and (not UnitAffectingCombat("player") or Vanish) and _spellCooldown(1784) == 0 then
				_Cast(1784)
				return
			end

			local target_is_dummy = _isDummy(t)

			local snapshot = GetCurrentSnapshot()
			local garrote_ticking = UnitDebuffID(t,703,"player")
			local rupture_remains = _debuffRemains(t,1943,"player")
			local rupture_ticking = rupture_remains > 0
			local garrote_remains = _debuffRemains(t,703,"player")
			local vendetta_up = UnitDebuffID(t,79140,"player")
			local toxic_blade_up = UnitDebuffID(t,245389,"player")
			local garrote_power = _garrotePower(t)
			
			local kidney_cd = _spellCooldown(408)

			local vanish_up = _spellCooldown(1856) == 0

			local shrouded_suffocation = AzeritePowerTaken(408)
			local scent_of_blood = AzeritePowerTaken(406)
			local double_dose = AzeritePowerTaken(136)
			local function poison_ticking(unit) return UnitDebuffID(unit,2818,"player") or UnitDebuffID(unit,8680,"player") end

			-- # Executed every time the actor is available.
			-- # Restealth if possible (no vulnerable enemies in combat)
			-- actions=stealth
			-- actions+=/variable,name=energy_regen_combined,value=energy.regen+poisoned_bleeds*7%(2*spell_haste)
			-- actions+=/variable,name=single_target,value=spell_targets.fan_of_knives<2
			local single_target = (arena and not spread) or fan_of_knives < 2 or bcc or target_is_dummy-- or _isDummy(t)
			-- actions+=/use_item,name=azsharas_font_of_power,if=!stealthed.all&master_assassin_remains=0&cooldown.vendetta.remains<10&!debuff.vendetta.up&!debuff.toxic_blade.up
			local Nightstalker = IsPlayerSpell(14062)
			local MasterAssassin = IsPlayerSpell(255989)
			local IsSubterfuge = IsPlayerSpell(108208)
			local Exsanguinate = IsPlayerSpell(200806)
			local deeper_stratagem = IsPlayerSpell(193531)
			local venom_rush = IsPlayerSpell(152152)
			local master_assassin_enabled = IsPlayerSpell(255989)

			local mage_on_team
			local mage_on_team_casting_cc
			local mage_cc_tar
			if arena then
				for i=1,#Friends do if UnitClass(Friends[i]) == "Mage" then mage_on_team=Friends[i] end end
			end

			if mage_on_team then
				local cast = UnitCastingInfo(mage_on_team)
				if cast == "Polymorph" or cast == "Ring of Frost" then
					mage_on_team_casting_cc=true
					mage_cc_tar=UnitSpellTarget(mage_on_team)
				end
			end

			local stundr = _stunDR(t)
			local drremains = _drRemains(t,"stun")

			time_to_max_cp=nil
			if not time_to_max_cp then
				local rounded_max_cp = ComboPointsDeficit
				if rounded_max_cp % 2 ~= 0 then rounded_max_cp = rounded_max_cp + 1 end
				local gcds_req = (rounded_max_cp/2)
				local energy_gained_over_time = (energy_regen_combined*gcd)*gcds_req
				local energy_req = (gcds_req*50)-energy_gained_over_time
				local time_for_energy = (energy_req/energy_regen_combined)-(Energy / energy_regen_combined)
				time_to_max_cp = gcds_req * gcd + time_for_energy
			end
			if time_to_max_cp < 0 then time_to_max_cp=0 end

			total_time_to_max_cp=nil
			if not total_time_to_max_cp then
				local rounded_max_cp = 6
				local gcds_req = (rounded_max_cp/2)
				local energy_gained_over_time = (energy_regen_combined*gcd)*gcds_req
				local energy_req = (gcds_req*50)-energy_gained_over_time
				local time_for_energy = (energy_req/energy_regen_combined)-(Energy / energy_regen_combined)
				total_time_to_max_cp = gcds_req * gcd + time_for_energy
			end
			if total_time_to_max_cp < 0 then total_time_to_max_cp=0 end

			time_to_next_max_cp=nil
			if not time_to_next_max_cp then
				local rounded_max_cp = ComboPointsDeficit + ComboPointsMax
				if rounded_max_cp % 2 ~= 0 then rounded_max_cp = rounded_max_cp + 1 end
				local gcds_req = (rounded_max_cp/2)
				local energy_gained_over_time = (energy_regen_combined*gcd)*gcds_req
				local energy_req = (gcds_req*50)-energy_gained_over_time
				local time_for_energy = (energy_req/energy_regen_combined)-(Energy / energy_regen_combined)
				time_to_next_max_cp = gcds_req * gcd + time_for_energy
			end
			if time_to_next_max_cp < 0 then time_to_next_max_cp=0 end

			local waiting_for_kidney
			local hold_cp_for_kidney
			local hold_energy_for_kidney
			local hold_gcd_for_kidney
			local kidney_ready
			kidney_countdown = 0

			--pool energy and dont build cp if mfd off cd soon and at 0 cp
			if ComboPoints == 0 and marked_for_death and marked_for_death_cd <= gcd*2 and marked_for_death_cd <= energy_time_to_max then
				hold_energy_for_kidney=true
			end

			local function kidney(t)

				if UnitIsPlayer(t) or target_is_dummy then
					local isret = UnitClass(t) == "Paladin" and _isMeleeDps(t)
					if isret and theirHealer and _CCremains(theirHealer) < 2 then
						return false
					end
				else
					return false 
				end

				local sr = _stunRemains(t)
				--go kidney
				if (stundr == 1 or (sr > 0 and sr <= gcd and stundr >= .5)) and not _immuneStuns(t) and valid_physical_target then
					if kidney_cd <= gcd and (_meleeRange(t) or _spellCooldown(36554) == 0) then
						kidney_ready = true
					end
					if ComboPointsDeficit == 0 then
						local d = _distance(t)
						local lockout = IsLocked(t,true)
						if lockout < gcd or PhysicalInterrupt(t,true,20) then
							if _Cast(408,t,true) then
								-- Squid_Alert("Kidney Shot " .. UnitClass(t),nil,2)
							end
						end
					end
				end

				local waiting_for = {}
				table.insert(waiting_for,kidney_cd)
				table.insert(waiting_for,drremains)
				table.sort(waiting_for,function(x,y) return x > y end)

				kidney_countdown = waiting_for[1] or 0

				kidney_countdown = math.ceil(kidney_countdown + time_to_max_cp)

				if kidney_countdown <= time_to_next_max_cp-1.8 and _spellCooldown(137619) > kidney_countdown then
					waiting_for_kidney=true
					hold_cp_for_kidney=true
					if energy_time_to_max > 5 and ComboPointsDeficit == 0 then
						hold_energy_for_kidney=true
					end
					if kidney_countdown <= gcd and ComboPointsDeficit == 0 then
						hold_gcd_for_kidney=true
					end
				end

				if kidney_countdown then
					kidney_countdown = math.floor(kidney_countdown)
					if (kidney_countdown == 5 or kidney_countdown == 1) and kidney_countdown > 0 then
						if locale == "zhCN" then
							Squid_Alert_Big(kidney_countdown .. "",nil,nil,4.5,408)
						else
							Squid_Alert_Big("Kidney Shot Soon","(".. kidney_countdown .. ")",nil,4.5,408)
						end
					end
					-- if kidney_countdown == 1 and ComboPoints >= 5 then
					-- 	Squid_Alert("Kidney Shot Ready","(Now)",nil,3.5,408)
					-- end
				end

			end

			local function stealthed(t)

				-- # Stealthed Actions
				--cheap offtarget / focus
				if UnitExists(current_focus) then
					if not unit_is_unit(current_target,current_focus) then
						if _valid(current_focus) and _stunDR(current_focus) == 1 and _CCremains(current_focus) <= 1 then
							if _Cast(1833,current_focus,nil,true) then
								Squid_Alert_Big("Cheap shot " .. UnitClass(current_focus),"(Focus)",nil,nil,1833)
							end
						end
					end 
				end
				for i=1,#Enemies do 
					if not unit_is_unit(current_target,Enemies[i]) then
						if _valid(Enemies[i]) and _stunDR(Enemies[i]) == 1 and _CCremains(Enemies[i]) <= 1 then
							if _Cast(1833,Enemies[i],nil,true) then
								Squid_Alert_Big("Cheap shot " .. UnitClass(Enemies[i]),"(Off Target)",nil,nil,1833)
							end
						end
					end 
				end
				-- # Nighstalker, or Subt+Exsg on 1T: Snapshot Rupture
				-- actions.stealthed=rupture,if=combo_points>=4&(talent.nightstalker.enabled|talent.subterfuge.enabled&(talent.exsanguinate.enabled&cooldown.exsanguinate.remains<=2|!ticking)&variable.single_target)&target.time_to_die-remains>6
				if not hold_cp_for_kidney and ComboPoints >= 3 and ((Nightstalker or IsSubterfuge) and ((Exsanguinate and _spellCooldown(200806) <= 2) or not rupture_ticking)) and single_target then
					_Cast(1943,t,true)
				end
				-- # Subterfuge + Shrouded Suffocation: Ensure we use one global to apply Garrote to the main target if it is not snapshot yet, so all other main target abilities profit.
				-- actions.stealthed+=/pool_resource,for_next=1
				-- actions.stealthed+=/garrote,if=azerite.shrouded_suffocation.enabled&buff.subterfuge.up&buff.subterfuge.remains<1.3&!ss_buffed
				if (ComboPoints < 5 or not kidney_ready) and shrouded_suffocation and Subterfuge and SubterfugeRemains < 1.3 and garrote_power < snapshot then
					_Cast(703,t,true)
				end
				-- # Subterfuge: Apply or Refresh with buffed Garrotes
				-- actions.stealthed+=/pool_resource,for_next=1
				-- actions.stealthed+=/garrote,target_if=min:remains,if=talent.subterfuge.enabled&(remains<12|pmultiplier<=1)&target.time_to_die-remains>2
				if (ComboPoints < 5 or not kidney_ready) and IsSubterfuge and (garrote_remains < 12 or garrote_power <= 1) then
					_Cast(703,t,true)
				end
				-- # Subterfuge + Shrouded Suffocation in ST: Apply early Rupture that will be refreshed for pandemic
				-- actions.stealthed+=/rupture,if=talent.subterfuge.enabled&azerite.shrouded_suffocation.enabled&!dot.rupture.ticking&variable.single_target
				if not hold_cp_for_kidney and single_target and IsSubterfuge and shrouded_suffocation and not rupture_ticking then
					_Cast(1943,t,true)
				end
				-- # Subterfuge w/ Shrouded Suffocation: Reapply for bonus CP and/or extended snapshot duration.
				-- actions.stealthed+=/pool_resource,for_next=1
				-- actions.stealthed+=/garrote,target_if=min:remains,if=talent.subterfuge.enabled&azerite.shrouded_suffocation.enabled&target.time_to_die>remains&(remains<18|!ss_buffed)
				if (ComboPoints < 5 or not kidney_ready) and IsSubterfuge and shrouded_suffocation and (garrote_remains < 18 or garrote_power <= 1) then
					_Cast(703,t,true)
				end
				-- # Subterfuge + Exsg: Even override a snapshot Garrote right after Rupture before Exsanguination
				-- actions.stealthed+=/pool_resource,for_next=1
				-- actions.stealthed+=/garrote,if=talent.subterfuge.enabled&talent.exsanguinate.enabled&cooldown.exsanguinate.remains<1&prev_gcd.1.rupture&dot.rupture.remains>5+4*cp_max_spend
				if (ComboPoints < 5 or not kidney_ready) and IsSubterfuge and Exsanguinate and _spellCooldown(200806) < 1 and (lastRupture and time-lastRupture <= gcd) and rupture_remains > 5+4*ComboPointsMax then
					_Cast(703,t,true)
				end

				if (ComboPoints < 5 or not kidney_ready) and master_assassin_enabled and garrote_remains < 8 then
					_Cast(703,t,nil,true)
				end
			end

			local function essences(t)
				-- # Essences
				-- actions.essences=concentrated_flame
				if not S then
					_Cast(295373,t,true)
				end
				-- # Always use Blood with Vendetta up. Also use with TB up before a finisher (if talented) as long as it runs for 10s during Vendetta.
				-- actions.essences+=/blood_of_the_enemy,if=debuff.vendetta.up&(!talent.toxic_blade.enabled|debuff.toxic_blade.up&combo_points.deficit<=1|debuff.vendetta.remains<=10)|target.time_to_die<=10
				-- actions.essences+=/guardian_of_azeroth
				-- actions.essences+=/focused_azerite_beam,if=spell_targets.fan_of_knives>=2|raid_event.adds.in>60&energy<70
				-- actions.essences+=/purifying_blast,if=spell_targets.fan_of_knives>=2|raid_event.adds.in>60
				-- actions.essences+=/the_unbound_force
				-- actions.essences+=/ripple_in_space
				-- actions.essences+=/worldvein_resonance,if=buff.lifeblood.stack<3
				-- actions.essences+=/memory_of_lucid_dreams,if=energy<50&!cooldown.vendetta.up

			end

			local function cds(t)
				-- # Cooldowns 
				-- actions.cds=call_action_list,name=essences,if=!stealthed.all&dot.rupture.ticking&master_assassin_remains=0
				if not S and rupture_ticking and not UnitBuffID("player",256735) then
					essences(t)
				end
				-- # If adds are up, snipe the one with lowest TTD. Use when dying faster than CP deficit or without any CP.
				-- actions.cds+=/marked_for_death,target_if=min:target.time_to_die,if=raid_event.adds.up&(target.time_to_die<combo_points.deficit*1.5|combo_points.deficit>=cp_max_spend)
				-- # If no adds will die within the next 30s, use MfD on boss without any CP.
				-- actions.cds+=/marked_for_death,if=raid_event.adds.in>30-raid_event.adds.duration&combo_points.deficit>=cp_max_spend
				-- actions.cds+=/vendetta,if=!stealthed.rogue&dot.rupture.ticking&!debuff.vendetta.up&(!talent.subterfuge.enabled|!azerite.shrouded_suffocation.enabled|dot.garrote.pmultiplier>1&(spell_targets.fan_of_knives<6|!cooldown.vanish.up))&(!talent.nightstalker.enabled|!talent.exsanguinate.enabled|cooldown.exsanguinate.remains<5-2*talent.deeper_stratagem.enabled)
				if UnitLevel(t) == -1 then
					if not S and rupture_ticking and not vendetta_up then
						if (not IsSubterfuge or not shrouded_suffocation or garrote_power > 1 and (fan_of_knives < 6 or not vanish_up)) 
						and (not Nightstalker or not Exsanguinate or _spellCooldown(200806) < 5-(deeper_stratagem and 1 or 0)) then
							_Cast(79140,t,true)
						end
					end
				end
				-- # Vanish with Exsg + (Nightstalker, or Subterfuge only on 1T): Maximum CP and Exsg ready for next GCD
				-- actions.cds+=/vanish,if=talent.exsanguinate.enabled&(talent.nightstalker.enabled|talent.subterfuge.enabled&variable.single_target)&combo_points>=cp_max_spend&cooldown.exsanguinate.remains<1&(!talent.subterfuge.enabled|!azerite.shrouded_suffocation.enabled|dot.garrote.pmultiplier<=1)
				-- # Vanish with Nightstalker + No Exsg: Maximum CP and Vendetta up
				-- actions.cds+=/vanish,if=talent.nightstalker.enabled&!talent.exsanguinate.enabled&combo_points>=cp_max_spend&debuff.vendetta.up
				-- # See full comment on https://github.com/Ravenholdt-TC/Rogue/wiki/Assassination-APL-Research.
				-- actions.cds+=/variable,name=ss_vanish_condition,value=azerite.shrouded_suffocation.enabled&(non_ss_buffed_targets>=1|spell_targets.fan_of_knives=3)&(ss_buffed_targets_above_pandemic=0|spell_targets.fan_of_knives>=6)
				-- actions.cds+=/pool_resource,for_next=1,extra_amount=45
				-- actions.cds+=/vanish,if=talent.subterfuge.enabled&!stealthed.rogue&cooldown.garrote.up&(variable.ss_vanish_condition|!azerite.shrouded_suffocation.enabled&dot.garrote.refreshable)&combo_points.deficit>=((1+2*azerite.shrouded_suffocation.enabled)*spell_targets.fan_of_knives)>?4&raid_event.adds.in>12
				-- # Vanish with Master Assasin: No stealth and no active MA buff, Rupture not in refresh range, during Blood essenz if available.
				-- actions.cds+=/vanish,if=talent.master_assassin.enabled&!stealthed.all&master_assassin_remains<=0&!dot.rupture.refreshable&dot.garrote.remains>3&(!essence.blood_of_the_enemy.major|debuff.blood_of_the_enemy.up)
				-- # Shadowmeld for Shrouded Suffocation
				-- actions.cds+=/shadowmeld,if=!stealthed.all&azerite.shrouded_suffocation.enabled&dot.garrote.refreshable&dot.garrote.pmultiplier<=1&combo_points.deficit>=1
				-- # Exsanguinate when both Rupture and Garrote are up for long enough
				-- actions.cds+=/exsanguinate,if=dot.rupture.remains>4+4*cp_max_spend&!dot.garrote.refreshable
				-- actions.cds+=/toxic_blade,if=dot.rupture.ticking
				if rupture_ticking and (not hold_energy_for_kidney or (kidney_countdown > gcd and kidney_countdown < gcd*2.5)) then
					_Cast(245388,t,true)
				end
				-- actions.cds+=/potion,if=buff.bloodlust.react|debuff.vendetta.up
				-- actions.cds+=/blood_fury,if=debuff.vendetta.up
				-- actions.cds+=/berserking,if=debuff.vendetta.up
				-- actions.cds+=/fireblood,if=debuff.vendetta.up
				-- actions.cds+=/ancestral_call,if=debuff.vendetta.up
				-- actions.cds+=/use_item,name=galecallers_boon,if=cooldown.vendetta.remains>45
				-- actions.cds+=/use_item,name=ashvanes_razor_coral,if=debuff.razor_coral_debuff.down|debuff.vendetta.remains>10|target.time_to_die<20+cooldown.latent_arcana.remains
				-- actions.cds+=/use_item,name=lurkers_insidious_gift,if=debuff.vendetta.up
				-- actions.cds+=/use_item,name=lustrous_golden_plumage,if=debuff.vendetta.up
				-- actions.cds+=/use_item,effect_name=gladiators_medallion,if=debuff.vendetta.up
				-- actions.cds+=/use_item,effect_name=gladiators_badge,if=debuff.vendetta.up
				-- actions.cds+=/use_item,effect_name=cyclotronic_blast,if=master_assassin_remains=0&!debuff.vendetta.up&!debuff.toxic_blade.up&buff.memory_of_lucid_dreams.down&energy<80&dot.rupture.remains>4
				-- # Default fallback for usable items: Use on cooldown.
				-- actions.cds+=/use_items
			end

			local function dot(t)
				-- # Damage over time abilities
				-- # Limit Garrotes on non-primrary targets for the priority rotation if 5+ bleeds are already up
				-- actions.dot=variable,name=skip_cycle_garrote,value=priority_rotation&spell_targets.fan_of_knives>3&(dot.garrote.remains<cooldown.garrote.duration|poisoned_bleeds>5)
				skip_cycle_garrote = mage_on_team or (fan_of_knives > 3 and (garrote_remains <= _spellCooldown(703) or poisoned_bleeds > 5))
				-- # Limit Ruptures on non-primrary targets for the priority rotation if 5+ bleeds are already up
				-- actions.dot+=/variable,name=skip_cycle_rupture,value=priority_rotation&spell_targets.fan_of_knives>3&(debuff.toxic_blade.up|(poisoned_bleeds>5&!azerite.scent_of_blood.enabled))
				skip_cycle_rupture = mage_on_team or (fan_of_knives > 3 and (not toxic_blade_up or (poisoned_bleeds > 5 and not scent_of_blood)))
				-- # Limit Ruptures if Vendetta+Toxic Blade is up and we have 2+ seconds left on the Rupture DoT
				-- actions.dot+=/variable,name=skip_rupture,value=debuff.vendetta.up&debuff.toxic_blade.up&dot.rupture.remains>2
				skip_rupture = vendetta_up and toxic_blade_up and rupture_remains > 2
				-- # Special Rupture setup for Exsg
				-- actions.dot+=/rupture,if=talent.exsanguinate.enabled&((combo_points>=cp_max_spend&cooldown.exsanguinate.remains<1)|(!ticking&(time>10|combo_points>=2)))
				if not hold_cp_for_kidney and Exsanguinate and ((ComboPoints >= ComboPointsMax and _spellCooldown(200806) < 1) or (rupture_remains <= 2 + ComboPoints and (time_in_combat > 10 or ComboPoints >= 2))) then
					_Cast(1943,t,true)
				end
				-- # Garrote upkeep, also tries to use it as a special generator for the last CP before a finisher
				-- actions.dot+=/pool_resource,for_next=1
				-- actions.dot+=/garrote,if=(!talent.subterfuge.enabled|!(cooldown.vanish.up&cooldown.vendetta.remains<=4))&combo_points.deficit>=1+3*(azerite.shrouded_suffocation.enabled&cooldown.vanish.up)&refreshable&(pmultiplier<=1|remains<=tick_time&spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&(!exsanguinated|remains<=tick_time*2&spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&!ss_buffed&(target.time_to_die-remains)>4&(master_assassin_remains=0|!ticking&azerite.shrouded_suffocation.enabled)
				if (ComboPoints < 5 or not kidney_ready) then -- and not hold_energy_for_kidney
					if (ComboPointsDeficit == 1 or garrote_remains < 11 - (max(3,kidney_countdown))) and garrote_remains < 14 - max(4,kidney_countdown) and ComboPointsDeficit >= 1 then
						_Cast(703,t,true)
					end
				end
				-- actions.dot+=/pool_resource,for_next=1
				-- actions.dot+=/garrote,cycle_targets=1,if=!variable.skip_cycle_garrote&target!=self.target&(!talent.subterfuge.enabled|!(cooldown.vanish.up&cooldown.vendetta.remains<=4))&combo_points.deficit>=1+3*(azerite.shrouded_suffocation.enabled&cooldown.vanish.up)&refreshable&(pmultiplier<=1|remains<=tick_time&spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&(!exsanguinated|remains<=tick_time*2&spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&!ss_buffed&(target.time_to_die-remains)>12&(master_assassin_remains=0|!ticking&azerite.shrouded_suffocation.enabled)
				if not skip_cycle_garrote and (ComboPoints < 5 or not kidney_ready) then -- and not hold_energy_for_kidney
					for i=1,#mainTarget do 
						local tar=mainTarget[i].pointer
						if not unit_is_unit(tar,t) and (arena or not IsSubterfuge or not (vanish_up and vendetta_cd <= 4) or target_is_dummy)
						and ComboPointsDeficit >= 1 + (3* ((((shrouded_suffocation and vanish_up and not arena)) 
						and (mainTarget[i].gp <= 1 or mainTarget[i].garrote <= 1.5 and fan_of_knives >= 3 + (shrouded_suffocation and 1 or 0)) 
						and (not Exsanguinated or garrote_remains <= 1.5*2 and fan_of_knives >= 3 + (shrouded_suffocation and 1 or 0))
						and mainTarget[i].gp <= 1) and 1 or 0) ) then
							_Cast(703,tar,true)
						end
					end
				end
				-- # Crimson Tempest only on multiple targets at 4+ CP when running out in 2s (up to 4 targets) or 3s (5+ targets)
				-- actions.dot+=/crimson_tempest,if=spell_targets>=2&remains<2+(spell_targets>=5)&combo_points>=4
				-- # Keep up Rupture at 4+ on all targets (when living long enough and not snapshot)
				-- actions.dot+=/rupture,if=!variable.skip_rupture&combo_points>=4&refreshable&(pmultiplier<=1|remains<=tick_time&spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&(!exsanguinated|remains<=tick_time*2&spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&target.time_to_die-remains>4
				if not hold_cp_for_kidney and not skip_rupture then
					local refreshable = rupture_remains <= 11 - (max(4,kidney_countdown)) and ComboPoints >= 4
					if refreshable and target_hp > 20 then
						_Cast(1943,t,true)
					end
				end
				-- actions.dot+=/rupture,cycle_targets=1,if=!variable.skip_cycle_rupture&!variable.skip_rupture&target!=self.target&combo_points>=4&refreshable&(pmultiplier<=1|remains<=tick_time&spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&(!exsanguinated|remains<=tick_time*2&spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&target.time_to_die-remains>4
				if not hold_cp_for_kidney and not skip_cycle_rupture and (rupture_count <= 2 or arena) then
					for i=1,#mainTarget do
						local tar=mainTarget[i].pointer
						local remains = mainTarget[i].rupture
						local refreshable = remains < 5 and ComboPoints >= 4
						if refreshable and mainTarget[i].hp > 20 then
							_Cast(1943,tar,true)
						end
					end
				end
			end

			local function direct(t)
				-- # Direct damage abilities
				-- # Envenom at 4+ (5+ with DS) CP. Immediately on 2+ targets, with Vendetta, or with TB; otherwise wait for some energy. Also wait if Exsg combo is coming up.
				-- actions.direct=envenom,if=combo_points>=4+talent.deeper_stratagem.enabled&(debuff.vendetta.up|debuff.toxic_blade.up|energy.deficit<=25+variable.energy_regen_combined|!variable.single_target)&(!talent.exsanguinate.enabled|cooldown.exsanguinate.remains>2)
				if not hold_cp_for_kidney and ComboPoints >= 4 + (deeper_stratagem and 1 or 0) and (not vendetta_up or toxic_blade_up or EnergyDeficit <= 25+energy_regen_combined or single_target) 
				and (not Exsanguinate or _spellCooldown(200806) > 2) then
					_Cast(196819,t,true)
				end 
				-- actions.direct+=/variable,name=use_filler,value=combo_points.deficit>1|energy.deficit<=25+variable.energy_regen_combined|!variable.single_target
				use_filler = (not hold_cp_for_kidney or energy_time_to_max < kidney_countdown-gcd or ComboPoints < 5) and (ComboPointsDeficit > 1 or EnergyDeficit <= 25+energy_regen_combined or not single_target) and not hold_energy_for_kidney
				if not use_filler then use_filler = waiting_for_kidney and ComboPoints < 5 and not hold_energy_for_kidney end
				-- # With Echoing Blades, Fan of Knives at 2+ targets.
				-- actions.direct+=/fan_of_knives,if=variable.use_filler&azerite.echoing_blades.enabled&spell_targets.fan_of_knives>=2
				-- # Fan of Knives at 19+ stacks of Hidden Blades or against 4+ (5+ with Double Dose) targets.
				-- actions.direct+=/fan_of_knives,if=variable.use_filler&(buff.hidden_blades.stack>=19|(!priority_rotation&spell_targets.fan_of_knives>=4+(azerite.double_dose.rank>2)+stealthed.rogue))
				-- # Fan of Knives to apply Deadly Poison if inactive on any target at 3 targets.
				-- actions.direct+=/fan_of_knives,target_if=!dot.deadly_poison_dot.ticking,if=variable.use_filler&spell_targets.fan_of_knives>=3 
				if not mage_on_team_casting_cc and fan_of_knives >= 3 and use_filler and not bcc then
					if fan_of_knives >= 4 and ComboPointsDeficit > 0 then
						_Cast(51723)
					end
					for i=1,#mainTarget do if mainTarget[i].distance <= 10 then
						local tar=mainTarget[i].pointer
						if not UnitDebuffID(tar,2818,"player") and not UnitDebuffID(tar,8680,"player") then
							_Cast(51723)
							return
						end
					end end
				end
				-- actions.direct+=/blindside,if=variable.use_filler&(buff.blindside.up|!talent.venom_rush.enabled&!azerite.double_dose.enabled)
				if use_filler and (UnitBuffID("player",121153) or (not venom_rush and not double_dose)) then
					_Cast(111240,t,true)
				end
				-- # Tab-Mutilate to apply Deadly Poison at 2 targets
				-- actions.direct+=/mutilate,target_if=!dot.deadly_poison_dot.ticking,if=variable.use_filler&spell_targets.fan_of_knives=2
				if use_filler then
					if fan_of_knives == 2 then
						for i=1,#mainTarget do if mainTarget[i].distance <= 6 then
							local tar=mainTarget[i].pointer
							if not poison_ticking(tar) then
								_Cast(1752,tar,true)
							end
						end end
					end
					_Cast(1752,t,true)
				end
				-- actions.direct+=/mutilate,if=variable.use_filler
			end

			-- actions+=/call_action_list,name=stealthed,if=stealthed.rogue
			if S then
				if Subterfuge or Vanish or AutoFollow then
					kidney(t)
					stealthed(t)
				end
				if Stealth then return; end
			end
			
			if valid_physical_target then
				if not start_attack_time or time - start_attack_time > .5 then
					StartAttack()
					start_attack_time=time
				end
			end

			--kidneys
			kidney(t)
			
			--MFD
			if (time_in_combat > 5 or kidney_ready) and (kidney_countdown > time_to_max_cp or kidney_countdown <= GetGCD()) then
				if target_hp < ComboPointsDeficit*1.5 or ComboPoints == 0 or kidney_ready then
					if ComboPoints < 3 then
						if _meleeRange(t) then
							_Cast(137619,t)
						end
					end
				end
			end

			--no gcd actions when kidney is next global, except in stealth
			if hold_gcd_for_kidney then return end

			-- actions+=/call_action_list,name=cds,if=(!talent.master_assassin.enabled|dot.garrote.ticking)&(!equipped.azsharas_font_of_power|!cooldown.latent_arcana.up)
			if (not IsPlayerSpell(255989) or garrote_ticking) then
				cds(t)
			end
			-- actions+=/call_action_list,name=dot
			dot(t)
			-- actions+=/call_action_list,name=direct
			direct(t)
			-- actions+=/arcane_torrent,if=energy.deficit>=15+variable.energy_regen_combined
			-- actions+=/arcane_pulse
			-- actions+=/lights_judgment


		end

	end

endfunction Squid_SubPvE()
    --if nil == nil then return end

	local racials = {

    }
 
	local covenant = {
        ids = {
            none = 0,
            kyrian = 1,
            venthyr = 2,
            nightFae = 3,
            necroLord = 4,
        },
        --kyrian
        kyrian = {
            echoingReprimand = 323547,
            summonSteward = 324739,
        },
        --Night Fae
        nightFae = {
            sepsis = 328305,
            soulShape = 310143,
        },
	}

	local rogue = {
		blind = 2094,
		cheapShot = 1833,
		cloakOfShadows = 31224,
		crimsonVial = 185311,
		distract = 1725,
		evasion = 5277,
		eviscerate = 196819,
		feint = 1966,
		kick = 1766,
		kidneyShot = 408,
		pickLock = 1804,
		pickPocket = 921,
		sap = 6770,
        shiv = 5938,
        smokeBomb = 212182,
		shroudOfConcealment = 114018,
		sliceAndDice = 315496,
		sprint = 2983,
		stealth = 1784,
		tricksOfTheTrade = 57934,
        vanish = 1856,
        
        buffs = {
            crimsonVial = 185311, -- Mainly for torghast when you can get it to no cooldown
            sliceAndDice = 315496,
            vanish = 11327,
        },
        debuffs = {
            cheapShot = 1833,
            kidneyShot = 408,
            smokeBomb = 212183
        },
	}

	local sub = {
		backstab = 53,
        blackPowder = 319175,
        coldBlood = 213981,
        shadowyDuel = 207736,
		rupture = 1943,
		shadowBlades = 121471,
		shadowDance = 185313,
		shadowStep = 36554,
		shadowStrike = 185438,
		shurikenStorm = 197835,
        shurikenToss = 114014,
        shurikenTornado = 277925,
        symbolsOfDeath = 212283,

        buffs = {
            masterAssassinsMark = 340094,
            premeditation = 343173,
            shadowBlades = 121471,
            shadowDance = 185422,
            shurikenTornado = 277925,
            subterfure = 115192,
            symbolsOfDeath = 212283,
            symbolsOfDeathAutoCrit = 227151,
            theRotten = 341134,         
        },

        debuffs = {
            findWeakness = 316220,
            rupture = 1943,
        },
    }

    local dungeon = {

    }
    local raid = {
        bossDebuffs = {
            --Sludgefist
            destructiveImpact = 331314, -- Sludgefist Destructive Impact, Damage taken increased by 100%. Stunned.
            --Huntsman
            destabilize = 334695,  --334695 - Destabilize 100% damage taken increased per stack
            brokenBonds = 345902,  -- broken bond
        },
    }

    --talents
    local vigorEnabled = IsPlayerSpell(14983)
    local masterOfShadowsEnabled = IsPlayerSpell(196976)
    local shadowFocusEnabled = IsPlayerSpell(108209)
    local alacrityEnabled = IsPlayerSpell(193539)
    local premeditationEnabled = IsPlayerSpell(343160)
    local nightStalkerEnabled = IsPlayerSpell(14062)
    local darkShadowEnabled = IsPlayerSpell(245687)
    local shurikenTornadoEnabled = IsPlayerSpell(277925)
    local envelopingShadowsEnabled = IsPlayerSpell(238104)
    local subterfugeEnabled = IsPlayerSpell(108208)
    local deeperStrategemEnabled = IsPlayerSpell(193531)
    local markedForDeathEnabled = IsPlayerSpell(137619)
    local elusivenessEnabled = IsPlayerSpell(79008)

    --Player shit
    local UnitBuffID = UnitBuffID
    local UnitDebuffID = UnitDebuffID
    local UnitCanAttack = UnitCanAttack
    local squid_ttd = squid_ttd
    local haste = UnitSpellHaste("player")
    local gcd = 1.5/(1+(haste/100))
    local gcd_remains = GetGCD()
    local player_hp = _HP("player")
    local Stealth = UnitBuffID("player",115191) or UnitBuffID("player",1784)
    local Subterfuge = UnitBuffID("player",115192)
	local SubterfugeRemains = _buffRemains("player",115192)
    local S = Stealth or Subterfuge
    local pooling = false
    local inInstance, instanceType = IsInInstance()
    local instanceName, _, _, _, _, _, _, _, _ = GetInstanceInfo()
    local Vanish = UnitBuffID("player",11327)
    local bcc8 = _bccAM(8)
    local battleground = instanceType == 'pvp'


    --Settings
    SQUID.auto_vial_percent = SQUID.auto_vial_percent or 50

    --Combo Points
    local combo_points_max = UnitPowerMax("player", 4)
    local combo_points = UnitPower("player",4)
    local combo_points_deficit = combo_points_max - combo_points

    --Energy
    local energy = UnitPower("player")
	local energy_max = UnitPowerMax("player")
	local energy_deficit = energy_max - energy
	local energy_regen = GetPowerRegen()
	local energy_time_to_max = energy_deficit / energy_regen
	local function energy_time_to(amount)
		return max ( 0, ( amount - energy ) / energy_regen )
    end

    --Shadow Dance
    local dance_base_cd = 60
	local dance_charges,dance_max_charges = GetSpellCharges(sub.shadowDance)
	local dance_total_cd = dance_base_cd * dance_max_charges
	local dance_charges_frac = _spellChargeFrac(sub.shadowDance)
	local dance_full_recharge_time = dance_total_cd - (dance_charges_frac*dance_base_cd)
    local dance_next_charge_cd = (math.ceil(dance_charges_frac) - dance_charges_frac) * dance_base_cd
    local dance_remains = _buffRemains("player",185422)
	local dance_up = dance_remains > 0
    
    --MFD
    local marked_for_death_cd = _spellCooldown(137619)

    --Estimated number of dance cooldown seconds refunded by deepening shadows over a given time
    --@param given_time - the time given
    --@param dances_saved - how many dance charges you want to save, altering the # of seconds refunded for future dances
    --@returns (number) - estimated number of dance cooldown seconds refunded by deepening shadows over given time
    local function deepening_shadows_reset(given_time, dances_saved)

        -- max gcds in the given time, with perfect uptime and no energy starvation
        local max_gcds = given_time / gcd
        local max_dances = dance_charges

        -- max time in dance
        local max_time_in_dance = 0
        max_time_in_dance = max_time_in_dance + dance_remains
        max_time_in_dance = dance_charges * 8
        if dance_charges ~= dance_max_charges and dance_next_charge_cd < given_time then
            local next_charge_value = min(8, given_time - dance_next_charge_cd)
            max_time_in_dance = max_time_in_dance + next_charge_value
            max_dances = max_dances + 1
        end
        max_time_in_dance = max_time_in_dance - (not dances_saved and 0 or dances_saved * 8)

        --max time in dance and max dances can't be more than the time alotted
        max_time_in_dance = min(given_time, max_time_in_dance)
        max_dances = min(round(given_time/8,0),max_dances)

        --marked for death finishers
        local marked_for_death_value = 0
        if markedForDeathEnabled then
            marked_for_death_value = marked_for_death_value + (marked_for_death_cd < given_time and 1 or 0)
            marked_for_death_value = marked_for_death_value + (math.floor((given_time-marked_for_death_cd)/60))
        end

        --time spent outside of dance in the given time
        local time_outside_dance = max(0, given_time-max_time_in_dance)

        -- rough estimate of gcds required per finisher with and without dance up, these estimates will probably always be high because procs, but can be adjusted
        local gcds_per_finisher = 4/1 --it feels like it rarely takes 5 entire gcds backstabbing to get to 5 cp.. we will just act like we have 4 max cp here
        local gcds_per_finisher_dance = 5/2 --where we step into the unknown we can average it out... 2.5 gcds per finisher during dance

        --energy spent per finisher during and outside of dance
        local energy_spent_per_finisher_dance = (gcds_per_finisher_dance * 40) 
        local energy_spent_per_finisher = (gcds_per_finisher * 35)

        --add the gcd of the actual finisher to this after energy spending is calculated since energy from finishers is refunded
        gcds_per_finisher = gcds_per_finisher + 1
        gcds_per_finisher_dance = gcds_per_finisher_dance + 1

        --energy gained can be calculated after adding finisher to gcds per finisher since you're still gaining energy while using the gcd on finisher
        local energy_gained_per_finisher_dance = (energy_regen*gcd) * gcds_per_finisher_dance
        local energy_gained_per_finisher = (energy_regen*gcd) * gcds_per_finisher

        local mos_energy_gain = (masterOfShadowsEnabled and 25*max_dances or 0)

        --max finishers during dance (unadjusted)
        local max_finishers_during_dance = max_time_in_dance / (gcds_per_finisher_dance * gcd)

        local net_energy_loss_dance = max_finishers_during_dance * energy_spent_per_finisher_dance
        local net_energy_gain_dance = max_finishers_during_dance * energy_gained_per_finisher_dance
        --net energy over time in dance
        local net_energy_during_dance = net_energy_gain_dance - net_energy_loss_dance + mos_energy_gain

        --max finishers outside of dance (unadjusted)
        local max_finishers_outside_dance = time_outside_dance / (gcds_per_finisher * gcd)
        
        --net energy over time outside dance
        local net_energy_loss = max_finishers_outside_dance * energy_spent_per_finisher
        local net_energy_gain = max_finishers_outside_dance * energy_gained_per_finisher
        local net_energy_outside_dance = net_energy_gain - net_energy_loss

        --net energy over time, and time spent pooling energy
        local net_energy = energy + net_energy_outside_dance + net_energy_during_dance
        local time_pooling_energy = max(0, -net_energy / energy_regen)

        --max finishers adjusted
        local max_finishers_during_dance_adjusted = (max_time_in_dance - time_pooling_energy) / (gcds_per_finisher_dance * gcd)
        local max_finishers_outside_dance_adjusted = (time_outside_dance - time_pooling_energy) / (gcds_per_finisher * gcd)

        local max_finishers = max_finishers_outside_dance_adjusted + max_finishers_during_dance_adjusted + marked_for_death_value

        local deepening_shadows_mod = 5 + (envelopingShadowsEnabled and 2.5 or 0)

        return max_finishers * deepening_shadows_mod, max_finishers

    end

    local function _valid(unit) 
		return UnitIsVisible(unit) 
		and UnitCanAttack("player",unit) 
		and not UnitIsDeadOrGhost(unit) 
		and not _breakableCC(unit) 
		and (arena or UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))
    end

    --Special Functions
    -----------------------------------------------------------------------------------------------------------------

    local function debuff_remains(unit, spellID)
        if not UnitDebuffID(unit, spellID) then
            return 0;
        else
            return _debuffRemains(unit, spellID);
        end
    end

    local function valid_enemies_around(unit, dist)
        local count = 0
        for i = 1, #Enemies do
            if _valid(Enemies[i]) and _distance(Enemies[i], unit) <= dist and not _breakableCC(Enemies[i], false) then
                count = count + 1
            end
        end
        return count;
    end

    local function dynamicTargeting(range)
        --Target enemies above 75% or below 35% preferably
        local bestUnit = bestUnit or nil
        if bestUnit == nil then
            if #Enemies > 0 then
                for i = 1, #Enemies do
                    local thisUnit = Enemies[i]
                    if _distance('player', thisUnit) <= range and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
                        bestUnit = thisUnit
                    end
                end
            end
        end
        if not UnitExists("target") and UnitAffectingCombat('player') then
            TargetUnit(bestUnit)
        end
    end

    local function is_instance_boss(unit)
        if IsInInstance() then
            local _, _, encountersTotal = GetInstanceLockTimeRemaining()
            for i = 1, encountersTotal do
                if unit == 'player' then
                    local bosses = select(1, GetInstanceLockTimeRemainingEncounter(i))
                end
                if (UnitIsVisible(unit) or false) then
                    local boss = GetInstanceLockTimeRemainingEncounter(i)
                    local tar = UnitName(unit)
                    if tar == boss then return true end
                end
            end
            for j = 1, 5 do
                local num = 'boss' .. j
                if unit_is_unit(num, unit) then return true end
            end
        end
        return false    
    end

    local function encounter_name(index)
        --Total of 10 Encounters
        if inInstance and instanceType == 'raid' and instanceName == "Castle Nathria" then
            local boss = GetInstanceLockTimeRemainingEncounter(index)
            return boss
        end
    end

    -- this wasn't defined before the functions so the functions will never find it
    local t = current_target

    local function is_boss(unit)
        if unit == nil then 
            unit = t 
        end
        --Probably needs locales set for totems
        if (UnitIsVisible(unit) or false) and UnitCreatureType(unit) ~= 'Totem' then
            local unitClass = UnitClassification(unit)
            local hMax = UnitHealthMax(unit)
            local pMax = UnitHealthMax('player')
            local instance = select(2, IsInInstance())
            return is_instance_boss(unit) 
                    or _isDummy(unit)
                    or not UnitIsTrivial(unit) and instance ~= 'party' and (unitClass == "rare" and hMax > 4 * pMax) or UnitLevel(unit) < 0
        end
        return false
    end
    local function shouldUseCDs()
        local bossID
        local targetForCDs
        local targetHasAppeared = false
        if inInstance and instanceType == 'raid' then
            --Huntsman
            for i = 1, #Enemies do
                if UnitName(Enemies[i]) == 'Huntsman Altimor' then
                    bossID = Enemies[i]
                end
                if UnitName(Enemies[i]) == 'Bargast' then
                    targetHasAppeared = true
                    targetForCDs = Enemies[i]
                end
            end
            if UnitAffectingCombat(bossID) then
                --We in combat with the damn encounter
                if targetHasAppeared and _debuffStacks(targetForCDs, raid.bossDebuffs.destabilize) >= 10 then
                    if _meleeRange('player', targetForCDs) then
                        return true;
                    elseif targetHasAppeared and UnitIsDead(targetForCDs) or not UnitIsVisible(targetForCDs) then
                        if _meleeRange('player', t) then
                            return true;
                        end
                    else
                        return false;
                    end
                end
            else
                return false;
            end
        elseif inInstance and instanceType == 'party' then
            if is_boss(t) then
                return true;
            else
                return false;
            end
        else
            return false;
        end
    end

    local function valid_stun_target(unit)
        return _CCremains(unit) <= .35 and (_stunDR(unit) == 1 or _drRemains(unit,"stun") > 17.5) and _stunDR(unit) >= .25 and not _immunePhysical(unit)
    end
    local function valid_kidney_target(unit)
        return _CCremains(unit) <= .35 and (_stunDR(unit) == 1) and not _immunePhysical(unit)
    end
    ------------------------------------------------------------------------------------------------------------------

    local covenantID = C_Covenants.GetActiveCovenantID()
    local t_is_boss = (t and is_boss(t) or false)

    ------------------------------------------------------------------------------------------------------------------
    --PvP
    local enemy_player_around
    for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then
        enemy_player_around=true
        break;
    end end

    local function Sappable(unit)
        return energy > 35 and not unit_has_dot(unit) and not UnitAffectingCombat(unit) and _incapacitateDR(unit) >= .25 and _CCremains(unit) <= .7 and (_incapacitateDR(unit) == 1 or _drRemains(unit,"incapacitate") > 17)
    end

    local function CCAvailable(unit)
        local canblind
        local blind = blind_cd <= gcd
        local vanish = vanish_cd <= gcd
        local sap = S
        
        local cc = 0

        if blind and _disorientDR(unit) == 1 then
            canblind=true
            cc = cc + 8
        end

        if vanish then
            local stundr = _stunDR(unit)
            local silencedr = _silenceDR(unit)
            if stundr >= .5 then
                cc = cc + (stundr*4)
            end
            if silencedr >= .5 then
                cc = cc + (silencedr*3)
            end
        end

        if Sappable(unit) or (vanish and (canblind or UnitDebuffID(unit,2094))) then
            local dr = _incapacitateDR(unit)
            cc = cc + (dr*8)
        end

        return cc
    end
    local function t_is_stunned(unit)
        if UnitDebuffID(unit, rogue.debuffs.cheapShot) then
            return rogue.debuffs.cheapShot
        elseif UnitDebuffID(unit, rogue.debuffs.kidneyShot) then
            return rogue.debuffs.kidneyShot
        end
    end
    local t_stun_remains = debuff_remains(t, t_is_stunned(t))

    local their_healer = theirHealer
	local their_healer_cc
	local their_healer_cc_remains = 0
	local their_healer_incapacitate_dr
	local their_healer_incapacitate_dr_remains = 0
	local their_healer_disorient_dr
	local their_healer_disorient_dr_remains = 0
	local their_healer_important_lockout
	if their_healer then
		if not UnitIsDeadOrGhost(their_healer) then
			their_healer_cc_remains = _CCremains(their_healer)
			their_healer_cc = their_healer_cc_remains > 0
			their_healer_incapacitate_dr = _incapacitateDR(their_healer)
			their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
			their_healer_disorient_dr = _disorientDR(their_healer)
			their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

			local class = select(2,UnitClass(their_healer))

			local locked,remaining,school = UnitIsLocked(their_healer)

			if locked and remaining > .25 then
				if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
				or ( class == "SHAMAN" and school == "Nature" )
				or ( class == "PALADIN" and school == "Holy" )
				or ( class == "MONK" and school == "Nature" )
				or ( class == "DRUID" and school == "Nature" )  then
					their_healer_important_lockout = true
				end
			end
		else -- no healer if he dead
			their_healer = nil
		end
    end
    if not their_healer then
		their_healer_cc = true
		their_healer_cc_remains = 100 - (lowestEnemy*1.5)
		their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
		their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
	end

    ------------------------------------------------------------------------------------------------------------------


    ------------------------------------------------------------------------------------------------------------------

        --Tricks
    ------------------------------------------------------------------------------------------------------------------

    local tricksTarget
    local auto_tricks = SQUID.auto_tricks_of_the_trade
    if auto_tricks and _spellCooldown(rogue.tricksOfTheTrade) == 0 and gcd_remains == 0 then
        for i = 1, #Friends do
            local thisUnit = Friends[i]
            if UnitGroupRolesAssigned(thisUnit) == "TANK" and not UnitIsDeadOrGhost(thisUnit) and _LoS('player', thisUnit) then
                tricksTarget = thisUnit
                break
            end
        end
    end

    ------------------------------------------------------------------------------------------------------------------

    	--equipped items
	local equipped_items = {}

	local trinkets = {
        173087, --Darkmoon Deck: Voracity
        178715, --Mistcaller Ocarina
	}

	for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end


    ---------------------------------------------------------------------------------------------------------------------
    --Restealth if Possible .. probably never   

	--variable,name=snd_condition,value=buff.slice_and_dice.up|spell_targets.shuriken_storm>=6
    --Used to determine whether cooldowns wait for SnD based on targets.
    local snd_condition = UnitBuffID("player", rogue.sliceAndDice) or Enemies_Around_Unit("player", 10) >= 6

    --	call_action_list,name=cds
    --  Check CDs at first

    --run_action_list,name=stealthed,if=stealthed.all
    --Run fully switches to the Stealthed Rotation (by doing so, it forces pooling if nothing is available).

    --slice_and_dice,if=spell_targets.shuriken_storm<6&fight_remains>6&buff.slice_and_dice.remains<gcd.max&combo_points>=4-(time<10)*2
    --Apply Slice and Dice at 2+ CP during the first 10 seconds, after that 4+ CP if it expires within the next GCD or is not up
    local slice_and_dice = Enemies_Around_Unit("player", 10) < 6 and squid_ttd(t) > 6 and _buffRemains("player", rogue.sliceAndDice) < (gcd or nil)
        and combo_points >= 4 - (time_in_combat < 10 and 1 or 0) * 2

    --variable,name=use_priority_rotation,value=priority_rotation&spell_targets.shuriken_storm>=2
    --Only change rotation if we have priority_rotation set and multiple targets up.
    local priority_rotation = false
    local use_priority_rotation = priority_rotation == true and Enemies_Around_Unit("player", 10) >= 2

    --variable,name=stealth_threshold,value=25+talent.vigor.enabled*20+talent.master_of_shadows.enabled*20+talent.shadow_focus.enabled*25+talent.alacrity.enabled*20+25*(spell_targets.shuriken_storm>=4)
    --Used to define when to use stealth CDs or builders
    local stealth_threshold = 25 + (vigorEnabled and 1 or 0) * 20 + (masterOfShadowsEnabled and 1 or 0) * 20 + (shadowFocusEnabled and 1 or 0)
        * 25 + (alacrityEnabled and 1 or 0) * 20 + 25 * ((Enemies_Around_Unit("player", 10) >= 4) and 1 or 0)

    --call_action_list,name=stealth_cds,if=variable.use_priority_rotation
    --Priority Rotation? Let's give a crap about energy for the stealth CDs (builder still respect it). Yup, it can be that simple.
    local stealth_cds = use_priority_rotation or energy_deficit <= stealth_threshold

    --call_action_list,name=finish,if=combo_points=animacharged_cp

    --call_action_list,name=finish,if=combo_points.deficit<=1|fight_remains<=1&combo_points>=3|buff.symbols_of_death_autocrit.up&combo_points>=4
    --Finish at 4+ without DS or with SoD crit buff, 5+ with DS (outside stealth)
    local finish = (combo_points_deficit <= 1 or (squid_ttd(t) <= 1 and combo_points >= 3) or UnitBuffID('player', sub.symbolsOfDeath) and combo_points >= 4)

    --call_action_list,name=finish,if=spell_targets.shuriken_storm>=4&combo_points>=4
    --With DS also finish at 4+ against 4 targets (outside stealth)
        or Enemies_Around_Unit("player", 10) >= 4 and combo_points >= 4

    --call_action_list,name=build,if=energy.deficit<=variable.stealth_threshold
    --Use a builder when reaching the energy threshold
    local build = energy_deficit <= stealth_threshold

    --arcane torrent Lowest priority in all of the APL because it causes a GCD
    local arcane_torrent = energy_deficit >= 15 + energy_regen

    --Stealth with enemy player around
    if enemy_player_around and IsUsableSpell("Stealth") then
        if not Stealth and (not UnitAffectingCombat("player") or Vanish) and _spellCooldown(1784) == 0 then
            if _spellCooldown(1784) == 0 and _Cast(1784) then
                Squid_Alert("Stealth",nil,nil,nil,1784)
            end
            return
        end
    end
    
    if (arena or battleground) then

        --arena cds
        if _meleeRange('player', t) and _valid(t) and UnitAffectingCombat('player') then
            if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
                UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
            end
        end

        local enemies_on_player,enemy_melee_on_player,enemy_ranged_on_player,enemy_cds_on_player = EnemiesAttacking("player")
        if enemy_cds_on_player >= 1 and elusivenessEnabled then
            _Cast(rogue.feint)
        end

        --blind peel
        if lowestFriend < 80 and not theirHealer then
            for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) and not _CCcheck(Enemies[i]) and _disorientDR(Enemies[i]) == 1 and UnitEnemiesAttacking(Enemies[i]) == 0 then
                _Cast(2094,Enemies[i])
            end end
        end

        --CC Trinket
        local trinketPointer
        local recentTrinket
        for i=1,#TrinketTracker do
            local pointer = TrinketTracker[i].pointer
            local trinketTime = TrinketTracker[i].time
            if UnitIsVisible(pointer) and _isHealer(pointer) then
                recentTrinket = time-trinketTime <= gcd*2
                timeSinceTrinket = time-trinketTime
                trinketPointer = pointer
            end
        end

        if recentTrinket then
            if trinketPointer and not unit_is_unit(trinketPointer,"target") and _LoS(trinketPointer) and not DoNotBCC(trinketPointer) and gcd_remains <= .25 then
                --Blind
                if _spellCooldown(rogue.blind) <= gcd and _disorientDR(trinketPointer) == 1 then
                    if _realDistance(trinketPointer) <= 15 then
                        if _Cast(rogue.blind,trinketPointer,nil,true) then
                            if locale == "zhCN" then
                                Squid_Alert_Big(">>", UnitClass(trinketPointer).. " ()",2,3.5,2094)
                            else
                                Squid_Alert_Big("Blinded " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,2094)
                            end
                        end
                        return
                    else
                        _Cast(sub.shadowStep,trinketPointer)
                        C_Timer.After(.03,function() 
                            if _Cast(rogue.blind,trinketPointer,nil,true) then 
                                if locale == "zhCN" then
                                    Squid_Alert_Big(">>", UnitClass(trinketPointer).. " ()",2,3.5,2094)
                                else
                                    Squid_Alert_Big("Blinded " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,2094)
                                end
                            end
                        end)
                    end
                end
                --Sap
                if (timeSinceTrinket <= gcd or S or Vanish) and Energy >= 35 and not UnitAffectingCombat(trinketPointer) and _incapacitateDR(trinketPointer) >= lowestEnemy / 100 and not _CCcheck(trinketPointer) then
                    if vanish_cd == 0 or S or Vanish then
                        if _realDistance(trinketPointer) <= 10 then
                            if not S and _Cast(1856) then
                                Squid_Alert("Vanish",nil,nil,nil,1856)
                            end
                            if S or Vanish then
                                CastSpellByID(6770,trinketPointer)
                                if _Cast(6770,trinketPointer,nil,true) then
                                    Squid_Alert_Big("Sapped " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,6770)
                                end
                            end
                            return
                        else
                            _Cast(36554,trinketPointer)
                            C_Timer.After(.03,function() 
                                if _Cast(6770,trinketPointer,nil,true) then
                                    Squid_Alert_Big("Sapped " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,6770)
                                end
                            end)
                        end
                    end
                end
            end
        end

        --sap followup
        if vanish_cd == 0 or S or Vanish then
            for i=1,#Enemies do if _isHealer(Enemies[i]) or not theirHealer then
                local cc = _CCremains(Enemies[i])
                if cc > 0 and not UnitAffectingCombat(Enemies[i]) and not _isDummy(Enemies[i]) then
                    local dr = _incapacitateDR(Enemies[i])
                    if cc < 1.1 and gcd_remains < cc and dr >= .25 then
                        if _distance(Enemies[i]) <= 10 then
                            if dr == 1 and not S 
                            and (not mage_on_team_casting_cc or (mage_cc_tar and not unit_is_unit(mage_cc_tar,Enemies[i]))) then
                                if _Cast(1856) then
                                    Squid_Alert("Vanish",nil,nil,3.5,1856)
                                end
                            end
                            if S or Vanish then
                                if _Cast(6770,Enemies[i],nil,true) then
                                    Squid_Alert_Big("Sapped " .. UnitClass(Enemies[i]),"(Followup)",nil,nil,6770)
                                end
                            end
                            return
                        else
                            if dr == 1 then
                                _Cast(36554,Enemies[i])
                            end
                        end
                    end
                end
            end end
        end

        local sapped_target
        for i=1,#Enemies do if UnitDebuffID(Enemies[i],6770,"player") then
            sapped_target = Enemies[i]
        end end

        --Sap Stealth
        for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) then
            if Sappable(Enemies[i]) and (not sapped_target or _isHealer(Enemies[i]) or unit_is_unit(Enemies[i],sapped_target)) then
                if IsStealthed() or UnitBuffID('player', sub.buffs.shadowDance) or UnitBuffID('player', rogue.buffs.vanish) then
                    if _distance(Enemies[i]) < 10 then
                        if _Cast(6770,Enemies[i],nil,true) then
                            Squid_Alert_Big("Sap " .. UnitClass(Enemies[i]),nil,4,nil,6770)
                            return
                        end
                    elseif UnitAffectingCombat("player") and (_isHealer(Enemies[i]) or not their_healer) then
                        if _Cast(36554,Enemies[i],nil,true) then
                            Squid_Alert("Step " .. UnitClass(Enemies[i]),"(Sap)",4,nil,36554)
                            return
                        end
                    end
                elseif _distance(Enemies[i]) < 10 or _spellCooldown(36554) == 0 then
                    _Cast(185313)
                end
            end 
        end end


        --Kidney
        for i = 1, #Enemies do
            if not _breakableCC(Enemies[i]) and valid_kidney_target(Enemies[i]) and _spellCooldown(rogue.kidneyShot) == 0 then
                if combo_points_deficit == 0 then
                    if _meleeRange('player', Enemies[i]) then
                        _Cast(rogue.kidneyShot, Enemies[i], nil, true)
                    else
                        _Cast(rogue.shadowStep, Enemies[i], nil, true)
                    end
                end
            end
        end

        --mfd
        if UnitAffectingCombat("player") and combo_points_deficit >= 4 then
            for i=1,#Enemies do
                if _distance(Enemies[i]) < 30 then
                     _Cast(137619, Enemies[i], nil, true)
                end
            end
        end

        --Cheap shots
        for i = 1, #Enemies do
            if not _breakableCC(Enemies[i]) and valid_stun_target(Enemies[i]) and (dance_up or S) and _meleeRange('player', Enemies[i]) then
                if energy > 40 and (_stunDR(Enemies[i]) == 1 or unit_is_unit(Enemies[i],current_target) or lowestFriend < 25 or _isHealer(Enemies[i]) and lowestEnemy < 35) then
                    _Cast(rogue.cheapShot, Enemies[i])
                end
            end
        end

        --Bomb the kidney
        if recentTrinket then
            if unit_is_unit(trinketPointer, "target") and _meleeRange('player', trinketPointer) and gcd <= .25 then
                if timeSinceTrinket <= 110 and (t_stun_remains >= 3 or _isSlowed(t)) and their_healer_cc_remains <= 1 then
                    _Cast(rogue.smokeBomb)
                end
            end
        end

        -- claok evasion
        if _HP("player") < 40 + ((EnemiesAttacking("player") and 1 or 0) * 20) then
            _Cast(31224)
            _Cast(5277)
        end

    end

    --Action lists with call requirements
    local function Builders()
        if _valid(t) and build and gcd_remains == 0 then
            --Shuriken Storm
            if valid_enemies_around('player', 8) >= 2 and energy >= GetSpellCost(sub.shurikenStorm) and combo_points_deficit >= 1 then
                if _meleeRange(t) and not bcc8 then
                    _Cast(sub.shurikenStorm)
                end
            end
            --Backstab
            if _meleeRange(t) and energy >= (GetSpellCost(sub.backstab) or 0) then
                if (deeperStrategemEnabled and combo_points <= 5) or (not deeperStrategemEnabled and combo_points <= 4) then
                    _Cast(sub.backstab, t, true)
                end
            end
        end
    end

    local function offGCDCooldowns()
        --shadow_dance,use_off_gcd=1,if=!buff.shadow_dance.up&buff.shuriken_tornado.up&buff.shuriken_tornado.remains<=3.5
        if enemy_player_around then
            if current_target and _meleeRange(current_target) then
                if _stunDR(current_target) == 1 or _HP(current_target) < 30 + (their_healer_cc_remains * 4) then
                    _Cast(sub.shadowDance)
                end
            end
        else
            --Use Dance off-gcd before the first Shuriken Storm from Tornado comes in.
            if not UnitBuffID('player', sub.buffs.shadowDance) and UnitBuffID('player', sub.buffs.shurikenTornado) and _buffRemains('player', sub.buffs.shurikenTornado) <= 3.5 then
                if _meleeRange(t) and _valid(t) then
                    _Cast(sub.shadowDance)
                end
            end
        end
        --symbols_of_death,use_off_gcd=1,if=buff.shuriken_tornado.up&buff.shuriken_tornado.remains<=3.5
        --(Unless already up because we took Shadow Focus) use Symbols off-gcd before the first Shuriken Storm from Tornado comes in.
        if UnitBuffID('player', sub.buffs.shurikenTornado) and _buffRemains('player', sub.buffs.shurikenTornado) <= 3.5 then
            if _meleeRange(t) and _valid(t) then
                _Cast(sub.symbolsOfDeath)
            end
        end
        --symbols_of_death,if=variable.snd_condition&(talent.enveloping_shadows.enabled|cooldown.shadow_dance.charges>=1)&(!talent.shuriken_tornado.enabled|talent.shadow_focus.enabled|cooldown.shuriken_tornado.remains>2)
        --Use Symbols on cooldown (after first SnD) unless we are going to pop Tornado and do not have Shadow Focus.
        if snd_condition and (envelopingShadowsEnabled or _spellChargeFrac(sub.shadowDance >= 1)) and (not shurikenTornadoEnabled or shadowFocusEnabled or _spellCooldown(sub.shurikenTornado) > 2) then
            if _meleeRange(t) and _valid(t) then
                _Cast(sub.symbolsOfDeath)
            end
        end
        --shadow_blades,if=variable.snd_condition&combo_points.deficit>=2
        if snd_condition and combo_points_deficit >= 2 then
            if _meleeRange(t) and _valid(t) and t_is_boss then
                _Cast(sub.shadowBlades)
            end
        end

        --Castle Nathria Specific Blades Scenario
        if inInstance and instanceType == 'raid' and instanceName == "Castle Nathria" then
            --Boss specific cooldown management here.
            --[[ 
                ~* Thought FLow *~
                Is the boss set to do something at a certain percentage? If so we want to use CDs whenever best ie. if boss has a damage taken debuff,
                    so I think we would want to try and determine if we used our CDs on the opener would they be up during the actual burst phase?
                    if ttd > base cooldown duration then its safe, if not we hold it
            --]]

        --shadow_dance,if=!buff.shadow_dance.up&fight_remains<=8+talent.subterfuge.enabled
        elseif not UnitBuffID('player', sub.buffs.shadowDance) and squid_ttd(t) <= 8 + (subterfugeEnabled and 1 or 0) then
            if _valid(t) and _meleeRange(t) then
                _Cast(sub.shadowDance)
            end
        else
            --do nothing
        end

        --use_items,if=buff.symbols_of_death.up|fight_remains<20
        --Default fallback for usable items: Use with Symbols of Death.
        if UnitBuffID('player', sub.buffs.symbolsOfDeath) or squid_ttd(t) < 20 and t_is_boss and _valid(t) and _meleeRange(t) then
            if tContains( equipped_items, 173087 ) and GetItemCD ( ( 173087 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 173087 ) ) )
				Squid_Alert( "Darkmoon Deck: Voracity", nil, nil, nil, 3717310 )
            end                                                        
        end

    end

    local function Cooldowns()
            --flagellation,if=variable.snd_condition&!stealthed.mantle
            --flagellation_cleanse,if=debuff.flagellation.remains<2
            --vanish,if=(runeforge.mark_of_the_master_assassin&combo_points.deficit<=3|runeforge.deathly_shadows&combo_points<1)&buff.symbols_of_death.up&buff.shadow_dance.up&master_assassin_remains=0&buff.deathly_shadows.down
            if (GetInventoryItemID('player', 9) == 172321 and combo_points_deficit <= 3) and UnitBuffID('player', sub.buffs.symbolsOfDeath) and UnitBuffID('player', sub.buffs.shadowDance) and (_buffRemains('player', sub.buffs.masterAssassinsMark) == 0 or nil) then
                if _meleeRange(t) and _valid(t) and t_is_boss then
                    _Cast(rogue.vanish)
                end
            end
            --pool_resource,for_next=1,if=talent.shuriken_tornado.enabled&!talent.shadow_focus.enabled
            --Pool for Tornado pre-SoD with ShD ready when not running SF.
            --Use Tornado pre SoD when we have the energy whether from pooling without SF or just generally.
            local pool_resource_for_next = shurikenTornadoEnabled and not shadowFocusEnabled
            --shuriken_tornado,if=energy>=60&variable.snd_condition&cooldown.symbols_of_death.up&cooldown.shadow_dance.charges>=1
            if shurikenTornadoEnabled then
                if not pool_resource_for_next and energy >= GetSpellCost(sub.shurikenTornado) and snd_condition and _spellCooldown(sub.symbolsOfDeath) == 0 and _spellChargeFrac(sub.shadowDance) >= 1 then
                    _Cast(sub.shurikenTornadoEnabled)
                end
            end
            --serrated_bone_spike,cycle_targets=1,if=variable.snd_condition&!dot.serrated_bone_spike_dot.ticking&target.time_to_die>=21|fight_remains<=5&spell_targets.shuriken_storm<3

            --Covenant Stuff
            ------------------------------------------------------------------------------------------------------------------------------------------------------
            --sepsis,if=variable.snd_condition&combo_points.deficit>=1
            if covenantID == covenant.ids.nightFae then
                if snd_condition and combo_points_deficit >= 1 then
                    if _meleeRange(t) and energy >= 20 and gcd_remains == 0 and _valid(t) and (t_is_boss or (arena or battleground)) then
                        _Cast(covenant.nightFae.sepsis, t, true)
                    end
                end
            end
            --echoing_reprimand,if=variable.snd_condition&combo_points.deficit>=2&(variable.use_priority_rotation|spell_targets.shuriken_storm<=4)
            if covenantID == covenant.ids.kyrian then
                if snd_condition and combo_points_deficit >= 2 and (use_priority_rotation or valid_enemies_around(t, 8) <= 4) then
                    if _meleeRange('player', t) and energy >= 10 then
                        _Cast(covenant.kyrian.echoingReprimand)
                    end
                end
            end
            ------------------------------------------------------------------------------------------------------------------------------------------------------
            --marked_for_death,target_if=min:target.time_to_die,if=raid_event.adds.up&(target.time_to_die<combo_points.deficit|!stealthed.all&combo_points.deficit>=cp_max_spend)
            --If adds are up, snipe the one with lowest TTD. Use when dying faster than CP deficit or not stealthed without any CP.

            --marked_for_death,if=raid_event.adds.in>30-raid_event.adds.duration&combo_points.deficit>=cp_max_spend
            --If no adds will die within the next 30s, use MfD on boss without any CP.

            --echoing_reprimand,if=variable.snd_condition&combo_points.deficit>=2&(variable.use_priority_rotation|spell_targets.shuriken_storm<=4)

            --shuriken_tornado,if=talent.shadow_focus.enabled&variable.snd_condition&buff.symbols_of_death.up
            --With SF, if not already done, use Tornado with SoD up.
            if shurikenTornadoEnabled then
                if shadowFocusEnabled and snd_condition and UnitBuffID('player', sub.buffs.symbolsOfDeath) then
                    if _meleeRange(t) and energy >= GetSpellCost(sub.shurikenTornado) then
                        _Cast(sub.shurikenTornado)
                    end
                end
            end
            --potion,if=buff.bloodlust.react|buff.symbols_of_death.up&(buff.shadow_blades.up|cooldown.shadow_blades.remains<=10)
            --blood_fury,if=buff.symbols_of_death.up
            --berserking,if=buff.symbols_of_death.up
            --fireblood,if=buff.symbols_of_death.up
            --ancestral_call,if=buff.symbols_of_death.up
            --use_items,if=buff.symbols_of_death.up|fight_remains<20
            --Default fallback for usable items: Use with Symbols of Death.

            --Use Whenever it's up and no one has the buff .. cuz why not.
            if GetInventoryItemID('player', 13) == 178715 or GetInventoryItemID('player', 14) == 178715 and not UnitAffectingCombat('player') then
                if select(2,GetItemCooldown(178715)) == 0 then
                    for i = 1, #Friends do
                        if not UnitBuffID(Friends[i], 330067) and _distance('player', Friends[i]) <= 20 then
                            if tContains( equipped_items, 178715 ) and GetItemCD ( ( 178715 ) ) == 0 then
                                UseItemByName( tostring( GetItemInfo ( 178715 ) ) )
                                Squid_Alert( "Mistcaller Ocarina", nil, nil, nil, 3717310 )
                            end
                        end
                    end
                end
            end                                                  
    end

    local function Finishers()
        if gcd_remains == 0 then
            --variable,name=premed_snd_condition,value=talent.premeditation.enabled&spell_targets<(5-covenant.necrolord)&!covenant.kyrian
            --While using Premeditation, avoid casting Slice and Dice when Shadow Dance is soon to be used, except for Kyrian
            local premed_snd_condition = premeditationEnabled and Enemies_Around_Unit(t, 10) < (5 - (covenantID == covenant.ids.necroLord and 1 or 0)) and covenantID ~= covenant.ids.kyrian
            
            --variable,name=skip_rupture,value=master_assassin_remains>0  |!talent.nightstalker.enabled&talent.dark_shadow.enabled&buff.shadow_dance.up|spell_targets.shuriken_storm>=5
            --Helper Variable for Rupture. Skip during Master Assassin or during Dance with Dark and no Nightstalker.
            local skip_rupture = UnitBuffID('player', masterAssassinsMark) or (not nightStalkerEnabled and darkShadowEnabled and UnitBuffID('player', sub.buffs.shadowDance)) or Enemies_Around_Unit('player', 10) >= 5

            --slice_and_dice,if=!variable.premed_snd_condition&spell_targets.shuriken_storm<6&!buff.shadow_dance.up&buff.slice_and_dice.remains<fight_remains&refreshable
            if not premed_snd_condition and Enemies_Around_Unit('player', 10) < 6 and not UnitBuffID('player', sub.buffs.shadowDance) then
                if (UnitBuffID('player', rogue.buffs.sliceAndDice) and _buffRemains('player', rogue.sliceAndDice) < squid_ttd(t)) then
                    if energy >= GetSpellCost(rogue.sliceAndDice) and _buffRemains('player', rogue.buffs.sliceAndDice) <= (3 or nil) then
                        _Cast(rogue.sliceAndDice)
                    end
                end
            end

            --rupture,if=!variable.skip_rupture&target.time_to_die-remains>6&refreshable
            --Keep up Rupture if it is about to run out.
            if _meleeRange(t) and _valid(t) and debuff_remains(t, sub.debuffs.rupture) <= 1 then
                if not skip_rupture and (squid_ttd(t) - debuff_remains(t, sub.debuffs.rupture)) > 6 and energy >= GetSpellCost(sub.rupture) then
                    _Cast(sub.rupture, t, true)
                end
            end

            --rupture,cycle_targets=1,if=!variable.skip_rupture&!variable.use_priority_rotation&spell_targets.shuriken_storm>=2&target.time_to_die>=(5+(2*combo_points))&refreshable
            --Multidotting targets that will live for the duration of Rupture, refresh during pandemic.
            if not skip_rupture and not use_priority_rotation and Enemies_Around_Unit('player', 10) >= 2 and squid_ttd(t) >= (5 + (2 * combo_points)) then
                --refreshable
                for i = 1, #Enemies do
                    if _meleeRange(Enemies[i]) and _valid(Enemies[i]) then
                        if debuff_remains(Enemies[i], sub.debuffs.rupture) <= 1.2 and energy >= GetSpellCost(sub.rupture) then
                            _Cast(sub.rupture, Enemies[i], true)
                        end
                    end
                end
            end

            --rupture,if=!variable.skip_rupture&remains<cooldown.symbols_of_death.remains+10&cooldown.symbols_of_death.remains<=5&target.time_to_die-remains>cooldown.symbols_of_death.remains+5
            --Refresh Rupture early if it will expire during Symbols. Do that refresh if SoD gets ready in the next 5s.
            if not skip_rupture and debuff_remains(t, sub.debuffs.rupture) < _spellCooldown(sub.symbolsOfDeath) + 10 and _spellCooldown(sub.symbolsOfDeath) <= 5 and squid_ttd(t) - debuff_remains(t, sub.debuffs.rupture) > _spellCooldown(sub.symbolsOfDeath) + 5 then
                if _meleeRange(t) and _valid(t) and energy >= GetSpellCost(sub.rupture) then
                    _Cast(sub.rupture, t, true)
                end
            end
            
            --black_powder,if=!variable.use_priority_rotation&spell_targets>=4-debuff.find_weakness.down (316220)
            if not use_priority_rotation and valid_enemies_around('player', 10) >= 4 - (UnitDebuffID(t, sub.debuffs.findWeakness) and 1 or 0) then
                if energy >= GetSpellCost(sub.blackPowder) + 1 then
                    _Cast(sub.blackPowder, t, true)
                end
            end

            --Eviscerate
            if _valid(t) and _meleeRange(t) and energy >= GetSpellCost(rogue.eviscerate) + 1 then
                _Cast(rogue.eviscerate, t, true)
            end
        end
    end

    local function stealthCooldowns()


        --Pvp
        --Use cold blood on CD for now?
        if (arena or battleground) and _valid(t) and _meleeRange(t) and _spellCooldown(sub.coldBlood) == 0 then
            _Cast(sub.coldBlood, t, true)
        end 

        --variable,name=shd_threshold,value=cooldown.shadow_dance.charges_fractional>=1.75
        --Helper Variable
        local shd_threshold = _spellChargeFrac(sub.shadowDance) >= 1.75
        --vanish,if=(!variable.shd_threshold|!talent.nightstalker.enabled&talent.dark_shadow.enabled)&combo_points.deficit>1&!runeforge.mark_of_the_master_assassin
        --Vanish if we are capping on Dance charges. Early before first dance if we have no Nightstalker but Dark Shadow in order to get Rupture up (no Master Assassin).
        if (not shd_threshold or not nightStalkerEnabled and darkShadowEnabled) and combo_points_deficit > 1 and GetInventoryItemID('player', 9) ~= 172321 then
            if t_is_boss and _valid(t) and _meleeRange(t) then
                _Cast(rogue.vanish)
            end
        end
        --variable,name=shd_combo_points,value=combo_points.deficit>=2+buff.shadow_blades.up
        --CP thresholds for entering Shadow Dance
        local shd_combo_points = combo_points_deficit >= 2 + (UnitBuffID('player', sub.buffs.shadowBlades) and 1 or 0)
        --variable,name=shd_combo_points,value=combo_points.deficit>=3,if=covenant.kyrian
            or combo_points_deficit >= 3 and covenantID == covenant.ids.kyrian
        --variable,name=shd_combo_points,value=combo_points.deficit<=1,if=variable.use_priority_rotation&spell_targets.shuriken_storm>=4
            or combo_points_deficit <= 1 and use_priority_rotation and Enemies_Around_Unit('player', 10) >= 4

        --shadow_dance,if=variable.shd_combo_points&(variable.shd_threshold|buff.symbols_of_death.remains>=1.2|spell_targets.shuriken_storm>=4&cooldown.symbols_of_death.remains>10)
        --Dance during Symbols or above threshold.
        if shd_combo_points and (shd_threshold or _buffRemains('player', sub.buffs.symbolsOfDeath) >= 1.2 or Enemies_Around_Unit('player', 10) >= 4 and _spellCooldown(sub.symbolsOfDeath) > 10) then
            if _valid(t) and _meleeRange(t) then
                _Cast(sub.shadowDance)
            end
        end
        --shadow_dance,if=variable.shd_combo_points&fight_remains<cooldown.symbols_of_death.remains
        --Burn remaining Dances before the fight ends if SoD won't be ready in time.
        if shd_combo_points and squid_ttd(t) < _spellCooldown(sub.symbolsOfDeath) then
            if not UnitBuffID('player', sub.buffs.shadowDance) then
                if _valid(t) and _meleeRange(t) then
                    _Cast(sub.shadowDance)
                end
            end
        end
    end

    local function stealth()

        --Shadowstrike whenever possible
        if _valid(t) and _meleeRange(t) and GetSpellCost(sub.shadowStrike) then
            if gcd_remains == 0 and combo_points_deficit >= 1 then
                _Cast(sub.shadowStrike, t, true)
            end
        end

        --call_action_list,name=finish,if=buff.shuriken_tornado.up&combo_points.deficit<=2
        --Finish at 3+ CP without DS / 4+ with DS with Shuriken Tornado buff up to avoid some CP waste situations.
        if UnitBuffID('player', sub.buffs.shurikenTornado) and combo_points_deficit <= 2 then
            Finishers()
        end

        --call_action_list,name=finish,if=spell_targets.shuriken_storm>=4&combo_points>=4
        --Also safe to finish at 4+ CP with exactly 4 targets. (Same as outside stealth.)
        if valid_enemies_around('player', 10) >= 4 and combo_points >= 4 then
            Finishers()
        end

        --call_action_list,name=finish,if=combo_points.deficit<=1-(talent.deeper_stratagem.enabled&buff.vanish.up)
        --Finish at 4+ CP without DS, 5+ with DS, and 6 with DS after Vanish
        if combo_points_deficit <= 1 - ((deeperStrategemEnabled and UnitBuffID('player', rogue.buffs.vanish)) and 1 or 0 ) then
            Finishers()
        end

        --shadowStrike,cycle_targets=1,if=debuff.find_weakness.remains<1&spell_targets.shuriken_storm<=3&target.time_to_die-remains>6
        --Up to 3 targets keep up Find Weakness by cycling Shadowstrike.
        for i = 1, #Enemies do
            if _valid(Enemies[i]) and _meleeRange(Enemies[i]) and gcd_remains == 0 and combo_points_deficit >= 1 then
                if debuff_remains(Enemies[i], sub.debuffs.findWeakness) < 1 and valid_enemies_around('player', 10) <= 3 and (squid_ttd(Enemies[i]) - debuff_remains(Enemies[i], sub.debuffs.findWeakness)) > 6 then
                    _Cast(sub.shadowStrike, Enemies[i], true)
                end
            end
        end

        --shadowStrike,if=variable.use_priority_rotation&(debuff.find_weakness.remains<1|talent.weaponmaster.enabled&spell_targets.shuriken_storm<=4)
        --For priority rotation, use Shadowstrike over Storm with WM against up to 4 targets or if FW is running off (on any amount of targets)

        --shuriken_storm,if=spell_targets>=3+(buff.the_rotten.up|runeforge.akaaris_soul_fragment&conduit.deeper_daggers.rank>=7)&(buff.symbols_of_death_autocrit.up|!buff.premeditation.up|spell_targets>=5)
        local stealthedStorm = 0
        if UnitBuffID(sub.buffs.premeditation) then stealthedStorm = 1 else stealthedStorm = 0 end
        if UnitAffectingCombat('player') and gcd_remains == 0 and valid_enemies_around('player', 10) >= 3 + stealthedStorm and energy >= GetSpellCost(sub.shurikenStorm) and combo_points_deficit >= 1 then
            if _meleeRange(t) and not bcc8 then
                _Cast(sub.shurikenStorm)
            end
        end

        --shadowStrike,if=debuff.find_weakness.remains<=1|cooldown.symbols_of_death.remains<18&debuff.find_weakness.remains<cooldown.symbols_of_death.remains
        --Shadowstrike to refresh Find Weakness and to ensure we can carry over a full FW into the next SoD if possible.
        if debuff_remains(t, sub.debuffs.findWeakness) <= 1 or _spellCooldown(sub.symbolsOfDeath) < 18 and debuff_remains(t, sub.debuffs.findWeakness) < _spellCooldown(sub.symbolsOfDeath) then
            if _valid(t) and _meleeRange(t) and energy >= GetSpellCost(sub.shadowStrike) and gcd_remains == 0 and combo_points_deficit >= 1 then
                _Cast(sub.shadowStrike, t, true)
            end
        end

        --gloomblade,if=buff.perforated_veins.stack>=5&conduit.perforated_veins.rank>=13

        --Shadowstrike if nothing to do
        if _valid(t) and _meleeRange(t) and energy >= GetSpellCost(sub.shadowStrike) and gcd_remains == 0 then
            if combo_points_deficit >= 1 then
                _Cast(sub.shadowStrike, t, true)
            end
        end

    end

    local function auto_defensives()
        local auto_vial = SQUID.auto_vial
        local vial_hpp = SQUID.auto_vial_percent or 50
        if auto_vial and player_hp <= vial_hpp and energy >= GetSpellCost(rogue.crimsonVial) and gcd_remains == 0 and _spellCooldown(rogue.crimsonVial) == 0 then
            if not UnitBuffID('player', rogue.buffs.crimsonVial) then --This is mainly for Torghast where you can get no cooldown on vial, so not to spam it.
                _Cast(rogue.crimsonVial)
            end
        end
    end

    dynamicTargeting(10)
    --ALWAYS try to restealth .. need to code to not attack immune things later on, or buffs we don't like
    --if IsUsableSpell(rogue.stealth) then
    --    _Cast(rogue.stealth)
    --end

    --Run Rotation
    if not IsMounted() and not UnitChannelInfo('player') then
        --Poisons
        if not (arena or battleground) and not UnitIsAFK('player') and not UnitChannelInfo('player') and not _isMoving('player') then
            if not UnitBuffID('player', 315584) and (not GetBattlefieldStatus(1) == "none" or select(6,GetBattlefieldStatus(1)) ~= "ARENA") then
                _Cast(315584)
            elseif not UnitBuffID("player", 8679) and select(6,GetBattlefieldStatus(1)) == "ARENA" then
                _Cast(8679)
            end
            if not UnitBuffID('player', 3408) then
                _Cast(3408)
            end
        elseif (arena or battleground) and not UnitChannelInfo('player') and not _isMoving('player') then
            if not UnitBuffID('player', 8679) then
                _Cast(8679)
            end
            if not UnitBuffID('player', 3408) then
                _Cast(3408)
            end
        end

        --Auto Tricks
        if tricksTarget ~= nil and _valid(t) and _distance('player', t) < 5 and UnitThreatSituation('player') and UnitThreatSituation('player') > 0 then
            _Cast(rogue.tricksOfTheTrade, tricksTarget)
        end
        --Slice and Dice Pre combat
        if slice_and_dice and gcd_remains == 0 then
            _Cast(rogue.sliceAndDice)
        end
        ----------- Defensives --------------
        if auto_defensives() then return true end;
        -------------------------------------
        ----------- CDs ---------------------
        if Cooldowns() then return true end;
        if offGCDCooldowns() then return true end;
        -------------------------------------
        ----------- Stealth -----------------
        if IsStealthed() or UnitBuffID('player', sub.buffs.shadowDance) or UnitBuffID('player', rogue.buffs.vanish) or UnitBuffID('player', sub.buffs.premeditation) then
            if stealth() then return true end;
        end
        -------------------------------------
        ----------- Stealth CDs -------------
        if use_priority_rotation then
            if stealthCooldowns() then return true end;
        end
        if energy_deficit <= stealth_threshold then
            if stealthCooldowns() then return true end;
        end
        -------------------------------------
        ----------- Finishers ---------------
        if combo_points_deficit <= 1 or squid_ttd(t) <= 1 and combo_points >= 3 or UnitBuffID('player', sub.buffs.symbolsOfDeathAutoCrit) and combo_points >= 4 then
            if Finishers() then return true end;
        end
        if Enemies_Around_Unit('player', 10) >= 4 and combo_points >= 4 then
            if Finishers() then return true end;
        end
        -------------------------------------
        ----------- Builders ----------------
        if energy_deficit <= stealth_threshold then
            if Builders() then return true end;
        end
        --------------------------------------
    end
    

end
















--Get combat time stuff
    --[[
    local function get_combat_time(self,event,...)
        if SubPvE_combat_start_time == nil then
            SubPvE_combat_start_time = 0
        end
        SubPvE_combat_start_time = GetTime()
    end
    
    local cTime = CreateFrame("Frame")
    cTime:RegisterEvent("PLAYER_REGEN_DISABLED")
    cTime:SetScript("OnEvent",get_combat_time)

    local function getCombatTime()
        local combat_time
        if SubPvE_combat_start_time == nil then
            SubPvE_combat_start_time = 0
        end
        if combat_time == nil then
            combat_time = 0
        end
        if UnitAffectingCombat("player") then
            combat_time = GetTime() - SubPvE_combat_start_time
        end
        return combat_time
    end
    --]]----------> top priority <------------- ---
-- fix time_to_max_cp and make energy + combo point pooling line up properly
-- step kidney trinkets
-- blinds
-- stop auto into immunities
-- wildseed buff needs to be immunity

-- -------> nex priority <------------- ---

-- cheap shot guardian of queens

-- don't step / do stupid shit while disarmed

-- shiv druid shapeshift onevent

-- something else is happening that refreshes combat timer that i don't track, no idea what it is
	-- also think when combat drops on the unit a healer is healing, they lose combat too

-- cheap healer over kidney if mage can 100% get sheep

-- jesus takes the wheel while people are in seed

-- if already in a sheep, don't need to kidney healer - kidney is exclusively better on the healer when he can be sapped out of it, otherwise kidney on KT is better for KP

-- ccing the healer when target is low is really good when the target could die during it or a long chain can be made from it

-- set use_symbols, use_dance, use_blades on goes

-- kyrian potion

-- sap stealth external

-- sap gpy before it land

-- cheap shot interrupt + fists/convoke

-- kidney / blind cc target trinket

-- cancel panda incap with stun ?????

-- team offensive cooldowns as one unit, but what's most important is diminishing returns
	-- whether or not they can be used due to lockouts or cc on your teammates
	-- calculate how much damage your mage can do or whatever based on fire blast tracking and cooldowns and meteor and other cooldowns and shit
	-- calculate how much damage total you can do to someone in a double or triple cheap shot go

-- pool combo points / energy ~6 sec before go, meanwhile draw for the user to move to the healer to kidney
	-- pool before every dance

-- to get triple cheap shot and do full damage, either
	-- 1. have shot in the dark or shadow focus
	-- 2. pool to 90+ energy - symbols and 35, have MFD, and only use symbols after the first cheap

-- initiate cc chain, maintain cc chain as long as possible, once you pull a defensive cooldown stop the go and wait for next dr

-- enemy team has both personal cds and shared cds, amz / darkness is a shared cd, shaman wall is personal cd, trinkets can be shared cooldowns but also personal cds

-- not only are goes where a kill is guaranteed necessary, if going on one target could pull more cooldowns or set your next go up for a guaranteed kill it's the best

-- diminishing returns on all units

-- dance goes
	-- 1. subterfuge + prey on the weak
		-- a. mfd ready: pool 60+ energy > kidney healer > step + dance + cold blood > cheap shot > symbols > (echoing / shadowstrike) > eviscerate + mfd > eviscerate > cheap shot > (echoing / shadowstrike) > cheap shot > eviscerate
			-- a notes: if echoing replaced shadowstrike in this variant, there is 1 extra shadowstrike usable at the end, often resulting in another finisher
  		-- b. no mfd: pool 90+ energy > kidney healer > step + dance + cold blood > cheap shot > symbols > 
  																											-- echoing if available >
  																												----> 4+ cp eviscerate > shadowstrike > cheap shot > eviscerate > cheap shot > shadowstrike > eviscerate
  																												----> <4 cp shadowstrike > eviscerate > cheap shot > shadowstrike > cheap shot > eviscerate > shadowstrike
  																											-- shadowstrike >
  																												----> 4+ cp eviscerate > shadowstrike > cheap shot > eviscerate > cheap shot > no more energy :( 

-- energy costs:
	-- 1.a. = (200 - echoing_usable*30) over 8 second dance


-- whenever a go with cross cc on the healer is possible on your target, on screen drawing will show
	-- 1. what offensive cooldowns are available to use into the stun on the kill target
	-- 2. what cc will be available to chain on the healer after the initial cc
	-- 2. defensives and trinkets that could be used to survive your go, including cooldowns that can disrupt your cc chain and STOP your go (like sanc/bop/reverse magic/bubble)
		-- we need to classify the debuff types of ALL crowd control's debuff type and which debuff types these cooldowns disrupt. (blind = physical, bop disrupts = physical, poly = magic, reverse disrupts = magic, sanc disrupts = stuns/fears/whatever)
	-- 3. upcoming offensive cooldowns and enemy defensive cooldowns will be displayed

-- cooldowns = {
-- 	defensives = {
-- 		survival = {
-- 			["Barkskin"] = {reduction=20, base_cd=60, usable_in_cc={["Stuns"]=true}},
-- 			["Feint"] = {reduction=30, base_cd=15},
-- 		}
-- 		disruptive = {
-- 			["Blessing of Sanctuary"] = {debufftypes={["Fear"]=true, ["Stun"]=true, ["Silence"]=true}, base_cd=45},
-- 			["Reverse Magic"] = {debufftypes={["Magic"]=true}, base_cd=90},
-- 			["Blessing of Protection"] = {debufftypes={["Physical"]=true, base_cd=69}},
-- 		}
-- 	}
-- }

-- crowd_control = {
-- 	["Stun"] = {
-- 		["HoJ"] = {debufftype="Magic"},
-- 		["Kidney"] = {debufftype="Physical"},
-- 	},
-- 	["Incapacitate"] = {
-- 		["Sheep"] = {debufftype="Magic"},
-- 		["Sap"] = {debufftype="Physical"},
-- 	},
-- 	["Disorient"] = {
-- 		["Blind"] = {debufftype="Physical"},
-- 	},
-- 	["Fear"] = {
-- 		["Fear"] = {debufftype="Magic"},
-- 		["Psychic Scream"] = {debufftype="Magic"},
-- 	},
-- 	["Silence"] = {
-- 		["Silence"] = {debufftype="Magic"},
-- 	}
-- }

-- player can choose to press the button at any time to start the go, or wait for upcoming offensives
-- if script sees an opportunity to land a guaranteed kill because of no trinkets or immunities available from the enemy team, it will automatically swap on that target
-- after giving both the rogue and mage players a heads up alert

-- cc, defensives, 

-- get trinket data like arenaframe addons do so we know if people are playing relent or adap

-- get enemy rogue's current position from distract missile ???

-- set load mode to "kill" when we have a go where the enemy we are attacking is in a stun or < 30% hp, cannot receive heals or is below 30% hp, does not have a trinket or life saving defensive, and cannot be saved by another person's trinket or defensive
	-- like during a bomb go for example, or when both the healer and target are in cc without trinkets and no go-stopping defensives are up

-- don't do goes when running away from enemies and healer is in cc?

-- kidney off target on goes - stun dr on target is <= gcd, dance is ready, target is not immune and cds don't extend past this window
	-- pool energy before this ( time to the drs lining up - energy time to max )
	-- step if necessary, not running towards target
 	-- blind healer is better here if they have trinket

-- blind on trinket

-- bomb on stun go
	-- target has no trinket? don't need to go for kidney
	-- healer is far away?
	-- healer is missing, but our mage is here with us to pump and we have all cds? so we bomb here and our opener will handle blades and such

-- kick certain spells out of stealth, don't overlap stuns with certain important interrupts unless they're running away fast or on events like roll and shit

-- auto attack totems, track auto attack timer to do it perfectly inbetween autos with minimal time off target?

-- lsit of every cooldown in arena
	-- which ones can be used while ccd (and what type of cc)
	-- which ones do teammates give to each other
		-- use this info to pick the best kill target based on trinkets and usable cds!
-- otherwise, goes are on target and we can swap focus with keybind

-- keybinds to perform certain openers,
	-- cheap shot - cold blood, cheaps target (step if far), dance + symbols, blinds healer if applicable, step sap / kidney's trinket, blades once healer is cc'd or on bomb
	-- shadowstrike - cold blood, shadow blades, shadow strike + dance + symbols, cheap shot, evisc, mfd, evisc
		-- auto kidney healer if we're close on one of these openers? - cold blood, mfd+kidney healer, step kill target and continue rotation

-- auto re-target last target if they were not a visible unit recently (last_target_time_visible?, start tracking when UnitIsVisible(last_target) is no more

-- continue cc chains as long as possible until cooldowns are forced and your cds are over
	-- know what we have for the healer, display alerts of how we're going to chain cc off of what he's in
	-- track how long they have been in cc for, maybe make an alert for how long the cc chain was lmao
	-- don't followup with sap when mage is casting sheep or ring on the target

-- dr is set to 18.45 - something up to like 200 ms / 18.25 drr is ok for cheap shot gap

-- prioritize shadowstrike over triple dr cheap shot when load mode is "kill" or master assassin is up

-- symbols dmg increase doesn't affect cold blood but it does give us a guaranteed crit shadowstrike
	-- don't use offensive vanish before using the free crit shadowstrike from symbols? (just don't use symbols at capped-1 combo points?)
--

-- Covenant Data
local covenants = {
	["None"] = 0,
	["Kyrian"] = 1,
	["Venthyr"] = 2,
	["NightFae"] = 3,
	["Necrolord"] = 4
}

local function bin(arg)
	return arg and 1 or 0
end

function Squid_CheapShot_Opener()
end
function Squid_Shadowstrike_Opener()
end
function Squid_FocusSwap()
end       
function Squid_HealerSwap()
end  
function Squid_CancelSwap()
end

-- our team is one unit, with different CC abilities, we can work to chain cc on the healer
-- draw when someone on your team is trying to chain cc, and stop the script from doing it
local function build_our_unit()
	
	local unit = {}

	-- we are a part of the unit :)
	unit["player"] = {
		cc = { name="blind", dr="disorient", duration=8, can_do_it=function(unit) return _distance(unit) < 10 and not _immunePhysical(unit) end }
	}

	unit["player"] = {
		cc = { name="hoj", dr="stun", duration=6, can_do_it=function(unit) return _distance(unit) < 15 and not _immuneMagic(unit) end }
	}

	local groupsize = GetNumGroupMembers()

end

local go_stopping_defensives = {
	
	-- Rogue
	1966, -- Feint, 30% damage reduction

	-- Mage
	110909, -- Alter Time, Heals Back to Initial HP - Worthless if we can purge

}

function go_stopping_defensive_remains(unit)
	
	-- how long does a defensive remain on this person which makes starting a go pointless?
	local buffs = _buffFromTable(unit,go_stopping_defensives,true,true);

	table.insert(buffs,{r=physical_immunity_remains(unit),id=select(2,physical_immunity_remains(unit))})

	-- we can start our go into certain buffs like feint before they're completely over
	for i=1,#buffs do
		if buffs[i].id == 1966 then
			buffs[i].r = buffs[i].r - 1 -- we can go if 1 sec of feint remains
		end
	end

	table.sort(buffs,function(x,y) return x.r > y.r end);

	return buffs[1].r, buffs[1].id
	-- return max( physical_immunity_remains(unit), buffs[1] and buffs[1].r or 0 ), buffs[1] ~= 0 and buffs[1].id or physical_immunity_remains(unit) and select(2, physical_immunity_remains(unit))
end

-- execute with double eviscerate ?
function eviscerate_damage(unit, cp, threshold, double)
	
	if _immunePhysical(unit) then return 0 end

	cp = cp or UnitPower("player",4)
	
	if cp == 0 then return 0 end
	
	if not unit_is_player(unit) then return 0 end
	
	local class = select(2,UnitClass(unit))
	
	local armor_type = {
		["PRIEST"] = (1 - .11),--"Cloth", ~ 9-12% physical damage reduction from cloth?
		["MAGE"] = (1 - .11),--"Cloth",
		["WARLOCK"] = (1 - .13), --"Leather", -- cause demon armor? we'll just put them between cloth and leather
		["ROGUE"] = (1 - .15), --"Leather",
		["DRUID"] = (1 - .15), --"Leather",
		["DEMONHUNTER"] = (1 - .165), --"Leather", -- these fuckers don't take damage
		["MONK"] = (1 - .15), --"Leather",
		["HUNTER"] = (1 - .275), --"Mail",
		["SHAMAN"] = (1 - .275), --"Mail",
		["PALADIN"] = (1 - .425), --"Plate",
		["WARRIOR"] = (1 - .425), --"Plate",
		["DEATHKNIGHT"] = (1 - .425), --"Plate",
	}

	-- table of all the damaging cooldown shits here and their "cost",
	-- function inside the function that does necessary crit calculations post addup only when vanish is part of the combination,
	-- returns the cheapest combination to kill the unit with an evisc?

	-- just redo the calculations in the evisc damage function before giving them here 
	-- then put the cooldowns in a table here, sort by least expensive, add up from each extra cd and compare to hp
	-- then assign upvalues to which cds we are going to use and then use them

	local prev_gcd = Prev_GCD(1)

	local er_stacks = max(_buffStacks("player", 323558), _buffStacks("player", 323559), _buffStacks("player", 323560))
	local er_ready = er_stacks > 0 and cp == er_stacks

	local fw_up = UnitDebuffID(unit, 316220, "player")
	local ma_up = UnitBuffID("player",340094)
	local dance_bonus = UnitBuffID("player",185422) and IsPlayerSpell(245687)
	local dance_bonus2 = UnitBuffID("player",185422) and IsPlayerSpell(14062)
	local symbols_up = UnitBuffID("player", 212283)
	local raw_effect = GetSpellEffect(196819)
	local eviscerate_effect = (raw_effect / 5) * (er_ready and 7 or cp) + (double and (raw_effect / 5) * 5 or 0)

	local runeforge = (GetInventoryItemID("player",9) == 172321 and "Crit") -- Master assassin
				  or (GetInventoryItemID("player",11) == 178926 and "Crit") 
				  or (GetInventoryItemID("player",12) == 178926 and "Crit")

	local dance_cost = _spellCooldown(185313)
	local vanish_cost = _spellCooldown(212283)

	local magic_immune = _immuneMagic(unit)

	-- arg: threshold, return the cheapest combination of cooldowns needed to reach this amount of damage
	-- potential mods sorted by lowest to highest cost...
	local potential_mods = {
		{item="Badge", mod=0.08, cost=20, usable=(IsEquippedItem(175884) and GetItemCD(175884) <= 0 or IsEquippedItem(175921) and GetItemCD(175921) <= 0)}, -- badge, ~8% damage increase
		{spell=212283, mod=0.15, cost=30, usable=(_spellCooldown(212283) == 0)}, -- symbols of death, +15% increase
		{spell=185313, mod=0.3, cost=80, usable=(IsPlayerSpell(245687) and _spellCooldown(185313) == 0)}, -- dance with dark shadow, +30% increase
		{spell=185313, mod=0.12-bin(arena)*0.04, cost=80, usable=(IsPlayerSpell(14062) and _spellCooldown(185313) == 0)}, -- dance with nightstalker, +8-12% increase
	}

	table.sort(potential_mods,function(x,y) return x.cost < y.cost end)

	local current_damage = eviscerate_effect

	local additive_mods = 1
	
	-- Currently active additive modifiers
	
	-- 5% badge
	if UnitBuffID("player", "Gladiator's Badge") then
		additive_mods = additive_mods + .08 -- 8% from badge...?
	end
	-- 15% symbols
	additive_mods = additive_mods + (symbols_up and .15 or 0)
	-- 30% dance + dark shadow
	additive_mods = additive_mods + (dance_bonus and .3 or 0)
	-- 8-12% dance + nightstalker
	additive_mods = additive_mods + (dance_bonus2 and 0.12-bin(arena)*0.04 or 0)

	local function post_additive(number, simulate_ma)

		-- guaranteed crit from master assassin
		number = number * ((ma_up or simulate_ma) and 1.75 or 1)
		
		-- 50% extra shadow damage with find weakness... is it indirectly affected by armor because it's calculated post armor damage reduction? nah right?
		local shadow_damage = 0
		shadow_damage = shadow_damage + (fw_up and not magic_immune and number * .5 or 0)
		
		-- base physical damage of eviscerate modified by armor
		number = number * (armor_type[unit] and (armor_type[unit] * (1 - (fw_up and .3 or 0))) or 1)

		-- add the shadow damage after armor mitigation
		number = number + shadow_damage

		return number

	end

	local can_vanish = runeforge == "Crit" and _spellCooldown(1856) == 0 and not ma_up
	local vanish_cost = 120 - bin(IsPlayerSpell(212081))*45

	-- table that will store the mods we use to meet the threshold
	local mods_used = { }

	local function current_mod()
		local mods = additive_mods -- current additive mods
		-- add together any mods used in potential damage calculation
		for i=1,#mods_used do if mods_used[i] and mods_used[i].mod then
			mods = mods + mods_used[i].mod
		end end
		return mods
	end

	local calculate_for_vanish
	local potential_damage = current_damage

	for i=1,#potential_mods do
		local cd = potential_mods[i]
		if cd.usable then
			some_usable_mods = true
			local new_potential = potential_damage
			-- simulate for vanish first if the cost is lower
			if can_vanish and vanish_cost < cd.cost then
				if post_additive(new_potential, true) >= threshold then
					table.insert(mods_used,{spell=1856, usable=can_vanish})
					calculate_for_vanish = true
					break -- break the loop if vanish was cheaper than this cd and met the threshold
				else
					-- apply all current additive modifiers + mods to be used + the mod of the current cd
					new_potential = new_potential * (current_mod() + cd.mod)
					-- apply post additive modifiers
					new_potential = post_additive(new_potential)
					if new_potential >= threshold then
						table.insert(mods_used,cd)
						break -- break the loop if we have met the threshold
					else
						-- calculate post-additive and/or potential vanish if it's the last cooldown and we haven't met the threshold
						if i >= #potential_mods then 
							-- local final_potential = post_additive(potential_damage * (current_mod() + cd.mod), can_vanish)
							if can_vanish then
								table.insert(mods_used,cd)
								table.insert(mods_used,{spell=1856, usable=can_vanish})
								calculate_for_vanish = true
							end
						else
							table.insert(mods_used,cd) -- add this cd to the table of cds that will be used if it didn't meet the threshold
						end
					end
				end
			else
				-- apply all current additive modifiers + mods to be used + the mod of the current cd
				new_potential = new_potential * (current_mod() + cd.mod)
				-- apply post additive modifiers
				new_potential = post_additive(new_potential)
				if new_potential >= threshold then
					table.insert(mods_used,cd)
					break -- break the loop if we have met the threshold
				else
					-- calculate post-additive and/or potential vanish if it's the last cooldown and we haven't met the threshold
					if i >= #potential_mods then 
						-- local final_potential = post_additive(potential_damage * (current_mod() + cd.mod), can_vanish)
						if can_vanish then
							table.insert(mods_used,cd)
							table.insert(mods_used,{spell=1856, usable=can_vanish})
							calculate_for_vanish = true
						end
					else
						table.insert(mods_used,cd) -- add this cd to the table of cds that will be used if it didn't meet the threshold
					end
				end
			end
		elseif i >= #potential_mods then
			local final_potential = post_additive(potential_damage * (current_mod() + cd.mod), can_vanish)
			if can_vanish then
				table.insert(mods_used,{spell=1856, usable=can_vanish})
				calculate_for_vanish = true
			end
		end
	end

	potential_damage = post_additive(current_damage * current_mod(), calculate_for_vanish)

	-- apply all additive modifiers to current damage before armor reduction
	current_damage = current_damage * additive_mods

	-- calculate current damage post additive modifiers
	current_damage = post_additive(current_damage)

	-- returns
	-- 1, current eviscerate effect
	-- 2, potential eviscerate effect
	-- 3, whether potential damage was greater than given threshold
	-- 4, table of cooldowns used in the potential damage calculations
	return current_damage, potential_damage, threshold and potential_damage >= threshold or false, mods_used
end

local function smooth_step(unit, ml_or)
	if _spellCooldown(36554) > 0 then return false end
	if already_stepped and GetTime() - already_stepped < .2 then return false end
	local px,py,pz = GetPlayerPosition()
	local fdir = ObjectFacing("player")
	local x,y,z = px + 2 * math.cos(fdir), py + 2 * math.sin(fdir), pz
	if _Cast(36554,unit) then
		StopMovingAndLock()
		C_Timer.After((ml or .245),function() SetMovementLocked(false) end)
		C_Timer.After(.15, function() if player_step and GetTime() - player_step <= .15 then _faceLocation(x,y,z) end end)
		already_stepped = GetTime()
		return true
	end
end

function Squid_SubPvP()

	-- disable the shit
	-- if nil == nil then return end

	local time = GetTime()
	local latency = squid_avg_latency
	local groupsize = GetNumGroupMembers()
	local update = 2/GetFramerate()
	local buffer = latency + update + .1
	local haste = UnitSpellHaste("player")
	local gcd = 1.5/(1+(haste/100))
	local gcd_remains = GetGCD()
	local combat = UnitAffectingCombat("player")
	local player_hp = _HP("player")
	local player_disarmed = unit_disarmed("player")
	local player_combat = UnitAffectingCombat("player")
	local player_has_dot = unit_has_dot("player")
	local player_immune = _immuneCheck("player",nil,true)
	local bcc10 = _bccAM(10)

	local cap_bot = SQUID.cap_bot

	local combat_ends = player_combat and 6 or 0
	if player_combat_tracker then
		combat_ends = 6 - (time - player_combat_tracker)
	end

	if player_combat and combat_ends <= 4 then
		Squid_Alert("Combat Ends in " .. max(math.floor(combat_ends),1))
	end

	-- stop script while eating, stealth while eating
	local eating = UnitBuffID("player",167152)
	if eating then
		if not player_combat and _Cast(1784) then
			Squid_Alert("Stealth",nil,nil,nil,1784)
			return
		end
		return 
	end

	-- stop script while mounted or flying
	if IsMounted() or IsFlying() then return end

	--check if unit is valid (immunes, dead, breakable cc etc)
	local function _valid(unit,immune,nocheck)
		if not unit then return false end
		return (nocheck or UnitCanAttack("player",unit))
		and (nocheck or not UnitIsDeadOrGhost(unit))
		and not _breakableCC(unit)
		and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
		and ((arena and unit_is_player(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
	end

	--our current target
	local t = current_target
	if not UnitIsVisible(t) then t = nil end

	local function valid_physical(after,unit)

		if not unit then unit = t end
		if not unit then return false end
		if not UnitIsVisible(unit) then return false end

		if UnitIsDeadOrGhost(unit) then return false end
			
		if arena and not unit_is_player(unit) then return "pet" end

		if not arena and not UnitAffectingCombat(unit) and not _isDummy(unit) and not unit_is_player(unit) then return false end

		if UnitCanAttack("player",unit)
		and (not _breakableCC(unit) or not arena and not unit_is_player(unit))
		and physical_immunity_remains(unit) <= after then
			return true
		end

	end
	
	local valid_attackable_target = t and UnitCanAttack("player",t)
	local valid_physical_target = valid_physical(0)

	local target_hp = valid_attackable_target and _HP(t) or 100
	local target_in_combat = valid_attackable_target and UnitAffectingCombat(t)

	--dots on target
	local target_rupture_remains = valid_attackable_target and _debuffRemains(t, 1943, "player") or 0
	local target_rupture_ticking = target_rupture_remains > 0

	local moving_towards_time = moving_towards_unit_duration(t,.11)
	local moving_towards = _movingTowards(t,.11)
	local moving_towards_target = valid_attackable_target and moving_towards and moving_towards_time > .15
	local moving_towards_long = valid_attackable_target and _unitIsFacingUnit("player",t,45) and moving_towards and moving_towards_time > .265
	local moving_towards_verylong = valid_attackable_target and _unitIsFacingUnit("player",t,45) and moving_towards and moving_towards_time > .5

	local moving_away = moving_away_from(t, select(2,GetUnitSpeed("player")) * .6)
	local fleeing_from_target = valid_attackable_target and moving_away

	local target_stun_remains = valid_attackable_target and _stunRemains(t) or 0

	local function fleeing_from_unit(unit, eh) return moving_away_from(unit, eh or select(2,GetUnitSpeed("player")) * .6) end

	local melee_range_target = valid_physical_target and _meleeRange(t)
	local distance_target = valid_physical_target and _distance(t) or 0

	local los_target = valid_attackable_target and _LoS(t)

	if follow_unit_until then
		local unit, endtime = unpack(follow_unit_until)
		if unit and UnitIsVisible(unit) and endtime - time > 0 then
			local x,y,z = ObjectPosition(unit)
			if not _amIfacing(unit) then
				MoveTo(x,y,z,true)
			else
				MoveTo(x,y,z)
			end
		end
	end

	if valid_physical_target and last_suck and time - last_suck < .5 and was_moving_towards_target and distance_target > 5 and (not last_shadowstep or time - last_shadowstep > 5) then
		if smooth_step(current_target,.1) then
			Squid_Alert("Shadowstep", "(Ursol's Vortex)", 5, nil, 36554)
			last_shadowstep = time
			follow_unit_until = {current_target, time + .55}
		end
	end

	if moving_towards_target then
		was_moving_towards_target = true
	elseif (not last_suck or time - last_suck > .5) and not UnitDebuffID("player",127797) then
		was_moving_towards_target = false
	end

	local energy = UnitPower("player")
	local energy_max = UnitPowerMax("player")
	local energy_deficit = energy_max - energy
	local energy_regen = GetPowerRegen()
	local energy_time_to_max = energy_deficit / energy_regen

	-- 8.33 repeating energy per second after dance
	local master_of_shadows_remains = _buffRemains("player",196980)

	function energy_after_time(elapsed)
		local mas_benefit = (min(elapsed,master_of_shadows_remains))*8.3333
		local regen_over_time = energy_regen*elapsed
		return min(energy_max, energy + mas_benefit + regen_over_time)
	end

	function energy_gained_over_time(elapsed)
		local mas_benefit = (min(elapsed,master_of_shadows_remains))*8.3333
		local regen_over_time = energy_regen*elapsed
		return mas_benefit + regen_over_time
	end

	local function energy_time_to(amount)
		local time_to_amount = max ( 0, ( amount - energy ) / energy_regen )
		return time_to_amount
	end

	local combo_points = UnitPower("player",4)
	local combo_points_max = UnitPowerMax("player",4)
	local combo_points_deficit = combo_points_max - combo_points

	local cp = combo_points

	local dance_remains = _buffRemains("player",185422)
	local dance_up = dance_remains > 0

	local dance_base_cd = 60
	local dance_charges,dance_max_charges = GetSpellCharges(185313)

	local dance_total_cd = dance_base_cd * dance_max_charges
	local dance_charges_frac = _spellChargeFrac(185313)
	local dance_full_recharge_time = dance_total_cd - (dance_charges_frac*dance_base_cd)
	local dance_next_charge_cd = (math.ceil(dance_charges_frac) - dance_charges_frac) * dance_base_cd

	local dance_cd = _spellCooldown(185313)

	local dance_adjusted_cd = (dance_cd > 0 and dance_cd*.8 or 0)

	local time_to_max_cp
	if not time_to_max_cp then
		local rounded_max_cp = combo_points_deficit
		if rounded_max_cp % (dance_up and 2 or 1) ~= 0 then rounded_max_cp = rounded_max_cp + 1 end
		local gcds_req = (rounded_max_cp/(dance_up and 2.25 or 1.25))
		local energy_gained_over_time = (energy_regen*gcd)*gcds_req
		local energy_req = (gcds_req*37.5)-energy_gained_over_time
		local time_for_energy = (energy_req/energy_regen)-(energy/energy_regen)
		time_to_max_cp = gcds_req * gcd + time_for_energy
	end
	if time_to_max_cp < 0 then time_to_max_cp=0 end

	local time_to_next_max_cp
	if not time_to_next_max_cp then
		local rounded_max_cp = 6
		local gcds_req = (rounded_max_cp/(dance_up and 2 or 1.15))
		local energy_gained_over_time = (energy_regen*gcd)*gcds_req
		local energy_req = (gcds_req*37.5)-energy_gained_over_time
		local time_for_energy = (energy_req/energy_regen)-(energy/energy_regen)
		time_to_next_max_cp = gcds_req * gcd + time_for_energy
	end
	if time_to_next_max_cp < 0 then time_to_next_max_cp=0 end

	local enveloping_shadows_enabled = IsPlayerSpell(238104)
	local mfd_enabled = IsPlayerSpell(137619)
	local subterfuge_enabled = IsPlayerSpell(108208)
	local nightstalker_enabled = IsPlayerSpell(14062)
	local snd_remains = _buffRemains("player", 315496)
	local snd_up = snd_remains > 0

	local vigor_enabled = IsPlayerSpell(14983)
	local master_of_shadows_enabled = IsPlayerSpell(196976)
	local shadow_focus_enabled = IsPlayerSpell(108209)
	local alacrity_enabled = IsPlayerSpell(193539)
	local dark_shadow_enabled = IsPlayerSpell(245687)

	local stealth_id = subterfuge_enabled and 115191 or 1784
	local stealth_up = UnitBuffID("player",stealth_id)
	local subterfuge_remains = _buffRemains("player",115192)
	local subterfuge_up = subterfuge_remains > 0

	local shot_in_the_dark_up = UnitBuffID("player",257506)
	local shot_in_the_dark_enabled = IsPlayerSpell(108209)

	local vanish_up = UnitBuffID("player",11327)
	local vanish_cd = _spellCooldown(1856)

   	local symbols_remains = _buffRemains("player", 212283)
    local symbols_up = symbols_remains > 0
    local symbols_cd = _spellCooldown(212283)
	local symbols_crit_up = UnitBuffID("player", 227151)

	local kidney_cd = _spellCooldown(408)
	local step_cd = _spellCooldown(36554)
	local blind_cd = _spellCooldown(2094)
	local mfd_cd = _spellCooldown(137619)

	local is_kyrian =  C_Covenants.GetActiveCovenantID() == covenants["Kyrian"]-- IsPlayerSpell(323547)

	-- Call Kyrian Steward
	if is_kyrian then
		if GetItemCount(177278) < 3 and Free_Bag_Slots() > 0 then
			if UnitBuffID("player", 32727) and GetNumGroupMembers() > 1 then
				_Cast(324739)
			end
		end
	end

	local er_ready
	if GetUnitChargedPowerPoints("player") then
		local points = GetUnitChargedPowerPoints("player")
		for i=1,#points do
			er_ready = combo_points == points[i]
		end
	end

	local runeforge = (GetInventoryItemID("player",9) == 172321 and "Crit") -- Master assassin
				  or (GetInventoryItemID("player",11) == 178926 and "Crit") 
				  or (GetInventoryItemID("player",12) == 178926 and "Crit")

    
    local master_assassin_remains = _buffRemains("player",340094) 
    local master_assassin_up = master_assassin_remains > 0

    -- set use_symbols, use_dance, use_blades
    local use_blades
   	if should_use_blades and time - should_use_blades < 1 then
   		use_blades = true
   	end

   	-- sprint gapclose
   	if moving_towards_cctar then
   		if _Cast(2983) then
   			Squid_Alert("Sprint",nil,nil,nil,2983)
   		end
   	end

   	--- fucking shit potion
   	if player_hp < 25 then
   		if GetItemCount(177278) > 0 and select(2,GetItemCooldown(177278)) == 0 then
   			UseItemByName(tostring(GetItemInfo(177278)))
   			Squid_Alert("Kyrian Shit Soup",nil,nil,nil,69)
   		end
   	end

   	-- Poisons
   	if not vanish_up and not dance_up then
		-- Wound
	    if _buffRemains("player",8679) < 600 - (player_combat and 595 or 0) then
	        if _Cast(8679) then
	        	Squid_Alert("Wound Poison", nil, nil, nil, 8679)
	        	return
	        end
	    end
	    -- Crippling
	    if _buffRemains("player",3408) < 600 - (player_combat and 595 or 0) then
		    if _Cast(3408) then
		        Squid_Alert("Crippling Poison", nil, nil, nil, 3408)
		        return
		    end
	    end
	end

    object_first_detected = object_first_detected or {}

    local totems = {
		101398,	--Psyfiend
		119052,	--War Banner
		104818,	--Ancestral Protection Totem
		53006,	--Spirit Link Totem
		2630,	--Earthbind Totem1
		60561,	--Earthgrab Totem
		-- 61245,	--Capacitor Totem 
		5925,	--Grounding Totem
		-- 105425,	--Skyfury Totem
		105427,	--Skyfury Totem
		11137,	--Skyfury Totem
		-- 5913,	--Tremor Totem
		105451,	--Counterstrike Totem
		6112,	-- windfury totem?
	}

    -- totem stomp
	local function Stomp(totem,name,important)
		local hp = UnitHealth(totem)
		local maxhp = UnitHealthMax(totem)
		if hp <= 1 then return false; end
		if not object_first_detected[totem] then
			object_first_detected[totem] = time
		else
			if time - object_first_detected[totem] > max(.35,minDelayTime*1.8) then
				if not load_mode or important then
					if _LoS(totem) then

						-- auto attack
						if hp <= 100 and _meleeRange(totem) then
							if _amIfacing(totem) then
								if not t or not tContains(totems, ObjectID(t)) then
									TargetUnit(totem)
									StartAttack(totem)
									recent_totem_stomp = time
									Squid_Alert_Big("Stomp " .. name, "(Auto Attack)", 4, nil, 6603)
									object_first_detected[totem] = nil
								end
							elseif _distance(totem) < 2 then
								-- move to it and attack?
								-- local x,y,z=ObjectPosition(totem)
								-- MoveTo(x,y,z)
								-- TargetUnit(totem)
								-- StartAttack(totem)
								-- recent_totem_stomp = time
								-- Squid_Alert_Big("Stomp " .. name, "(Auto Attack)", 4, nil, 6603)
								-- object_first_detected[totem] = nil
							end
						end

						if unit_is_unit(totem,current_target) and hp < 300 then
							if not auto_attack_totem or time - auto_attack_totem > .1 then
								StartAttack(totem)
								auto_attack_totem = time
								object_first_detected[totem] = nil
							end
							return
						end

						if _meleeRange(totem) then
							-- shadowstrike
							if dance_up or subterfuge_up then
								if _Cast(185438,totem,nil,true) then
									Squid_Alert_Big("Stomp " .. name,"(Shadowstrike)",4,nil,185438)
									object_first_detected[totem] = nil
									return
								end
							end
							
							-- backstab
							if _Cast(53,totem,nil,true) then
								Squid_Alert_Big("Stomp " .. name,"(Backstab)",4,nil,53)
								object_first_detected[totem] = nil
								return
							end
						else
							-- shuriken toss
							if _Cast(114014,totem,nil,true) then
								Squid_Alert_Big("Stomp " .. name,"(Throw)",4,nil,114014)
								object_first_detected[totem] = nil
								return
							end
						end

					end
				end
			end
		end
	end

	local function target_last_non_totem_target()
		if last_non_totem_target and UnitIsVisible(last_non_totem_target) then
			TargetUnit(last_non_totem_target)
		end
	end

	local target_id = valid_attackable_target and ObjectID(t) or 999
	if tContains(totems,target_id) then
		if UnitHealth(t) <= 1 then
			if not totem_tlt_queued then
				C_Timer.After((max(.25,minDelayTime*1.5)),function() target_last_non_totem_target() totem_tlt_queued = nil end)
				totem_tlt_queued = true
			end
		end
	elseif not UnitIsVisible(t) then
		if recent_totem_stomp and time - recent_totem_stomp < 2 then
			if not totem_tlt_queued then
				C_Timer.After((max(.25,minDelayTime*1.5)),function() target_last_non_totem_target() totem_tlt_queued = nil end)
				totem_tlt_queued = true
			end
		end
	else
		if t and target_id ~= 61245 then
			last_non_totem_target = t
		end
	end

	local totems_to_stomp = {}

	-- do the totem stomp
	if arena then
		if not _CCcheck("player") then
			for i=1,#Pets do
				local e = Pets[i]
				local name = UnitName(e);
				local id = ObjectID(e)
				--only kill cap totems when they're casting
				if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e) and _castTimeLeft(e) < latency + 1.5 and Friends_Around_Unit(e, 10) > 0) then
					-- prio cap if it's going to stun anyone
					if id == 61245 and UnitCastingInfo(e) and _castTimeLeft(e) < latency + 1 and Friends_Around_Unit(e, 10) > 0 then
						table.insert(totems_to_stomp,{pointer=e, name=name, prio=1})
					-- prio spirit link totem
					elseif id == 53006 then
						table.insert(totems_to_stomp,{pointer=e, name=name, prio=2})
					else
						table.insert(totems_to_stomp,{pointer=e, name=name, prio=3})
					end
				end
				--shiv abomination
				if id == 149555 and not _slowImmuneCheck(e) and _CCremains(e) + _rootRemains(e) < 2 then
					if _Cast(5938,e,nil,true) then
						Squid_Alert("Shiv","Abomination",nil,nil,5938)
						return
					end
				end
			end
		end
	end
	table.sort(totems_to_stomp, function(x,y) return x.prio < y.prio end)

	if not stealth_up and combat_ends > 3.5 then
		for i=1,#totems_to_stomp do
			local t = totems_to_stomp[i]
			Stomp(t.pointer, t.name, true)
		end
	end

	local function auto_defensives()
        local auto_vial = SQUID.auto_vial
        local vial_hpp = SQUID.auto_vial_percent or 50
        
        local total,melee,ranged,cds = EnemiesAttacking("player")

        -- vial
        if auto_vial and player_hp <= vial_hpp + total*5 and energy >= GetSpellCost(185311) and _spellCooldown(185311) == 0 then
            if not UnitBuffID('player',185311) then --This is mainly for Torghast where you can get no cooldown on vial, so not to spam it.
                if _Cast(185311) then
                	Squid_Alert("Crimson Vial",nil,nil,nil,185311)
                	return true
                end
            end
        end

        -- cloak
        if cap_bot and player_hp <= 50 + (ranged * 25) then
        	if _Cast(31224) then
        		Squid_Alert("Cloak of Shadows",nil,nil,nil,31224)
            	return true
            end
        end

        -- evasion
        if cap_bot and player_hp <= 50 + (melee * 35) then
        	if _Cast(5277) then
        		Squid_Alert("Evasion",nil,nil,nil,5277)
            	return true
            end
        end

    end

    auto_defensives()

	local friendly_mage
	for i=1,#Friends do
		local class = select(2,UnitClass(Friends[i]))
		--mage
		if class == "MAGE" then
			friendly_mage = Friends[i]
		end
	end

	-- alerts for friendly mage cooldowns coming back
	if friendly_mage then
		
		if UnitCooldown(friendly_mage, 190319) <= 6.5 then
			if combustion_alert == false then
				Squid_Alert_Big("Combust Ready Soon", nil, nil, 3, 190319)
				combustion_alert = true
			end
		else
			combustion_alert = false
		end

		if UnitCooldown(friendly_mage, 153561) <= 3.5 then
			if meteor_alert == false then
				Squid_Alert_Big("Meteor Ready Soon", nil, nil, 1.8, 153561)
				meteor_alert = true
			end
		else
			meteor_alert = false
		end

	end

 	local rogue_mage = friendly_mage and true

	local sepsis_stealth = UnitBuffID("player", 347037)

	-- if=buff.perforated_veins.stack>=5&conduit.perforated_veins.rank>=13
	local pv_stacks = _buffStacks("player", 341572)
	local pv_rank = conduit_rank("Perforated Veins")

	-- premed gives 2 extra combo points if slice and dice is up, otherwise 10 sec slice and dice
	local premed_up = UnitBuffID("player",343173)
	local premed_enabled = IsPlayerSpell(343160)

	-- enemy players around
	local enemy_player_around
	local enemy_player_close
	for i=1,#Enemies do 
		if unit_is_player(Enemies[i]) then
			local d = _distance(Enemies[i])
			if d < 40 then
				enemy_player_around = true
				if d < 10 then
					enemy_player_close = true
				end
			end
		end 
	end

	-- team cc casts
	local team_sheep_cast = {}
	local team_clone_cast = {}
	for i=1,#Friends do 
		local cast = UnitCastingInfo(Friends[i])

		if cast == "Cyclone" then
			local target = UnitSpellTarget(Friends[i])
			if target then
				team_clone_cast[target] = _castTimeLeft(Friends[i])
			end
		elseif cast == "Polymorph" then
			local target = UnitSpellTarget(Friends[i])
			if target then
				team_sheep_cast[target] = _castTimeLeft(Friends[i])
			end
		end

	end
	
	local function Sappable(unit)
        return energy > 35 and unit_is_player(unit) and not UnitAffectingCombat(unit) and not _immunePhysical(unit) and _incapacitateDR(unit) >= .25 and _CCremains(unit) <= .5 and (_incapacitateDR(unit) == 1 or _drRemains(unit,"incapacitate") > 17) and (not team_sheep_cast[unit] or team_sheep_cast[unit] > _CCremains(unit) + .1) and not unit_has_dot(unit) and not _isDummy(unit)
    end

	-- sap stealth
	local stealthed_sappable
	if energy >= 35 then
		for i=1,#Enemies do if unit_is_player(Enemies[i]) and _stealthCheck(Enemies[i]) and Sappable(Enemies[i]) then
			stealthed_sappable = Enemies[i]
		end end
	end
	if stealth_up or dance_up or vanish_up then
		if stealthed_sappable and _Cast(6770, stealthed_sappable, nil, true) then
			Squid_Alert_Big("Sap " .. UnitClass(stealthed_sappable), "(".. GetSpellInfo(_stealthCheck(stealthed_sappable)) .. ")", 6, nil, 6770)
			return
		end
	end
	--/run local stealthed_sappable = "player" Squid_Alert_Big("Sap " .. UnitClass(stealthed_sappable), "(".. GetSpellInfo(_stealthCheck(stealthed_sappable)) .. ")", 6, nil, 6770)

	-- sapped target
	local sapped_target
	local sapped_target_remains = 0
	for i=1,#Enemies do 
		local sap_remains = _debuffRemains(Enemies[i],6770,"player")
		if sap_remains > 0 then
        	sapped_target = Enemies[i]
        	sapped_target_remains = sap_remains
        end
    end

    local their_healer = {}

    local no_healer
    if not their_healer and not their_healer_hiding then no_healer = true end
    
	local their_healer_cc
	local their_healer_cc_remains = 0
	local their_healer_incapacitate_dr
	local their_healer_incapacitate_dr_remains = 0
	local their_healer_disorient_dr
	local their_healer_disorient_dr_remains = 0
	local their_healer_important_lockout
	
	if theirHealer then
		their_healer.p = theirHealer
		if not UnitIsDeadOrGhost(theirHealer) then
			their_healer.cc_remains = _CCremains(their_healer.p)
			their_healer.cc = their_healer.cc_remains > 0
			their_healer.incapacitate_dr = _incapacitateDR(their_healer.p)
			their_healer.incapacitate_dr_remains = _drRemains(their_healer.p,"incapacitate")
			their_healer.disorient_dr = _disorientDR(their_healer.p)
			their_healer.disorient_dr_remains = _drRemains(their_healer.p,"disorient")

			local class = select(2,UnitClass(their_healer.p))
			their_healer.class = class

			local locked,remaining,school = UnitIsLocked(their_healer.p)
			their_healer.lockout = {locked,remaining,school}

			if locked and remaining > .25 then
				if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
				or ( class == "SHAMAN" and school == "Nature" )
				or ( class == "PALADIN" and school == "Holy" )
				or ( class == "MONK" and school == "Nature" )
				or ( class == "DRUID" and school == "Nature" )  then
					their_healer.important_lockout = true
				end
			end
		else -- no healer if he dead
			their_healer = {}
		end
	end

	-- rogue_mage=true -- testing
	local healer_sheep_ready = rogue_mage and their_healer.incapacitate_dr_remains or 99

	local our_healer_cc_remains = ourHealer and _CCremains(ourHealer) or 0
	local our_healer_cc = ourHealer and our_healer_cc_remains > 0

	--sap targets that fall out of combat
	if not player_disarmed then
	    for i=1,#Enemies do if unit_is_player(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and not do_not_sap(Enemies[i]) then
	    	local e = Enemies[i]
	    	local is_healer = _isHealer(e)
	    	local idr = _incapacitateDR(e)
	        if Sappable(e) and (not sapped_target or is_healer or unit_is_unit(e,sapped_target)) then                                             -- dance                     -- vanish
	            if stealth_up and target_in_combat and (lowestEnemy <= 90 or recently_trinketed(e, 3) or _stealthCheck(e)) or UnitBuffID('player', 185422) or UnitBuffID('player', 11327) then
	                if (_isHealer(Enemies[i]) or no_healer) and time_since_combat < 15 and _distance(Enemies[i]) > 10 then
		                if smooth_step(Enemies[i]) then
	                        Squid_Alert("Step " .. UnitClass(Enemies[i]),"(Sap)",4,nil,36554)
	                        SquidFrame = 2
	                        return
	                    end
	                end
                    if _Cast(6770,Enemies[i],nil,true) then
                        Squid_Alert_Big("Sap " .. UnitClass(Enemies[i]),nil,5,nil,6770)
                        return
                    end
	            elseif _isHealer(Enemies[i]) and (_distance(Enemies[i]) < 10 or _spellCooldown(36554) == 0 and _distance(Enemies[i]) <= 23 and _LoS(Enemies[i])) and idr == 1 and not stealth_up and not dance_up and player_combat then
	                if _Cast(185313) then
	                	Squid_Alert("Dance","(Sap " .. UnitClass(Enemies[i]) .. ")", nil, nil, 185313)
	                	SquidFrame = 2
	                	return
	                end
	            end
	        end 
	    end end
	end

	if UnitIsVisible(theirHealer) then
		-- shiv healer out of los
		if valid_attackable_target then
			if not unit_is_unit(theirHealer,t) and not _breakableCC(theirHealer) and _CCremains(theirHealer) <= .1 and not _immunePhysical(theirHealer) and UnitAffectingCombat(theirHealer) and (_distance(theirHealer,t) > 43 or not _LoS(theirHealer,t)) then
				if _Cast(5938, theirHealer, nil, true) then
					Squid_Alert_Big("Shiv Healer","(Bad Position)",4,3.5,5938)
					return
				end
			end
			-- shiv target out of los
			if _CCremains(theirHealer) <= 3.5 and (_distance(theirHealer,t) > 43 or not _LoS(theirHealer,t)) and _CCremains(t) < .1 then
				if _Cast(5938, t, nil, true) then
					Squid_Alert_Big("Shiv Target","(Bad Position)",4,3.5,5938)
					return
				end
			end
		end
	end

	-- stealth breaking soon
    if stealth_up and not vanish_up and unit_has_dot("player") then

    	Squid_Alert_Big("|cFFfef367Stealth Breaking Soon!", nil, nil, .25)

    	-- we could use this var elsewhere to set up a go on someone with master assassin
    	stealth_breaking_soon = true

    	-- shadowstrike
    	if valid_physical_target and (moving_towards_long or moving_towards and not fleeing_from_target) then
    		if _Cast(185438,current_target,nil,true) then
    			Squid_Alert("Shadowstrike", "(Stealth Breaking)",5,nil,185438)
    			return true
    		end
    	end

    else
    	stealth_breaking_soon = false
    end

	-- restealth when possible and enemy player is around or enemy is targeted, or when an arena is starting
    if not stealth_up and not player_combat and (not offensive_vanish or time - offensive_vanish > 3) then
    	if enemy_player_around or (UnitIsVisible(t) and UnitCanAttack("player",t)) or enemy_player_close or (arena and not UnitBuffID("player",32727)) then
    		if time_since_combat < 3 or enemy_player_close then
    			if player_has_dot and valid_physical_target and moving_towards then
    				local tx,ty,tz = ObjectPosition(t)
    				local px,py,pz = PredictUnitPosition("player",.5)
    				if not TraceLine(tx,ty,tz+1.8,px,py,pz+1.8,0x100030) then
    					if _Cast(1784) then
			    			recent_restealth = time
							Squid_Alert("Restealth","(|cFFc31d39Dotted)",7,nil,1784)
							SquidFrame = 2
		    				return
		    			end
		    		end
    			elseif not player_has_dot then
		    		if _Cast(1784) then
		    			recent_restealth = time
		    			Squid_Alert("Restealth",nil,7,nil,1784)
		    			return
		    		end
		    	else
		    		Squid_Alert("|cFFfef367Not Stealthing","|cFFc31d39(Dotted)",nil,nil,1784)
		    	end
	    	else
	    		if player_has_dot and valid_physical_target and moving_towards then
    				local tx,ty,tz
    				local px,py,pz = PredictUnitPosition("player",.5)
    				if not TraceLine(tx,ty,tz+1.8,px,py,pz+1.8,0x100030) then
    					if _Cast(1784) then
			    			recent_restealth = time
							Squid_Alert("Stealth","(Dotted)",7,nil,1784)
		    				return
		    			end
		    		end
    			elseif not player_has_dot then
		    		if _Cast(1784) then
		    			recent_restealth = time
		    			Squid_Alert("Stealth",nil,nil,nil,1784)
		    			return
		    		end
		    	else
		    		Squid_Alert("|cFFfef367Not Stealthing","|cFFc31d39(Dotted)",nil,nil,1784)
		    	end
	    	end
    	end
    end

    -- returns a modifier, like .4 if they take 40% of normal damage from the given damage source
    local function unit_damage_taken_modifier(unit)
    	local physical_mod = 0
    	local magic_mod = 0
    	local any_mod = 0
    	-- gather any defensive buffs and add the value
    	if damagetype == "magic" then

    	elseif damagetype == "physical" then

    	end
    	-- full immunities = 100
    	return any_mod, physical_mod, magic_mod
    end

    local peel_mode
    local peel_unit
    for i=1,#Friends do

    	local f = Friends[i]

		local hp = 30
		local severe_hp = 10

		local count,melee,range,cds = EnemiesAttacking(f)

		local any_mod,physical_mod,magic_mod = unit_damage_taken_modifier(f)

		if any_mod == 0 then
			hp = 0
		else
			hp = hp + ((melee * 10) * physical_mod)
			hp = hp + ((range * 10) * magic_mod)
			hp = hp + (cds * 20)
			hp = hp + ((not ourHealer or our_healer_cc) and 25 or 0)
		end

		hp = hp * any_mod

		if any_mod == 0 then
			severe_hp = 0
		else
			severe_hp = severe_hp + ((melee * 7) * physical_mod)
			severe_hp = severe_hp + ((range * 7) * magic_mod)
			severe_hp = severe_hp + (cds * 18)
			severe_hp = severe_hp * ((not ourHealer or our_healer_cc) and 1.3 or 1)
		end

		local current_hp = math.floor(_HP(f))
		if current_hp < severe_hp then
			peel_mode = "severe"
			peel_unit = f
			break
		else
			peel_mode = true
			peel_unit = f
		end

	end

    local kidney_ready = kidney_cd == 0 and combo_points >= 5 - bin(mfd_enabled and mfd_cd == 0)*5

    local target_go_ready = 999
    if t and valid_attackable_target then
    	local reasons_to_wait = {
    		{r = _drRemains(t,"stun"), reason = "Stun DR"},	-- remaining stun DR
    		{r = go_stopping_defensive_remains(t), reason = GetSpellInfo(select(2,go_stopping_defensive_remains(t)))}, -- go stopping defensives
    		{r = dance_cd, reason = "Dance Cooldown"}, -- dance cd
    	}
    	table.sort(reasons_to_wait, function(x,y) return x.r > y.r end)
    	target_go_ready = reasons_to_wait[1].r
    	target_go_reason = reasons_to_wait[1].reason
    end

    -- print(target_go_reason)
    if valid_attackable_target and target_go_ready > gcd and target_go_reason then
  	  	-- Squid_Alert("Delaying Go for " .. target_go_reason)
  	end

    local off_target
	for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) then
		off_target = Enemies[i]
	end end

    -- engage load mode during cc or when we might still have a kill on the target after cc
    local load_mode = valid_physical_target and (their_healer.cc or target_hp < 65) and go_stopping_defensive_remains(t) == 0
    
    -- REMOVE ME
	load_mode = valid_physical_target and _stunCheck(t) and "kill" or load_mode

    local cc_chain = {}

    local pooling_combo_points
    local pooling_energy = force_pool or load_mode and 0 or 35 -- we can pool less energy when symbols is available .. ?
    local pooling_energy_reason

    local energy_needed_for_go = (mfd_enabled and mfd_cd == 0 and 50 or 90)

    cc_draw_line = nil
    local function healer_cc()

    	local unit = theirHealer or "focus"

    	--stop if no unit
		if not unit or not UnitIsVisible(unit) then return 69 end

		--do not sap? (ext. func)
		local dont_sap = do_not_sap(unit)

		--dist to unit
		local dist = _distance(unit)
		-- melee range?
		local melee_range = _meleeRange(unit)

		-- immunities
		local immunity_remains = max( physical_immunity_remains(unit), cc_immunity_remains(unit) )

		--druid?
		local is_druid = select(2,UnitClass(unit)) == "DRUID"

		--check root
		local root = ( not is_druid and _rootRemains(unit) or 0 )

		--check cc
		local ccr = _CCremains(unit)
		local cc = ccr > 0 
		
		--incapacitate info
		local idr = _incapacitateDR(unit)
		local idr_remains = _drRemains(unit,"incapacitate")
		local incap_remains, incap = incapacitate_remains(unit)

		--disorient drs
		local ddr = _disorientDR(unit)
		local ddr_remains = _drRemains(unit,"disorient")

		--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
		local immune_sheep = _isBeast(unit) or _isDummy(unit) or UnitBuffID(unit, 197625)

		--meteor?
		local standing_in_meteor = UnitDebuffID(unit,155158)

		--banner?
		local banner = UnitBuffID(unit,236321)

		--yea dont cc into it...unless
		if banner then return 69 end

		--incap on unit?
		local incap = _incapacitateCheck(unit)

		-- stun dr
		local sdr_remains = _drRemains(unit,"stun")

		--healer?
		local is_healer = _isHealer(unit) 

		--lockout? (only important lockout...)
		-- local lockout = IsLocked(unit,true)
		local locked,lockout_remaining,school = UnitIsLocked(unit)

		local important_lockout_remaining = 0
		if locked and lockout_remaining > 0 then
			if ( class == "PRIEST" and school == "Shadow" )
			or ( class == "SHAMAN" and school == "Nature" )
			or ( class == "PALADIN" and school == "Holy" )
			or ( class == "MONK" and school == "Nature" )
			or ( class == "DRUID" and school == "Nature" )
			or ( class == "MAGE" and school == "Arcane" )
			or ( class == "WARLOCK" and school == "Shadowflame" ) then
				important_lockout_remaining = lockout_remaining
			end
		end

		--los?
		local los = _LoS(unit)

		--charmed friend?
		local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

		if friendly then return 69 end

		local unit_type = _isHealer(unit) and "Healer" or UnitClass(unit)

		-- kidney healer
							-- target "hp" needs to be adjusted by defensives
		local time_to_stun = max(0, (target_hp > 75 or dance_cd > 0) and target_go_ready-gcd or 0, ccr - latency - .15, sdr_remains, rogue_mage and ccr == 0 and (idr_remains < 14 and idr_remains) or 0, kidney_cd, _CCremains(friendly_mage) - 3, mfd_enabled and min(mfd_cd, time_to_max_cp + energy_time_to(energy_needed_for_go)) or time_to_max_cp + energy_time_to(energy_needed_for_go), immunity_remains, energy_time_to(energy_needed_for_go), symbols_cd - gcd*2)
		if not stealth_up and player_combat or player_forced then
	    	if unit and not team_sheep_cast[unit] then
	    		if time_to_stun <= 0 and immunity_remains == 0 then
	    			if combo_points >= combo_points_max - bin(melee_range) then
						if _Cast(408, unit, nil, true) then
							Squid_Alert_Big("Kidney "..unit_type,"(Going)", 1, .8, 408)
							return 0
						end
						-- out of range
		    			if _distance(unit) > 5 then
		    				local fleeing = fleeing_from_unit(unit,.3)
		    				if _movingTowards(unit, .13) and moving_towards_unit_duration(t,.13) > .3 and not fleeing then
		    					-- wait to get in melee range
		    					Squid_Alert("Please move to "..unit_type,"(Kidney)", nil, .8, 408)
		    				elseif _distance(unit) > 8 + bin(_movingTowards(unit,.14))*5 - bin(_isSlowed("player"))*3 and not fleeing then
		    					-- step to them
		    					if smooth_step(unit) then
		    						Squid_Alert_Big("Step "..unit_type,"(Kidney)", nil, .8, 36554)
		    						SquidFrame = 2
		    						return 0
		    					elseif step_cd > 1 then
		    						Squid_Alert_Big("Please move to "..strlower(unit_type),"(Kidney)", nil, .8, 408)
		    					end
		    				else
		    					Squid_Alert_Big("Please move to "..strlower(unit_type),"(Kidney)", nil, .8, 408)
		    				end
		    			end
					elseif mfd_cd == 0 and combo_points <= 3 and _distance(unit) <= 5 + bin(_spellCooldown(36554) == 0 and _LoS(unit))*18 then
						for i=1,#Enemies do if _Cast(137619,Enemies[i]) then Squid_Alert("Marked for Death","(Kidney)",nil,nil,137619) SquidFrame = 2 return 0 end end
					end
					pooling_combo_points = true
					cc_draw_line = {unit=unit, spellID=408, countdown=time_to_stun, ready=true}
	    		elseif time_to_stun < 6.25 then
	    			if time_to_stun > energy_time_to(energy_needed_for_go + 30*combo_points_deficit) then
	    				pooling_energy = energy_needed_for_go
	    			end
	    			pooling_combo_points = true
	    			if time_to_stun <= 6 and time_to_stun > 5 then
	    				Squid_Alert("Kidney " .. unit_type .. " in 5 sec.", nil, nil, 3, 408)
	    			end
	    			cc_draw_line = {unit=unit, spellID=408, countdown=time_to_stun}
	    		end
	    	end
	    end

    	return min( time_to_stun )

	end

	local max_cast_time = 69
	max_cast_time = healer_cc()

	if max_cast_time > gcd and valid_physical_target and distance_target < 23.5 and los_target and ( dance_remains >= 4 - bin(dance_charges > 0)*4 ) then
		if load_mode == "kill" then
			if runeforge == "Crit" then
				if (combo_points_deficit <= 1 - bin(deeper_strategem_enabled or runeforge == "DS" and combo_points == 0) or dance_up and symbols_up and target_stun_remains > 3.2 - gcd and energy >= 80 and (not mfd_enabled or mfd_cd == 0)) and symbols_up and dance_up and master_assassin_remains == 0 and not deathly_shadows_up and gcd_remains <= buffer + .125 and energy - pooling_energy >= 45 then
					if _Cast(1856) then
						Squid_Alert_Big("Vanish","(Offensive)",6,nil,1856)
						should_use_blades = time
						offensive_vanish = time
						SquidFrame = 2 -- run again next frame
					end
				end
			end
		end
	end

	local function dance_go(unit)

		if not dance_up or max_cast_time < gcd then return end

		local relent_mod = 0 -- need to find out if the unit is playing relentless
		local ogre_mod = select(2,UnitRace(unit)) == "Orc" and 0.2 or 0
		local cc_mod = 1 - ogre_mod - relent_mod

		local stun_dr = _stunDR(unit)
		if stun_dr < .25 then stun_dr = 0 end

		local sdr_remains = _drRemains(unit,"stun")
		local immune_cheap = _immuneStuns(unit,true)

		local cs_duration = (4 * stun_dr) * cc_mod

		local stun_remains = _stunRemains(unit)

		local dance_spells = {
			["Echoing Reprimand"] = {id=323547, cd=_spellCooldown(323547), cost=10},
			["Shadowstrike"] = {id=185438, cd=gcd_remains, cost=40},
			["Cheap Shot"] = {id=1833, cd=gcd_remains, cost=40, free=shot_in_the_dark_up},
		}

		-- shadow focus energy cost reduction
		if IsPlayerSpell(108209) then
			for k, v in pairs(dance_spells) do
				v.cost = v.cost * .8		
			end
		end

		local melee_range = _meleeRange(unit)

		local acceptable_gap = .41 * (1 + (max(ogre_mod*4,relent_mod*4)))
		local gcds_before_stun = math.floor( (stun_remains + acceptable_gap + .01 - gcd_remains) / gcd )

		if stun_remains > 0 and combo_points == 0 and stun_remains <= (4 * cc_mod)-gcd and gcds_before_stun > 0 then
			if _Cast(137619, t) then
				Squid_Alert("Marked for Death", nil, nil, nil, 137619)
				SquidFrame = 2
				return true
			end
		end

		-- general symbols usage 
		if melee_range and (energy_deficit >= 30 + (combo_points >= 4 and energy_gained_over_time(gcd) or 0) or stun_remains > 0 and (shadow_focus_enabled or shot_in_the_dark_enabled) or master_assassin_remains > gcd_remains+latency) then
			if _Cast(212283) then
				Squid_Alert("Symbols of Death",nil,nil,nil,212283)
			end
		end

		-- damage higher prio than 1/4 stun w crit
		if stun_dr <= .25 and master_assassin_remains > latency + gcd_remains then
			-- eviscerate with 4+
			if combo_points >= 4 then
				-- eviscerate?
				if _Cast(196819,unit,nil,true) then
					SquidFrame = 2 -- run script again on next frame
					return true
				end
			else
				-- cold blood
				if gcd_remains <= .4 and dance_remains > gcd_remains + .1 and _Cast(213981) then
					Squid_Alert("Cold Blood",nil,nil,nil,213981)
				end
				-- shadowstrike
				if _Cast(185438,unit,nil,true) then
					SquidFrame = 2
					return true
				end
			end
		end

		-- stuns
		if cs_duration > 0 and (sdr_remains == 0 or sdr_remains >= 17.5) and not immune_cheap then
			-- cheap again if stun on target remains < gcd - acceptable gap
			if stun_remains < gcd - acceptable_gap then
				if melee_range then
					if stun_remains > buffer and gcds_before_stun <= 0 then
						SquidFrame = 2
						return "wait"
					else
						-- cold blood
						if gcd_remains <= .4 and dance_remains > gcd_remains + .1 and _Cast(213981) then
							Squid_Alert("Cold Blood",nil,nil,nil,213981)
						end
						-- cheap
						if _Cast(1833,unit,nil,true) then
							SquidFrame = 2 -- run script again on next frame
							return true
						end
					end
				elseif _distance(unit) > 6 + bin(_movingTowards(unit,.11))*2 and stun_dr == 1 and not fleeing_from_unit(unit,.9) then
					if smooth_step(unit) then
						Squid_Alert("Shadowstep", "(Going)", nil, nil, 36554)
						SquidFrame = 2 -- run script again on next frame
						return true
					end
				end
			end
		end

		-- finishers
		if combo_points >= 4 - bin(gcds_before_stun == 2 and mfd_enabled and mfd_cd == 0) or er_ready then
			-- rupture
			if _HP(unit) > 75 and not target_rupture_ticking and not master_assassin_up then
				if _Cast(1943, unit, nil, true) then SquidFrame = 2 return true end
			end
			-- eviscerate?
			if _Cast(196819,unit,nil,true) then
				SquidFrame = 2 -- run script again on next frame
				return true
			end
		end

		-- echoing
		if (energy_deficit + dance_spells["Echoing Reprimand"].cost) - energy_gained_over_time(gcd) >= 20 then
			if _Cast(323547,unit,nil,true) then
				SquidFrame = 2
				return true
			end
		end

		if melee_range and combo_points <= 3 and energy_deficit >= 35 then
			if _Cast(212283) then
				Squid_Alert("Symbols of Death",nil,nil,nil,212283)
			end
		end

		-- cold blood
		if gcd_remains <= .4 and dance_remains > gcd_remains + .1 and _Cast(213981) then
			Squid_Alert("Cold Blood",nil,nil,nil,213981)
		end
		-- shadowstrike
		if _Cast(185438,unit,nil,true) then
			SquidFrame = 2
			return true
		end


	end

	if valid_physical_target and dance_go(t) then return true end

	local equipped_items = {}

	local trinkets = {
        173087, --Darkmoon Deck: Voracity
        178715, --Mistcaller Ocarina
        175884, --Sinful Aspirant's Badge of Ferocity
        175921,	--Sinful Gladiator's Badge of Ferocity
	}

	for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then 
		equipped_items[trinkets[i]] = GetItemCD(trinkets[i])
	end end

	-- REMOVEME
    -- use_dance = use_dance or target_go_ready <= 0 and not pooling_combo_points and melee_range_target or dance_charges_frac >= 1.8 and melee_range_target

    if valid_physical_target and _stunRemains(t) > 2.8 then
    	if _Cast(212182) then Squid_Alert("Bomb","( ))",nil,4,212182) return end
    end

	-- force following
	if target_to_follow and UnitIsVisible(target_to_follow) and not _immunePhysical(target_to_follow) then
		local x,y,z = PredictUnitPosition(target_to_follow,.09)
		if _distance(target_to_follow) > 1 then
			JesusMoveTo(x,y,z)
		end
		Squid_Alert_Big("JESUS IS TAKING THE WHEEL")
	end

	-- reset execute persistence
	if doing_execute and time - doing_execute >= 1 then doing_execute = nil end

	-- execute
	if get_squid_var("SubPvP - Execute") then
		if gcd_remains <= .55 + latency or doing_execute then
			for i=1,#Enemies do if unit_is_player(Enemies[i]) and not _immunePhysical(Enemies[i]) and (GetUnitSpeed(Enemies[i]) <= GetUnitSpeed("player")+2 or doing_execute or _meleeRange(Enemies[i])) and (unit_is_unit(Enemies[i],current_target) or _HP(Enemies[i]) < target_hp) then
				
				local e = Enemies[i]

				local effective_hp = UnitHealth(e) + UnitGetTotalAbsorbs(e)
				local current_damage, potential_damage, threshold_passed, cds_used

				-- execute power with current combo points
				if combo_points >= 4 or er_ready or mfd_enabled and mfd_cd == 0 then -- let the function know if we can use mfd after the first evisc
					current_damage, potential_damage, threshold_passed, cds_used = eviscerate_damage(e, combo_points < 4 and mfd_enabled and mfd_cd == 0 and 5 or combo_points, effective_hp, get_squid_var("SubPvP - Execute GCDs") >= 2 and (combo_points >= 4 or er_ready) and mfd_enabled and mfd_cd == 0)
					-- print(1,e, combo_points < 4 and mfd_enabled and mfd_cd == 0 and 5 or combo_points, effective_hp, get_squid_var("SubPvP - Execute GCDs") >= 2 and (combo_points >= 4 or er_ready) and mfd_enabled and mfd_cd == 0)
				else -- execute power without at least 4 combo points, let the function know we have the potential of 5 combo points with mfd
					current_damage, potential_damage, threshold_passed, cds_used = eviscerate_damage(e, mfd_enabled and mfd_cd == 0 and 5 or combo_points, effective_hp)
					-- print(2,e, mfd_enabled and mfd_cd == 0 and 5 or combo_points, effective_hp)
				end


				if cds_used then
					-- testing
					-- print(current_damage, potential_damage, threshold_passed, #cds_used)
					-- for i=1,#cds_used do print(cds_used[i].spell or cds_used[i].item) end
					local symbols_used
					for i=1,#cds_used do
						if cds_used[i].spell == 212283 then
							symbols_used = true
						end
					end
					if current_damage and cds_used and (energy >= 35 or symbols_used) then
						if (threshold_passed or (combo_points >= 4 and (_meleeRange(e) and potential_damage >= effective_hp*.75 or _stunRemains(e) >= 2 and potential_damage >= effective_hp*.7) or load_mode == "kill" and potential_damage >= effective_hp*.6)) or doing_execute then
							local cds = {}
							local items = {}
							for i=1,#cds_used do
								if cds_used[i].item then table.insert(items,cds_used[i].item) end
								if cds_used[i].spell then table.insert(cds,cds_used[i].spell) end
							end
							if _meleeRange(e) then
								if cp >= 4 or er_ready or _Cast(137619,Enemies[i]) and Squid_Alert("Marked for Death", nil, nil, nil, 137619) then
									-- persistent execute
									doing_execute = doing_execute or time
									if not unit_is_unit(e,current_target) then TargetUnit(e) end
									-- use items
									for i=1,#items do
										-- badge
										if items[i] == "Badge" then
											UseItemByName(tostring(GetItemInfo(175921)))
											UseItemByName(tostring(GetItemInfo(175884)))
											Squid_Alert("Gladiator's Badge", nil, nil, nil, 277185)
										end
									end
									-- use spells
									for i=1,#cds do
										-- dance
										if cds[i] == 185313 and _Cast(185313) then
											Squid_Alert("Dance", "(Execute)", nil, nil, 185313)
										end
										-- symbols
										if cds[i] == 212283 and _Cast(212283) then
											Squid_Alert("Smybols of Death", "(Execute)", nil, nil, 212283)
										end
										-- symbols
										if cds[i] == 1856 and not master_assassin_up and _Cast(1856) then
											Squid_Alert("Vanish", "(Execute)", 5, nil, 1856)
											offensive_vanish = time
										end
									end
									-- eviscerate
									if _Cast(196819,Enemies[i],nil,true) then
										StartAttack(Enemies[i])
										Squid_Alert("Eviscerate", "(Execute)", 6, nil, 196819)
										SquidFrame = 2 -- force the script to run again next frame
										return
									end
								end
							elseif not get_squid_var("SubPvP - No Execute Step") and (cp >= 4 or er_ready or _Cast(137619,Enemies[i]) and Squid_Alert("Marked for Death", nil, nil, nil, 137619)) then
								if _spellCooldown(36554) == 0 and _distance(Enemies[i]) <= 23.5 and _LoS(Enemies[i]) then
									StopMovingAndLock()
									target_to_follow = Enemies[i]
									-- print("ttf set, movement stopped")
									C_Timer.After(1,function() SetMovementLocked(false) target_to_follow = nil end)
								end
								if gcd_remains <= .2 + latency and _Cast(36554, Enemies[i]) then
									-- persistent execute
									doing_execute = doing_execute or time
									-- use items
									for i=1,#items do
										-- badge
										if items[i] == "Badge" then
											UseItemByName(tostring(GetItemInfo(175921)))
											UseItemByName(tostring(GetItemInfo(175884)))
											Squid_Alert("Gladiator's Badge", nil, nil, nil, 277185)
										end
									end
									-- use spells
									for i=1,#cds do
										-- dance
										if cds[i] == 185313 and _Cast(185313) then
											Squid_Alert("Dance", "(Execute)", nil, nil, 185313)
										end
										-- symbols
										if cds[i] == 212283 and _Cast(212283) then
											Squid_Alert("Smybols of Death", "(Execute)", nil, nil, 212283)
										end
										-- symbols
										if cds[i] == 1856 and not master_assassin_up and _Cast(1856) then
											Squid_Alert("Vanish", "(Execute)", 5, nil, 1856)
											offensive_vanish = time
										end
									end
									-- eviscerate
									if _Cast(196819,Enemies[i],nil,true) then
										StartAttack(Enemies[i])
										Squid_Alert("Eviscerate", "(Execute)", 6, nil, 196819)
										SquidFrame = 2 -- force the script to run again next frame
										return
									end
									SquidFrame = 2 -- force the script to run again next frame
									return
								end
								-- stop the script from doing other things than stepping to the guy and eviscerating
								if doing_execute and _spellCooldown(36554) == 0 and not _meleeRange(e) then return end
							end
						end
					end
				end
			end end
		end
	end

	-- alert when energy is being pooled
	if pooling_energy > energy and pooling_energy > 35 then
		Squid_Alert_Big("Pooling to " .. pooling_energy .. " Energy", pooling_energy_reason and "(" .. pooling_energy_reason .. ")", nil, .75)
	end

	-- alert when combo points are being pooled
	if pooling_combo_points then
		Squid_Alert("Pooling Combo Points")
	end

	-- alert when moving towards target
	-- if moving_towards_long then Squid_Alert_Big("Moving Towards Long",nil,nil,.5) elseif moving_towards then Squid_Alert("Moving Towards",nil,nil,.5) end

    -- stealth breaking soon
    if stealth_up and not vanish_up and unit_has_dot("player") then

    	Squid_Alert_Big("|cFFfef367Stealth Breaking Soon!", nil, nil, .25)

    	-- we could use this var elsewhere to set up a go on someone with master assassin
    	stealth_breaking_soon = true

    	-- shadowstrike
    	if valid_physical_target and (moving_towards_long or moving_towards and not fleeing_from_target) then
    		if _Cast(185438,current_target,nil,true) then
    			Squid_Alert("Shadowstrike", "(Stealth Breaking)",5,nil,185438)
    			return true
    		end
    	end

    else
    	stealth_breaking_soon = false
    end

    if theirHealer or their_healer_hiding then

    else
    	-- cc chain on dps
    end

	-- target is valid and attackable
	if valid_attackable_target then

		local snd_condition

		local usable_energy = energy - pooling_energy

		-- auto focus the best focus target
		if arena then
			if not UnitIsVisible(current_focus) or unit_is_unit(current_focus,current_target) then
				if their_healer.p and not unit_is_unit(their_healer.p,current_target) then
					FocusUnit(their_healer.p)
					Squid_Alert("Focusing Healer")
				elseif their_healer_hiding then
					-- do nothing
				else
					if UnitIsVisible(off_target) and not UnitIsDeadOrGhost(off_target) then
						FocusUnit(off_target)
						Squid_Alert("Focusing Off Target")
					end
				end
			end
		end

		local function use_items()

			-- badge
			if equipped_items[175884] and equipped_items[175884] <= 0
			or equipped_items[175921] and equipped_items[175921] <= 0 then
				UseItemByName(tostring(GetItemInfo(175921)))
				UseItemByName(tostring(GetItemInfo(175884)))
				Squid_Alert("Gladiator's Badge", nil, nil, nil, 277185)
				return true
			end

			-- that one trinket from the raid

		end

		local function cds()
			
			if not valid_physical_target then return end

			-- cold blood
			if dance_up and symbols_up then
				if _Cast(213981) then
					Squid_Alert_Big("Cold Blood",nil,nil,nil,213981)
				end
			end

			-- actions.cds+=/vanish,if=(runeforge.mark_of_the_master_assassin&combo_points.deficit<=1-talent.deeper_strategem.enabled|runeforge.deathly_shadows&combo_points<1)&buff.symbols_of_death.up&buff.shadow_dance.up&master_assassin_remains=0&buff.deathly_shadows.down
			if load_mode == "kill" then
				if runeforge == "Crit" then
					if (combo_points_deficit <= 1 - bin(deeper_strategem_enabled or runeforge == "DS" and combo_points == 0) or dance_up and symbols_up and target_stun_remains > 3.2 - gcd and energy >= 80 and (not mfd_enabled or mfd_cd == 0)) and symbols_up and dance_up and master_assassin_remains == 0 and not deathly_shadows_up and gcd_remains <= buffer + .125 and usable_energy >= 45 then
						if _Cast(1856) then
							Squid_Alert_Big("Vanish","(Offensive)",6,nil,1856)
							should_use_blades = time
							offensive_vanish = time
							SquidFrame = 2 -- run again next frame
							return true
						end
					end
				end
			end

			-- actions.cds+=/serrated_bone_spike,cycle_targets=1,if=variable.snd_condition&!dot.serrated_bone_spike_dot.ticking&target.time_to_die>=21|fight_remains<=5&spell_targets.shuriken_storm<3
			
			-- actions.cds+=/sepsis,if=variable.snd_condition&combo_points.deficit>=1
			
			if melee_range_target then
				-- actions.cds+=/symbols_of_death,if=variable.snd_condition&(talent.enveloping_shadows.enabled|cooldown.shadow_dance.charges>=1)
				if snd_condition and use_symbols then
					if enveloping_shadows_enabled or dance_charges >= 1 then
						if _Cast(212283) then
							Squid_Alert("Symbols of Death", nil, nil, nil, 212283)
							-- return true
						end
					end
				end
				-- actions.cds+=/marked_for_death,target_if=combo_points.deficit>=cp_max_spend
				if not pooling_combo_points and combo_points_deficit >= combo_points_max and not dance_up and (target_go_ready > 15 or load_mode == "kill")  then
					if _Cast(137619, t) then
						Squid_Alert("Marked for Death", nil, nil, nil, 137619)
						return true
					end
				end
				-- actions.cds+=/shadow_blades,if=variable.snd_condition&combo_points.deficit>=2
				if use_blades and combo_points_deficit >= 2 then
					if _Cast(121471) then
						Squid_Alert_Big("Shadow Blades", nil, 5, nil, 121471)
						return true
					end
				end
			end

			-- actions.cds+=/echoing_reprimand,if=variable.snd_condition&combo_points.deficit>=2
			if max_cast_time >= gcd and is_kyrian and snd_condition and combo_points_deficit >= 2 then
				if _Cast(323547, t, true) then
					Squid_Alert("Echoing Reprimand", nil, nil, nil, 323547)
					return true
				end
			end

			-- actions.cds+=/shadow_dance,if=!buff.shadow_dance.up&fight_remains<=8+talent.subterfuge.enabled
			if use_dance then
				if _Cast(185313) then
					Squid_Alert("Shadow Dance", nil, nil, nil, 185313)
					return true
				end
			end
			
			-- racials
			if symbols_up then
				-- actions.cds+=/blood_fury,if=buff.symbols_of_death.up
				if _Cast(20572) then
					Squid_Alert("Blood Fury", nil, nil, nil, 20572)
				end
				-- actions.cds+=/berserking,if=buff.symbols_of_death.up
				if _Cast(26297) then
					Squid_Alert("Berserking", nil, nil, nil, 26297)
				end
				-- actions.cds+=/fireblood,if=buff.symbols_of_death.up
				if _Cast(265221) then
					Squid_Alert("Fireblood", nil, nil, nil, 265221)
				end
				-- actions.cds+=/ancestral_call,if=buff.symbols_of_death.up
				if _Cast(274738) then
					Squid_Alert("Ancestral Call", nil, nil, nil, 274738)
				end
				
			end
			
			-- # Default fallback for usable items: Use with Symbols of Death.
			-- actions.cds+=/use_items,if=buff.symbols_of_death.up|fight_remains<20
			if symbols_up and load_mode then
				if use_items() then return true end
			end
		end

		local function build()

			if valid_physical_target and (combo_points_deficit > 0 or energy >= energy_max - 5) then
				
				-- # Builders
				-- actions.build=shiv,if=!talent.nightstalker.enabled&runeforge.tiny_toxic_blade&spell_targets.shuriken_storm<5
				if max_cast_time >= gcd and usable_energy >= GetSpellCost(5938) and not nightstalker_enabled and runeforge == "TTB" then
					if _Cast(5938, t, true) then Squid_Alert("Why are you using tiny toxic blade?",nil,nil,nil,5938) return true end
				end
				
				-- actions.build+=/shuriken_storm,if=spell_targets>=2
				if not dance_up and max_cast_time >= gcd and not bcc10 and AllEnemiesAroundMe(8) >= 2 and usable_energy >= GetSpellCost(197835) then
					if _Cast(197835) then return true end
				end

				-- actions.build+=/serrated_bone_spike,if=cooldown.serrated_bone_spike.charges_fractional>=2.75|soulbind.lead_by_example.enabled&!buff.lead_by_example.up
				
				-- actions.build+=/gloomblade
				if max_cast_time >= gcd and usable_energy >= GetSpellCost(200758) and _Cast(200758, t, true) then return true end
				-- actions.build+=/backstab
				if max_cast_time >= gcd and usable_energy >= GetSpellCost(53) and _Cast(53, t, true) then return true end

				-- knife target
				if usable_energy >= energy_max and max_cast_time >= gcd and (not fleeing_from_target or pooling_combo_points) and combat_ends > 3.5 and not er_ready and combo_points_deficit > 0 and (not dance_up or _rootCheck("player")) then
					if _Cast(114014, t, nil, true) then return true end
				end

			end
		end

		local function finish()

			if not valid_physical_target then return end
			if pooling_combo_points then return end

			-- # While using Premeditation, avoid casting Slice and Dice when Shadow Dance is soon to be used, except for Kyrian
			-- actions.finish=variable,name=premed_snd_condition,value=talent.premeditation.enabled&spell_targets.shuriken_storm<(5-covenant.necrolord)&!covenant.kyrian
			local premed_snd_condition = premed_enabled and not is_kyrian
			if not er_ready and not master_assassin_up and usable_energy > GetSpellCost(315496) then
				-- actions.finish+=/slice_and_dice,if=!variable.premed_snd_condition&spell_targets.shuriken_storm<6&!buff.shadow_dance.up&buff.slice_and_dice.remains<fight_remains&refreshable
				if max_cast_time >= gcd and not load_mode and not premed_snd_condition and not dance_up and snd_remains < 4 and (not player_combat or fleeing_from_target) and not pooling_combo_points then
					if _Cast(315496) then
						Squid_Alert("Slice and Dice",nil,nil,nil,315496)
						return true
					end
				end
				-- actions.finish+=/slice_and_dice,if=variable.premed_snd_condition&cooldown.shadow_dance.charges_fractional<1.75&buff.slice_and_dice.remains<cooldown.symbols_of_death.remains&(cooldown.shadow_dance.ready&buff.symbols_of_death.remains-buff.shadow_dance.remains<1.2)
				if max_cast_time >= gcd and premed_snd_condition and dance_charges_frac < 1.75 and snd_remains < symbols_cd and dance_cd == 0 and symbols_remains - dance_remains < 1.2 and (not player_combat or fleeing_from_target) then
					if _Cast(315496) then
						Squid_Alert("Slice and Dice",nil,nil,nil,315496)
						return true
					end
				end
			end

			-- # Helper Variable for Rupture. Skip during Master Assassin or during Dance with Dark and no Nightstalker.
			-- actions.finish+=/variable,name=skip_rupture,value=master_assassin_remains>0|!talent.nightstalker.enabled&talent.dark_shadow.enabled&buff.shadow_dance.up|spell_targets.shuriken_storm>=5
			local skip_rupture = master_assassin_remains > 0 or not nightstalker_enabled and dark_shadow_enabled and dance_up
			-- # Keep up Rupture if it is about to run out.
			-- actions.finish+=/rupture,if=(!variable.skip_rupture|variable.use_priority_rotation)&target.time_to_die-remains>6&refreshable
			if not master_assassin_up then
				if max_cast_time >= gcd and not skip_rupture and target_hp > 25 and target_rupture_remains < 4 + bin(not load_mode)*3 - combo_points_deficit*2 then
					if _Cast(1943, t, nil, true) then return true end
				end
			end
			-- actions.finish+=/secret_technique
			if max_cast_time >= gcd and not bcc10 and _Cast(280719, t, true) then return true end

			-- # Multidotting targets that will live for the duration of Rupture, refresh during pandemic.
			-- actions.finish+=/rupture,cycle_targets=1,if=!variable.skip_rupture&!variable.use_priority_rotation&spell_targets.shuriken_storm>=2&target.time_to_die>=(5+(2*combo_points))&refreshable
			
			-- # Refresh Rupture early if it will expire during Symbols. Do that refresh if SoD gets ready in the next 5s.
			-- actions.finish+=/rupture,if=!variable.skip_rupture&remains<cooldown.symbols_of_death.remains+10&cooldown.symbols_of_death.remains<=5&target.time_to_die-remains>cooldown.symbols_of_death.remains+5
			if not master_assassin_up then
				if max_cast_time >= gcd and not skip_rupture and target_rupture_remains < symbols_cd + 10 and symbols_cd <= 5 then
					if _Cast(1943, t, nil, true) then return true end
				end
			end
		
			-- actions.finish+=/eviscerate
			if max_cast_time >= gcd and _Cast(196819, t, true) then return true end

		end

		local function stealthed()
			
			if not valid_physical_target then return end
			local ss_cost = GetSpellCost(185438)

			-- # If Stealth/vanish are up, use Shadowstrike to benefit from the passive bonus and Find Weakness, even if we are at max CP (unless using Master Assassin)
			-- perform the shadowstrike opener?
			-- actions.stealthed=shadowstrike,if=(buff.stealth.up|buff.vanish.up)&master_assassin_remains=0

			-- # Finish at 4+ CP without DS, 5+ with DS, and 6 with DS after Vanish
			-- actions.stealthed+=/call_action_list,name=finish,if=combo_points.deficit<=1-(talent.deeper_stratagem.enabled&buff.vanish.up)
			if combo_points_deficit <= 1 - bin(deeper_stratagem_enabled and vanish_up) or er_ready then
				if finish() then return true end
			end

			-- actions.stealthed+=/shadowstrike,if=stealthed.sepsis&spell_targets.shuriken_storm<4
			if max_cast_time >= gcd and sepsis_stealth and usable_energy >= ss_cost then
				if _Cast(185438, t, true) then return true end
			end

			-- actions.stealthed+=/shiv,if=talent.nightstalker.enabled&runeforge.tiny_toxic_blade&spell_targets.shuriken_storm<5
			if max_cast_time >= gcd and nightstalker_enabled and runeforge == "TTB" then
				if _Cast(5938, t, true) then Squid_Alert("Why are you using tiny toxic blade?",nil,nil,nil,5938) return true end
			end

			-- spread mode
			-- # Up to 3 targets (no prio) keep up Find Weakness by cycling Shadowstrike.
			-- actions.stealthed+=/shadowstrike,cycle_targets=1,if=!variable.use_priority_rotation&debuff.find_weakness.remains<1&spell_targets.shuriken_storm<=3&target.time_to_die-remains>6

			-- # For priority rotation, use Shadowstrike over Storm with WM against up to 4 targets or if FW is running off (on any amount of targets)
			
			-- actions.stealthed+=/shadowstrike,if=variable.use_priority_rotation&(debuff.find_weakness.remains<1|talent.weaponmaster.enabled&spell_targets.shuriken_storm<=4)
			local fw_remains = _debuffRemains(t, 316220, "player")
			if max_cast_time >= gcd and fw_remains < 1 and usable_energy >= ss_cost then
				if _Cast(185438, t, true) then return true end
			end
			-- actions.stealthed+=/shuriken_storm,if=spell_targets>=3+(buff.the_rotten.up|runeforge.akaaris_soul_fragment&conduit.deeper_daggers.rank>=7)&(buff.symbols_of_death_autocrit.up|!buff.premeditation.up|spell_targets>=5)
			if not dance_up and max_cast_time >= gcd and not bcc10 and AllEnemiesAroundMe(8) >= 3 + bin(target_hp < 45) and usable_energy >= GetSpellCost(197835) then
				if _Cast(197835) then return true end
			end
			-- # Shadowstrike to refresh Find Weakness and to ensure we can carry over a full FW into the next SoD if possible.
			-- actions.stealthed+=/shadowstrike,if=debuff.find_weakness.remains<=1|cooldown.symbols_of_death.remains<18&debuff.find_weakness.remains<cooldown.symbols_of_death.remains
			if max_cast_time >= gcd and usable_energy >= ss_cost and (fw_remains < 1 or symbols_cd < 18 and fw_remains < symbols_cd) then
				if _Cast(185438, t, true) then return true end
			end
			-- actions.stealthed+=/gloomblade,if=buff.perforated_veins.stack>=5&conduit.perforated_veins.rank>=13
			if max_cast_time >= gcd and pv_stacks >= 5 and pv_rank >= 13 and usable_energy >= GetSpellCost(200758) then
				if _Cast(200758, t, true) then return true end
			end
			-- actions.stealthed+=/shadowstrike
			if max_cast_time >= gcd and usable_energy >= ss_cost then
				if _Cast(185438, t, true) then return true end
			end
			-- actions.stealthed+=/cheap_shot,if=!target.is_boss&combo_points.deficit>=1&buff.shot_in_the_dark.up&energy.time_to_40>gcd.max
			-- uhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
		end

		local function stealth_cds()
			-- # Stealth Cooldowns
			-- # Helper Variable
			-- actions.stealth_cds=variable,name=shd_threshold,value=cooldown.shadow_dance.charges_fractional>=1.75
			-- # Vanish if we are capping on Dance charges. Early before first dance if we have no Nightstalker but Dark Shadow in order to get Rupture up (no Master Assassin).
			-- actions.stealth_cds+=/vanish,if=(!variable.shd_threshold|!talent.nightstalker.enabled&talent.dark_shadow.enabled)&combo_points.deficit>1&!runeforge.mark_of_the_master_assassin
			-- # Pool for Shadowmeld + Shadowstrike unless we are about to cap on Dance charges. Only when Find Weakness is about to run out.
			-- actions.stealth_cds+=/pool_resource,for_next=1,extra_amount=40,if=race.night_elf
			-- actions.stealth_cds+=/shadowmeld,if=energy>=40&energy.deficit>=10&!variable.shd_threshold&combo_points.deficit>1&debuff.find_weakness.remains<1
			-- # CP thresholds for entering Shadow Dance
			-- actions.stealth_cds+=/variable,name=shd_combo_points,value=combo_points.deficit>=2+buff.shadow_blades.up
			-- actions.stealth_cds+=/variable,name=shd_combo_points,value=combo_points.deficit>=3,if=covenant.kyrian
			-- actions.stealth_cds+=/variable,name=shd_combo_points,value=combo_points.deficit<=1,if=variable.use_priority_rotation&spell_targets.shuriken_storm>=4
			-- # Dance during Symbols or above threshold.
			-- actions.stealth_cds+=/shadow_dance,if=variable.shd_combo_points&(variable.shd_threshold|buff.symbols_of_death.remains>=1.2|spell_targets.shuriken_storm>=4&cooldown.symbols_of_death.remains>10)
			-- # Burn remaining Dances before the fight ends if SoD won't be ready in time.
			-- actions.stealth_cds+=/shadow_dance,if=variable.shd_combo_points&fight_remains<cooldown.symbols_of_death.remains

		end

		local function actions()
			
			-- # Used to determine whether cooldowns wait for SnD based on targets.
			snd_condition = snd_up

			if (stealth_up or vanish_up) and (not offensive_vanish or time - offensive_vanish >= 3) then return true end

			-- actions+=/call_action_list,name=cds
			if cds() then return true end

			-- # Run fully switches to the Stealthed Rotation (by doing so, it forces pooling if nothing is available).
			-- actions+=/run_action_list,name=stealthed,if=stealthed.all
			if dance_up or subterfuge_up or ( vanish_up or stealth_up ) and offensive_vanish and time - offensive_vanish < 3 then
				if stealthed() then return true end
			end

			-- # Apply Slice and Dice at 2+ CP during the first 10 seconds, after that 4+ CP if it expires within the next GCD or is not up
			-- actions+=/slice_and_dice,if=spell_targets.shuriken_storm<6&fight_remains>6&buff.slice_and_dice.remains<gcd.max&combo_points>=4-(time<10)*2
			-- if max_cast_time >= gcd and snd_remains < gcd and combo_points >= 4 - bin(time_in_combat<10) * 2 and not pooling_combo_points and (not player_combat or fleeing_from_target) then
			-- 	if _Cast(315496) then
			-- 		Squid_Alert("Slice and Dice",nil,nil,nil,315496)
			-- 		return true
			-- 	end
			-- end

			-- # Only change rotation if we have priority_rotation set and multiple targets up.
			-- actions+=/variable,name=use_priority_rotation,value=priority_rotation&spell_targets.shuriken_storm>=2
			-- # Priority Rotation? Let's give a crap about energy for the stealth CDs (builder still respect it). Yup, it can be that simple.
			-- actions+=/call_action_list,name=stealth_cds,if=variable.use_priority_rotation
			-- # Used to define when to use stealth CDs or builders
			-- actions+=/variable,name=stealth_threshold,value=25+talent.vigor.enabled*20+talent.master_of_shadows.enabled*20+talent.shadow_focus.enabled*25+talent.alacrity.enabled*20+25*(spell_targets.shuriken_storm>=4)
			local stealth_threshold = 25 + bin(vigor_enabled)*20 + bin(master_of_shadows_enabled)*20 + bin(shadow_focus_enabled)*25 + bin(alacrity_enabled)*20
			-- # Consider using a Stealth CD when reaching the energy threshold
			-- actions+=/call_action_list,name=stealth_cds,if=energy.deficit<=variable.stealth_threshold
			if energy_max - usable_energy <= stealth_threshold then
				if stealth_cds() then return true end
			end 
			-- actions+=/call_action_list,name=finish,if=combo_points=animacharged_cp

			if er_ready and not pooling_combo_points then
				if finish() then return true end
			end
			-- # Finish at 4+ without DS or with SoD crit buff, 5+ with DS (outside stealth)
			-- actions+=/call_action_list,name=finish,if=combo_points.deficit<=1|fight_remains<=1&combo_points>=3|buff.symbols_of_death_autocrit.up&combo_points>=4
			if combo_points_deficit <= 1 or symbols_crit_up and combo_points >= 4 then
				if finish() then return true end
			end

			-- ? ? ? ? 
			-- # With DS also finish at 4+ against 4 targets (outside stealth)
			-- actions+=/call_action_list,name=finish,if=spell_targets.shuriken_storm>=4&combo_points>=4
			
			-- # Use a builder when reaching the energy threshold
			-- actions+=/call_action_list,name=build,if=energy.deficit<=variable.stealth_threshold
			if energy_deficit <= stealth_threshold then
				if build() then return true end
			end
			
			-- # Lowest priority in all of the APL because it causes a GCD
			-- actions+=/arcane_torrent,if=energy.deficit>=15+energy.regen
			-- actions+=/arcane_pulse
			-- actions+=/lights_judgment
			-- actions+=/bag_of_tricks

		end

		
		-- stealth_openers()

		-- stealth_finishers()

		actions()

		-- if lockdown() then return true end

		-- if cooldowns() then return true end

		-- if spend() then return true end
		
		-- if generate() then return true end

	end

endfunction Squid_DeathKnight()

	if IsMounted() or IsFlying() then return; end

	local auto_chains = SQUID.auto_chains

	-- Priorities (actions.precombat):
 --    flask/food/augmentation/snapshot_stats/potion/raise_dead/army_of_the_dead,delay=2
 	local time = GetTime()
 	local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
 	local gcd_remains = GetGCD()
 	local spec = GetSpecialization();
 	local pet_up = UnitExists("pet") and not UnitIsDeadOrGhost("pet")
 	local RunicPower = UnitPower("player");
 	local function PlayerRunesUp() local count=0; for i=1,6 do if select(3,GetRuneCooldown(i)) == true then count=count+1; end end return count,6-count; end
 	local Runes = PlayerRunesUp();
 	local frenzy = UnitBuffID("player",207289);
 	local wounds = current_target and _debuffStacks(current_target,194310);
 	local leap_cd = _spellCooldown(47482)
 	local dark_transformation = pet_up and UnitBuffID("pet",63560)
 	local controlling_pet
 	--grip gap closers on units moving away from player
 	-- if _movingAwayFrom("player",.11,unit) then
 	--Unholy
 	if spec == 3 then
 		
 		local function priority_actions()
 			--dark sim
 			local sim = {
	 			--mage
				28272,		-- Pig
				118,		-- Sheep
				277792,		-- Bee
				161354,		-- Monkey
				277787,		-- Direhorn
				161355,		-- Penguin
				161353,		-- Polar Bear
				120140,		-- Porcupine
				61305,		-- Cat
				61721,		-- Rabbit
				61780,		-- Turkey
				28271,		-- Turtle
				82691,		-- Ring of Frost
				203286,		-- Greater Pyroblast
				199786,		-- Glacial Spike

				--warlock
				116858,		-- Chaos Bolt
				157695,   	-- Demon Bolt
				5782,		-- Fear
				118699,		-- Fear

				--shaman
				51514,		-- Hex

				--paladin
				20066,		-- Repentance

				--druid
				33786,		-- Cyclone
				202771,		-- full moon

				--priest
				2060,       -- Greater Heal
 			}

 			if IsPlayerSpell(77606) and _spellCooldown(77606) <= .45 then
	 			for i=1,#Enemies do
	 				local cast,_,_,_,_,_,_,_,id = UnitCastingInfo(Enemies[i])
	 				if cast and tContains(sim,id) and _distance(Enemies[i]) < 40 then
	 					local timeleft = _castTimeLeft(Enemies[i])
	 					if timeleft <= gcd + .5 then
	 						if timeleft <= .4 then
	 							if _Cast(77606,Enemies[i],nil,true) then
	 								Squid_Alert_Big("Dark Sim","(".. GetSpellInfo(id) ..")",1,3.5,77606)
	 							end
	 						end
	 						waiting_for_sim = time
	 						waiting_for_sim_unit = Enemies[i]
	 					end
	 				end
	 			end
	 		end

 			--grip gap openers
	 		if enemy_gapclose and time - enemy_gapclose <= gcd then
	 			if unit_is_unit(enemy_gapclose_pointer,current_target) and _movingAwayFrom("player",.11,current_target) then
	 				if _Cast(49576,current_target,true) then
	 					Squid_Alert_Big("Grip " .. UnitClass(current_target),"(Gap Opener)",1,3.5,49576)
	 					gap_opener_gripped = time
	 					gap_opener_gripped_pointer = current_target
	 				end
	 			end
	 		end
	 		--chains after gripping a gap opener
	 		if gap_opener_gripped and time - gap_opener_gripped <= gcd+.5 then
	 			local e = gap_opener_gripped_pointer
	 			if not _slowImmuneCheck(e) and not _immuneMagic(e) then
	 				_Cast(45524,e)
	 			end
	 		end
	 		--keep pet 5 yds from target when petkick is available
	 		if dark_transformation and leap_cd <= 2 then--and not _isMeleeDps(current_target) then
	 			local pet_dist = _distance("pet",current_target)
	 			if pet_dist <= 5.5 or pet_dist > 8 then
	 				local x,y,z = ObjectPosition("pet")
					local tx,ty,tz = ObjectPosition(current_target)
					local direction
					for i=0,math.pi*2,.05 do
						if not TraceLine(tx - 9 * math.cos(i), ty - 9 * math.sin(i), tz+1, x, y, z+1, 0x100111) then
							direction = i
							break
						end
					end
					--sometimes we end up with a nil TraceLine result
					if not tx or not ty then
						tx,ty,tz = ObjectPosition(current_target)
					end
					tx = tx - 9 * math.cos(direction)
					ty = ty - 9 * math.sin(direction)
					RunMacroText("/petmoveto")
					ClickPosition(tx,ty,tz)
					CancelPendingSpell()
					_targetLastTarget()
	 			end
	 			controlling_pet=true
	 		end
	 		--offensive icebound
	 		if lowestEnemy <= 30 then
	 			if _stunCheck("player") then
	 				if _spellCooldown(48792) == 0 then
	 					CastSpellByID(48792)
	 					Squid_Alert_Big("Icebound Fortitude","(Offensive)",4,3.5,48792)
	 				end
	 			end
	 		end
	 	end

	 	local function essences()
	 		_Cast(295373,current_target,true);
	 	end

	 	local function aoe()

		 	local dndticking = UnitBuffID("player",188290)
			-- actions.aoe=death_and_decay,if=cooldown.apocalypse.remains
			if _spellCooldown(275699) > 3 then
				_AeCast(43265,current_target,30)
			end
			-- actions.aoe+=/defile
			-- actions.aoe+=/epidemic,if=death_and_decay.ticking&rune<2&!variable.pooling_for_gargoyle
			if dndticking and Runes < 2 and RunicPower >= 30 then
				_Cast(207317)
			end
			-- actions.aoe+=/death_coil,if=death_and_decay.ticking&rune<2&!variable.pooling_for_gargoyle
			if Runes < 2 and dndticking then
				if _HP("player") < 80 then
					_Cast(49998)
				else
					_Cast(47541)
				end
			end
			-- actions.aoe+=/scourge_strike,if=death_and_decay.ticking&cooldown.apocalypse.remains
			if not arena then
				if dndticking and _spellCooldown(275699) > 3 then
					if IsPlayerSpell(223829) then
						_Cast(223829)
					else
						_Cast(55090)
					end
				end
			end
			-- actions.aoe+=/clawing_shadows,if=death_and_decay.ticking&cooldown.apocalypse.remains
			-- actions.aoe+=/epidemic,if=!variable.pooling_for_gargoyle
			if RunicPower >= 30 then
				_Cast(207317)
			end
			-- actions.aoe+=/festering_strike,target_if=debuff.festering_wound.stack<=1&cooldown.death_and_decay.remains
			if wounds <= 1 and _spellCooldown(43265) > 2 then
				_Cast(85948)
			end
			-- actions.aoe+=/festering_strike,if=talent.bursting_sores.enabled&spell_targets.bursting_sores>=2&debuff.festering_wound.stack<=1
			-- actions.aoe+=/death_coil,if=buff.sudden_doom.react&rune.deficit>=4
			if UnitBuffID("player",49530) and Runes <= 2 then
				_Cast(47541)
			end
			-- actions.aoe+=/death_coil,if=buff.sudden_doom.react&!variable.pooling_for_gargoyle|pet.gargoyle.active
			if UnitBuffID("player",49530) then
				_Cast(47541)
			end
			-- actions.aoe+=/death_coil,if=runic_power.deficit<14&(cooldown.apocalypse.remains>5|debuff.festering_wound.stack>4)&!variable.pooling_for_gargoyle
			if RunicPower > 86 and (_spellCooldown(275699) > 5 or wounds > 4) then
				if _HP("player") < 80 then
					_Cast(49998)
				else
					_Cast(47541)
				end
			end
			-- actions.aoe+=/scourge_strike,if=((debuff.festering_wound.up&cooldown.apocalypse.remains>5)|debuff.festering_wound.stack>4)&cooldown.army_of_the_dead.remains>5
			if ((wounds > 0 and _spellCooldown(275699) > 5) or wounds > 4) and _spellCooldown(288853) > 5 then
				_Cast(223829);
			end
			-- actions.aoe+=/clawing_shadows,if=((debuff.festering_wound.up&cooldown.apocalypse.remains>5)|debuff.festering_wound.stack>4)&cooldown.army_of_the_dead.remains>5
			-- actions.aoe+=/death_coil,if=runic_power.deficit<20&!variable.pooling_for_gargoyle
			if RunicPower > 80 then
				if _HP("player") < 80 then
					_Cast(49998)
				else
					_Cast(47541)
				end
			end
			-- actions.aoe+=/festering_strike,if=((((debuff.festering_wound.stack<4&!buff.unholy_frenzy.up)|debuff.festering_wound.stack<3)&cooldown.apocalypse.remains<3)|debuff.festering_wound.stack<1)&cooldown.army_of_the_dead.remains>5
			if ((((wounds < 4 and not frenzy) or wounds < 3) and _spellCooldown(275699) < 3) or wounds < 1) and _spellCooldown(288853) > 5 then
				_Cast(85948)
			end
			-- actions.aoe+=/death_coil,if=!variable.pooling_for_gargoyle
			if _HP("player") < 80 then
				_Cast(49998)
			else
				_Cast(47541)
			end

		end
		-- print(Runes)
	 	local function cooldowns()
	 		-- Priorities (actions.cooldowns):
		   --abomb
		   	if IsPlayerSpell(288853) then
				_AeCast(288853,current_target,40)
			else
				_Cast(42650)
			end
		    -- army_of_the_dead/apocalypse,if=debuff.festering_wound.stack>=4/dark_transformation,if=!raid_event.adds.exists|raid_event.adds.in>15
		    if wounds >= 4 then
		    	if _Cast(275699) then
		    		Squid_Alert("Apocalypse",nil,nil,nil,275699)
		    	end
		    end
		    if frenzy or lowestEnemy <= 50 or lowestFriend <= 35 then
		    	_Cast(63560)
		    end
		    -- summon_gargoyle,if=runic_power.deficit<14
		    -- unholy_frenzy,if=debuff.festering_wound.stack<4&!(equipped.ramping_amplitude_gigavolt_engine|azerite.magus_of_the_dead.enabled)
		    -- unholy_frenzy,if=cooldown.apocalypse.remains<2&(equipped.ramping_amplitude_gigavolt_engine|azerite.magus_of_the_dead.enabled)
		    if (_spellCooldown(275699) < 2 or _spellCooldown(275699) > 35) and _distance(current_target) < 5 then
		    	_Cast(207289)
		    end
		    -- unholy_frenzy,if=active_enemies>=2&((cooldown.death_and_decay.remains<=gcd&!talent.defile.enabled)|(cooldown.defile.remains<=gcd&talent.defile.enabled))
		    -- soul_reaper,target_if=target.time_to_die<8&target.time_to_die>4
		    -- soul_reaper,if=(!raid_event.adds.exists|raid_event.adds.in>20)&rune<=(1-buff.unholy_frenzy.up)/unholy_blight
		    if Runes < 3 and wounds > 0 then
		    	_Cast(130736)
		    end

	 	end

	 	local function generic()
		
			--  death_coil,if=buff.sudden_doom.react&!variable.pooling_for_gargoyle|pet.gargoyle.active
			if UnitBuffID("player",49530) then
				_Cast(47541,current_target)
			end
			--  death_coil,if=runic_power.deficit<14&(cooldown.apocalypse.remains>5|debuff.festering_wound.stack>4)&!variable.pooling_for_gargoyle
			if RunicPower >= 86 then
				if _HP("player") < 80 then
					_Cast(49998,current_target)
				else
					_Cast(47541,current_target)
				end
			end
			--  death_and_decay,if=talent.pestilence.enabled&cooldown.apocalypse.remains/defile,if=cooldown.apocalypse.remains
			--  scourge_strike,if=((debuff.festering_wound.up&cooldown.apocalypse.remains>5)|debuff.festering_wound.stack>4)&cooldown.army_of_the_dead.remains>5
			if wounds > 0 then
				if _spellCooldown(275699) > 5 or wounds > 4 then
					-- if IsPlayerSpell(223829) then
						_Cast(223829,current_target)
					-- end
				end
			end
			--  clawing_shadows,if=((debuff.festering_wound.up&cooldown.apocalypse.remains>5)|debuff.festering_wound.stack>4)&cooldown.army_of_the_dead.remains>5
			--  death_coil,if=runic_power.deficit<20&!variable.pooling_for_gargoyle
			if RunicPower >= 80 then
				if _HP("player") < 80 then
					_Cast(49998)
				else
					_Cast(47541)
				end
			end
			-- festering_strike,if=((((debuff.festering_wound.stack<4&!buff.unholy_frenzy.up)|debuff.festering_wound.stack<3)&cooldown.apocalypse.remains<3)|debuff.festering_wound.stack<1)&cooldown.army_of_the_dead.remains>5
			if ((((wounds <= 4 and not frenzy) or wounds <= 3) and _spellCooldown(275699) < 3) or wounds < 1) and (_spellCooldown(288853) > 3 or _spellCooldown(42650) > 3) then
				_Cast(85948)
			end

	 	end
 		--get pet
 		if not UnitExists("pet") or UnitIsDeadOrGhost("pet") then
 			_Cast(46584)
 		end


		--totem stomp
		function Stomp(totem,name)
			local hp = UnitHealth(totem)
			local maxhp = UnitHealthMax(totem)
			if hp <= 1 then return false; end
			--DEATH COIL
			if hp <= 12500 then
				_Cast(47541,totem)
			end
			--SCOURGE STRIKE
			if hp <= 9000 then
				_Cast(55090,totem)
			end
		end

		local totems = {
		101398,	--Psyfiend
		119052,	--War Banner
		104818,	--Ancestral Protection Totem
		53006,	--Spirit Link Totem
		2630,	--Earthbind Totem
		60561,	--Earthgrab Totem
		-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
		5925,	--Grounding Totem
		105425,	--Skyfury Totem
		5913,	--Tremor Totem
		105451,	--Counterstrike Totem
		}

		if arena then
			for i=1,#Pets do
				local e = Pets[i]
				local name = UnitName(e);
				local id = UnitCreatureID(e)
				--only kill cap totems when they're casting
				if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
					Stomp(e,name)
				end
			end
		end

 		--Combat
 		if current_target and UnitCanAttack("player",current_target) and not UnitIsDeadOrGhost(current_target) and not _immuneCheck(current_target) and (UnitAffectingCombat(current_target) or UnitIsPlayer(current_target) or _isDummy(current_target)) then
			
			--wraith
			if _rootCheck("player") and _rootRemains("player") >= 1.5 and _distance(current_target) > 7 then
				if _Cast(212552) then
					Squid_Alert_Big("Wraith Walk","(Root)",nil,nil,212552)
				end
			end

			--death's advance
			if frenzy or lowestEnemy < 35 then
				if _Cast(48265) then
					Squid_Alert_Big("Death's Advence","(Offensive)",nil,nil,48265)
				end
			end

			priority_actions();

			--Chains Target
			if UnitIsPlayer(current_target) and _distance(current_target) > 4 and not _isSlowed(current_target) and not _CCcheck(current_target) then
				if not _slowImmuneCheck(current_target) and _movingAwayFrom("player",.11,current_target) then
					if _Cast(45524,current_target) then
						Squid_Alert("Chains","(Target)",nil,nil,45524)
					end
				end
			end

			--chains peel
			if auto_chains then
				if lowestFriend <= 60 then
					for i=1,#Enemies do if _isMeleeDps(Enemies[i]) then
						local e = Enemies[i]
						if not _isSlowed(e) and not _CCcheck(e) and not _slowImmuneCheck(e) then
							if not _slowImmuneCheck(e) then
								if _Cast(45524,e) then
									Squid_Alert("Chains " .. UnitClass(e),"(Peel)",nil,nil,45524)
								end
							end
						end
					end end
				end
			end

			if _HP("player") < 50 then
				_Cast(49998,current_target);
			end

			-- actions+=/outbreak,target_if=dot.virulent_plague.remains<=gcd
			if _debuffRemains(current_target,191587) < 2.5 then
				_Cast(77575,current_target);
			end

			if (not PetAttackSent or time-PetAttackSent > 2) and not controlling_pet then
				PetAttack();
				-- RunMacroText("/use 14")
				PetAttackSent=time
			end

			if not AutoAttackSent or time-AutoAttackSent > 2 then
				StartAttack()
			end

			--auto_attack/variable,name=pooling_for_gargoyle,value=cooldown.summon_gargoyle.remains<5&talent.summon_gargoyle.enabled
			essences();

			cooldowns();

			aoe();

			generic();


		end


 	end


endfunction Squid_Druid()

	if IsMounted() or IsFlying() or IsAoEPending() then return end
	local spec = GetSpecialization()
	local time = GetTime()
	local latency = select(4,GetNetStats())/1000

	local utilities = SQUID.UtilitiesOnly

	--Feral
	if spec == 2 then

		--swiftmended out of stealth? (maybe had dot)
		--crucible of flamed out of stealth (also maybe broke to dot..idk)
		--add primal wrath
		--add pre bear
		--add clones
		--add auto dash / sr
		--add get people out of stealth
		--add auto stuns
		--add shift roots
		--add war banner check for stuns
		--add minimum flat hp for rip, smth like this UnitHealthMax("player")/9 * groupsize

		local spread = SQUID.spread_mode
		local auto_burst = SQUID.auto_burst

		local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
		local gcd_remains = GetGCD()

		local groupsize = GetNumGroupMembers()

		local human = GetShapeshiftForm() == 0
		local cat = UnitBuffID("player",768)
		local bear = UnitBuffID("player",5487)
		local travel = UnitBuffID("player",783)

		local cp = UnitPower("player",4)
		local energy = UnitPower("player",3)
		local energy_max = UnitPowerMax("player",3)
		local energy_deficit = energy_max-energy
		local energy_regen = GetPowerRegen()
		local energy_time_to_max = energy_deficit/energy_regen
		local player_hp = _HP("player")
		local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")

		local prowl = UnitBuffID("player",5215) or UnitBuffID("player",102547)
		local shadowmeld = UnitBuffID("player",58984)
		local ps_remains = _buffRemains("player",69369)
		local ps = ps_remains > 0
		local clearcasting = UnitBuffID("player",135700)
		local clearcasting_remains = _buffRemains("player",135700)
		local berserk_remains = _buffRemains("player",106951)
		local incarn_remains = _buffRemains("player",102543)
		local berserk_incarn = berserk_remains > 0 or incarn_remains > 0
		local berserk_incarn_remains = berserk_remains > 0 and berserk_remains or incarn_remains
		local tigers_fury_remains = _buffRemains("player",5217)
		local tigers_fury = tigers_fury_remains > 0
		local iron_jaws = UnitBuffID("player",276026)
		local bloodtalons_stacks = _buffStacks("player",145152)
		local bloodtalons_up = bloodtalons_stacks > 0
		local dash = UnitBuffID("player",1850)
		local dash_cd = _spellCooldown(1850)
		local stampeding_roar = UnitBuffID("player",77764)
		local savage_roar_remains = _buffRemains("player",52610)
		local savage_roar_up = savage_roar_remains > 0
		
		local existing_root_remains = 0
		local existing_root
		for i=1,#Enemies do
			local r = _debuffRemains(Enemies[i],339,"player")
			if r > 0 then
				existing_root_remains = r
				existing_root = true
			end
		end

		local wild_fleshrending_enabled = AzeritePowerTaken(359)
		local feral_frenzy_enabled = IsPlayerSpell(274837)
		local bloodtalons_enabled = IsPlayerSpell(155672)
		local savage_roar_enabled = IsPlayerSpell(52610)
		local sabertooth_enabled = IsPlayerSpell(202031)
		local incarn_enabled = IsPlayerSpell(102543)
		local balance_affinity = IsPlayerSpell(197488)
		local lunar_inspiration = IsPlayerSpell(155580)
		local thorns_enabled = IsPlayerSpell(305497)
		local fresh_wound = IsPlayerSpell(203224)

		local tigers_fury_cd = _spellCooldown(5217)
		local feral_frenzy_cd = _spellCooldown(274837)
		local berserk_cd = _spellCooldown(106951)
		local incarn_cd = _spellCooldown(102543)
		local berserk_incarn_cd = berserk_cd > 0 and berserk_cd or incarn_cd
		local swiftmend_cd = IsPlayerSpell(18562) and _spellCooldown(18562) or 1000
		local remove_corruption_cd = _spellCooldown(2782)
		local wild_charge_cd = _spellCooldown(102401)
		local thorns_cd = _spellCooldown(305497)
		local maim_cd = _spellCooldown(22570)

		local function rip_remains(unit) return _debuffRemains(unit,1079,"player") end
		local function rake_remains(unit) return _debuffRemains(unit,155722,"player") end
		local rip_power = _ripPower
		local rake_power = _rakePower
		local current_rake_snapshot = GetCurrentSnapshot(1822)
		local current_rip_snapshot = GetCurrentSnapshot()
		local hold_cp_for_maim

		local combat = UnitAffectingCombat("player")
		local group_size = GetNumGroupMembers()

		if SQUID.cap_bot then
			ok_to_cat = time
		end

		if not bite_effect_checked or time-bite_effect_checked > 5 then
			bite_effect = GetSpellEffect(22568)
			if not bite_effect then
				--for clients in other langs
				bite_effect = (UnitAttackPower("player")*.7) * 5
			end
			bite_effect_checked=time
		end

		--really good bite effect (not accounting for armor and defensives)
		local bite_effect = bite_effect / 5 * cp
		local bite_mod = 1 + ((energy-25)*.04)
		if bite_mod < 1 then bite_mod = 1 end
		if bite_mod > 2 then bite_mod = 2 end
		bite_effect = bite_effect * bite_mod

		local their_healer
		local their_healer_cc
		local their_healer_cc_remains = 0
		if theirHealer then
			their_healer = theirHealer
			their_healer_cc_remains = _CCremains(theirHealer)
			their_healer_cc = their_healer_cc_remains > 0
		end

		local enemy_player_around
		for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then
			enemy_player_around=true
			break
		end end

		local enemy_rogue
		local enemy_rogue_kidney_cd
		local enemy_rogue_cp
		for i=1,#Enemies do if UnitClass(Enemies[i]) == "Rogue" then
			enemy_rogue = Enemies[i]
			break
		end end
		if enemy_rogue then
			enemy_rogue_kidney_cd = UnitCooldown(enemy_rogue,408)
			-- enemy_rogue_cp = UnitPower(enemy_rogue,) --fix
			enemy_rogue_cc = _CCremains(enemy_rogue) >= .05
		end

		local our_healer = ourHealer
		local our_healer_cc
		local our_healer_cc_remains = 0
		if our_healer then
			our_healer_cc_remains = _CCremains(ourHealer)
			our_healer_cc = our_healer_cc_remains > 0
		end

		local our_mage
		local our_mage_casting_cc
		local our_mage_cc_target
		for i=1,#Friends do if UnitClass(Friends[i]) == "Mage" then
			our_mage = Friends[i] 
			break
		end end
		if arena and our_mage then
			local magecc = {
			"Polymorph",
			"Ring of Frost",
			}
			our_mage_casting_cc = tContains(magecc,UnitCastingInfo(our_mage))
			if our_mage_casting_cc then
				our_mage_cc_target = UnitSpellTarget(our_mage)
			end
		end

		if player_cast and player_cast_id == 33786 then
			squid_clone_delay = time
		end

		local nature_lockout = _spellCooldown(33786) > gcd_remains or _spellCooldown(8936) > gcd_remains

		--reset shifting delay after clone cast if it was interrupted, or completed
		if nature_lockout or (player_clone and time - player_clone < .35) then squid_clone_delay = nil end

		local aoe_range = 8.5 + (balance_affinity and 5 or 0)

		local enemies_around = EnemiesAroundMe(aoe_range)
		local bcc = _bccAM(aoe_range)

		local function root_value(unit)
			local root = _rootRemains(unit)
			if root > 1 then
				if lowestFriend < 40 then
					local friend = lowestFriendName
				end
			end
		end

		--check if unit is valid (immunes, dead, breakable cc etc)
		local function valid(unit,immune,nocheck)
			if not unit then return false end
			return (nocheck or UnitCanAttack("player",unit))
			and (nockeck or not UnitIsDeadOrGhost(unit))
			and not _breakableCC(unit)
			and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
			and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
		end

		--our current target
		local t = current_target
		local valid_attackable_target = t and UnitCanAttack("player",t)
		local valid_physical_target = valid(t,1)
		local valid_magical_target = valid(t,2)

		--dots on target
		local target_rip_ticking = valid_physical_target and rip_remains(t) > 0
		local target_rip_remains = target_rip_ticking and rip_remains(t) or 0
		local target_rip_power = target_rip_ticking and rip_power(t) or 0

		-- print(target_rip_power)

		local target_rake_ticking = valid_physical_target and rake_remains(t) > 0
		local target_rake_remains = target_rake_ticking and rake_remains(t) or 0
		local target_rake_power = target_rake_ticking and rake_power(t) or 0

		local moving_towards_time = moving_towards_unit_duration(t,.11)
		local moving_towards = _movingTowards(t,.11)
		local moving_towards_target = valid_physical_target and moving_towards and moving_towards_time > .135
		local moving_towards_long = valid_physical_target and moving_towards and moving_towards_time > .18
		local melee_range_target = valid_physical_target and _meleeRange(t)
		local distance_target = valid_physical_target and _distance(t) or 0
		local function target_outruns_player(dist)
			if valid_attackable_target and moving_towards_target then
				local px,py,pz = GetPlayerPosition()
				px,py,pz = PredictUnitPosition("player",.25)
				local x,y,z = ObjectPosition(t)
				x,y,z = PredictUnitPosition(t,.25)
				local estimated_dist = GetDistanceBetweenPositions(x,y,z,px,py,pz) - UnitCombatReach("player") - UnitCombatReach("target")
				return estimated_dist > dist
			end
			return false
		end

		local function valid_stun_target(unit)
			return _CCremains(unit) <= .35 and (_stunDR(unit) == 1 or _drRemains(unit,"stun") > 8) and not _immunePhysical(unit)
		end

		--offtargets, prioritized by hp or lowest dot duration
		local offtargets = {}
		local riptargets = {}
		local raketargets = {}
		local thrashtargets = {}
		for i=1,#Enemies do
			local e=Enemies[i]
			if valid(e,1,true) then
				local hp = _HP(e)
				local melee_range = _meleeRange(e)
				local prio = 0
				local rake = rake_remains(e)
				local rip = rip_remains(e)
				local thrash = _debuffRemains(e,106830,"player")
				table.insert(offtargets,{pointer=e,hp=hp,rake=rake,rip=rip,thrash=thrash,mr=melee_range})
				table.insert(riptargets,{pointer=e,hp=hp,rake=rake,rip=rip,thrash=thrash,mr=melee_range})
				table.insert(raketargets,{pointer=e,hp=hp,rake=rake,rip=rip,thrash=thrash,mr=melee_range})
				table.insert(thrashtargets,{pointer=e,hp=hp,rake=rake,rip=rip,thrash=thrash,mr=melee_range})
			end 
		end
		table.sort(offtargets,function(x,y) return x.hp < y.hp end)
		table.sort(riptargets,function(x,y) return x.rip < y.rip or (x.rip == y.rip and x.hp < y.hp) end)
		table.sort(raketargets,function(x,y) return x.rake < y.rake or (x.rake == y.rake and x.hp < y.hp) end)
		table.sort(thrashtargets,function(x,y) return x.thrash < y.thrash or (x.thrash == y.thrash and x.hp < y.hp) end)

		local lowestfriends = {}
		for i=1,#Friends do
			local e=Friends[i]
			if UnitIsPlayer(e) then
				local hp = _HP(e)
				table.insert(lowestfriends,{pointer=e,hp=hp})
			end 
		end
		table.sort(lowestfriends,function(x,y) return x.hp < y.hp end)

		local dispellable ={
		80240,	--havoc
		51514,	--hex
		211015,	--hex cockroach
		210873,	--hex compy
		211010,	--hex snake
		211004,	--hex spider
		277784,	--hex wicker mongrel
		277778,	--hex zandalari tendonripper
		309328,	--hex living honey
		199954,	--curse of frag (removed?)
		202914,	--spider sting
		202797,	--viper sting
		};

		local function remove_corruption(unit)
			local lessDelay = minDelayTime/1.3;
			for i=1,#dispellable do
				local debuff,_,_,five,six,seven = UnitDebuffID(unit,dispellable[i]);
				if debuff and seven-time < six-lessDelay then
					return dispellable[i];
				end
			end
		end

		local function hibernate_inc()
			for i=1,#Enemies do 
				if UnitCastingInfo(Enemies[i]) == "Hibernate" then
					local e = Enemies[i]
					local dest = UnitSpellTarget(Enemies[i])
					if unit_is_unit(dest,player_pointer) and _distance(e) < 40 then
						local time_left = _castTimeLeft(e)
						if time_left <= latency + .23 then
							return true
						end
					end
				end
			end
		end

		local function stealth()
			--rake stun stealthed targets
			for i=1,#Enemies do if _stealthCheck(Enemies[i]) then
				if _Cast(1822,Enemies[i],nil,true) then
					Squid_Alert_Big("Rake Stun " .. UnitClass(Enemies[i]),"(Stealth)",1,nil,1822)
					return
				end
			end end
			--stampeding roar invis mage (after arena preparation)
			if our_mage and not UnitBuffID("player",32727) and _distance(our_mage) < 12 then
				if UnitBuffID(our_mage,66) then
					if _Cast(106898) then
						Squid_Alert("Stampeding Roar","Mage Invis")
						return
					end
				end
			end
			--rake target if not immune
			if valid_physical_target and melee_range_target then
				if _Cast(1822,t,true) then
					Squid_Alert("Rake Stun",UnitClass(t),nil,nil,1822)
					return
				end
			end
		end

		local function root_healer_los()
			if gcd_remains > .4 then return end
			if their_healer and their_healer_cc_remains < gcd+1 and _rootRemains(their_healer) < gcd+1 and _rootDR(their_healer) >= .25 then
				if valid_attackable_target and not _LoS(their_healer,t) then
					if _Cast(339,their_healer) then
						Squid_Alert_Big("Root " .. UnitClass(their_healer),"(LoS)",4,nil,339)
						return
					end
				end
			end
		end

		local function priority_ps()
			if gcd_remains > .4 then return end
			--root healer los
			root_healer_los()
			--root target to gapclose
			if moving_towards_target
				and _isMoving(current_target) 
			    and (distance_target > 7.75 or _isSlowed("player") and not _isSlowed(current_target)) 
			    and (select(4,GetUnitSpeed("player")) <= select(4,GetUnitSpeed(current_target)) or distance_target > 13.65) then
				if not _slowImmuneCheck(current_target) and not _immuneMagic(current_target) then
					if _Cast(339,current_target) then
						Squid_Alert("Root Target","(Gapclose)",nil,nil,339)
						return true
					end
				end
			end
			--root melee
			if (group_size < 5 or instance_type == "pvp") then
				for i=1,#Enemies do
					local d = _distance(Enemies[i])
					if d <= 38 then
						local e = Enemies[i]
						if (not unit_is_unit(e,current_target) or d > 7) and (existing_root_remains < 2 or d > 7) then
							if _isMeleeDps(e) and not _slowImmuneCheck(e) and not _immuneMagic(e) and select(2,UnitClass(e)) ~= "DRUID" then
								local cc = _CCremains(e)
								if cc < 1 then
									local root = _rootRemains(e)
									local rootdr = _rootDR(e)
									local dr_remains = _drRemains(e,"root")
									if (rootdr == 1 or dr_remains > 15 and rootdr >= .5) and root < 1 then
										if _Cast(339,e) then
											Squid_Alert("Root " .. UnitClass(e),"(Melee)",nil,nil,339)
											return true
										end
										return
									end
								end
							end
						end
					end
				end
			end
			--regrowths on people who need
			local rghp = 85
			rghp=rghp+(bloodtalons_enabled and 25 or 0)
			for i=1,#lowestfriends do
				local f = lowestfriends[i].pointer
				local hp = _HP(f)
				if hp <= rghp and _distance(f) < 38 and _LoS(f) then
					if _Cast(8936,f) then
						Squid_Alert("Regrowth "..UnitClass(f),nil,nil,nil,8936)
						return true
					end
					return
				end
			end
		end

		local function use_ps()
			if gcd_remains > .4 then return end
			if priority_ps() then return true end
			--roots on everything else
			if group_size < 5 or instance_type == "pvp" then
				for i=1,#Enemies do if not unit_is_unit(Enemies[i],t) then
					if _distance(Enemies[i]) <= 35 then
						local e = Enemies[i]
						local cc = _CCremains(e)
						if cc < 1 and not _slowImmuneCheck(e) and not _immuneMagic(e) and existing_root_remains < 2 then
							local root = _rootRemains(e)
							local rootdr = _rootDR(e)
							local dr_remains = _drRemains(e,"root")
							if (rootdr == 1 or dr_remains > 12 and rootdr >= .5) and root < 1 then
								if _Cast(339,e) then
									Squid_Alert("Root " .. UnitClass(e),"(PS)",nil,nil,339)
									return true
								end
								return
							end
						end
					end
				end end
			end
			--regrowths on anything
			local rghp = 101
			for i=1,#lowestfriends do
				local f = lowestfriends[i].pointer
				local hp = _HP(f)
				if hp <= rghp and _distance(f) < 38 and _LoS(f) then
					if _Cast(8936,f) then
						Squid_Alert("Regrowth "..UnitClass(f),nil,nil,nil,8936)
						return true
					end
					return
				end
			end
		end

		local function priority_actions()

			--auto attack
			if cat and valid_physical_target then
				if not start_attack_time or time - start_attack_time > .5 then
					StartAttack()
					start_attack_time=time
				end
			end

			--queued maim
			if squid_maim_queued then
				if time - squid_maim_queued < 8 then
					if UnitIsVisible(squid_maim_target) and valid_stun_target(squid_maim_target) then
						if maim_cd < 5 then
							if cp == 5 and maim_cd <= gcd_remains+1 then
								if _meleeRange(squid_maim_target) then
									if energy >= 30 * (berserk_incarn and .6 or 1) and _Cast(22570,squid_maim_target,nil,true) then
										Squid_Alert_Big("Maim " .. UnitClass(squid_maim_target),"(Queued)",nil,nil,22570)
										C_Timer.After(.3,function()
											-- Squid_Alert("|cFFc31d39Maim no longer queued",nil,nil,nil,22570)
											squid_maim_queued=nil
											squid_maim_target=nil
										end)
										return
									end
								elseif wild_charge_cd == 0 and maim_cd <= gcd_remains+.3 then
									local d = _distance(squid_maim_target)
									if d < 8 then
										Squid_Alert("Maim Ready","(Move Closer)",nil,nil,22570)
									elseif d > 25 then
										Squid_Alert("Too far to leap for maim",nil,nil,nil,22570)
									elseif d >= 8 and d <= 25 then
										if _Cast(102401,squid_maim_target,nil,true) then
											Squid_Alert("Wild Charge","(Maim Ready)",nil,nil,102401)
											return
										end
									end
								end
							end
							hold_cp_for_maim=true
						end
					end
				else
					Squid_Alert("|cFFc31d39Maim no longer queued",nil,nil,nil,22570)
					squid_maim_queued=nil
					squid_maim_target=nil
				end
			end

			--leap to healer when they are in breakable cc nether tempest / living bomb while they are in breakable cc

			--root their healer out of LoS of your target
			if ps then
				root_healer_los()
			end

			--pre bear
			if not bear then
				--healer cc or vendetta up or hp < 65 or no healer present
				if our_healer_cc or UnitDebuffID("player",79140) or (player_hp < 65 and (not our_healer or player_hp < 35)) then
					--don't spam pre bear. if the player wants to force cat after a pre bear, let them.
					if not pre_bear or time - pre_bear > 9 then
						--step was on player, kidney is off cd, and we're off dr
						if enemy_shadowstep and time-enemy_shadowstep <= gcd then
							if unit_is_unit("player",enemy_shadowstep_target) 
							and enemy_rogue
							and enemy_rogue_kidney_cd <= gcd
							and not enemy_rogue_cc
							and _drRemains(player_pointer,"stun") <= gcd then
								if _Cast(5487) then
									Squid_Alert_Big("Pre Bear","(Step Kidney)",2,4.5,5487)
									C_Timer.After(.1,function() if UnitBuffID("player",5487) then pre_bear=time end end)
								end
							end
						end
						--rogue targeting player
						if enemy_rogue and enemy_rogue_kidney_cd <= gcd and not enemy_rogue_cc and _distance(enemy_rogue) < 8 then
							--player off dr
							if _drRemains(player_pointer,"stun") <= gcd then
								local rogue_target = UnitTarget(enemy_rogue)
								--player is rogue's target
								if unit_is_unit("player",rogue_target) then
									if _Cast(5487) then
										Squid_Alert_Big("Pre Bear","(Kidney)",2,4.5,5487)
										C_Timer.After(.1,function() if UnitBuffID("player",5487) then pre_bear=time end end)
									end
								end
							end
						end
					end
				end

			else
				--bear actions
				if _HP("player") < 50 + ((not our_healer or our_healer_cc) and 20 or 0) then
					_Cast(22842)
				end
			end


			--shift hibernate
			if cat then
				if hibernate_inc() then
					RunMacroText("/cancelform")
					Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
				end
			elseif travel then
				if hibernate_inc() then
					RunMacroText("/cancelform")
					Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
				end
			elseif bear then
				if hibernate_inc() then
					if EnemiesAttacking("player") == 0 then
						RunMacroText("/cancelform")
						Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
					end
				end
			end

			--rooting on event
			if lowestFriend < 30 or not bloodtalons_enabled or cp >= 4 then
				if ps then
					if shouldRootUnit 
					and UnitIsVisible(shouldRootUnit) 
					and shouldRootTime 
					and time-shouldRootTime < gcd
					and _rootDR(shouldRootUnit) >= .25 
					and not _slowImmuneCheck(shouldRootUnit)
					and not _immuneMagic(shouldRootUnit) then
						if shouldRootReason ~= "Cat Form" or _distance(shouldRootUnit) > 9 then
							if _Cast(339,shouldRootUnit) then
								Squid_Alert_Big("Rooted ",shouldRootReason,4,3.5,339)
							end
						end
					end
					if valid_magical_target
					and _debuffRemains(t,113942) >= 88.3
					and not _slowImmuneCheck(t) then
						if _Cast(339,t) then
							Squid_Alert_Big("Rooted","Demonic Gateway",4,3.5,339)
						end
					end
				end
			end

			--dispel
			if remove_corruption_cd <= gcd_remains then
				for i=1,#Friends do
					local dispel = remove_corruption(Friends[i])
					if dispel and _LoS(Friends[i]) and _Cast(2782,Friends[i]) then
						Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,2782)
					end
				end
			end

			--priority rooting
			-- if lowestFriend <= 75 or travel then
			-- 	--root melee to peel 
			-- 	if ps then
			-- 		for i=1,#Enemies do 
			-- 			local e = Enemies[i]
			-- 			--melee, lowest friend < 50%hp, or cds up and 75
			-- 			if _isMeleeDps(e) and (lowestFriend <= 50 or _CDcheck(e) or bear) then
			-- 				--rootdr
			-- 				local rootdr = _rootDR(e)
			-- 				local drremains = _drRemains(e,"root")
			-- 				if (rootdr == 1 or drremains > 14 and rootdr >= .5) and not _slowImmuneCheck(e) and not _immuneMagic(e) then
			-- 					if _Cast(339,e) then
			-- 						Squid_Alert("Rooted " .. UnitClass(e),"(Peel)",nil,nil,339)
			-- 					end
			-- 				end
			-- 			end
			-- 		end
			-- 	end
			-- end

			--totem stomp
			local function Stomp(totem,name)
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				--LI MOONFIRE TOTEMS
				if lunar_inspiration and hp <= 5000 then
					if _Cast(155625,totem,nil,true) then
						Squid_Alert_Big(name .. " Stomped","(Moonfire)",1,3.5,155625)
						return
					end
				end
				--REGULAR MOONFIRE PSYFIEND
				if name == "Psyfiend" then
					if _meleeRange(totem) then
						if _Cast(1822,totem,nil,true) then
							Squid_Alert_Big(name .. " Stomped","(Rake)",1,4,1822)
							return
						end
					else
						if _Cast(8921,totem,nil,true) then
							Squid_Alert_Big(name .. " Stomped","(Moonfire)",1,3.5,8921)
							return
						end
					end
				end
				--SHRED TOTEMS (CLEARCASTING)
				if clearcasting then
					if _Cast(5221,totem,nil,true) then
						Squid_Alert_Big(name .. " Stomped","(Shred)",1,4,5221)
						return
					end
				end
				--RAKE TOTEMS
				if hp <= 3400 then
					if _Cast(1822,totem,nil,true) then
						Squid_Alert_Big(name .. " Stomped","(Rake)",1,4,1822)
						return
					end
				end
				--SHRED TOTEMS
				if hp <= 13000 then
					if _Cast(5221,totem,nil,true) then
						Squid_Alert_Big(name .. " Stomped","(Shred)",1,4,5221)
						return
					end
				end
			end

			local totems = {
			101398,	--Psyfiend
			119052,	--War Banner
			104818,	--Ancestral Protection Totem
			53006,	--Spirit Link Totem
			2630,	--Earthbind Totem
			60561,	--Earthgrab Totem
			-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
			5925,	--Grounding Totem
			105425,	--Skyfury Totem
			5913,	--Tremor Totem
			105451,	--Counterstrike Totem
			"Twisted Appendage", -- tentacle
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					local id = UnitCreatureID(e)
					--only kill cap totems when they're casting
					if tContains(totems,id) or tContains(totems,name) or (id == 61245 and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
					--root abomination
					if id == 149555 and ps and _rootDR(e) >= .5 and _CCremains(e) + _rootRemains(e) < gcd then
						if _Cast(339,e) then
							Squid_Alert("Root","Abomination",nil,nil,339)
							return
						end
					end
				end
			end

			if _rootCheck("player") and (not squid_clone_delay or time - squid_clone_delay > 1) then
				if cat then
					if _Cast(783) then
						Squid_Alert("Travel Form","(Shift Root)",nil,nil,783)
						ok_to_cat=time
						return
					end
				else
					if _Cast(768) then
						Squid_Alert("Cat Form","(Shift Root)",nil,nil,768)
						return
					end
				end
			end

			if not utilities then
				if _isSlowed("player") and (not squid_clone_delay or time - squid_clone_delay > 1) then
					if target_outruns_player(12) then
						if cat then
							if _Cast(783) then
								Squid_Alert("Travel Form","(Shift Slow)",nil,nil,783)
								ok_to_cat=time
								return
							end
						else
							if _Cast(768) then
								Squid_Alert("Cat Form","(Shift Slow)",nil,nil,768)
								return
							end
						end
					end
				end
			end

			--cloning??

			--valid physical
			if valid_physical_target and not utilities then

				if player_has_control() then
					--tigers fury (root / slow break)
					if _rootCheck("player") 
					  or ( _isSlowed("player") and valid_physical_target and distance_target > 4 and distance_target < 10 and target_outruns_player(10) ) then
						if tigers_fury_cd == 0 then
							--cancel form if in form, otherwise cast TF
							if not human and not tigers_fury then RunMacroText("/cancelform"); tf_powershift = time; return; else _Cast(5217); end
						end
					end
					--follow thru
					if tf_powershift and time - tf_powershift < 1 then
						if _Cast(5217) then Squid_Alert("Tiger's Fury","(Powershift)",nil,nil,5217) end
					end
				end

				--tigers fury (normal usage)
				if energy_deficit >= 60 and melee_range_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) and not _rootCheck("player") then
					if (_isSlowed("player") or _rootCheck("player")) and _spellCooldown(5217) == 0 and player_has_control() and not human then RunMacroText("/cancelform"); return; end
					if _Cast(5217) then Squid_Alert("Tiger's Fury",nil,nil,nil,5217) return end
				end

				--burst (berserk / incarn) only when moving towards target. would rather not burst when trying to play defensive.
				if auto_burst and (moving_towards_target or not _isMoving("player")) and melee_range_target then
					--berserk
					local tf_returning_cd = 5 + (incarn_enabled and 10 or 0)
					if energy >= 30 and (_spellCooldown(5217) > tf_returning_cd or tigers_fury or their_healer_cc_remains > 5) then
						if _Cast(106951) then
							Squid_Alert("Berserk",nil,nil,nil,106951)
							return
						end
						if _Cast(102543) then
							Squid_Alert("Incarnation",nil,nil,nil,102543)
							return
						end
					end
				end

				if Squid_Burst then
					if _Cast(106951) then
						Squid_Alert("Berserk",nil,nil,nil,106951)
						return
					end
					if _Cast(102543) then
						Squid_Alert("Incarnation",nil,nil,nil,102543)
						return
					end
				end

				if (not savage_roar_enabled or savage_roar_remains >= 3) and sabertooth_enabled and target_rip_remains == 0 and cp > 0 and melee_range_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) then
					_Cast(5217)
				end

				--apply TF rip on target if more powerful than current rip and sabertooth
				if (not savage_roar_enabled or savage_roar_remains >= 3) and sabertooth_enabled and (target_rip_remains == 0 or (target_rip_power < current_rip_snapshot and UnitHealth(t) > 25000 * groupsize)) then

					--tiger's fury up, in melee and ready to go, do it with at least 1 cp
					if cp > 0 and melee_range_target then

						--tf 
						if (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) and (bloodtalons_stacks > 0 or not bloodtalons_enabled) and _Cast(5217) then
							Squid_Alert("Tiger's Fury",nil,nil,nil,5217)
						end

						if tigers_fury then
							--only with bloodtalons up if it's taken
							if bloodtalons_enabled then
								if bloodtalons_stacks > 0 then
									if _Cast(1079,t,true) then
										return
									end
								end
							else--otherwise just do it
								if _Cast(1079,t,true) then
									return
								end
							end
						end

					end

				end

			end

			--thorns
			if thorns_enabled and thorns_cd <= gcd then
				for i=1,#Friends do
					local f=Friends[i]
					if _HP(f) < 85 and select(2,EnemiesAttacking(f)) > 0 then
						if _Cast(305497,f) then
							Squid_Alert("Thorns " .. UnitClass(f),nil,nil,nil,305497)
						end
					end
				end
			end

			--feral frenzy
			if valid_physical_target then
				if cp == 0 then
					_Cast(274837,t,true)
				end
			end

			--essences here

			--breath of the dying (reaping flames)
			if valid_magical_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) then
				if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains then
					local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t));
					if hp < 20 or (hp < 82 + (their_healer_cc and 18 or 0) and hp > 80) then
						if hp < 20 or _HP(t) > 80 then
							if _Cast(310690,t,true) then
								Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
							end
						end
					end
				end
			end

			--concentrated flame
			if valid_magical_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) then
				if energy <= 25 or energy <= 40 and _buffStacks("player",295378) < 2 or energy <= 60 and _spellChargeFrac(295373) >= 1.85 or distance_target > 8 then
					_Cast(295373,t,true)
				end
			end

		end

		local function finishers()

			if hold_cp_for_maim then return end

			--execute bite (anyone, pvp or targeted)
			if energy >= 25 then
				for i=1,#offtargets do
					local t = offtargets[i].pointer
					local mr = offtargets[i].mr
					if mr and (arena or unit_is_unit(t,current_target)) then
						local hp = UnitHealth(t)
						if bite_effect > hp then
							if _Cast(22568,t,true) then
								Squid_Alert("Bite "..UnitClass(t),"(Execute)",nil,nil,22568)
							end
						end
					end
				end
			end

			if utilities then return end

			--savage roar maintain
			if cp > 0 and savage_roar_enabled then
				if savage_roar_remains < 2 then
					_Cast(52610)
				end
			end

			--rip maintenance bite spread
			if cp == 5 then
				for i=1,#riptargets do
					local t = riptargets[i].pointer
					local rip = riptargets[i].rip
					local mr = riptargets[i].mr
					if rip > 0 and rip < (gcd*2) + .2 then
						_Cast(22568,t,true)
					end
				end
			end

			--priority ps
			if ps and ((cp >= 4 and not berserk_incarn) or energy < 40 or ps_remains <= gcd or bloodtalons_enabled) and (not tigers_fury or energy < 25 or bloodtalons_enabled) and (not bloodtalons_enabled or cp >= 4) then
				if priority_ps() then return end
			end

			--spread rips to other targets if spread mode is on
			if spread and (bloodtalons_enabled and cp == 5 or bloodtalons_enabled and bloodtalons_stacks == 1 and cp >= 4 or not bloodtalons_enabled and cp >= 4) and not waiting_for_cp then
				for i=1,#riptargets do if UnitIsPlayer(riptargets[i].pointer) or _isDummy(riptargets[i].pointer) then
					local t = riptargets[i].pointer
					local mr = riptargets[i].mr
					local rip = riptargets[i].rip
					if mr and rip < 7.2 and (rip == 0 or not sabertooth_enabled) then
						if _Cast(1079,t,true) then return end
					end
				end end
			end

			--rip maintenance bite spread
			if cp == 5 then
				for i=1,#riptargets do
					local t = riptargets[i].pointer
					local rip = riptargets[i].rip
					local mr = riptargets[i].mr
					if rip > 0 then
						_Cast(22568,t,true)
					end
				end
			end

			local waiting_for_cp

			--auto maims
			-- if valid_physical_target and iron_jaws and cp >= 4 then
			-- 	local dr = _stunDR(t)
			-- 	local drremains = _drRemains(t,"stun")
			-- 	local ccr = _CCremains(t)
			-- 	if dr == 1 or ccr > 0 and ccr <= gcd_remains + .1 and dr >= .5 or drremains >= 16 and dr >= .5 then
			-- 		if cp == 5 then
			-- 			_Cast(22570,t,true)
			-- 		else
			-- 			waiting_for_cp=true
			-- 		end
			-- 	end
			-- end

			--maintain rip on target (5 cp or 3 with sabertooth)
			if valid_physical_target and not waiting_for_cp and (cp == 5 or (sabertooth_enabled and not bloodtalons_enabled and cp >= 4)) then
				local rip = target_rip_remains
				--if no rip on the target....
				if rip == 0 then
					--wait until tiger's fury comes back
					if tigers_fury_cd > 2 then
						if _Cast(1079,t,true) then return end
					end
				else
					if not sabertooth_enabled and rip <= 7.2 then
						if _Cast(1079,t,true) then return end
					end
					if (rip <= 19.2 or sabertooth_enabled) and (current_rip_snapshot > target_rip_power and UnitHealth(t) > 25000 * groupsize) then
						if _Cast(1079,t,true) then return end
					end
				end
			end

			--refresh rips to other targets if spread mode is on
			if spread and (bloodtalons_enabled and cp == 5 or bloodtalons_enabled and bloodtalons_stacks == 1 and cp >= 4 or not bloodtalons_enabled and cp >= 4) and not waiting_for_cp then
				for i=1,#riptargets do if UnitIsPlayer(riptargets[i].pointer) then
					local t = riptargets[i].pointer
					local mr = riptargets[i].mr
					local rip = riptargets[i].rip
					if mr and rip < 7.2 and (rip == 0 or not sabertooth_enabled) then
						if _Cast(1079,t,true) then return end
					end
				end end
			end

			--bite target
			if cp == 5 and valid_physical_target then
				if (energy >= 50 * (berserk_incarn and .6 or 1) or target_rip_remains <= 4.5) and target_rip_remains > 0 then
					if _Cast(22568,t,true) then return end
				end
			end

		end

		local function generators()
			
			--root melee / regrowth >= 4 cp if bloodtalons enabled
			if ps and bloodtalons_enabled and (cp >= 4 or ps_remains <= gcd) then
				if use_ps() then return end
			end

			if utilities then return end

			--no generating while capped cp
			if cp == 5 or feral_frenzy_cd > 43 then return end

			--rake generator w/ fresh wound
			if fresh_wound and cp <= 3 then
				for i=1,#raketargets do
					local t = raketargets[i].pointer
					local mr = raketargets[i].mr
					local rake = raketargets[i].rake
					if rake == 0 then
						if _Cast(1822,t,true) then return end
					end
				end
			end

			--thrash cleave clearcasting w/ spread
			if valid_physical_target and spread then
				if not bcc and enemies_around >= 2 then
					if clearcasting then
						if _Cast(106830) then return end
					end
				end
			end

			--brutal slash cleave if spread mode (if > 3 targets)
			if valid_physical_target and spread then
				if not bcc and enemies_around >= 3 then
					if _Cast(202028) then return end
				end
			end

			--rake target < 4.5 without bloodtalons, or not ticking with bloodtalons
			if valid_physical_target then
				if target_rake_remains < 2.65 or not bloodtalons_enabled and target_rake_remains < 4.5 then
					if not fresh_wound or target_rake_remains == 0 then
						if _Cast(1822,t,true) then return end
					end
				end
			end

			--rake bloodtalons up and 7s and current multiplier > power * .85
			if valid_physical_target then
				if bloodtalons_up and (bloodtalons_stacks > 1 or not lunar_inspiration) then
					if target_rake_remains < 7 and current_rake_snapshot > target_rake_power * .85 then
						if not fresh_wound or target_rake_remains == 0 then
							if _Cast(1822,t,true) then return end
						end
					end
				end
			end

			--maintain rake on multiple targets, not ticking or multiplier > power
			if spread or fresh_wound then
				for i=1,#raketargets do
					local t = raketargets[i].pointer
					local mr = raketargets[i].mr
					local rake = raketargets[i].rake
					if rake < 5 or current_rake_snapshot > _rakePower(t) then
						if not fresh_wound or rake == 0 then
							if _Cast(1822,t,true) then return end
						end
					end
				end
			end

			--thrash cleave w/ spread
			if valid_physical_target and spread and not bcc then
				local count = 0
				for i=1,#thrashtargets do
					if thrashtargets[i].mr and thrashtargets[i].thrash < 4 then
						count = count + 1
					end
				end
				if count >= 2 then
					if _Cast(106830) then return end
				end
			end

			--brutal slash cleave (> 2 targets)
			if valid_physical_target and melee_range_target then
				if not bcc and enemies_around >= 2 then
					if _Cast(202028) then return end
				end
			end

			--brutal slash with tigers fury up
			if valid_physical_target and melee_range_target and tigers_fury then
				if not bcc then
					if _Cast(202028) then return end
				end
			end

			--thrash maintain w/ spread
			if valid_physical_target and spread and not bcc then
				local dur_deficit = 0
				for i=1,#thrashtargets do
					if thrashtargets[i].mr then
						dur_deficit = dur_deficit + (15 - thrashtargets[i].thrash)
					end
				end
				if dur_deficit >= 13 then
					if _Cast(106830) then return end
				end
			end

			--shred with clearcasting
			if valid_physical_target and clearcasting then
				if _Cast(5221,t,true) then return end
			end

			--brutal slash filler
			if valid_physical_target and melee_range_target then
				if not bcc then
					if _Cast(202028) then return end
				end
			end

			--maintain rake on multiple targets, not ticking or multiplier > power
			if spread or fresh_wound then
				for i=1,#raketargets do
					local t = raketargets[i].pointer
					local mr = raketargets[i].mr
					local rake = raketargets[i].rake
					if rake < 5 or current_rake_snapshot > _rakePower(t) then
						if not fresh_wound or rake == 0 then
							if _Cast(1822,t,true) then return end
						end
					end
				end
			end

			--shred fallthru
			if valid_physical_target then
				if _Cast(5221,t,true) then return end
			end

		end

		--acceptable stealth actions
		if valid_physical_target and moving_towards_target and distance_target > 8 and (not prowl or UnitAffectingCombat(t)) then
			if not dash and not stampeding_roar then
				if _Cast(102401,t,true) then
					Squid_Alert("Wild Charge","Gapclose",nil,nil,102401)
					return
				end
			end
			if not stampeding_roar then
				if wild_charge_cd > 1 and distance_target > 16 then
					if _spellCooldown(1850) <= gcd and _isSlowed("player") then RunMacroText("/cancelform") end
					if _Cast(1850) then
						Squid_Alert("Dash","Gapclose",nil,nil,1850)
						return
					end
				end
			end
			if wild_charge_cd > 1 and dash_cd > 0 and not dash and distance_target > 16 then
				if _Cast(77764) then
					Squid_Alert("Stampeding Roar","Gapclose",nil,nil,106898)
					return
				end
			end
		end

		--prowl
		if (not combat or shadowmeld) and not prowl and (valid_attackable_target or enemy_player_around) then
			if _Cast(5215) then
				Squid_Alert("Prowl",nil,nil,nil,5215)
				return
			end
			if _spellCooldown(5215) <= 1.5 then return end
		end

		--stealth actions
		if prowl or shadowmeld then 
			stealth()
			return
		end

		--cat
		if (human or not cat and ok_to_cat and time-ok_to_cat < 2.5) and valid_attackable_target then
			if not squid_clone_delay or time - squid_clone_delay > 1.2 or moving_towards_long then
				if _Cast(768) then
					return
				end
			end
		end

		priority_actions()

		finishers()

		--swiftmend
		if swiftmend_cd <= gcd_remains and not bear and not feral_frenzy_active then
			local maxhp = 45
			maxhp = maxhp + (our_healer_cc and 30 or 0)
			--less swiftmending with energy available, when on target
			if valid_physical_target and distance_target < 7 then
				maxhp = maxhp - (energy/2.5)
			end
			--much less swiftmending with high combo points, especially when a rip will fall off

			for i=1,#lowestfriends do
				local f = lowestfriends[i].pointer
				local hp = lowestfriends[i].hp
				if hp < maxhp then
					if _Cast(18562,f) then
						Squid_Alert("Swiftmend " .. UnitClass(f),nil,nil,nil,18562)
						return
					end
				end
			end
		end

		generators()

	--end of feral
	elseif spec == 1 then
		
		--balance
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local gcd_remains = GetGCD()
		local astral_power = UnitPower("player",8)

		local prowl = UnitBuffID("player",5215)
		if prowl then return end --pause in prowl
		local cat = UnitBuffID("player",768)
		local bear = UnitBuffID("player",5487)
		local moonkin = UnitBuffID("player",24858)
		local travel = UnitBuffID("player",783) or (GetShapeshiftForm() == 6 and not (cat or bear or moonkin))

		local starlord_enabled = IsPlayerSpell(202345)
		local stellar_flare_enabled = IsPlayerSpell(202347)
		local new_moon_enabled = IsPlayerSpell(274281)
		local twin_moons_enabled = IsPlayerSpell(279620)
		local incarn_enabled = IsPlayerSpell(102560)
		local lucid_dreams_taken = IsPlayerSpell(298357)

		local lucid_dreams_up = UnitBuffID("player",298357)
		local starlord_up = UnitBuffID("player",279709)
		local starlord_remains = _buffRemains("player",279709)
		local starlord_stacks = _buffStacks("player",279709)
		local arcanic_pulsar_stacks = _buffStacks("player",287790)
		local lunar_empowerment_stacks = _buffStacks("player",164547)
		local solar_empowerment_stacks = _buffStacks("player",164545)

		if UnitCastingInfo("player") == "Stellar Flare" then SFDelay=time end

		local ca_inc_remains = 0
		if UnitBuffID("player",102560) then
			ca_inc_remains = _buffRemains("player",102560)
		end
		if UnitBuffID("player",194223) then
			ca_inc_remains = _buffRemains("player",194223)
		end

		local ca_inc = ca_inc_remains > 0

		local ca_inc_cd = 0
		local incarn_cd = _spellCooldown(102560)
		local ca_cd = _spellCooldown(194223)
		local lucid_dreams_cd = _spellCooldown(298357)

		if incarn_cd > ca_inc_cd then ca_inc_cd = incarn_cd end
		if ca_cd > ca_inc_cd then ca_inc_cd = ca_cd end

		-- actions.precombat+=/variable,name=az_ss,value=azerite.streaking_stars.rank
		local az_ss = GetNumAzeritePowerTaken(122)
		-- actions.precombat+=/variable,name=az_ap,value=azerite.arcanic_pulsar.rank
		local az_ap = GetNumAzeritePowerTaken(200)

		local lively_spirit = AzeritePowerTaken(364)

		-- # Starfall v Starsurge target cutoff
		-- actions.precombat+=/variable,name=sf_targets,value=4
		local sf_targets = 4
		local starfall_count = 0
		local starfall_target
		for i=1,#Enemies do if _distance(Enemies[i]) < 40 then
			local ea = Enemies_Around_Unit(Enemies[i],10)
			if ea >= starfall_count then
				starfall_count=ea
				starfall_target=Enemies[i]
			end
		end end

		-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=azerite.arcanic_pulsar.enabled
		sf_targets = sf_targets + (az_ap > 0 and 1 or 0)
		-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=talent.starlord.enabled
		sf_targets = sf_targets + (starlord_enabled and 1 or 0)
		-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=azerite.streaking_stars.rank>2&azerite.arcanic_pulsar.enabled
		sf_targets = sf_targets + ((az_ss > 2 and az_ap > 0) and 1 or 0)
		-- actions.precombat+=/variable,name=sf_targets,op=sub,value=1,if=!talent.twin_moons.enabled
		sf_targets = sf_targets - (not twin_moons_enabled and 1 or 0)
		

		local function moonfire_ticking(unit)
			return _debuffRemains(unit,164812,"player") >= 1.7
		end

		local function moonfire_remains(unit)
			return _debuffRemains(unit,164812,"player")
		end

		local function sunfire_ticking(unit)
			return _debuffRemains(unit,164815,"player") >= 1.7
		end

		local function sunfire_remains(unit)
			return _debuffRemains(unit,164815,"player")
		end

		local function stellar_flare_ticking(unit)
			return _debuffRemains(unit,202347,"player") >= 1.7
		end

		local function stellar_flare_remains(unit)
			return _debuffRemains(unit,202347,"player")
		end

		local function spell_ap_gen(spell)
			local spells = {
			{id=8921,value=3},		--moonfire
			{id=93402,value=3},		--sunfire
			{id=190984,value=8},	--wrath
			{id=194153,value=12},	--lunar strike
			{id=202347,value=8},	--stellar flare
			{id=274281,value=10},	--new moon
			{id=274282,value=20},   --half moon
			{id=274283,value=40},	--full moon
			{id=194223,value=40},	--celestial alignment
			}
			for i=1,#spells do
				local name = GetSpellInfo(spells[i].id)
				local id = spells[i].id
				if spell == id or spell == name then
					return spells[i].value
				end
			end
			return 0
		end

		function ap_check(spell)
			if nil==nil then return true end --wtf is this garbage??? this apl makes no sense
			if not spell then return astral_power >= 40 end
			if spell then return astral_power >= 40-spell_ap_gen(spell) end
		end

		-- actions.precombat+=/moonkin_form
		if not bear and (not cat or (not UnitBuffID("player",252216) and not Prowl)) and not travel and not moonkin then
			_Cast(24858)
		end

		local enemies_in_range = {}
		for i=1,#Enemies do if _distance(Enemies[i]) < 50 then
			table.insert(enemies_in_range,Enemies[i])
		end end

		local function _valid(unit,immune) 
			return unit 
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit) 
			and not _breakableCC(unit)
			and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
			and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
		end

		local e=enemies_in_range
		local t=current_target
		local vt=_valid(t,2)

		-- # CDs
		-- actions+=/berserking,if=buff.ca_inc.up
		-- actions+=/use_item,name=azsharas_font_of_power,if=!buff.ca_inc.up,target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
		-- actions+=/guardian_of_azeroth,if=(!talent.starlord.enabled|buff.starlord.up)&!buff.ca_inc.up,target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
		if (not starlord_enabled or starlord_up) and not ca_inc then
			if vt then
				if moonfire_ticking(t) and sunfire_ticking(t) and (not stellar_flare_enabled or stellar_flare_ticking(t)) then
					CastSpellByName("Guardian of Azeroth",t)
				end
			end
		end
		-- actions+=/use_item,effect_name=cyclotronic_blast,if=!buff.ca_inc.up,target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
		-- actions+=/use_item,name=shiver_venom_relic,if=!buff.ca_inc.up,target_if=dot.shiver_venom.stack>=5
		-- actions+=/blood_of_the_enemy,if=cooldown.ca_inc.remains>30
		-- actions+=/memory_of_lucid_dreams,if=!buff.ca_inc.up&(astral_power<25|cooldown.ca_inc.remains>30),target_if=dot.sunfire.remains>10&dot.moonfire.remains>10&(!talent.stellar_flare.enabled|dot.stellar_flare.remains>10)
		if lucid_dreams_taken and not ca_inc and (astral_power < 25 or ca_inc_cd > 30) then
			if vt then
				if sunfire_remains(t) > 10 and moonfire_remains(t) > 10 and (not stellar_flare_enabled or stellar_flare_remains(t) > 10) then
					_Cast(298357)
				end
			end
		end
		-- actions+=/purifying_blast
		-- actions+=/ripple_in_space
		-- actions+=/concentrated_flame
		if vt then
			if IsPlayerSpell(295373) then
				_Cast(295373,t,true)
			end
		end
		-- actions+=/the_unbound_force,if=buff.reckless_force.up,target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
		-- actions+=/worldvein_resonance
		-- actions+=/focused_azerite_beam,if=(!variable.az_ss|!buff.ca_inc.up),target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
		-- actions+=/thorns
			for i=1,#Friends do
				if _HP(Friends[i]) < 85 and EnemiesAttacking(Friends[i],1) >= 1 then
					_Cast(305497,Friends[i]);
				end
			end
		-- actions+=/use_items,slots=trinket1,if=!trinket.1.has_proc.any|buff.22.up
		-- actions+=/use_items,slots=trinket2,if=!trinket.2.has_proc.any|buff.ca_inc.up
		-- actions+=/use_items
		-- actions+=/warrior_of_elune
		if vt then _Cast(202425) end
		-- actions+=/innervate,if=azerite.lively_spirit.enabled&(cooldown.incarnation.remains<2|cooldown.celestial_alignment.remains<12)
		if lively_spirit and ((incarn_enabled and incarn_cd < 2) or (not incarn_enabled and ca_cd < 12)) then
			for i=1,#Friends do if UnitGroupRolesAssigned(Friends[i]) == "HEALER" then
				_Cast(29166,Friends[i])
			end end
		end
		-- actions+=/incarnation,if=!buff.ca_inc.up&
		-- (buff.memory_of_lucid_dreams.up|((cooldown.memory_of_lucid_dreams.remains>20|!essence.memory_of_lucid_dreams.major)&ap_check))&(buff.memory_of_lucid_dreams.up|ap_check),target_if=dot.sunfire.remains>8&dot.moonfire.remains>12&(dot.stellar_flare.remains>6|!talent.stellar_flare.enabled)
		if incarn_enabled then
			if not ca_inc and (lucid_dreams_up or ((lucid_dreams_cd > 20 or not lucid_dreams_taken) and ap_check())) and (lucid_dreams_up or ap_check()) and sunfire_remains(t) > 8 and moonfire_remains(t) > 12 and (not stellar_flare_enabled or stellar_flare_remains(t) > 6) then
				_Cast(102560)
			end
		end
		-- actions+=/celestial_alignment,if=!buff.ca_inc.up&
		--(buff.memory_of_lucid_dreams.up|((cooldown.memory_of_lucid_dreams.remains>20|!essence.memory_of_lucid_dreams.major)&ap_check))&(!azerite.lively_spirit.enabled|buff.lively_spirit.up),target_if=(dot.sunfire.remains>2&dot.moonfire.ticking&(dot.stellar_flare.ticking|!talent.stellar_flare.enabled))
		if not incarn_enabled then
			if not ca_inc and (lucid_dreams_up or ((lucid_dreams_cd > 20 or not lucid_dreams_taken) and ap_check(194223))) and (not lively_spirit or lively_spirit_up) and sunfire_remains(t) > 2 and moonfire_ticking(t) and (not stellar_flare_enabled or stellar_flare_ticking(t)) then
				_Cast(194223)
			end
		end
		-- actions+=/fury_of_elune,if=(buff.ca_inc.up|cooldown.ca_inc.remains>30)&solar_wrath.ap_check
		-- actions+=/force_of_nature,if=(buff.ca_inc.up|cooldown.ca_inc.remains>30)&ap_check
		-- # Spenders
		-- actions+=/cancel_buff,name=starlord,if=buff.starlord.remains<3&!solar_wrath.ap_check
		if starlord_up and starlord_remains < 3 and not ap_check(190984) then
			for i=1,40 do
				local buff=UnitBuff("player",i)
				if not buff then break end
				if buff == "Starlord" then
					CancelUnitBuff("player",i);
				end
			end
		end
		-- actions+=/starfall,if=(buff.starlord.stack<3|buff.starlord.remains>=8)&spell_targets>=variable.sf_targets&(target.time_to_die+1)*spell_targets>cost%2.5
		if (starlord_stacks < 3 or starlord_remains >= 8) and starfall_count >= sf_targets and _HP(starfall_target) > 30 then
			_AeCast(191034,starfall_target,45,15)
		end
		-- actions+=/starsurge,if=(talent.starlord.enabled&(buff.starlord.stack<3|buff.starlord.remains>=5&buff.arcanic_pulsar.stack<8)|!talent.starlord.enabled&(buff.arcanic_pulsar.stack<8|buff.ca_inc.up))&spell_targets.starfall<variable.sf_targets&buff.lunar_empowerment.stack+buff.solar_empowerment.stack<4&buff.solar_empowerment.stack<3&buff.lunar_empowerment.stack<3&(!variable.az_ss|!buff.ca_inc.up|!prev.starsurge)|target.time_to_die<=execute_time*astral_power%40|!solar_wrath.ap_check
		if vt then
			if starlord_enabled and (starlord_stacks < 3 or starlord_remains >= 5 and arcanic_pulsar_stacks < 8) then 
				_Cast(78674,t,true)
			else
				if not starlord_enabled 
				and (arcanic_pulsar_stacks < 8 or ca_inc) 
				and starfall_count < sf_targets 
				and lunar_empowerment_stacks + solar_empowerment_stacks < 4 
				and solar_empowerment_stacks < 3 
				and lunar_empowerment_stacks < 3 
				and (az_ss == 0 or not ca_inc or prev_gcd ~= "Starsurge") 
				or _HP(t) < 15 then
					_Cast(78674,t,true)
				end
			end
		end
		-- actions+=/sunfire,if=buff.ca_inc.up&buff.ca_inc.remains<gcd.max&variable.az_ss&dot.moonfire.remains>remains
		if vt then
			if ca_inc and ca_inc_remains < gcd and az_ss > 0 and moonfire_remains(t) > sunfire_remains(t) then
				_Cast(93402,t,nil,true)
			end
		end
		-- actions+=/moonfire,if=buff.ca_inc.up&buff.ca_inc.remains<gcd.max&variable.az_ss
		if vt then
			if ca_inc and ca_inc_remains < gcd and az_ss > 0 then
				_Cast(8921,t,nil,true)
			end
		end
		-- # DoTs
		-- actions+=/sunfire,target_if=refreshable,if=ap_check&floor(target.time_to_die%(2*spell_haste))*spell_targets>=ceil(floor(2%spell_targets)*1.5)+2*spell_targets&
		--(spell_targets>1+talent.twin_moons.enabled|dot.moonfire.ticking)&(!variable.az_ss|!buff.ca_inc.up|!prev.sunfire)&(buff.ca_inc.remains>remains|!buff.ca_inc.up)
		if ap_check(93402) then
			if sunfire_remains(t) < 6 and (moonfire_ticking(t) or Enemies_Around_Unit(t,8) > 1 + (twin_moons_enabled and 1 or 0)) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Sunfire") and (ca_inc_remains > sunfire_remains(t) or not ca_inc) then
				_Cast(93402,t,nil,true)
			end
		end
		-- actions+=/moonfire,target_if=refreshable,if=ap_check&floor(target.time_to_die%(2*spell_haste))*spell_targets>=6
		--&(!variable.az_ss|!buff.ca_inc.up|!prev.moonfire)&(buff.ca_inc.remains>remains|!buff.ca_inc.up)
		if ap_check(8921) then
			if vt then
				if moonfire_remains(t) < 6 and (az_ss == 0 or not ca_inc or prev_gcd ~= "Moonfire") and (ca_inc_remains > moonfire_remains(t) or not ca_inc) then
					_Cast(8921,t,nil,true)
				end
			end
		end
		-- actions+=/stellar_flare,target_if=refreshable,if=ap_check&floor(target.time_to_die%(2*spell_haste))>=5&(!variable.az_ss|!buff.ca_inc.up|!prev.stellar_flare)
		if stellar_flare_enabled and ap_check(202347) then
			if vt and (not SFDelay or time-SFDelay > .15) then
				if not stellar_flare_ticking(t) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Moonfire") and (ca_inc_remains > moonfire_remains(t) or not ca_inc) then
					_Cast(202347,t,nil,true)
				end
			end
		end
		-- # Generators
		-- actions+=/new_moon,if=ap_check
		-- actions+=/half_moon,if=ap_check
		-- actions+=/full_moon,if=ap_check
		-- actions+=/lunar_strike,if=buff.solar_empowerment.stack<3&(ap_check|buff.lunar_empowerment.stack=3)&((buff.warrior_of_elune.up|buff.lunar_empowerment.up|spell_targets>=2&!buff.solar_empowerment.up)&(!variable.az_ss|!buff.ca_inc.up)|variable.az_ss&buff.ca_inc.up&prev.solar_wrath)
		if vt then
			if solar_empowerment_stacks < 3 and (ap_check(194153) or lunar_empowerment_stacks == 3) and ((warrior_of_elune_up or lunar_empowerment_stacks > 0 or Enemies_Around_Unit(t,8) >= 2 and solar_empowerment_stacks == 0) and (az_ss == 0 or not ca_inc) or az_ss > 0 and ca_inc and prev_gcd == "Solar Wrath") then
				_Cast(194153,t,true)
			end
		end
		-- actions+=/solar_wrath,if=variable.az_ss<3|!buff.ca_inc.up|!prev.solar_wrath
		if vt then
			if az_ss < 3 or not ca_inc or prev_gcd ~= "Solar Wrath" then
				_Cast(190984,t,true)
			end
		end

		for i=1,#enemies_in_range do
			local e=enemies_in_range[i]
			if not sunfire_ticking(e) and (moonfire_ticking(e) or Enemies_Around_Unit(e,8) > 1) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Sunfire") and (ca_inc_remains > sunfire_remains(e) or not ca_inc) then
				_Cast(93402,e,nil,true)
			end
		end

		for i=1,#enemies_in_range do
			local e=enemies_in_range[i]
			if not moonfire_ticking(e) and (moonfire_ticking(e) or Enemies_Around_Unit(e,8) > 1) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Moonfire") and (ca_inc_remains > moonfire_remains(e) or not ca_inc) then
				_Cast(8921,e,nil,true)
			end
		end

		for i=1,#enemies_in_range do
			local e=enemies_in_range[i]
			if not stellar_flare_ticking(e) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Moonfire") and (ca_inc_remains > moonfire_remains(e) or not ca_inc) then
				_Cast(202347,e,nil,true)
			end
		end

		-- # Fallthru for movement
		-- actions+=/sunfire

		-- guardian
	elseif spec == 3 then
	
		local rage = UnitPower("player")
		local enemies_on_me = EnemiesAttacking("player")
		local cds_on_me = select(4, EnemiesAttacking("player"))
		local melee_on_me = select(2, EnemiesAttacking("player"))
		local bcc = _bccAM(10)
		local galactic_guardian = UnitBuffID("player", 213708)
		local anima_stacks = UnitBuffID("player", 294966)
		local human = GetShapeshiftForm() == 0
		local cat = UnitBuffID("player",768)
		local bear = UnitBuffID("player",5487)
		local travel = UnitBuffID("player",783)
		local remove_corruption_cd = _spellCooldown(2782)
		local gcd_remains = GetGCD()
		local player_hp = _HP("player")
		local prowl = UnitBuffID("player",5215) or UnitBuffID("player",102547)
		
		local lowestfriends = {}
		for i=1,#Friends do
			local e=Friends[i]
			if UnitIsPlayer(e) then
				local hp = _HP(e)
				table.insert(lowestfriends,{pointer=e,hp=hp})
			end 
		end
		table.sort(lowestfriends,function(x,y) return x.hp < y.hp end)

		local dispellable ={
		80240,	--havoc
		51514,	--hex
		211015,	--hex cockroach
		210873,	--hex compy
		211010,	--hex snake
		211004,	--hex spider
		277784,	--hex wicker mongrel
		277778,	--hex zandalari tendonripper
		309328,	--hex living honey
		199954,	--curse of frag (removed?)
		202914,	--spider sting
		202797,	--viper sting
		};

		local function remove_corruption(unit)
			local lessDelay = minDelayTime/1.3;
			for i=1,#dispellable do
				local debuff,_,_,five,six,seven = UnitDebuffID(unit,dispellable[i]);
				if debuff and seven-time < six-lessDelay then
					return dispellable[i];
				end
			end
		end

		local function hibernate_inc()
			for i=1,#Enemies do 
				if UnitCastingInfo(Enemies[i]) == "Hibernate" then
					local e = Enemies[i]
					local dest = UnitSpellTarget(Enemies[i])
					if unit_is_unit(dest,"player") and _distance(e) < 40 then
						local time_left = _castTimeLeft(e)
						if time_left <= latency + .2 then
							return true
						end
					end
				end
			end
		end
		
		local function moonfire_ticking(unit)
			return _debuffRemains(unit,164812,"player") >= 6.24
		end
		
		local function _valid(unit,immune) 
			return unit 
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit) 
			and not _breakableCC(unit)
			and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
			and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
		end

		--dispel
		if remove_corruption_cd <= gcd_remains then
			for i=1,#Friends do
				local dispel = remove_corruption(Friends[i])
				if dispel and _LoS(Friends[i]) and _Cast(2782,Friends[i]) then
					Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,2782)
				end
			end
		end
		

		--auto
		if _valid(current_target) then
			if not auto_atack_sent or time - auto_atack_sent > 1 then
				StartAttack()
				auto_atack_sent = time
			end
		end

		--defensives
		
		-- survival instincts
		if (cds_on_me and player_hp <= 80 or (player_hp <= 50 and enemies_on_me >=1 )) and not UnitBuffID("player", 61336) then
			_Cast(61336)
		end
		
		-- barkskin
		if player_hp <= 80 and enemies_on_me <=1 and not UnitBuffID("player", 61336) then
			_Cast(22812)
		end
		
		-- frenzy regen
		if player_hp <= 68 and not UnitBuffID("player", 22842) then
			_Cast(22842)
		end
		
		-- ironfur
		if melee_on_me >= 1 and player_hp <= 80 then
			_Cast(192081)
		end
		
		--healing
		if guardian_heal then
			for i=1,#lowestfriends do
				local friend = lowestfriends[i]
				
				--swiftmend
				if _LoS(friend.pointer) then
					_Cast(18562, friend.pointer)
				end
				
				--regrowth w/ swiftmend buff
				if _LoS(friend.pointer) and UnitBuffID("player", 236185) then
					_Cast(8936, friend.pointer)
				end
				
				-- rejuv
				if _LoS(friend.pointer) and not UnitBuffID(friend.pointer, 774) then
					_Cast(774, friend.pointer)
				end
				
				-- regrowth
				if _LoS(friend.pointer) then
					_Cast(8936, friend.pointer)
				end
			end
		end
		
		--shift hibernate
		if cat then
			if hibernate_inc() then
				RunMacroText("/cancelform")
				Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
			end
		elseif travel then
			if hibernate_inc() then
				RunMacroText("/cancelform")
				Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
			end
		elseif bear then
			if hibernate_inc() then
				if EnemiesAttacking("player") == 0 then
					RunMacroText("/cancelform")
					Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
				end
			end
		end
		
		--shift roots
		if _rootCheck("player") then
			if bear then
				-- dont come out of bear unless we arent being attacked
				if EnemiesAttacking("player") == 0 then
					if _Cast(768) then
						Squid_Alert("Cat Form","(Shift Root)",nil,nil,339)
						ok_to_cat=time
						return
					end
				end
			else
				if _Cast(5487) then
					Squid_Alert("Bear Form","(Shift Root)",nil,nil,768)
					return
				end
			end
		end
		
		-- go bear
		if human and not hibernate_inc() then
			_Cast(5487)
		end
		
		-- thrash on cd
		if Enemies_Around_Unit("player",8) > 0 then
			_Cast(77758)
		end

		-- moonfire all the things
		for i=1,#Enemies do if not moonfire_ticking(Enemies[i]) and _valid(Enemies[i], 2) and _LoS(Enemies[i]) then
			_Cast(8921, Enemies[i])
		end end

		-- auto attack
		local t = UnitGUID("target")
		if not attack_guid or attack_guid ~= t then
			AttackTarget()
			attack_guid = t
		end
	
		-- anima essence
		if _HP("target") <= 70 and _meleeRange("target") and not bcc then
			_Cast(294926)
		end
		
		-- maul
		if not galactic_guardian and _valid("target", 1) and (enemies_on_me == 0 or player_hp > 70) then
			_Cast(6807, "target")
		end
		
		-- mangle
		-- if _valid("target", 1) and enemies_on_me == 0 then
			_Cast(33917, "target")
		-- end
		
		--thrash
		if _valid("target", 1) and not bcc and _meleeRange("target") then
			_Cast(77758, "target")
		end
		
		-- moonfire with buff
		if galactic_guardian and _valid("target", 2) and _LoS("target") then
			_Cast(8921, "target")
		end
		
		--swipe
		if _valid("target", 1) and not bcc and _meleeRange("target") then
			_Cast(213771, "target")
		end

		--moonfire fallthru
		_Cast(8921, "target")
		
	end

-- 	# Executed before combat begins. Accepts non-harmful actions only.
-- actions.precombat=flask
-- actions.precombat+=/food
-- actions.precombat+=/augmentation
-- # Azerite variables
-- actions.precombat+=/variable,name=az_ss,value=azerite.streaking_stars.rank
-- actions.precombat+=/variable,name=az_ap,value=azerite.arcanic_pulsar.rank
-- # Starfall v Starsurge target cutoff
-- actions.precombat+=/variable,name=sf_targets,value=4
-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=azerite.arcanic_pulsar.enabled
-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=talent.starlord.enabled
-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=azerite.streaking_stars.rank>2&azerite.arcanic_pulsar.enabled
-- actions.precombat+=/variable,name=sf_targets,op=sub,value=1,if=!talent.twin_moons.enabled
-- actions.precombat+=/moonkin_form
-- # Snapshot raid buffed stats before combat begins and pre-potting is done.
-- actions.precombat+=/snapshot_stats
-- actions.precombat+=/potion
-- actions.precombat+=/solar_wrath,if=!bfa.font_of_power_precombat_channel

-- # Executed every time the actor is available.
-- actions=potion,if=buff.ca_inc.remains>6
-- # CDs
-- actions+=/berserking,if=buff.ca_inc.up
-- actions+=/use_item,name=azsharas_font_of_power,if=!buff.ca_inc.up,target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
-- actions+=/guardian_of_azeroth,if=(!talent.starlord.enabled|buff.starlord.up)&!buff.ca_inc.up,target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
-- actions+=/use_item,effect_name=cyclotronic_blast,if=!buff.ca_inc.up,target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
-- actions+=/use_item,name=shiver_venom_relic,if=!buff.ca_inc.up,target_if=dot.shiver_venom.stack>=5
-- actions+=/blood_of_the_enemy,if=cooldown.ca_inc.remains>30
-- actions+=/memory_of_lucid_dreams,if=!buff.ca_inc.up&(astral_power<25|cooldown.ca_inc.remains>30),target_if=dot.sunfire.remains>10&dot.moonfire.remains>10&(!talent.stellar_flare.enabled|dot.stellar_flare.remains>10)
-- actions+=/purifying_blast
-- actions+=/ripple_in_space
-- actions+=/concentrated_flame
-- actions+=/the_unbound_force,if=buff.reckless_force.up,target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
-- actions+=/worldvein_resonance
-- actions+=/focused_azerite_beam,if=(!variable.az_ss|!buff.ca_inc.up),target_if=dot.moonfire.ticking&dot.sunfire.ticking&(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
-- actions+=/thorns
-- actions+=/use_items,slots=trinket1,if=!trinket.1.has_proc.any|buff.ca_inc.up
-- actions+=/use_items,slots=trinket2,if=!trinket.2.has_proc.any|buff.ca_inc.up
-- actions+=/use_items
-- actions+=/warrior_of_elune
-- actions+=/innervate,if=azerite.lively_spirit.enabled&(cooldown.incarnation.remains<2|cooldown.celestial_alignment.remains<12)
-- actions+=/incarnation,if=!buff.ca_inc.up&(buff.memory_of_lucid_dreams.up|((cooldown.memory_of_lucid_dreams.remains>20|!essence.memory_of_lucid_dreams.major)&ap_check))&(buff.memory_of_lucid_dreams.up|ap_check),target_if=dot.sunfire.remains>8&dot.moonfire.remains>12&(dot.stellar_flare.remains>6|!talent.stellar_flare.enabled)
-- actions+=/celestial_alignment,if=!buff.ca_inc.up&(buff.memory_of_lucid_dreams.up|((cooldown.memory_of_lucid_dreams.remains>20|!essence.memory_of_lucid_dreams.major)&ap_check))&(!azerite.lively_spirit.enabled|buff.lively_spirit.up),target_if=(dot.sunfire.remains>2&dot.moonfire.ticking&(dot.stellar_flare.ticking|!talent.stellar_flare.enabled))
-- actions+=/fury_of_elune,if=(buff.ca_inc.up|cooldown.ca_inc.remains>30)&solar_wrath.ap_check
-- actions+=/force_of_nature,if=(buff.ca_inc.up|cooldown.ca_inc.remains>30)&ap_check
-- # Spenders
-- actions+=/cancel_buff,name=starlord,if=buff.starlord.remains<3&!solar_wrath.ap_check
-- actions+=/starfall,if=(buff.starlord.stack<3|buff.starlord.remains>=8)&spell_targets>=variable.sf_targets&(target.time_to_die+1)*spell_targets>cost%2.5
-- actions+=/starsurge,if=(talent.starlord.enabled&(buff.starlord.stack<3|buff.starlord.remains>=5&buff.arcanic_pulsar.stack<8)|!talent.starlord.enabled&(buff.arcanic_pulsar.stack<8|buff.ca_inc.up))&spell_targets.starfall<variable.sf_targets&buff.lunar_empowerment.stack+buff.solar_empowerment.stack<4&buff.solar_empowerment.stack<3&buff.lunar_empowerment.stack<3&(!variable.az_ss|!buff.ca_inc.up|!prev.starsurge)|target.time_to_die<=execute_time*astral_power%40|!solar_wrath.ap_check
-- actions+=/sunfire,if=buff.ca_inc.up&buff.ca_inc.remains<gcd.max&variable.az_ss&dot.moonfire.remains>remains
-- actions+=/moonfire,if=buff.ca_inc.up&buff.ca_inc.remains<gcd.max&variable.az_ss
-- # DoTs
-- actions+=/sunfire,target_if=refreshable,if=ap_check&floor(target.time_to_die%(2*spell_haste))*spell_targets>=ceil(floor(2%spell_targets)*1.5)+2*spell_targets&(spell_targets>1+talent.twin_moons.enabled|dot.moonfire.ticking)&(!variable.az_ss|!buff.ca_inc.up|!prev.sunfire)&(buff.ca_inc.remains>remains|!buff.ca_inc.up)
-- actions+=/moonfire,target_if=refreshable,if=ap_check&floor(target.time_to_die%(2*spell_haste))*spell_targets>=6&(!variable.az_ss|!buff.ca_inc.up|!prev.moonfire)&(buff.ca_inc.remains>remains|!buff.ca_inc.up)
-- actions+=/stellar_flare,target_if=refreshable,if=ap_check&floor(target.time_to_die%(2*spell_haste))>=5&(!variable.az_ss|!buff.ca_inc.up|!prev.stellar_flare)
-- # Generators
-- actions+=/new_moon,if=ap_check
-- actions+=/half_moon,if=ap_check
-- actions+=/full_moon,if=ap_check
-- actions+=/lunar_strike,if=buff.solar_empowerment.stack<3&(ap_check|buff.lunar_empowerment.stack=3)&((buff.warrior_of_elune.up|buff.lunar_empowerment.up|spell_targets>=2&!buff.solar_empowerment.up)&(!variable.az_ss|!buff.ca_inc.up)|variable.az_ss&buff.ca_inc.up&prev.solar_wrath)
-- actions+=/solar_wrath,if=variable.az_ss<3|!buff.ca_inc.up|!prev.solar_wrath
-- # Fallthru for movement
-- actions+=/sunfire
end-- fix swapping of sheep from healer who is already sheeped

-- could_have_klepto - need to track enemy mage's alter heal effect and klept (+ cancel) at the approp times

-- rotation feels really sluggish some games like it's using globals on something??

-- Mage_Rotation_Override="PvP"
-- door of shadows to disorients

-- calculate bleed damage over duration of ring of frost with unit_has_dot and resheep just before it breaks

-- [fixes implemented, need testing]:
-- phoenix flames queued up while casting sheep breaks the sheep 

local cc_casts = {118,28272,277792,161354,277787,161355,161353,120140,61305,61721,61780,28271,113724}
local crit_casts = {2948,133}

local all_sheeps = {
	118,		-- Sheep
	28272,		-- Pig
	277792,		-- Bee
	161354,		-- Monkey
	277787,		-- Direhorn
	161355,		-- Penguin
	161353,		-- Polar Bear
	120140,		-- Porcupine
	61305,		-- Cat
	61721,		-- Rabbit
	61780,		-- Turkey
	28271,		-- Turtle
}

-- Covenant Data
local covenants = {
	["None"] = 0,
	["Kyrian"] = 1,
	["Venthyr"] = 2,
	["NightFae"] = 3,
	["Necrolord"] = 4
}

local sheep_ids = {}

local function check_sheep_ids()
	sheep_ids = {}
	for i=1,#all_sheeps do
		if IsPlayerSpell(all_sheeps[i]) then
			table.insert(sheep_ids,all_sheeps[i])
		end
	end
end

check_sheep_ids()

local function sheep_remains(unit)
	local longest = 0
	for i=1,#all_sheeps do
		local remains = _debuffRemains(unit,all_sheeps[i],"player")
		if remains > longest then
			longest = remains
		end
	end
	return longest

	-- local debuffs = _debuffFromTable(unit,all_sheeps,true);
	-- table.sort(debuffs,function(x,y) return x>y end);
	-- if #debuffs > 0 then
	-- 	return debuffs[1];
	-- end

end

local function bin(arg)
	return arg and 1 or 0
end

local mage_frame
-- fire mage frame
if UnitClass("player") == "MAGE" and GetSpecialization() == 2 then

end

local function bleeds_around(unit,dist)

	if UnitDebuffID(unit,1079) and UnitEnemiesAttacking(unit) > 0 then return "this unit" end

	local rips_up = 0
	for i=1,#Enemies do
		if UnitDebuffID(Enemies[i],1079) and UnitEnemiesAttacking(Enemies[i]) > 0 then
			rips_up = rips_up + 1
		end
	end

	if rips_up >= 1 then
		return true
	end

end

function Squid_FireMagePvP()

	-- pause script (Eating, Soulshape)
	if UnitBuffID("player",167152) or UnitBuffID("player",310143) then return end

	local tanking = SQUID.tank_mmr

	local time = GetTime()
	local latency = squid_avg_latency
	local groupsize = GetNumGroupMembers()
	local msperframe = 2/GetFramerate()
	local buffer = latency + msperframe + .1
	local haste = UnitSpellHaste("player")
	local gcd = 1.5/(1+(haste/100))
	local gcd_remains = GetGCD()
	local combat = UnitAffectingCombat("player")
	local player_hp = _HP("player")
	local player_mana = (100 * UnitPower("player") / UnitPowerMax("player"));
	local player_immune = _immuneCheck("player",nil,true)

	local player_covenant = active_soulbinds[1] and active_soulbinds[1].covenantName

	local sheep = SQUID.poly_id or 118

	if SQUID.poly_id == "random" then
		sheep = sheep_ids [ math.random(1, #sheep_ids) ]
	end

	--barrier pre gate
	if UnitBuffID("player",32727) and arena_start_timer and arena_start_timer < 20 and not tanking then
		if _Cast(235313) then
			Squid_Alert("Blazing Barrier",nil,nil,nil,235313)
			return
		end
	end

	local auto_temp = SQUID.auto_temp

	local GetItemInfo_OG = GetItemInfo
	local GetItemInfo = function ( itemid ) local info = GetItemInfo_OG( itemid ) or ""; return info end

	local utilities_only = SQUID.utilities_only

	--equipped items
	local equipped_items = {}

	local trinkets = {
	174103,	--Manifesto of Madness
	167380,	--Notorious Gladiator's Badge
	172669,	--Corrupted Gladiator's Badge
	165058,	--Sinister Gladiator's Badge
	172666,	--Corrupted Gladiator's Medallion
	167377,	--Notorious Gladiator's Medallion
	165055,	--Sinister Gladiator's Medallion
	175884,	--Sinful Aspirant's Badge of Ferocity
	175921, --Sinful Glad's Badge
	159615,	--Ignition Mage's Fuse
	161411,	--Tzane's Barkspines
	161377,	--Azurethos' Singed Plumage
	166793,	--Ancient Knot of Wisdom (HORDE) (278267 SPELLID)
	161417,	--Ancient Knot of Wisdom (ALLIANCE) (278267 SPELLID)
	169318,	--Shockbiter's Fang
	168973,	--Neural Synapse Enhancer
	159630,	--Balefire Branch
	}

	for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end

	local extra_items = {
	159624,	--Rotcrusted Voodoo Doll
	169305,	--Aquipotent Nautilus
	168905,	--Shiver Venom Relic
	173944,	--Forbidden Obsidian Claw
	167677,	--Harmonic Dematerializer
	167835,	--Malformed Herald's Legwraps
	168989,	--Hyperthread Wristwraps (300142 SPELLID)
	167672,	--Cyclotronic Blast (293491 SPELLID)
	165576,	--Tidestorm Codex (289885 SPELLID)
	}

	for i=1,#extra_items do if IsEquippedItem ( extra_items[i] ) then table.insert( equipped_items, extra_items[i] ) end end

	local auto_cc = get_squid_var("Auto CC")
	local only_cc_healers = SQUID.only_cc_healers

	local fire_lockout = _spellCooldown(133) > gcd_remains and _spellCooldown(133) or 0
	local arcane_lockout = _spellCooldown(118) > gcd_remains and _spellCooldown(118) or 0
	local ring_cd = _spellCooldown(113724)
	local db_cd = _spellCooldown(31661)
	local meteor_cd = _spellCooldown(153561)
	local remove_curse_cd = _spellCooldown(475)
	local combustion_cd = _spellCooldown(190319)
	local blink_cd = _spellCooldown(212653)

	meteor_in_flight = meteor_cd > 42
	meteor_in_flight_remains = (3 - ( 45 - meteor_cd )) - buffer

	local rune_of_power_base_cd = 40
	local rune_of_power_charges = GetSpellCharges(116011)
	local rune_of_power_charges_frac = _spellChargeFrac(116011)
	local rune_of_power_next_charge_cd = (math.ceil(rune_of_power_charges_frac) - rune_of_power_charges_frac) * rune_of_power_base_cd

	local heating_up = UnitBuffID("player",48107)
	local heating_up_remains = _buffRemains("player",48107)
	local tinder_up = UnitBuffID("player",203277)
	local flamecannon_stacks = _buffStacks("player",203285)
	local rune_of_power_up = UnitBuffID("player",116014)

	local hot_streak = UnitBuffID("player",48108) or UnitBuffID("player",333100)
	local hot_streak_remains = _buffRemains("player",48108)
	local pyroclasm = UnitBuffID("player",269651)
	local pyroclasm_remains = _buffRemains("player",269651)
	local searing_touch_enabled = IsPlayerSpell(269644)
	local rune_of_power_enabled = IsPlayerSpell(116011)
	local ring_enabled = IsPlayerSpell(113724)
	local tinder_enabled = IsPlayerSpell(203275)
	local firestarter_enabled = IsPlayerSpell(203283)
	local flame_on = IsPlayerSpell(205029)
	local meteor_enabled = IsPlayerSpell(153561)
	local combustion_remains = _buffRemains("player",190319)
	local combustion = combustion_remains > 0
	
	local fire_blast_base_cd = flame_on and 10 or 12
	-- fire_blast_base_cd = fire_blast_base_cd * (1-(haste/100-.04))
	fire_blast_base_cd = fire_blast_base_cd - ( haste * 0.076954715597427 )

	local fire_blast_charges,fire_blast_max_charges = GetSpellCharges(108853)
	local fire_blast_total_cd = fire_blast_base_cd * fire_blast_max_charges
	local fire_blast_charges_frac = _spellChargeFrac(108853)
	local fire_blast_full_recharge_time = fire_blast_total_cd - (fire_blast_charges_frac*fire_blast_base_cd)
	local fire_blast_next_charge_cd = (math.ceil(fire_blast_charges_frac) - fire_blast_charges_frac) * fire_blast_base_cd

	function time_to_fb_charges(amt)
		return fire_blast_base_cd*amt - fire_blast_charges_frac*fire_blast_base_cd
	end

	local phoenix_flames_enabled = IsPlayerSpell(257541)
	local phoenix_flames_base_cd = 30
	local phoenix_flames_charges,phoenix_flames_max_charges = GetSpellCharges(257541)
	if not phoenix_flames_enabled then
		phoenix_flames_charges = 0
		phoenix_flames_max_charges = 0
	end
	local phoenix_flames_total_cd = phoenix_flames_base_cd * phoenix_flames_max_charges
	local phoenix_flames_charges_frac = _spellChargeFrac(257541)
	local phoenix_flames_full_recharge_time = phoenix_flames_total_cd - (phoenix_flames_charges_frac*phoenix_flames_base_cd)
	-- local phoenix_flames_next_charge_cd = (math.ceil(phoenix_flames_charges_frac) - phoenix_flames_charges_frac) * phoenix_flames_base_cd

	local enhanced_pyrotechnics_remains = _buffRemains("player",157644)
	-- local enhanced_pyrotechnics_up = enhanced_pyrotechnics_remains > 0
	-- local enhanced_pyrotechnics_stacks = _buffStacks("player",157644)

	local kyrian_fb_pool = player_covenant == "Kyrian" and time_to_fb_charges(2) >= (max(meteor_cd,_spellCooldown(307443)))

	local klepto_enabled = IsPlayerSpell(198100)

	flamecannon_value = (flamecannon_stacks * 3)

	gpy_range = 40
	sheep_range = 30
	ring_range = 30

	gpy_range = gpy_range + flamecannon_value
	sheep_range = sheep_range + flamecannon_value
	ring_range = ring_range + flamecannon_value

	local poly_cast_time = _castTime(118)
	local ring_cast_time = _castTime(113724)
	local greater_pyro_cast_time = _castTime(203286)
	local fireball_cast_time = _castTime(133)
	local scorch_cast_time = _castTime(2948)
	local rune_of_power_cast_time = _castTime(116011)

	local triune_ward = GetInventoryItemID("player",2) == 178927

	local thoughtsteal_remains = _debuffRemains("player",322464)

 	meteor_in_flight = meteor_cd > 42
	meteor_in_flight_remains = (3 - ( 45 - meteor_cd )) - buffer

	local can_be_purged

	local enemies_on_player,enemy_melee_on_player,enemy_ranged_on_player,enemy_cds_on_player = EnemiesAttacking("player")

	player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
	player_cast_target = UnitSpellTarget("player")
	player_cast_time_left = _castTimeLeft("player")
	player_cast_percent_complete = _castPctDone("player")
	player_interruptable = PlayerCanBeKicked()

	if tContains(sheep_ids,player_cast_id) then
		poly_cast_delay = time
		poly_cast_target = player_cast_target
	end

	if player_cast_id ~= 300728 then
		if door_of_shadows_pos then
			local _,_,_,_,startTime = unpack ( door_of_shadows_pos ) 
			if time - startTime > .15 then
				door_of_shadows_pos = nil
			end
		end
	elseif door_of_shadows_pos and player_cast_id == 300728 and player_cast_time_left <= buffer + .125 then

		local unit,x,y,z = unpack ( door_of_shadows_pos )

		if UnitIsVisible(unit) then
			local ux,uy,uz = ObjectPosition( unit ) 
			if GetDistanceBetweenPositions(x,y,z,ux,uy,uz) > 5 then
				Squid_Alert("Stop Casting","(Missed)",nil,nil,300728)
				SpellStopCasting()
			elseif _CCremains(unit) >= 2 then
				Squid_Alert("Stop Casting","(Overlap)",nil,nil,300728)
				SpellStopCasting()
			elseif _immuneMagic(unit) then
				Squid_Alert("Stop Casting","(Immune)",nil,nil,300728)
			end
		end

	end

	if player_cast_id == 113724 then
		ring_cast_delay = time
	end

	if player_cast_id == 203286 then
		gpy_cast_delay = time
	end

	--gui setting, disable movement stop for cc
	local move_setting = SQUID.stop_to_cc;

	local player_casting_non_cc = player_cast and not tContains(cc_casts,player_cast_id)
	local player_casting_cc = player_cast and tContains(cc_casts,player_cast_id)
	player_casting_sheep = player_cast and player_cast_id ~= 113724 and tContains(cc_casts,player_cast_id)

	local player_casting_crittable_damage = player_cast and tContains(crit_casts,player_cast_id)
	local player_casting_guaranteed_crit = player_cast and tContains(crit_casts,player_cast_id) and (combustion or (player_cast_id == 2948 and UnitIsVisible(player_cast_target) and _HP(player_cast_target) < 30 and IsPlayerSpell(269644)))

	--blazing barrier absorb
	local barrier,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID("player",235313)
	local barrier_remains = barrier and absorb or 0
	
	barrier,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID("player",11426)
	barrier_remains = barrier_remains + (barrier and absorb or 0)

	barrier,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID("player",235313)
	barrier_remains = barrier_remains + (barrier and absorb or 0)

	local player_effective_hp = (100 * (UnitHealth("player") + barrier_remains) / UnitHealthMax("player"));

	local sheeped_target
	local sheeped_target_duration = 0
	for i=1,#Enemies do
		local remains = sheep_remains(Enemies[i]) --, _debuffRemains(Enemies[i],82691,"player") )
		-- if _debuffRemains(Enemies[i],82691,"player") > remains then remains = _debuffRemains(Enemies[i],82691,"player") end
		if remains > 0 then
			sheeped_target = Enemies[i]
			sheeped_target_duration = remains
		end
	end

	if sheeped_target and SQUID.i_am_xen then 
		-- Squid_Alert(UnitName(sheeped_target))
		-- print(sheeped_target_duration)
	end

	local their_healer = theirHealer
	local their_healer_cc
	local their_healer_cc_remains = 0
	local their_healer_incapacitate_dr
	local their_healer_incapacitate_dr_remains = 0
	local their_healer_disorient_dr
	local their_healer_disorient_dr_remains = 0
	local their_healer_important_lockout
	if their_healer then
		if not UnitIsDeadOrGhost(their_healer) then
			their_healer_cc_remains = _CCremains(their_healer)
			their_healer_cc = their_healer_cc_remains > 0
			their_healer_incapacitate_dr = _incapacitateDR(their_healer)
			their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
			their_healer_disorient_dr = _disorientDR(their_healer)
			their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

			local class = select(2,UnitClass(their_healer))

			local locked,remaining,school = UnitIsLocked(their_healer)

			if locked and remaining > .25 then
				if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
				or ( class == "SHAMAN" and school == "Nature" )
				or ( class == "PALADIN" and school == "Holy" )
				or ( class == "MONK" and school == "Nature" )
				or ( class == "DRUID" and school == "Nature" )  then
					their_healer_important_lockout = true
				end
			end
		else -- no healer if he dead
			their_healer = nil
		end
	end

	local function their_healer_can_dispel(unit,after)
		after = after or 0
		if not UnitIsVisible(their_healer) or not UnitIsVisible(unit) then return false end
		if unit_is_unit(unit,their_healer) then return false end
		local dispels = {
			["DRUID"] = 88423,	--Nature's Cure (Druid)
			["PALADIN"] = 4987,	--Cleanse (Paladin)
			["PRIEST"] = 527,	--Purify (Priest)
			["SHAMAN"] = 77130,	--Purify Spirit (Shaman)
			["MONK"] = 115450,	--Detox (Monk)
		}
		local class = select(2,UnitClass(their_healer))
		local cd = UnitCooldown(their_healer,dispels[class])
		if cd <= after and _distance(unit,their_healer) <= 48 and their_healer_cc_remains < poly_cast_time then
			return true
		end
	end

	if not their_healer then
		their_healer_cc = true
		their_healer_cc_remains = 100 - (lowestEnemy*1.5)
		their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
		their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
	end

	-- auto focus the best focus target
	if arena then
		if not UnitIsVisible(current_focus) or unit_is_unit(current_focus,current_target) then
			if their_healer and not unit_is_unit(their_healer,current_target) then
				FocusUnit(their_healer)
				Squid_Alert("Focusing Healer")
			elseif their_healer_hiding then
				-- do nothing
			else
				if UnitIsVisible(off_target) and not UnitIsDeadOrGhost(off_target) then
					FocusUnit(off_target)
					Squid_Alert("Focusing Off Target")
				end
			end
		end
	end

	-- for when the next cc defining max_cast_time is assigned to the healer
	local next_cc_is_healer
	local friendly_priest
	local friendly_feral
	local friendly_rogue

	for i=1,#Friends do
		local class = select(2,UnitClass(Friends[i]))
		--rog
		if class == "ROGUE" then
			friendly_rogue = Friends[i]
		--feral
		elseif class == "DRUID" and not _isHealer(Friends[i]) then
			friendly_feral = Friends[i]
		--priest
		elseif class == "PRIEST" then
			friendly_priest = Friends[i]
		end
	end

	local friendly_rogue_blind_cd
	if friendly_rogue then
		friendly_rogue_blind_cd = UnitCooldown(friendly_rogue,2094)
	end

	local our_healer
	local our_healer_cc
	local our_healer_cc_remains = 0
	if ourHealer then
		our_healer = ourHealer
		our_healer_cc_remains = _CCremains(ourHealer)
		our_healer_cc = our_healer_cc_remains > 0
	end

	-- enemy players count
	local enemy_players = 0
	for i=1,#Enemies do if unit_is_player(Enemies[i]) then
		enemy_players = enemy_players + 1
	end end

	-- team clone cast count
	local team_clone_cast = {}
	local team_hibernate_cast = {}
	for i=1,#Friends do 
		local cast = UnitCastingInfo(Friends[i])

		if cast == "Cyclone" then
			local target = UnitSpellTarget(Friends[i])
			if target then
				team_clone_cast[target] = true
			end
		elseif cast == "Hibernate" then
			local target = UnitSpellTarget(Friends[i])
			if target then
				team_hibernate_cast[target] = true
			end
		end
	end

	-- print ( enemy_players )

	local not_moving_duration = 0 

	if _isMoving("player") then
		not_moving_duration = 0
		last_move = time
	else
		if not last_move then last_move = time end
		not_moving_duration = time - last_move
	end

	local function meteor(unit,keypress)
		if meteor_cd > gcd then return false end
		local x,y,z = best_meteor_point(unit,keypress)
		if x and y and z then
			if player_casting_crittable_damage and meteor_cd == 0 and (not comubstion or player_cast_time_left > .5) then SpellStopCasting() end
			if _Cast(153561) then
				ClickPosition(x,y,z)
				_targetLastTarget()
				Squid_Alert("Meteor",nil,nil,nil,153561)
			end
			return true
		end
	end

	local function db(unit,alert)
		if poly_cast_delay and time - poly_cast_delay < .2 then return false end
		if ring_cast_delay and time - ring_cast_delay < .2 then return false end
		if _distance(unit) < 8.5 and _LoS(unit) and not breakable_cc_around(unit,8) then
			if db_cd == 0 then
				-- No db while casting
				if not UnitCastingInfo("player") then 
					if player_has_control() then
						local f = ObjectFacing("player")
						FaceDirection(GetAnglesBetweenObjects("player",unit),true)
						SQ_CastSpellByID(31661)
						FaceDirection(f,true)
						if alert == nil then
							Squid_Alert_Big("Dragon's Breath",UnitClass(unit),nil,nil,31661)
						end
						return true
					end
				-- Stop cast to db
				elseif (player_cast_id == 2948 or player_cast_id == 133) then
					SpellStopCasting() 
				end
			elseif db_cd <= gcd_remains + latency + .35 then
				return "wait"
			end
		end
	end

	function db_random()
		for i=1,#Enemies do if db(Enemies[i]) then Squid_Alert_Big("Dragon's Breath","(Pyroclasm!)",nil,nil,31661) return true end end
	end

	function Squid_DB(unit)
		return db(unit)
	end

	--Keybindz
	if blink_db_healer then
		if their_healer then
			if _CCremains(their_healer) < .75 then
				blink_db(their_healer)
				return
			else
				Squid_Alert("|cFFa665cdWaiting for Overlap","(Blink DB)",nil,nil,31661)
			end
		else
			local str = "|cFFa665cdHealer Not Found!"
			Squid_Alert(str,"(Blink DB)",nil,nil,31661)
		end
	end

	if blink_db_focus then
		if current_focus then
			if _CCremains(current_focus) < .75 then
				blink_db(current_focus)
				return
			else
				Squid_Alert("|cFFa665cdWaiting for Overlap","(Blink DB)",nil,nil,31661)
			end
		else
			local str = "|cFFa665cdFocus Not Found!"
			Squid_Alert(str,"(Blink DB)",nil,nil,31661)
		end
	end

	if blink_db_target then
		if current_target then
			if _CCremains(current_target) < .75 then
				blink_db(current_target)
				return
			else
				Squid_Alert("|cFFa665cdWaiting for Overlap","(Blink DB)",nil,nil,31661)
			end
		else
			local str = "|cFFa665cdTarget Not Found!"
			Squid_Alert(str,"(Blink DB)",nil,nil,31661)
		end
	end

	if meteor_key then
		if current_target then
			meteor(current_target,true)
		end
	end

	mage_next_cc_target = nil
	mage_next_cc_nooverride = nil
	mage_next_cc = nil
	mage_next_cc_dr = nil
	mage_next_cc_time = nil

	if _silenceCheck("player") then return end

	local bcc12 = _bccAM(12)

	local ttd = squid_ttd

	--db druid opener
	if _debuffRemains("player",50259) > 1.75 and  _debuffRemains("player",50259) < 1.955 then
		local source = select(7,UnitDebuffID("player",50259))
		if not UnitIsVisible(source) or _stealthCheck(source) or _disorientDR(source) == 1 then
			if not wildcharge_db or time - wildcharge_db > 5 then
				if player_has_control() then
					if _spellCooldown(31661) == 0 then
						local facing = ObjectFacing("player")
						FaceDirection(mod(facing + math.pi, math.pi * 2),true)
						CastSpellByID(31661)
						FaceDirection(facing)
						Squid_Alert("DB","(Druid Opener)",4,nil,31661)
						wildcharge_db = time
					end
				end
			end
		end
	end

	--nova cover imp
	if imp_exists then
		--sheep
		if player_casting_sheep then
			if _isHealer(player_cast_target) then
				if _spellCooldown(122) <= .3
				and _incapacitateDR(player_cast_target) == 1 
				and not _rootImmuneCheck(player_cast_target) 
				and _rootDR(player_cast_target) >= .5 then
					if _distance(player_cast_target) < 9 then
						if _Cast(122,nil,nil,nil,nil,true) then -- force queue
							Squid_Alert_Big("Nova " .. UnitClass(player_cast_target),"(Imp Cover)",1,nil,122)
						end
					elseif player_cast_time_left <= latency + .3 then
						--blink to them
						blink_to_unit(player_cast_target,8,true)
						Squid_Alert("Blink to " .. UnitClass(player_cast_target),"(Imp Cover)",nil,nil,212653)
					end
				end
			end
		end
		-- print("imp detected!!!")
	end

	--nova stealth
	if not bcc12 then
		for i=1,#Enemies do if _stealthCheck(Enemies[i]) and _distance(Enemies[i]) < 8 then
			if _Cast(122) then
				Squid_Alert_Big("Nova " .. UnitClass(Enemies[i]),"(Stealth)",1,nil,122)
			end
		end end
	end

	if self_reliance_stealth and not UnitBuffID("player",32727) then
		if _Cast(122) then
			Squid_Alert_Big("Nova","(Stealth Detected)",1,nil,122)
		end
	end

	--nova thing from beyond
	if not bcc12 and (not legendary_cloaked or time - legendary_cloaked > 4.5) and UnitDebuffID("player",319695) then
		for i=1,#things_from_beyond do
			local thing = things_from_beyond[i]
			if _realDistance(thing) < 11.25 then
				if _Cast(122) then
					Squid_Alert_Big("Frost Nova","(Thing From Beyond)",4,nil,122)
				end
			end
		end
	end

	if UnitAffectingCombat("player") and UnitCastingInfo("player") == "Pyroblast" and _castTimeLeft("player") > .75 and pyroclasm_remains < (player_cast_id == 11366 and player_cast_time_left or _castTime(11366)) then
		SpellStopCasting()
		Squid_Alert("Stopcasting","(Hardcasting Pyro)",nil,nil,11366)
	end

	local mage_stop_moving

	if IsMounted() or IsFlying() or UnitBuffID("player",66) or UnitBuffID("player",32612) or UnitBuffID("player",45438) or UnitBuffID("player",110960) or not player_has_control() then return end --32612

	local t=current_target	

	-- local function _valid(unit,immune)
	-- 	if not unit or not UnitExists(unit) then return false end
	-- 	if UnitIsDead(unit) or UnitIsDeadOrGhost(unit) then return false end
	-- 	return UnitCanAttack("player",unit)
	-- 	and not UnitIsFriend("player",unit)
	-- 	and not _breakableCC(unit)
	-- 	and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
	-- 	and ((arena and unit_is_player(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or unit_is_player(unit)))); 
	-- end

	local m_i_r = t and magic_immunity_remains(t,true) or 0

	local target_dist = _distance(t)

	local function valid_magic(after,unit)

		if not unit then unit = t end
		if not unit then return false end
		if not UnitIsVisible(unit) then return false end

		if UnitIsDeadOrGhost(unit) then return false end
			
		if arena and not unit_is_player(unit) then return "pet" end

		if not arena and not UnitAffectingCombat(unit) and not _isDummy(unit) and not unit_is_player(unit) then return false end

		if UnitCanAttack("player",unit)
		and (not _breakableCC(unit) or not arena and not unit_is_player(unit))
		and (unit == t and m_i_r <= after or magic_immunity_remains(unit,true) <= after) then
			return true
		end

	end

	if t and UnitBuffID(t,53480) then
		Squid_Alert_Big("Target has RoS","(Switch Targets)",2,nil,53480)
	end

	local target_hp = _HP(t)
	local target_absorbs = 0
	local target_effective_hp = 100

	if UnitIsVisible(t) then
		target_absorbs = UnitGetTotalAbsorbs(t)
		target_effective_hp = (100 * (UnitHealth(t)+target_absorbs) / UnitHealthMax(t))
	end

	--magic defensive remains
	local MDR = valid_magic(0) and magic_defensive_remains(t) or 0

	local active_enemies = t and Enemies_Around_Unit(t,10) + 1 or 0

	local current_cast = UnitCastingInfo("player")

	--engage load mode when the enemy team is locked down
	local load_mode = valid_magic(0) and ( ( their_healer and ( their_healer_cc_remains > 0 or their_healer_important_lockout ) ) or combustion_remains > 0 or _stunRemains(t) > 0 or target_effective_hp < 30 * ((their_healer or not arena) and 1 or SQUID.cap_bot and 3 or 2.3) or unit_is_unit(their_healer,t) and target_effective_hp < 55 + ( ( _stunCheck(t) or _drRemains(t,"stun") > 15 ) and 35 or 0 ) + (SQUID.cap_bot and 25 or 0) ) 

	--engage load mode when burst mode is forced
	if Squid_Burst then load_mode = true end

	local load_target = valid_magic(0) and ( _stunCheck(t) or _HP(t) < 30 * ( their_healer_cc and 2.5 or 1 ) )

	--disable load mode when the enemy trades a defensive, unless already stunned or combusting
	if load_mode and _stunRemains(t) == 0 and combustion_remains == 0 then
		
		--not wasting this precious load on your magic defenses
		if MDR > 0 then
			load_mode = nil
		end

	end

	load_mode_active = load_mode

	--auto burst
	if SQUID.auto_mage_burst then
		if load_mode then
			--no healer
			if not their_healer then
				if valid_magic(0) and _LoS(t) and ( _stunRemains(t) > 2.5 or _HP(t) < 25 and select(2,GetUnitSpeed(t)) < 4 ) then
					SquidBurst()
				end
			--healer
			else
				if their_healer_cc_remains > 5.8 and valid_magic(0) and _LoS(t) and ( _stunRemains(t) > 1 or _HP(t) < 85 and select(2,GetUnitSpeed(t)) < 4.5 ) then
					SquidBurst()
				end
			end
		end
	end

	local function phoenix_flames(unit)
		if not phoenix_flames_enabled then return false end
		if phoenix_flames_charges == 0 then return false end
		if fire_lockout > gcd_remains then return false end
		if arena and not unit_is_player(unit) then return false end
		local total,bcc = Enemies_Around_Unit(unit,13.5)
		if bcc == 0 and not player_casting_cc then
			if _amIfacing(unit) and _LoS(unit) then
				SQ_CastSpellByID(257541,unit)
				return true
			end
		end
	end

	Squid_Meteor = meteor

	local function cc(unit,player_forced,offtarget)

		if not arena and not unit_is_player(unit) and not player_forced then return 69 end

		--stop if no unit
		if not unit or not UnitIsVisible(unit) then return 69 end

		--do not sheep? (ext. func)
		if DoNotSheep(unit) then return 69 end

		--dist to unit
		local dist = _distance(unit)

		local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit), _buffRemains(unit,48707) )

		--this function should not only cc, but also return the time until cc needs to happen
		--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
		local time_to_cc = 0

		--druid?
		local is_druid = select(2,UnitClass(unit)) == "DRUID"

		--check root
		local root = ( not is_druid and _rootRemains(unit) or 0 )

		--check cc
		local ccr = _CCremains(unit)
		local cc = ccr > 0 
		
		--incap drs
		local idr = _incapacitateDR(unit)
		local idr_remains = _drRemains(unit,"incapacitate")

		--disorient drs
		local ddr = _disorientDR(unit)
		local ddr_remains = _drRemains(unit,"disorient")

		--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
		local immune_sheep = _isBeast(unit) or _isDummy(unit) or UnitBuffID(unit, 197625)

		--meteor?
		local standing_in_meteor = UnitDebuffID(unit,155158)

		--yea dont cc into it
		if standing_in_meteor then return 69 end

		--banner?
		local banner = UnitBuffID(unit,236321)

		--remaining shep
		local sheep_remains = sheep_remains(unit)

		--yea dont cc into it...unless
		if banner then return 69 end

		--incap on unit?
		local incap = _incapacitateCheck(unit)

		--healer?
		local is_healer = _isHealer(unit) 

		--lockout? (only important lockout...)
		-- local lockout = IsLocked(unit,true)
		local locked,lockout_remaining,school = UnitIsLocked(unit)

		local important_lockout_remaining = 0
		if locked and lockout_remaining > 0 then
			if ( class == "PRIEST" and school == "Shadow" )
			or ( class == "SHAMAN" and school == "Nature" )
			or ( class == "PALADIN" and school == "Holy" )
			or ( class == "MONK" and school == "Nature" )
			or ( class == "DRUID" and school == "Nature" )
			or ( class == "MAGE" and school == "Arcane" )
			or ( class == "WARLOCK" and school == "Shadowflame" ) then
				important_lockout_remaining = lockout_remaining
			end
		end

		--los?
		local los = _LoS(unit)
		local time_los = time_in_los(unit)

		--charmed friend?
		local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

		if friendly then return 69 end

		local bleeds = bleeds_around(unit,9)

		--door of shadows disorient
		local time_til_dos_ready = 69
		-- if immunity_remains == 0 and conduit_taken(331576) and (not friendly_rogue or friendly_rogue_blind_cd > 16 - bin(lowestEnemy<40)*5) and (not friendly_priest or _distance(friendly_priest,unit) > 12) and (not _isMoving(unit) or ccr > 0) then
		-- 	local dos_cast_time = _castTime(300728)
		-- 	if not immune_sheep or ring_enabled and ring_cd < buffer+dos_cast_time then
		-- 		local sheep_dr_ready = idr == 1 or ( idr >= .5 and idr_remains > 17.25 - (cc and 6 * idr or 0) - ((100-lowestEnemy) * .038) ) or idr_remains < gcd + poly_cast_time
		-- 		local dos_ready = _spellCooldown(300728) == 0
		-- 		if (sheep_dr_ready or ccr > dos_cast_time and ccr < dos_cast_time + buffer*2) and (is_healer or not their_healer and not their_healer_hiding) and ccr < dos_cast_time + buffer*2 then
		-- 			if _spellCooldown(300728) == 0 then
		-- 				local ring_ready = ring_cd < gcd
		-- 				--delay dragon's breath when druid is in form, and no ring available
		-- 				if bleeds then
		-- 					Squid_Alert("Delaying DoS","(Bleeds)",nil,5,300728)
		-- 				elseif immune_sheep and not ring_ready and lowestEnemy > 65 then
		-- 					-- don't do it mane
		-- 				else
		-- 					if not team_clone_cast[unit] and (current_target and magic_immunity_remains(current_target) <= buffer + .25 + dos_cast_time) then
		-- 						door_of_shadows(unit)
		-- 					end
		-- 				end
		-- 				mage_next_cc = 300728
		-- 				mage_next_cc_time = 0
		-- 			end
		-- 		end
		-- 		time_til_dos_ready = dist < 32 and los and max((ccr < dos_cast_time or ccr > dos_cast_time + buffer*2) and idr_remains or 0,_spellCooldown(300728),ccr,ddr_remains) or 69 --may need fix vs druids
		-- 	end
		-- end

		--db druids out of form, and before drs in order to sheep. may need some
		--alternative in the future to hold casts while waiting for a druid to leave form.
		local time_til_db_ready = 69
		if immunity_remains == 0 and (not friendly_rogue or friendly_rogue_blind_cd > 18 - bin(lowestEnemy < 30)*6) and (not friendly_priest or _distance(friendly_priest,unit) > 13) then
			if not immune_sheep or ring_enabled and ring_cd < gcd+buffer then    --less restrictive dr checks when continuing cc chain / dr coming back up in the time it takes to db+sheep
				local sheep_dr_ready = idr == 1 or ( idr >= .25 and idr_remains > 17.25 - (cc and 6 * idr or 0) - ((100-lowestEnemy) * .038) ) or idr_remains < gcd + poly_cast_time
				local db_ready = db_cd <= gcd and dist < 6.5 and ccr < gcd and ddr == 1
				if sheep_dr_ready and db_ready and (is_healer or not their_healer and not their_healer_hiding) then
					local ring_ready = ring_cd < gcd
					--delay dragon's breath when druid is in form, and no ring available
					if immune_sheep and not ring_ready then
						Squid_Alert("Delaying DB","(Shapeshift)",nil,5,31661)
						--attempt to force druid out of form with a frost nova
						if not bcc12 and _Cast(122) then
							Squid_Alert_Big("Frost Nova","(Force Shift)",nil,nil,122)
						end
					else
						if not team_clone_cast[unit] and (current_target and magic_immunity_remains(current_target) <= buffer + .25) then
							--execute the db
							db(unit)
						end
					end
					mage_next_cc = 31661
					mage_next_cc_time = 0
				end
				time_til_db_ready = dist < 6.5 and max(idr_remains,db_cd,ccr,ddr_remains) or 69 --may need fix vs druids
			end
		end

		--ring to followup cc, if the unit is a beast, or we are locked on sheep
		local time_til_ring_ready = 69
		if immunity_remains <= ring_cast_time and (not ring_cast_delay or time - ring_cast_delay > .08) and (not poly_cast_delay or time - poly_cast_delay > .175 or arcane_lockout > 0) and (not UnitDebuffID(unit,33786) or (_debuffRemains(unit,33786) < ring_cast_time and _debuffRemains(33786) > ring_cast_time-(buffer*1.5))) then
			if ( idr >= .5 or lowestEnemy < 15 and idr >= .25 ) and ( idr == 1 or idr_remains > 16 or not incap and idr_remains > 8 and lowestEnemy < 55 ) then
				if arcane_lockout > 0 or immune_sheep or max( ccr, root ) > ring_cast_time - buffer or (sheeped_target and not unit_is_unit(unit,sheeped_target)) then
					local poly_cast_time_extra = poly_cast_time + buffer
					local max_overlap = ring_cast_time + ( buffer*2.65 ) + ( player_interruptable and ( not combustion or idr == 1 ) and idr >= .5 and poly_cast_time_extra + 1 or 0 ) + .1 + ( not incap and .25 or 0 ) --arcane_lockout < ring_cast_time and
					local ring_ready = ring_enabled and ring_cd <= gcd and max( ccr, root ) > ring_cast_time-buffer and ccr <= max_overlap and (idr == 1 or (not los or arcane_lockout > gcd_remains or player_interruptable) and idr >= .5)

					if ring_ready and dist < ring_range then
						--alert when moving, stop casting scorch when not
						local can_ring = ring_of_frost(unit)
						if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Ring)",nil,.5,113724)
						elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
						mage_stop_moving = {unit=unit, dist=ring_range}
						time_to_cc = 0
						if not mage_next_cc then
							mage_next_cc = 113724
						end
						mage_next_cc_time = 0
					end

					time_til_ring_ready = ccr > ring_cast_time + buffer and dist < ring_range and max(ring_cd,ccr,idr == 1 and 0 or idr == .5 and arcane_lockout > gcd_remains and 0 or idr_remains) or 69
				end
			end
		end

		local sheeped_and_dispellable = sheep_remains > 4 + poly_cast_time and their_healer_can_dispel(unit,poly_cast_time - buffer)

		--sheep, if drs are available, and the unit is not immune
		local time_til_poly_ready = 69
		local max_overlap = poly_cast_time + (buffer*2.55) + (player_interruptable and idr >= .5 and ( ring_cd <= gcd or SQUID.auto_juke ) and ring_cast_time + buffer + ( SQUID.auto_juke and buffer or 0 ) or 0) -- + (idr >= .5 and ring_cd < gcd and ccr > ring_cast_time and ring_cast_time or 0)
		if los and (not ring_cast_delay or time - ring_cast_delay > .3 or ring_cd > gcd_remains) and (not poly_cast_delay or time - poly_cast_delay > .125 or sheeped_and_dispellable ) then --no sheep into lockout, unless they're casting another school
			if (not immune_sheep or team_hibernate_cast[unit]) and (important_lockout_remaining <= poly_cast_time + 1.5 + (buffer*2.5) + (player_interruptable and poly_cast_time or 0) or UnitCastingInfo(unit)) then -- need better logic here to determine if the lockout is worth sheeping over, cause it often is.
				
				local sheep_dr_ready = idr == 1 or (idr >= .25 and idr_remains > 17.45 - (ccr >= poly_cast_time and 8 * idr or 0) - (incap and ccr >= poly_cast_time-.2 and 6 * idr or 0) - ((100-lowestEnemy) * .038) - (offtarget and idr >= .5 and 2 or 0) + (idr == .25 and 2 or 0) ) or ( idr_remains < poly_cast_time-(buffer/2) and ( idr_remains ~= 0 or idr == 1 ) )
				
				-- print(sheep_dr_ready, idr, idr_remains)
				-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
				local no_sheeps_out = not sheeped_target or unit_is_unit(unit,sheeped_target) or _incapacitateDR(sheeped_target) < .25 or (is_healer and idr == 1 and not _isHealer(sheeped_target)) --or (not _isHealer(sheeped_target) and _incapacitateDR(sheeped_target) <= .5 and _drRemains(sheeped_target,"incapacitate") > 3 and _drRemains(sheeped_target,"incapacitate") < 16.5)
				if sheep_dr_ready and no_sheeps_out then
					
					if dist < sheep_range and ( ccr < max_overlap or sheeped_and_dispellable ) then
						if thoughtsteal_remains == 0 then
							if arcane_lockout <= buffer then
								if immunity_remains <= poly_cast_time+latency+msperframe-.03 then -- extra 30 ms window
									--alert when moving, stop casting scorch when not
									if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Sheep)",nil,.5,sheep)
									elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
									if time_los >= 1 then
										mage_stop_moving = {unit=unit, dist=ring_range}
									end
									if (not poly_cast_delay or time-poly_cast_delay > .2) and _Cast(sheep,unit) then
										if team_hibernate_cast[unit] then
											Squid_Alert("Sheep + Hibernate",UnitClass(unit),nil,3,sheep)
										else
											Squid_Alert("Sheeping",UnitClass(unit),nil,3,sheep)
										end
									end
									time_to_cc = 0
									if not mage_next_cc then
										mage_next_cc = 118
									end
									mage_next_cc_time = 0
								end
							else
								time_to_cc = max(arcane_lockout,time_to_cc)
							end
						else
							time_to_cc = max(thoughtsteal_remains,time_to_cc)
						end
					else
						time_to_cc = max(ccr,time_to_cc)
					end

					local immune_val = 0
					if immunity_remains > 0 then
						immune_val = max ( immunity_remains - poly_cast_time - (buffer * .45), 0 )
					end

					time_til_poly_ready = dist < sheep_range and max(ccr-max_overlap,idr_remains < 17 and idr_remains or 0,arcane_lockout,immune_val,thoughtsteal_remains) or 69 -- "never" if out of range (applied to ring too)

					if immune_sheep and not is_healer then time_til_poly_ready = 69 end

				end
			end
		end

		local this_unit_dos
		if door_of_shadows_pos then
			local dosunit = unpack ( door_of_shadows_pos )
			if unit_is_unit(unit, dosunit) then this_unit_dos = true end
		end

		--db when drs are available, or to continue cc chain, and we are in range
		if (not friendly_priest or _distance(friendly_priest,unit) > 13) and not SQUID.i_am_xen and not this_unit_dos then
			if immunity_remains == 0 and (not friendly_rogue or friendly_rogue_blind_cd > 18) then
				if idr == 1 or idr_remains > 17 or lowestEnemy < 33 + (combust and 15 or 0) + (not is_druid and 30 or 0) then
					local db_ready = db_cd <= gcd and dist < 9.25 and ccr < gcd and ddr == 1 and (not poly_cast_delay or time-poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,unit))
					if db_ready and is_healer and not immune_sheep and los then
						if ccr < gcd_remains + buffer + .1 then
							if not team_clone_cast[unit] then
								db(unit)
							end
						else
							time_to_cc = max(ccr,time_to_cc)
						end
						if not mage_next_cc then
							mage_next_cc = 31661
						end
					end
					time_til_db_ready = is_healer and dist < 8.5 and max(idr_remains,db_cd,ccr,ddr_remains) or 69
				end
			end
		end

		local val = math.min(time_til_db_ready,time_til_ring_ready,time_til_poly_ready,time_til_dos_ready)

		if val < greater_pyro_cast_time then

			if arcane_lockout > gcd and (ring_cd > greater_pyro_cast_time or max(root, ccr) < ring_cast_time-buffer) and (dist > 8.25 or db_cd > gcd_remains or ddr < 1 or idr <= .25 and lowestEnemy > 40) then

				val = greater_pyro_cast_time + .5

			end

		end

		--next cc unit used for drawings
		mage_next_cc_target = unit
			
		--default to sheep if no other cc defined above
		if not mage_next_cc then mage_next_cc = 118 end

		--display dr
		if mage_next_cc == 118 or mage_next_cc == 113724 then
			mage_next_cc_dr = idr
			mage_next_cc_time = val >= 69 and idr_remains or val
		else
			mage_next_cc_dr = ddr
			mage_next_cc_time = val >= 69 and ddr_remains or val
		end

		return val
		
	end

	local function only_ripped_target(unit)
		-- check if unit is the only enemy with rip applied, this means never sheep it because it is the kill target
		local unit_ripped = UnitDebuffID(unit,1079)
		if not unit_ripped then return false end
		local rips_up = 0
		for i=1,#Enemies do
			if UnitDebuffID(Enemies[i],1079) then
				rips_up = rips_up + 1
			end
		end
		if rips_up == 1 or SQUID.cap_bot then
			return true
		end
	end

	--designate highest prio to cc on healer (returning 69 will fall back to off dps cc)
	local function healer_cc()
		
		local healers = {}

		for i=1,#Enemies do if _isHealer(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) then
			local unit = Enemies[i]
			if _distance(unit) < sheep_range then
				local friends_attacking = UnitEnemiesAttacking(unit)
				local unit_hp = _HP(unit)
				if friends_attacking == 0 and not only_ripped_target(unit) then 
					table.insert(healers,unit)
				end
			end
		end end

		local soonest = 69
		for i=1,#healers do
			local val = cc(healers[i])

			if val < soonest then
				soonest = val
			end

		end

		return soonest + .05

	end

	--cc off dps while waiting for dr on healer, or to secure cc on healer while they have interrupts available
	local function off_cc()

		if only_cc_healers then return 69 end

		local units = {}

		for i=1,#Enemies do
			local e = Enemies[i]
			if unit_is_player(e) then--or (UnitIsHunterPet(e) and combustion_cd <= 2) then 
				if not unit_is_unit(e,current_target) and _distance(e) < sheep_range and _LoS(e) and not only_ripped_target(e) then
					local friends_attacking = UnitEnemiesAttacking(e)
					local unit_hp = _HP(e)
					if friends_attacking == 0 then
						local min_hp = 70
						min_hp = min_hp - (our_healer_cc and 20 or 0)
						min_hp = min_hp - (_CDcheck(e) and 20 or 0)
						min_hp = min_hp - (lowestFriend < 40 and 20 or 0)
						if unit_hp > min_hp then
							table.insert(units,e)
						end
					end
				end
			end
		end

		local soonest = 69
		for i=1,#units do
			local val = cc(units[i],nil,true) -- looser remaining incap dr on off targets

			if val < soonest then
				soonest = val
			end
		end

		return soonest

	end

	-- local function priority_cc()
		
	-- 	local player_exists

	-- 	for i=1,#Enemies do if unit_is_player(Enemies[i]) then player_exists = true end end

	-- 	if not arena and not player_exists then return 69 end

	-- 	--healer
	-- 	local unit = their_healer

	-- 	--focus target if there is no healer
	-- 	if not unit then unit = current_focus end

	-- 	if unit_is_unit(unit,current_target) then
	-- 		unit = current_focus
	-- 	end

	-- 	local idr
	-- 	local idr_r
	-- 	if unit then
	-- 		idr = _incapacitateDR(unit)
	-- 		idr_r = _drRemains(unit,"incapacitate")
	-- 	end

	-- 	if unit_is_unit(unit,current_target) then
	-- 		--off target
	-- 		for i=1,#Enemies do if unit_is_player(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) then
	-- 			unit=Enemies[i]
	-- 			break
	-- 		end end
	-- 	else
	-- 		if unit then
	-- 			if idr < .25 or ( idr_r > 3 and idr_r < 15 ) or _distance(unit) > 39 or (not _LoS(unit) and ring_cd > gcd) then
	-- 				--off target
	-- 				for i=1,#Enemies do if unit_is_player(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) then
	-- 					unit=Enemies[i]
	-- 					break
	-- 				end end
	-- 			end
	-- 		end
	-- 	end

	-- 	--someone on team is attacking?
	-- 	if unit then
	-- 		local friends_attacking = UnitEnemiesAttacking(unit)
	-- 		if friends_attacking > 0 then 
	-- 			local temp_unit = unit
	-- 			unit = nil
	-- 			--off target
	-- 			for i=1,#Enemies do if unit_is_player(Enemies[i]) and not unit_is_unit(Enemies[i],temp_unit) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) and (_incapacitateDR(Enemies[i]) >= .5 or _drRemains(Enemies[i],"incapacitate") <= 1) then
	-- 				unit=Enemies[i]
	-- 				break
	-- 			end end
	-- 		end
	-- 	end

	-- 	--stop function if no viable cc target
	-- 	if not unit then return 69 end

	-- 	if unit and UnitIsDeadOrGhost(unit) then return 69 end

	-- 	return cc(unit)

	-- end

	local function kill(unit)

		if not unit then return end

		local m_i_r = magic_immunity_remains(unit)
		local idr = _incapacitateDR(unit)
		local ddr = _disorientDR(unit)
		local ccr = _CCremains(unit)
		local hp = _HP(unit)
		local d = _distance(unit)
		local idr_remains = _drRemains(unit,"incapacitate")

		-- good incap dr
		if idr >= .5 and not gpy_flying then
			if hp > 60 and idr == 1 and m_i_r < poly_cast_time and ccr < poly_cast_time + buffer then
				-- sheep target if hp is higher than it would be after 1 gpy
				if (not poly_cast_delay or time - poly_cast_delay > .15) and (not ring_cast_delay or time - ring_cast_delay > .25) then
					_Cast(sheep,unit)
				end
			elseif ( db_cd <= gcd and ddr == 1 and ( d < 8.25 or blink_cd == 0 ) or ring_cd <= gcd_remains + ccr and ccr > ring_cast_time - buffer and ( ccr < greater_pyro_cast_time - ( buffer * 2 ) or gpy_flying ) ) then
				-- db > ring target if target hp is low
				if ccr <= buffer and (not ring_cast_delay or time - ring_cast_delay > .25) and ring_cd <= gcd then
					blink_db(unit)
				elseif ccr > ring_cast_time - buffer and ( ccr < ring_cast_time + buffer + (UnitDebuffID(unit,31661) and .25 or 0) ) then
					ring_of_frost(unit)
				end
			elseif idr == 1 then
				-- sheep target anyway if not close enough to db
				if (not poly_cast_delay or time - poly_cast_delay > .1) and (not ring_cast_delay or time - ring_cast_delay > .25) then
					_Cast(sheep,unit)
				end
			end
		end

		-- if casting gpy where target is in cc for the entire duration of the cast, blink to make distance ( 15-25 yd ) for a meteor that will hit simultaneously with gpy

		-- cast gpy into cc that remains > gpy cast time - a bit
		if ccr > greater_pyro_cast_time - ( buffer * 4 ) and (not gpy_flying and (not gpy_cast_delay or time - gpy_cast_delay > buffer) or ring_cd > ccr + ring_cast_time)  then--(not gpy_flying or _debuffRemains(unit,82691) > max ( greater_pyro_cast_time - ( buffer * 3 ), 0 ) and gpy_est_hit_time and gpy_est_hit_time - time < buffer)  then
			_Cast(203286,unit,nil,true)
		end

		-- ring if gpy is flying and target is in cc long enough
		if gpy_flying and ccr > ring_cast_time - buffer and ( gpy_est_hit_time and gpy_est_hit_time - time < ring_cast_time + buffer and gpy_est_hit_time - time > ring_cast_time - ( buffer * 1.5 ) ) then
			ring_of_frost(unit)
		end

		-- blink to target if gpy is flying, db is ready, and ring is not ready or cc remains not long enough for a ring
		if player_cast_id ~= 82691 and player_cast_id ~= 203286 and ( idr <= .5 or ring_cd <= gcd ) then
			if db_cd <= gcd and ( ring_cd > gcd or ccr < ring_cast_time - buffer and idr < 1 and not gpy_flying ) and ( not ring_cast_delay or time - ring_cast_delay > .2 ) then
				if not gpy_est_hit_time and ccr < gcd or gpy_est_hit_time and min ( _debuffRemains(unit,82691), gpy_est_hit_time - time ) < gcd then
					if not gpy_est_hit_time and ccr > buffer * 2 or gpy_est_hit_time and gpy_est_hit_time - time > buffer * 2 then
						blink_to_db(unit)
					else
						if not gpy_est_hit_time and ccr <= buffer or gpy_est_hit_time and max( ccr, gpy_est_hit_time - time ) <= buffer * 2 then
							blink_db(unit)
						end
					end
				end
			end
		end

		if not ring_cast_delay or time - ring_cast_delay > .45 then
			-- db as gpy hits / meteor falls on target out of ring, or if ring is avail
			if ( meteor_cd <= gcd or meteor_in_flight ) and idr <= .5 and idr_remains > 13.5 and (not gpy_est_hit_time and ccr < buffer or gpy_est_hit_time and max(gpy_est_hit_time - time, ccr) < buffer or meteor_in_flight) then
				blink_db(unit)
			end 
			-- meteor on cc'd target
			if max(db_cd,blink_cd) > gcd_remains + buffer or d > 8.25 then
				if ( ( ccr > 0 or ( db_cd > gcd or idr <= .25 and gpy_flying ) and ring_cd > gcd ) and idr <= .25 + (UnitDebuffID(unit,82691) and .25 or 0) or ( ring_cd > gcd and _debuffRemains(unit,31661) > 0 and ( _debuffRemains(unit,82691) <= 1.25 or gpy_est_hit_time and gpy_est_hit_time - time < 2.5 ) ) ) and ( ccr < greater_pyro_cast_time - ( buffer * 2.5 ) or gpy_est_hit_time and gpy_est_hit_time - time < 2.5 ) then
					if not gpy_flying or gpy_est_hit_time and gpy_est_hit_time - time < buffer or idr <= .25 or db_cd > gcd then
						meteor(unit)
					end
				end
			end
		end

	end

	if killshot_key then--or ( SQUID.cap_bot and valid_magic(0) and _incapacitateDR(current_target) >= .5 + (db_cd > gcd and .5 or 0) and IsPlayerSpell(203286) and ring_cd <= gcd and enemy_players == 1 and UnitEnemiesAttacking(current_target) == 0 ) or killshot_engaged and time - killshot_engaged < 6 then
		kill(current_target)
		Squid_Alert("Killshot Enabled")
		if not killshot_key then
			if not killshot_engaged or time - killshot_engaged > 6 then
				killshot_engaged = time
			end
		end
		if not killshot_engaged or time - killshot_engaged < 6 then
			return
		end
	end

	if killshot_engaged and time - killshot_engaged > 6 then killshot_engaged = nil end
	if killshot_engaged and (ring_cd > gcd or db_cd > gcd) and ( current_target and not _CCcheck(current_target) ) then killshot_engaged = nil end

	local function priority_shit(max_cast_time)
		
		local target_stun = UnitExists(t) and _stunRemains(t) or 0

		if UnitExists(t) and _isDummy(t) then target_stun = 10 end

		--badge w/ combust
		if combustion or meteor_in_flight then

			local race = UnitRace("player")
			
			if race == "Orc" then
				SQ_CastSpellByName("Blood Fury")
			end

			if UnitBuffID("player",313948) then
				RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
				Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
			end

			if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
				Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
			end

			if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
			or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
			or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 ) 
			or ( tContains( equipped_items, 175884 ) and GetItemCD ( ( 175884 ) ) == 0 )
			or ( tContains( equipped_items, 175921 ) and GetItemCD ( ( 175921 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
				UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
				UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
				UseItemByName( tostring( GetItemInfo ( 175921 ) ) )
				Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
			end

			if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
			or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
			or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
				UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
				Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
			end

			if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
				Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
			end

			if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
				Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
			end

			if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
				Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
			end

			if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
			or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
				UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
				Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
			end

			if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
				Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
			end

			if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
				Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
			end

			if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
				Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
			end

		end

		--even healers on your team (if you're playing a caster comp) should be stunning your kill target on goes, securing a clean 50k meteor.
		local stun_classes = {
		"ROGUE",
		"DRUID",
		"PALADIN",
		"WARRIOR",
		"DEATHKNIGHT",
		"DEMONHUNTER",
		"MONK",
		}

		local stuns_on_team
		for i=1,#Friends do 
			if tContains(stun_classes,select(2,UnitClass(Friends[i]))) then
				stuns_on_team = true
			end
		end

		if not _stealthCheck("player") then
			
			--klepto
			-- if klepto_enabled and valid_magic(0) and should_klepto(t) and max_cast_time >= gcd then
			-- 	if _Cast(30449,t,nil,true) then
			-- 		Squid_Alert_Big("Klepto",UnitClass(t),1,nil,30449)
			-- 	end
			-- end

			--blink feral frenzy
			if _debuffRemains("player",274838) > 5.5 then
				if not player_blink or time - player_blink > 2.5 then
					if _Cast(212653) then
						Squid_Alert("Blink","(Feral Frenzy)",4,nil,212653)
					end
				end
			end

			--db fists
			for i=1,#Enemies do
				local e = Enemies[i]
				local channel,_,_,_,endtime,_,_,spellID = UnitChannelInfo(e)
				if channel then
					if spellID == 113656 and _disorientDR(e) >= .25 then
						if endtime and endtime/1000 >= time + 1.25 then
							if not breakable_cc_around(e,10) then
								if db(e,false) then
									Squid_Alert("Dragon's Breath","(Fists of Fury)",4,nil,31661)
								end
							end
						end
					end
					if spellID == 323764 and _disorientDR(e) >= .25 then
						if endtime and endtime/1000 >= time + 1 then
							if not breakable_cc_around(e,10) then
								if db(e,false) then
									Squid_Alert("Dragon's Breath","(Convoke the Spirits)",4,nil,31661)
								end
							end
						end
					end
				end
			end

			--pve rune of power & combust
			-- actions+=/rune_of_power,if=talent.firestarter.enabled&firestarter.remains>full_recharge_time|cooldown.combustion.remains>variable.combustion_rop_cutoff&buff.combustion.down|target.time_to_die<cooldown.combustion.remains&buff.combustion.down
			-- actions+=/call_action_list,name=combustion_phase,if=(talent.rune_of_power.enabled&cooldown.combustion.remains<=action.rune_of_power.cast_time|cooldown.combustion.ready)&!firestarter.active|buff.combustion.up
			-- actions.bm_combustion_phase+=/combustion,use_off_gcd=1,use_while_casting=1,if=azerite.blaster_master.enabled&((action.meteor.in_flight&action.meteor.in_flight_remains<0.2)|!talent.meteor.enabled|prev_gcd.1.meteor)&(buff.rune_of_power.up|!talent.rune_of_power.enabled)
			-- actions.bm_combustion_phase+=/rune_of_power,if=buff.combustion.down
			if rune_of_power_enabled then
				if valid_magic(0) and not unit_is_player(t) and ttd(t) > 9.5 then
					if combustion_cd > rune_of_power_next_charge_cd + rune_of_power_cast_time and not combustion or ttd(t) < combustion_cd and not combustion then
						_Cast(116011)
					end
					if combustion_cd <= rune_of_power_cast_time then
						-- --lucid dreams
						-- if IsPlayerSpell(298357) and _spellCooldown(298357) <= gcd then
						-- 	SQ_CastSpellByID(298357)
						-- 	return
						-- end
						-- if not combustion and not rune_of_power_up then
						-- 	_Cast(116011)
						-- end
						-- --combustion
						-- if meteor_cd > 42.5 and meteor_cd < 43.85 and rune_of_power_up then
						-- 	SQ_CastSpellByID(190319)
						-- end
					end
				end
			end

			if not utilities_only then
				
				local valid_meteor = valid_magic(1.25)

				if valid_meteor and valid_meteor ~= "pet" and (max_cast_time >= gcd or target_stun > 0 and target_stun <= gcd*2.5) then
					
					local kyrian_meteor = player_covenant == "Kyrian" and (_debuffRemains(t, 307443, "player") >= 3.5 or _spellCooldown(307443) > 15)

					-- target stun
					if unit_is_player(t) or _isDummy(t) then
						if kyrian_meteor or player_covenant ~= "Kyrian" and target_stun >= .75 + buffer then
							if meteor_enabled and meteor_cd <= gcd_remains + (buffer*3) then
								if meteor(t, kyrian_meteor) then return end
							end
						end
					end

					-- 2s meteor on any cc?
					if unit_is_player(t) and load_mode then
						if groupsize == 2 and GetNumArenaOpponents() <= 2 then
							if kyrian_meteor or player_covenant ~= "Kyrian" and _CCremains(t) >= .75 + buffer then
								if meteor_enabled and meteor_cd < gcd_remains + (buffer*3) then
									if meteor(t, kyrian_meteor) then return end
								end
							end
						end
					end

					-- mirror image
					if load_mode and max_cast_time > gcd and not combustion and lowestFriend < 60 and lowestEnemy > 40 then
						if _Cast(55342) then
							Squid_Alert("Mirror Images",nil,nil,nil,55342)
						end
					end

				end

			end

			local defensives = {
				-- Flat Walls
				{id = 212800, dr = 35}, -- Blur (35% DMG REDUC)
				{id = 209426, dr = 100}, -- Darkness (Just calling it 100%)
				{id = 498, dr = 20}, -- Divine Protection (20% wall)
				{id = 31821, dr = 20}, -- Aura Mastery (20% wall)
				{id = 243435, dr = 20}, -- Fort Brew (20% wall)
				{id = 125174, dr = 100}, -- Karma (100% absorb that doesn't show up in absorbs)
				{id = 122278, dr = 50}, -- Diffuse Magic (20-50% wall based on damage of incoming attack, calling it 50 for the sake of botd)
				{id = 61336, dr = 50}, -- Survival Instincts (50% wall)
				{id = 22812, dr = 20}, -- Barkskin (20% wall)
				{id = 102342, dr = 20}, -- Ironbark (20% wall)
				{id = 201633, dr = 7}, -- Earthen Wall (~7% of botd dmg absorbed)
				{id = 108271, dr = 40}, -- Astral Shift (40% wall)
				{id = 104773, dr = 40}, -- Unending Resolve (40% wall)
				{id = 1966, dr = 30}, -- Feint (30% wall)
				{id = 33206, dr = 40}, -- Pain Supp (40% wall)
				{id = 81782, dr = 40}, -- Barrier (25-50% wall depending on talent)
				{id = 47585, dr = 75}, -- Dispersion (75% wall)
				{id = 213602, dr = 100}, -- Greater Fade (100% wall)
				{id = 197690, dr = 20}, -- Defensive Stance (20% wall)
				{id = 118038, dr = 30}, -- Parry (30% wall)
				{id = 48792, dr = 30}, -- IBF (30% wall)
				{id = 287081, dr = 30}, -- Lichborne (30% wall)
				{id = 186265, dr = 100}, -- Turtle (hunter det)
				{id = 45438, dr = 100}, -- Ice Block

				-- Magic Walls (AMS shows up in UnitGetTotalAbsorbs so not putting here)
				{id = 122783, dr = 60}, -- Diffuse Magic (60% mwall)
				{id = 31224, dr = 100}, -- Cloak of Shadows (100% magic immune)
				{id = 198065, dr = 50}, -- Prismatic Cloak Mage Blink Shit
				{id = 204018, dr = 100}, -- Spell Warding
			}

			-- --reaping effective dmg
			-- local reaping_damage = GetSpellEffect(310690)
			-- --modifier for kb bonus
			-- reaping_damage = reaping_damage * ( UnitBuffID("player",311202) and 2 or 1 )

			-- local target_dmg_reduc = 0
			-- for i=1,#defensives do
			-- 	local id = defensives[i].id
			-- 	local dr = defensives[i].dr
			-- 	if UnitBuffID("target",id) then
			-- 		target_dmg_reduc = target_dmg_reduc + dr
			-- 	end
			-- end
			-- target_dmg_reduc = target_dmg_reduc / 100

			-- local reaping_mod = 1 - target_dmg_reduc

			-- --essences
			-- if max_cast_time >= gcd and (combustion_remains == 0 or (fire_blast_charges == 0 and phoenix_flames_charges == 0 and not hot_streak and combustion_remains < scorch_cast_time)) then
			-- 	--breath of the dying
			-- 	if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains and valid_magic(0) then
			-- 		local cur_hp = _HP(t)
			-- 		local est_hp = (100 * ( UnitHealth("target") - ( reaping_damage * reaping_mod ) + target_absorbs ) / UnitHealthMax("target") )
			-- 		if not combustion or est_hp < 20 then
			-- 			if est_hp < 20 or cur_hp > 80 and ( cur_hp < 98 or load_mode ) then
			-- 				if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) then
			-- 					if _LoS(t) and _distance(t) < 40 and _amIfacing(t) then
			-- 						CastSpellByID(310690,t)
			-- 					end
			-- 					if _Cast(310690,t,true) then
			-- 						Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
			-- 					end
			-- 				end
			-- 			end
			-- 		end
			-- 	end
			-- 	if IsPlayerSpell(295373) then
			-- 		local stacks = _buffStacks("player",295378)
			-- 		if valid_magic(0) and (load_mode or (GetSpellCharges(295373) == 2 and stacks < 2) or stacks == 0 or _HP(t) < 8*stacks) then
			-- 			if combustion_remains == 0 or (fire_blast_charges < 1 and not hot_streak and stacks >= 1) or stacks == 2 then
			-- 				local str = stacks == 1 and "1 Stack" or stacks .. " Stacks"
			-- 				if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) then
			-- 					if _Cast(295373,t,true) then
			-- 						Squid_Alert("Crucible of Flame",str,nil,nil,295373)
			-- 					end
			-- 				end
			-- 			end
			-- 		end
			-- 	end
			-- end

			-- use the radiant spark
			-- if max_cast_time >= _castTime(307443) and (combustion_remains == 0 or (fire_blast_charges == 0 and phoenix_flames_charges == 0 and not hot_streak and combustion_remains < scorch_cast_time)) then
			-- 	if valid_magic(_castTime(307443)) and _Cast(307443,t,true) then
			-- 		Squid_Alert("Radiant Spark", nil, nil, nil, 307443)
			-- 		return true
			-- 	end
			-- end

			-- rune of power on go
			if not player_interruptable and IsPlayerSpell(116011) and max_cast_time > _castTime(116011) and not combustion and time_in_los(t) > 2 then
				if their_healer_cc_remains >= 6 and combustion_cd > 8 then
					if _Cast(116011) then
						Squid_Alert("Rune of Power", nil, nil, nil, 116011)
						return true
					end
				end
			end

			-- Radiant Spark
			if player_covenant == "Kyrian" then
				if max_cast_time > _castTime(307443) and (meteor_cd <= 2 + fire_blast_charges or meteor_cd > 30 + _castTime(307443)) and load_mode then
					if valid_magic(_castTime(307443)) and _Cast(307443, t, true) then
						Squid_Alert("Radiant Spark", nil, nil, nil, 307443)
						return true
					end
				end
			end

			-- Mirrors of Torment
			if C_Covenants.GetActiveCovenantID() == covenants["Venthyr"] then
				if max_cast_time < 15 - poly_cast_time - buffer and max_cast_time > _castTime(314793) and player_interruptable and (not their_healer or next_cc_is_healer) then
					if valid_magic(_castTime(314793)) and _Cast(314793,t,true) then
						Squid_Alert("Mirrors of Torment", nil, nil, nil, 314793)
						return true
					end
				end
			end
		end
	end

	local function standard_rotation(max_cast_time)

		local target_stun = UnitExists(t) and _stunRemains(t) or 0

		--cast gpy if target will LoS before cast is off, and shimmer available???

		-- hardcast pyro with pyroclasm
		if pyroclasm_remains > 4 then
			if valid_magic(_castTime(11366)) and (not load_mode or lowestEnemy > 45 or fire_blast_charges == 0 and not (_HP(t) < 30 and searing_touch_enabled)) and max_cast_time > _castTime(11366) - buffer - (player_interruptable and 2 or 0) then
				if combustion_remains == 0 and t then
					if IsPlayerSpell(235870) and pyroclasm_remains >= 4.5 + gcd then
						if db_random() then return end
					end
					if not hot_streak then
						if _Cast(11366,t,nil,true) then return end
					elseif pyroclasm_remains > 4.5 + gcd and (UnitBuffID("player", 334277) or pyroclasm_remains < 6) then
						RunMacroText("/cancelaura hot streak!")
						Squid_Alert("Cancel Hot Streak","(Pyroclasm)",nil,nil,48108)
						SquidFrame = 2
						return
					end
				end
			end
		end

		-- q fireball before hot streak pyro / phoenix flames if pveing
		if valid_magic(fireball_cast_time) and (hot_streak and hot_streak_remains > fireball_cast_time + buffer and not UnitBuffID("player",333100)) and (not combustion or fireball_cast_time < scorch_cast_time and fire_blast_charges == 0 and not player_interruptable) and (not load_mode or tinder_up) then
			if max_cast_time > fireball_cast_time and not player_interruptable and fire_blast_full_recharge_time > gcd+buffer then
				if not meteor_in_flight or not UnitDebuffID(t, 307454, "player") then
					if _Cast(133,t,true) then return end
				end
			end
		end

		--consume hot streak (combust prio)
		if combustion and (player_hp > 15 or player_immune) then
			if valid_magic(0) and (hot_streak or player_casting_guaranteed_crit and heating_up) then
				if max_cast_time >= gcd / 2 then
					if _LoS(t) and _distance(t) < gpy_range then
						if ( not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) ) and ( not ring_cast_delay or time - ring_cast_delay > .2 ) then
							if _Cast(11366,t,true) then return end
						end
					end
				end
			end
		end

		--blazing barrier high prio
		local blazing_hp = 25
		blazing_hp = blazing_hp + (enemies_on_player * 50)
		blazing_hp = blazing_hp + (not our_healer and enemies_on_player * 25 or our_healer_cc and 75 or 0)
		blazing_hp = blazing_hp + (enemy_cds_on_player * 100)
		blazing_hp = blazing_hp + (triune_ward and 25 or 0)
		blazing_hp = blazing_hp - (load_target and 35 or 0)
		blazing_hp = blazing_hp - (combustion and 25 or 0)
		-- blazing_hp = blazing_hp - (UnitBuffID("player",310143) and 45 or 0)

		--why die before using blazing barrier?
		if blazing_hp < 5 then
			blazing_hp = 5
		end

		--why use blazing barrier when invincible?
		if player_immune then blazing_hp = 0 end

		if max_cast_time > gcd and player_hp < blazing_hp and barrier_remains < 1400 and (not temp_up or _HP("player") < 25) then
			if not UnitChannelInfo("player") and _Cast(235313) then
				Squid_Alert("Blazing Barrier",nil,nil,nil,235313)
				return
			end
		end

		--consume hot streak
		if valid_magic(0) and (hot_streak or player_casting_guaranteed_crit and heating_up) then
			if max_cast_time >= gcd + (player_cast_id ~= nil and player_cast_time_left or 0) then
				if _LoS(t) and _distance(t) < gpy_range then
					if ( not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) ) and ( not ring_cast_delay or time - ring_cast_delay > .2 ) then
						if not (pyroclasm_remains >= 5 and UnitBuffID("player", 334277)) or max_cast_time < 4 then
							if _Cast(11366,t,true) then return end
						else
							Squid_Alert_Big("Stand Still","(KILL SHOT)",nil,nil,11366)
						end
					end
				end
			end
		end

		if SQUID.auto_temp then

			local temp_hp = 5
			temp_hp = temp_hp + (enemies_on_player * 10.5)
			temp_hp = temp_hp * (1 + (enemy_cds_on_player * 2))
			temp_hp = temp_hp * (our_healer_cc_remains >= 3 and our_healer_cc_remains * 1.25 or 1)
			
			-- go in
			if player_effective_hp < temp_hp and (not our_healer or our_healer_cc or enemy_cds_on_player >= 1 and barrier_remains <= 1000) and not player_immune then
				if not UnitBuffID("player",110909) then
					if _spellCooldown(108978) == 0 then SpellStopCasting() end
					if _Cast(108978) then
						Squid_Alert_Big("Alter Time",nil,5,nil,110909)
						return
					end
				end
			end

			-- go back 
			-- note: needs to consider enemy mage having klepto when we don't
			if squid_alter then
				local start_hp = squid_alter.start_hp
				local alter_effect = start_hp - player_hp
				if alter_effect >= 50 - bin(can_be_purged)*20 or player_effective_hp <= 5 + bin(enemy_melee_on_player > 0 and _stunDR("player") == 1)*16 + enemies_on_player*7 and alter_effect >= player_effective_hp - 8 then
					if _Cast(127140) then
						Squid_Alert_Big("Alter Return","+" .. alter_effect .. "%",6,3,127140)
						return
					end
				elseif alter_effect < 0 and _buffRemains("player",110909) <= buffer then
					RunMacroText("/cancelaura alter time")
					Squid_Alert_Big("|cFFc31d39Alter Cancelled", nil, nil, nil, 110909)
				end
			end

		end

		--temp shield
		if SQUID.cap_bot then
			local temp_hp = 12
			temp_hp = temp_hp + ( (enemies_on_player * 25) * (not our_healer and 2 or our_healer_cc and 2 or 1) )
			temp_hp = temp_hp + (enemy_cds_on_player * 60)
			temp_hp = temp_hp * (not our_healer and 2.25 or our_healer_cc and 2.25 or 1)

			if auto_temp and player_hp < temp_hp and barrier_remains < 1200 then
				if not UnitBuffID("player",110909) and _Cast(108978) then
					Squid_Alert_Big("Temp Shield",nil,nil,nil,108978)
					return
				end
			end

			if alter_effect and UnitBuffID("player",110909) and (alter_effect > 45 or player_hp < 20) then
				if _Cast(108978) then
					Squid_Alert_Big("Alter Return",alter_effect .. "%",nil,nil,108978)
				end
			end
		end

		--pre blaze or temp doesnt matter
		if gpy_on_player then 
			if not temp_up and _Cast(235313) then
				Squid_Alert_Big("Blazing Barrier","Greater Pyro",nil,nil,235313)
				return
			-- elseif barrier_remains < 35000 and _Cast(198111) then
			-- 	Squid_Alert_Big("Temp Shield","Greater Pyro",nil,nil,198111)
			-- 	return
			end
		end

		--pre blaze or temp doesnt matter
		if big_dmg_inc and (our_healer_cc or not our_healer or rly_big_dmg_inc or _HP("player") < 50) then
			local spell = GetSpellInfo(big_dmg_inc)
			if barrier_remains < 9000 and _Cast(198111) then
				Squid_Alert_Big("Temp Shield",spell,nil,nil,198111)
				return
			elseif not temp_up and _Cast(235313) then
				Squid_Alert_Big("Blazing Barrier",spell,nil,nil,235313)
				return
			end
		end

		--pre blaze or temp doesnt matter
		if _debuffRemains("player",274838) > 5.5 then
			if not temp_up and _Cast(235313) then
				Squid_Alert_Big("Blazing Barrier","Feral Frenzy",nil,nil,235313)
				return
			elseif barrier_remains < 5000 and _Cast(198111) then
				Squid_Alert_Big("Temp Shield","Feral Frenzy",nil,nil,198111)
				return
			end
		end

		--pre blaze cc
		if cc_flying_towards_player then
			local spell = GetSpellInfo(cc_flying_towards_player)
			if barrier_remains < 18000 and _Cast(235313) then
				Squid_Alert_Big("Blazing Barrier",spell,nil,nil,235313)
				return
			end
		end

		--phoenix flames
		if phoenix_flames_enabled and max_cast_time > gcd and (not fb_used or time - fb_used > .25 + buffer) then
			if valid_magic(0) and not hot_streak and not UnitBuffID(t,53480) and (not fb_flying and not pyro_flying and not pf_flying or not heating_up) then
				-- --use to keep stacks from capping
				if phoenix_flames_full_recharge_time <= gcd * 2 + gcd_remains and not heating_up and not player_casting_crittable_damage and lowestEnemy < 85 then
					if phoenix_flames(t) then return end
				end
				--use after fireball casts
				-- if player_cast_id == 133 and not heating_up and (phoenix_flames_charges_frac >= 1.85 or lowestEnemy < 60 or load_mode) and fire_blast_charges_frac >= .85 then
				-- 	if phoenix_flames(t) then return end
				-- end
				--dump during load mode
				if not player_casting_crittable_damage and load_mode and (not heating_up or combustion) and (phoenix_flames_charges_frac >= 1.85 or combustion) then
					if phoenix_flames(t) then return end
				end
			end
		end

		--consume tinder buff with fireball
		if fireball_cast_time < max_cast_time and valid_magic(fireball_cast_time) and tinder_up then
			local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
			if not unsafe_cast and _Cast(133,t,true) then
				return
			end
		end

		--fire blast
		if (not fb_used or time - fb_used > .2 + buffer) and fire_blast_charges >= bin(kyrian_fb_pool)*2 then
			-- print("FB  NO US " .. math.random(1,9999999))
			--valid target, and not hot streaking already (Never FB into RoS)
			if valid_magic(0) and not hot_streak and not UnitBuffID(t,53480) and (not fb_flying and not pyro_flying and not pf_flying or combustion and combustion_remains < 9.85 and not heating_up) then
				--use to protect heating up procs from casts that may non-crit, and from falling off
				if heating_up and load_mode and (player_cast_id == 133 and player_cast_time_left < (buffer*2) or heating_up_remains <= buffer or player_cast_id == 2948 and not player_casting_guaranteed_crit and fire_blast_full_recharge_time < 3 + (load_mode and 6 or 0) ) and (fire_blast_full_recharge_time <= 14 or load_mode) and not player_casting_guaranteed_crit then
					if _Cast(108853,t,true) then
						-- print("used to protect")
						fb_used = time
						SquidFrame = 2
						return
					end
				end
				--use to keep from stacks capping (with heating up, or while casting guaranteed crit / gpy)
				local kyrian_setup = meteor_in_flight and UnitDebuffID(t,307443,"player") and _debuffStacks(t,307454,"player") < 3 + bin(meteor_in_flight_remains < buffer+1)
				if (fire_blast_full_recharge_time < gcd + ( heating_up and heating_up_remains <= buffer and gcd * 1.5 or 0 ) or kyrian_setup) and (heating_up and not player_casting_guaranteed_crit or not heating_up and player_casting_guaranteed_crit or player_cast_id == 203286 or kyrian_setup) then
					if _Cast(108853,t,true) then
						-- print("used to not cap")
						fb_used = time
						SquidFrame = 2
						return
					end
				end
				--dump all charges for hot streak w/ load mode
				if load_mode and ( heating_up and not player_casting_guaranteed_crit or fire_blast_charges_frac >= 1.85 or combustion_remains > max(scorch_cast_time, fire_blast_next_charge_cd) or player_casting_guaranteed_crit and not heating_up ) then
					if _Cast(108853,t,true) then
						-- print("used to dump")
						fb_used = time
						SquidFrame = 2
						return
					end
				end
			end
		end

		--phoenix flames
		if phoenix_flames_enabled and max_cast_time > gcd and (not fb_used or time - fb_used > .25 + buffer) and (combustion or load_mode or phoenix_flames_charges >= 3) then
			if valid_magic(0) and not hot_streak and not UnitBuffID(t,53480) and (not fb_flying and not pyro_flying and not pf_flying or not heating_up) then
				-- --use to keep stacks from capping
				if phoenix_flames_full_recharge_time <= gcd * 2 + gcd_remains and not heating_up and not player_casting_crittable_damage and lowestEnemy < 90 then
					if phoenix_flames(t) then return end
				end
				--use after fireball casts
				-- if player_cast_id == 133 and not heating_up and (phoenix_flames_charges_frac >= 1.85 or lowestEnemy < 60 or load_mode) and fire_blast_charges_frac >= .85 then
				-- 	if phoenix_flames(t) then return end
				-- end
				--dump during load mode
				if not player_casting_crittable_damage and load_mode and (not heating_up or combustion) and (phoenix_flames_charges_frac >= 1.85 or combustion) then
					if phoenix_flames(t) then return end
				end
			end
		end

		--spellsteals
		if not combustion and valid_magic(0) and max_cast_time > gcd and player_mana > 70 then
			local ss = Basic_Spellsteal(t)
			if ss and _Cast(30449,t,nil,true) then
				Squid_Alert("Spellsteal " .. UnitClass(t),"("..GetSpellInfo(ss)..")",nil,nil,30449)
			end
		end
		
		--maintain flames of alacrity with fireball
		-- if flames_of_alacrity_enabled and flames_of_alacrity_count == 3 and enhanced_pyrotechnics_remains < fireball_cast_time * 2.5 and (not fireball_cast_delay or time - fireball_cast_delay > .25) and not fb_flying then
		-- 	if valid_magic(fireball_cast_time) and max_cast_time > fireball_cast_time then
		-- 		-- local unsafe_cast = combustion --player_interruptable and fire_blast_charges >= ((heating_up or fire_blast_next_charge_cd < 1) and 1 or 2)
		-- 		if not combustion and _Cast(133,t,true) then
		-- 			return
		-- 		end
		-- 	end
		-- end

		--scorch execute off targets if main target is higher hp
		if max_cast_time > scorch_cast_time and not (valid_magic(0) and _HP(t) < 30) and not hot_streak and ( not pyro_flying or not hot_streak and fire_blast_charges == 0 and fire_blast_next_charge_cd > scorch_cast_time ) then
			if searing_touch_enabled and not arena and UnitAffectingCombat("player") then
				local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
				if not unsafe_cast then
					for i=1,#Enemies do if not _breakableCC(Enemies[i]) then
						if _HP(Enemies[i]) < 30 and ttd(Enemies[i]) > scorch_cast_time then
							_Cast(2948,Enemies[i],true)
						end
					end end
				end
			end
		end

		--gpy only if followup cc is not needed before a finished cast, or if full lockout on arcane and no ring available or healer out of cc
		if IsPlayerSpell(203286) and valid_magic(greater_pyro_cast_time) and (not load_mode or fire_blast_charges == 0 and not hot_streak and not (_HP(t) < 30 and searing_touch_enabled)) and max_cast_time > greater_pyro_cast_time - buffer - ( player_interruptable and 2.5 or 0 ) then
			if combustion_remains == 0 and t then
				--stop casting dummy scorch after planting (causes issues with scorch totem stomp and not really necessary)
				-- if player_cast_id == 2948 and not_moving_duration > .3 and player_cast_time_left > .45 and (not searing_touch_enabled or _HP(t) > 30) and (not combustion or combustion_remains < player_cast_time_left) then
				-- 	SpellStopCasting()
				-- end
				if not killshot_engaged and _Cast(203286,t,nil,true) then
					return
				end
			end
		end

		--scorch w/ combust or execute
		if valid_magic(scorch_cast_time) and max_cast_time > scorch_cast_time and ( not pyro_flying or not hot_streak and fire_blast_charges == 0 and fire_blast_next_charge_cd > scorch_cast_time ) then
			if combustion_remains > scorch_cast_time or (_HP(t) <= 30 and searing_touch_enabled) then
				local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
				if not unsafe_cast and _Cast(2948,t,true) then
					return
				end
			end
		end

		--firestarter fireballs
		if firestarter_enabled then
			if valid_magic(fireball_cast_time) and fireball_cast_time < max_cast_time and (not combustion or fireball_cast_time < scorch_cast_time and fire_blast_charges == 0) then
				local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
				if not unsafe_cast and _Cast(133,t,true) then
					return
				end
			end
		end

		--rebuff intellect
		local someone_missing_int
		for i=1,#Friends do if not UnitBuffID(Friends[i],1459) and _distance(Friends[i]) < 40 and not UnitCanAttack("player",Friends[i]) and (not combat or not _isMeleeDps(Friends[i])) then
			someone_missing_int = true
		end end
		-- dont rebuff while casting
		if max_cast_time > gcd and someone_missing_int and not UnitCastingInfo("player") and not tanking then 
			if _Cast(1459,"player") then 
				Squid_Alert("Rebuff",nil,nil,nil,1459)
				return
			end
		end

		--conjure food
		if GetItemCount(80610) == 0 and GetItemCount(113509) == 0 and not tanking and get_squid_var("Auto Food") then
			if UnitBuffID("player",32727) and GetNumGroupMembers() > 1 then
				_Cast(190336)
			end
			if Free_Bag_Slots() > 0 and (not food_already_clicked or time - food_already_clicked > 2 or (GetItemCount(80610) >= 20 and GetItemCount(80610) <= 40) or (GetItemCount(113509) >= 20 and GetItemCount(113509) <= 40)) then
				InteractUnit("Refreshment Table")
				InteractUnit("Lavish Refreshment Table")
				food_already_clicked = time
			end
		end

		-- Call Kyrian Steward
		if C_Covenants.GetActiveCovenantID() == covenants["Kyrian"] then
			if GetItemCount(177278) < 3 and not tanking and Free_Bag_Slots() > 0 then
				if UnitBuffID("player", 32727) and GetNumGroupMembers() > 1 then
					_Cast(324739)
				end
			end
		end

		--fireball (only with tinder if playing gpy)
		if fireball_cast_time < max_cast_time and valid_magic(fireball_cast_time) and (not tinder_enabled or tinder_up or firestarter_enabled) and (not combustion or fireball_cast_time < scorch_cast_time and fire_blast_charges == 0) then
			local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
			if not unsafe_cast and _Cast(133,t,true) then
				return
			end
		end

		--dispel dots
		local function low_prio_dispel(unit)
			local agony_stacks = _debuffStacks(unit,980)
			if agony_stacks >= 9 then
				return 980
			end
		end

		if remove_curse_cd <= gcd_remains and max_cast_time > gcd*2 then
			for i=1,#Friends do
				local dispel = low_prio_dispel(Friends[i])
				if dispel and _LoS(Friends[i]) then
					if _Cast(475,Friends[i]) then
						Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
					end
				end
			end
		end

		--scorch fallthrough for movement
		if SQUID.scorch_filler then
			if max_cast_time > scorch_cast_time and valid_magic(scorch_cast_time) and (not combustion or fire_blast_charges == 0) and ( not pyro_flying or not hot_streak and fire_blast_charges == 0 and fire_blast_next_charge_cd > scorch_cast_time ) then
				local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
				if not unsafe_cast and _Cast(2948,t,true) then
					return
				end
			end
		end

	end

	--stop bad fire casts
	if combustion and fire_blast_charges > 1 - ((heating_up or hot_streak or pyro_flying or fb_flying) and 1 or 0) and (player_casting_crittable_damage or player_cast_id == 203286) and player_interruptable then
		SpellStopCasting()
		Squid_Alert("Stop Casting Fire","(Combustion/Interruptable)",nil,nil,nil,190319)
	end

	--burst mode
	if Squid_Burst and (valid_magic(0) or meteor_in_flight and UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and not _immuneMagic(current_target)) then
		--lucid dreams
		if IsPlayerSpell(298357) then
			if _Cast( 298357 ) then
				Squid_Alert( "Memory of Lucid Dreams", nil, nil, nil, 298357 )
				return
			end
		end

		--combust
		if _spellCooldown(190319) <= .5 and (not IsPlayerSpell(298357) or _spellCooldown(298357) > gcd_remains + 2 and gcd_remains <= .2) then--  _spellCooldown(190319) < .2 and _spellCooldown(11366) <= buffer and then
			SQ_CastSpellByID ( 190319 )
			Squid_Alert_Big( "Combustion", nil, nil, nil, 190319 )
		end

		--racials
		local race = UnitRace("player")
		if race == "Orc" then
			SQ_CastSpellByName("Blood Fury")
		end

		--items
		if UnitBuffID("player",313948) then
			RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
			Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
		end

		if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
			Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
		end

		if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
		or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
		or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 ) 
		or ( tContains( equipped_items, 175884 ) and GetItemCD ( ( 175884 ) ) == 0 )
		or ( tContains( equipped_items, 175921 ) and GetItemCD ( ( 175921 ) ) == 0 ) then
			UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
			UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
			UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
			UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
			UseItemByName( tostring( GetItemInfo ( 175921 ) ) )
			Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
		end

		if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
		or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
		or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
			UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
			UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
			UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
			Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
		end

		if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
			Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
		end

		if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
			Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
		end

		if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
			Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
		end

		if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
		or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
			UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
			UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
			Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
		end

		if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
			Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
		end

		if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
			Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
		end

		if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
			Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
		end

	end

	local dispellable ={
	51514,	--hex
	199954,	--curse of frag
	199890,	--curse of tongues
	80240,	--havoc
	51514,	--hex
	211015,	--hex cockroach
	210873,	--hex compy
	211010,	--hex snake
	211004,	--hex spider
	277784,	--hex wicker mongrel
	277778,	--hex zandalari tendonripper
	309328,	--hex living honey
	269352,	--hex skeletal raptor
	};

	local function remove_curse(unit)
		local lessDelay = minDelayTime/1.1;
		if SQUID.max_mindelay > 200 then
			lessDelay = .35
		end
		for i=1,#dispellable do
			local debuff,_,_,five,six,seven,source = UnitDebuffID(unit,dispellable[i]);
			if debuff and seven-time < six-lessDelay then
				return dispellable[i], source;
			end
		end
	end

	--dispel
	if remove_curse_cd <= gcd_remains then
		for i=1,#Friends do
			local dispel,source = remove_curse(Friends[i])
			if dispel and _LoS(Friends[i]) then
				if _Cast(475,Friends[i]) then
					Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
				end
				if (player_casting_crittable_damage or (player_cast_id == 203286 and player_cast_time_left > 1)) and player_cast_time_left > gcd_remains then
					if dispel == 80240 then
						-- check source coil cd is up
						-- if source then
						-- 	source = ObjectPointer(source)
						-- 	if UnitIsVisible(source) and UnitCooldown(source,6789) <= 1 then
						-- 		SpellStopCasting()
						-- 	end
						-- end
						-- check that coil hasn't been used (this will not work well vs double warlock)
						if not enemy_coil or time - enemy_coil >= 42 then
							SpellStopCasting()
						end
					else
						SpellStopCasting()
					end
				end
			end
		end
	end

	-- keep rogu
	local keep_rogue
	for i=1,#Enemies do if select(2,UnitClass(Enemies[i])) == "ROGUE" and _CCremains(Enemies[i]) <= buffer and not UnitAffectingCombat(Enemies[i]) and (not player_cast_id or not unit_is_unit(player_cast_target,Enemies[i])) and not _immuneMagic(Enemies[i]) then
		keep_rogue = Enemies[i]
	end end

	if keep_rogue and UnitIsVisible(keep_rogue) then
		-- flamestrike with hotstreak -- FIXME ADD BREAKABLE CC CHECK
		if hot_streak and ( not _LoS(keep_rogue) or not _isSlowed(keep_rogue) ) and breakable_cc_around(keep_rogue,14) == 0 then
			if _AeCast(2120,keep_rogue,40,8) then
				Squid_Alert("Flamestrike","(Keep Rogue)",4,nil,2120)
				return
			end
		end
		-- keep rogue with fb
		if not hot_streak and (not fb_flying and not pyro_flying and not pf_flying or combustion and combustion_remains < 9.85 and not heating_up) then
			if not fb_used or time - fb_used > .25 + buffer then
				if _Cast(108853,keep_rogue,nil,true) then
					Squid_Alert("Fire Blast","(Keep Rogue)",4,nil,108853)
					fb_used = time
					SquidFrame = 2
					return
				end
			end
		else
		-- keep rogue with pyro
			-- if _Cast(11366,keep_rogue,nil,true) then
			-- 	Squid_Alert("Pyroblast","(Keep Rogue)",4,nil,11366)
			-- 	return
			-- end
		end
	end

	--stop drink
	local drinkbuffs = {
		274914, -- (rockskip mineral water / seafoam coconut water?)
		167152, -- (mage food)
	}

	local stop_drink
	for i=1,#Enemies do if _buffFromTable(Enemies[i],drinkbuffs) then
		stop_drink = Enemies[i]
	end end

	if stop_drink and UnitIsVisible(stop_drink) then
		-- flamestrike with hotstreak -- FIXME ADD BREAKABLE CC CHECK
		if hot_streak and breakable_cc_around(stop_drink,14) == 0 then
			if _AeCast(2120,stop_drink,40,8) then
				Squid_Alert("Flamestrike","(Stop Drink)",4,nil,2120)
				return
			end
		end
		-- keep rogue with fb
		if not hot_streak and (not fb_flying and not pyro_flying and not pf_flying or combustion and combustion_remains < 9.85 and not heating_up) then
			if not fb_used or time - fb_used > .25 + buffer then
				if _Cast(108853,stop_drink,nil,true) then
					Squid_Alert("Fire Blast","(Stop Drink)",4,nil,108853)
					fb_used = time
					SquidFrame = 2
					return
				end
			end
		else
		-- keep rogue with pyro
			if _Cast(11366,stop_drink,nil,true) then
				Squid_Alert("Pyroblast","(Stop Drink)",4,nil,11366)
				return
			end
		end
	end

	local function should_klepto(unit)
			
		if UnitDebuffID(unit,33786) then return false end

		local value = 0

		local stun = _stunRemains(unit)

		--fixme add big value for recent overgrowth
		if unit_is_unit(unit,current_target) then
			value = value + _buffRemains(unit,774)*min(max(stun*1.5,1.8),4.5) -- rejuv duration
			value = value + _buffRemains(unit,155777)*min(max(stun*1.5,1.8),4.5) -- rejuv germination duration
			value = value + (_buffRemains(unit,33763) * (.65 + (_buffStacks(unit,203554) / 4))) -- lifebloom duration * stacks
			--safegaurd
			local buff,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID(unit,286342)
			if buff and absorb > 20000 then
				value = value + 20 + (15 * (absorb / 20000))
			end
			value = value + _buffRemains(unit,198111)*3 -- some value for temp based on duration
			value = value + _buffRemains(unit,305497)*.35 -- half value for thorns duration
			--high value for ghost wolf / es / riptide when stunned
			if stun >= 1 then
				value = value + (UnitBuffID(unit,2645) and _isHealer(unit) and 45 or 0)
				value = value + (UnitBuffID(unit,974) and _isHealer(unit) and 20 or 0)
				value = value + (UnitBuffID(unit,61295) and _isHealer(unit) and 10 or 0)
			elseif _HP(unit) < 30 then
				--es and riptide still have value when they rly low
				value = value + (UnitBuffID(unit,974) and _isHealer(unit) and 15 or 0)
				value = value + (UnitBuffID(unit,61295) and _isHealer(unit) and 10 or 0)
			end
			value = value * (load_mode and 1.35 or 1)
			value = value * (_HP(unit) < 50 and 1.35 or 1)
			value = value * (_stunCheck(unit) and 1.5 or 1)
		end

		-- only if spellsteal has been used in last 30 seconds
		if not unit_has_klepto(unit) then
			value = value + _buffRemains(unit,190319)*11 -- high value for combust
		end

		--big value for bop when being targeted by melee
		value = value + (_buffRemains(unit,1022) > 0 and enemy_melee_on_player > 0 and _buffRemains(unit,1022)*10 or 0)
		
		if _buffUptime(unit,210294) > minDelayTime * 2 or UnitCastingInfo(unit) then
			value = value + (UnitBuffID(unit,210294) and 69 or 0) -- always klept divine favor
		end

		value = value * ( (not theirHealer or their_healer_cc) and 1.5 or 1 )

		return value >= 60

	end

	-- klepto
	if klepto_enabled and not SQUID.dont_klept then
		for i=1,#Enemies do 
			local e = Enemies[i]
			if not _immuneCheck(e) and should_klepto(e) then
				if _Cast(30449,e,nil,true) then
					Squid_Alert_Big("Klepto",UnitClass(e),1,nil,30449)
					return
				end
			end
		end
	end

	--priority cc, and define max cast time here
	local max_cast_time = 69
	if auto_cc then
		max_cast_time = healer_cc()

		--is the next cc for the healer?
		next_cc_is_healer = max_cast_time ~= 69

		if max_cast_time > poly_cast_time * 2 then
			max_cast_time = min ( max_cast_time, off_cc() )
		end
	end

	-- if max_cast_time < 69 then max_cast_time = max_cast_time - buffer end
	if max_cast_time < 0 then max_cast_time = 0 end

	-- print(max_cast_time)

	--stop moving!
	-- if not _isMoving("player") and not UnitCastingInfo("player") and #movement_lock_commands == 0 then
	-- 	SetMovementLocked(false)
	-- end
	if mage_stop_moving and move_setting and not _silenceCheck("player") then
		StopMovingAndLock()
		C_Timer.After(.15 + buffer,function() if not player_cast_id then SetMovementLocked(false) else unlock_after = player_cast_time_left end end)
	end

	if mage_stop_moving then
		if not UnitIsVisible(mage_stop_moving.unit) then
			SetMovementLocked(false)
			mage_stop_moving = nil
		elseif _distance(mage_stop_moving.unit) > mage_stop_moving.dist then
			SetMovementLocked(false)
			mage_stop_moving = nil
		end
	end

	if not arena and IsMovementLocked() then
		SetMovementLocked(false)
	end

	if unlock_after and unlock_after > 0 then
		C_Timer.After(unlock_after, function() SetMovementLocked(false) end)
		unlock_after = nil
	end

	--still use gcds and scorch while moving
	if _isMoving("player") then max_cast_time = gcd+.5 end

	if cc_healer_key then
		if UnitExists(theirHealer) then
			cc(theirHealer,true)
			return
		else
			Squid_Alert("|cFFc31d39No Healers Found",nil,nil,nil,sheep)
		end
	end
	if cc_focus_key then
		if UnitExists(current_focus) then
			cc(current_focus,true)
			return
		else
			Squid_Alert("|cFFc31d39No Focus Target",nil,nil,nil,sheep)
		end
	end
	if cc_offtarget_key then
		if UnitExists(off_target) then
			cc(off_target,true)
			return
		else
			Squid_Alert("|cFFc31d39No off target found",nil,nil,nil,sheep)
		end
	end

	--nova healer out of game
	if not poly_cast_delay or time - poly_cast_delay > .1 or not unit_is_unit(their_healer,poly_cast_target) then
		if not bcc12 and their_healer and valid_magic(69) then
			if not unit_is_unit(their_healer,t) and _realDistance(their_healer) < 11 and _LoS(their_healer) and not _CCcheck(their_healer) and (_distance(their_healer,t) > 42 or not _LoS(their_healer,t)) then
				if _Cast(122) then
					Squid_Alert_Big("Frost Nova Healer","(Bad Position)",4,3.5,122)
					return
				end
			end
		end
	end

	--nova subterfuge
	if not bcc12 then
		for i=1,#Enemies do 
			if UnitBuffID(Enemies[i],115192) and not _immuneMagic(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) and _LoS(Enemies[i]) then
				if _realDistance(Enemies[i]) < 11.15 then
					if _Cast(122) then
						Squid_Alert_Big("Frost Nova","(Subterfuge)",nil,3.5,122)
					end
				end
			end 
		end
	end

	--nova melee
	if not combustion and not bcc12 then
		local p_slowed = _isSlowed("player")
		for i=1,#Enemies do
			local e = Enemies[i]
			if _isMeleeDps(e) and not _immuneMagic(e) and (select(2,UnitClass(e)) ~= "DRUID" or lowestFriend < 45) and not _slowImmuneCheck(e) then
				local d = _realDistance(e)
				if lowestFriend < 50 + ((not our_healer or our_healer_cc) and 30 or 0) + (_CDcheck(e) and 30 or 0) - (UnitEnemiesAttacking(e) * 40) - (unit_is_unit(e,current_target) and _amIfacing(e) and 40 or 0) then
					if d < 11 and _LoS(e) and (d > 8 or d > 2 and moving_away_from(e,max(7-d-(p_slowed and 1.5 or 0),2))) and (_isMoving("player") or _isMoving(e)) then
						if _Cast(122) then
							Squid_Alert_Big("Frost Nova","(Melee, Kiting)",nil,3.5,122)
						end
					end
				end
			end 
		end
	end

	object_first_detected = object_first_detected or {}
	auto_totem_target = auto_totem_target or {}

	for k,v in pairs(object_first_detected) do
		if time - v > 5 then
			object_first_detected[k] = nil
		end
	end 

	--totem stomp
	local function Stomp(totem,name)
		local hp = UnitHealth(totem)
		local maxhp = UnitHealthMax(totem)
		if hp <= 1 then return false; end
		if not object_first_detected[totem] then
			object_first_detected[totem] = time
		else
			if time - object_first_detected[totem] > max(.35,minDelayTime*2) or player_cast_id and player_cast_time_left < .165 + latency or SQUID.max_mindelay < 50 then
				if _LoS(totem) and _distance(totem) < 40 and fire_lockout == 0 then
					--Fire Blast
					if hp <= 17000 and (not fb_used or time-fb_used > .18) then
						if not auto_totem_target[name] or time - auto_totem_target[name] > 1 then
							TargetUnit(totem)
							auto_totem_target[name] = time
						end
						if _Cast(108853,totem,nil,true) then
							Squid_Alert_Big("Stomp " .. name,"(Fire Blast)",4,nil,108853)
							fb_used=time
							SquidFrame = 2
							return
						end
					end

					--Pyroblast
					if hot_streak then
						if not auto_totem_target[name] or time - auto_totem_target[name] > 1 then
							TargetUnit(totem)
							auto_totem_target[name] = time
						end
						if _Cast(11366,totem,nil,true) then
							Squid_Alert_Big("Stomp " .. name,"(Pyroblast)",4,nil,11366)
							return
						end
					end
					-- if _isMoving("player") then
						if _Cast(2948,totem,true) then
							if not auto_totem_target[name] or time - auto_totem_target[name] > 1 then
								TargetUnit(totem)
								auto_totem_target[name] = time
							end
							Squid_Alert_Big("Stomp " .. name,"(Scorch)",4,nil,2948)
							return
						end
					-- else
					-- 	if _Cast(133,totem,true) then
					-- 		Squid_Alert_Big("Stomp " .. name,"(Fireball)",4,nil,133)
					-- 		return
					-- 	end
					-- end
				end
			end
		end
	end

	local totems = {
	101398,	--Psyfiend
	119052,	--War Banner
	104818,	--Ancestral Protection Totem
	53006,	--Spirit Link Totem
	-- 2630,	--Earthbind Totem
	-- 60561,	--Earthgrab Totem
	-- 61245,	--Capacitor Totem 
	5925,	--Grounding Totem
	-- 105425,	--Skyfury Totem
	105427,	--Skyfury Totem
	-- 5913,	--Tremor Totem
	105451,	--Counterstrike Totem
	6112,	--Windfury Totem
	}

	local function target_last_non_totem_target()
		if last_non_totem_target and UnitIsVisible(last_non_totem_target) then
			TargetUnit(last_non_totem_target)
		end
	end

	local target_id = ObjectID(t)
	if tContains(totems,target_id) then
		if UnitHealth(t) <= 1 then
			if not totem_tlt_queued then
				C_Timer.After((max(.25,minDelayTime*1.5)),function() target_last_non_totem_target() totem_tlt_queued = nil end)
				totem_tlt_queued = true
			end
		end
	else
		if t and target_id ~= 61245 then
			last_non_totem_target = t
		end
	end

	-- if arena then
		for i=1,#Pets do
			local e = Pets[i]
			local name = UnitName(e);
			local id = ObjectID(e)
			--only kill cap totems when they're casting
			if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e) and _castTimeLeft(e) < latency + 1.15) or (name == "Twisted Appendage" and lowestFriend < 75 + (not our_healer and 25 or our_healer_cc and 25 or 0) and lowestEnemy > 15) then
				Stomp(e,name)
			end
			--root abomination
			if id == 149555 and _rootDR(e) >= .5 and _CCremains(e) + _rootRemains(e) < gcd and _distance(e) < 8 and not bcc12 and _LoS(e) then
				if _Cast(122) then
					Squid_Alert("Nova","Abomination",nil,nil,122)
					return
				end
			end
		end
	-- end

	--Prio Spellsteal
	if player_mana > 22 then
		for i=1,#Enemies do
			local ss = Prio_Spellsteal(Enemies[i]) 
			if ss and valid_magic(0,Enemies[i]) and _Cast(30449,Enemies[i],nil,true) then
				Squid_Alert("Spellsteal " .. UnitClass(Enemies[i]),"("..GetSpellInfo(ss)..")",nil,nil,30449)
				return true
			end
		end
	end

	-- ? ? ? ? 
	-- if auto_cc then

	-- 	local off_target
	-- 	for i=1,#Enemies do if not unit_is_unit(current_target,Enemies[i]) and _distance(Enemies[i]) < 40 and not UnitIsDead(Enemies[i]) then
	-- 		off_target=Enemies[i]
	-- 		break
	-- 	end end

	-- 	if off_target then
	-- 		cc(off_target)
	-- 	end

	-- end

	-- print(mage_next_cc_target,mage_next_cc,mage_next_cc_dr,mage_next_cc_time)

	-- print(max_cast_time)

	priority_shit(max_cast_time)

	if not utilities_only then
		standard_rotation(max_cast_time)
	end

endfunction Squid_FrostMagePvP()

	-- FLOW --


	--		Queue      --

	-- 		Work in Progress / Up Next    --

	

	-- 		Added Recently  --

	local time = GetTime()
	local latency = squid_avg_latency
	local groupsize = GetNumGroupMembers()
	local msperframe = 2/GetFramerate()
	local buffer = latency + msperframe + .1
	local haste = UnitSpellHaste("player")
	local gcd = 1.5/(1+(haste/100))
	local gcd_remains = GetGCD()
	local combat = UnitAffectingCombat("player")
	local player_hp = _HP("player")
	local player_immune = _immuneCheck("player",nil,true)
	local corruption = GetNetCorruption()

	-- barrier pre gate
	if UnitBuffID("player",32727) and arena_start_timer and arena_start_timer < 20 then
		if _Cast(11426) then
			Squid_Alert("Ice Barrier",nil,nil,nil,11426)
			return
		end
	end

	local auto_temp = SQUID.auto_temp

	local GetItemInfo_OG = GetItemInfo
	local GetItemInfo = function ( itemid ) local info = GetItemInfo_OG( itemid ) or ""; return info end

	--Auto Targeting
	local function dynamicTargeting(range)
		--Target enemies above 75% or below 35% preferably
		local bestUnit = bestUnit or nil
		if bestUnit == nil then
			if #Enemies > 0 then
				for i = 1, #Enemies do
					local thisUnit = Enemies[i]
					if _distance('player', thisUnit) <= range and _LoS('player', Enemies[i]) and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
						bestUnit = thisUnit
					end
				end
			end
		end
		if not UnitExists("target") and UnitAffectingCombat('player') then
			TargetUnit(bestUnit)
		end
	end
	local auto_target = SQUID.auto_target
	if auto_target then
		dynamicTargeting(40)
	end

	local utilities_only = SQUID.utilities_only

	--equipped items
	local equipped_items = {}

	local trinkets = {
	174103,	--Manifesto of Madness
	167380,	--Notorious Gladiator's Badge
	172669,	--Corrupted Gladiator's Badge
	165058,	--Sinister Gladiator's Badge
	172666,	--Corrupted Gladiator's Medallion
	167377,	--Notorious Gladiator's Medallion
	165055,	--Sinister Gladiator's Medallion
	159615,	--Ignition Mage's Fuse
	161411,	--Tzane's Barkspines
	161377,	--Azurethos' Singed Plumage
	166793,	--Ancient Knot of Wisdom (HORDE) (278267 SPELLID)
	161417,	--Ancient Knot of Wisdom (ALLIANCE) (278267 SPELLID)
	169318,	--Shockbiter's Fang
	168973,	--Neural Synapse Enhancer
	159630,	--Balefire Branch
	}

	for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end

	local extra_items = {
	159624,	--Rotcrusted Voodoo Doll
	169305,	--Aquipotent Nautilus
	168905,	--Shiver Venom Relic
	173944,	--Forbidden Obsidian Claw
	167677,	--Harmonic Dematerializer
	167835,	--Malformed Herald's Legwraps
	168989,	--Hyperthread Wristwraps (300142 SPELLID)
	167672,	--Cyclotronic Blast (293491 SPELLID)
	165576,	--Tidestorm Codex (289885 SPELLID)
	}

	for i=1,#extra_items do if IsEquippedItem ( extra_items[i] ) then table.insert( equipped_items, extra_items[i] ) end end

	local auto_cc = SQUID.auto_cc
	local only_cc_healers = SQUID.only_cc_healers

	local icicles = _buffStacks("player",205473)

	local pet
	local pet_hp = 100
	local pet_cast_id,pet_cast_target
	local pet_exists = UnitIsVisible("pet")
	if pet_exists then
		pet = ObjectPointer("pet")
		pet_hp = _HP(pet)
		pet_status = squid_pet_status
		pet_cast_id,_,pet_cast_target = UnitCastID(pet)
	end
	local pet_position = {ObjectPosition("pet")}

	if pet_cast_id == 0 then pet_cast_id = nil pet_cast_target = nil end

	local frost_lockout = _spellCooldown(116) > gcd_remains and _spellCooldown(116) or 0
	local arcane_lockout = _spellCooldown(118) > gcd_remains and _spellCooldown(118) or 0
	local ring_cd = _spellCooldown(113724)
	local comet_cd = _spellCooldown(153595)
	local ice_nova_cd = _spellCooldown(157997)
	local remove_curse_cd = _spellCooldown(475)
	local veins_cd = _spellCooldown(12472)
	local blink_cd = _spellCooldown(212653)
	local ray_of_frost_cd = _spellCooldown(205021)
	local coc_cd = _spellCooldown(120)
	local freeze_cd = pet_exists and _spellCooldown(33395) or 99
	local orb_cd = _spellCooldown(198149)

	local fof_remains = _buffRemains("player",44544)
	local fof_stacks = fof_remains > 0 and _buffStacks("player",44544) or 0
	local fof = fof_stacks > 0
	local brain_freeze_remains = _buffRemains("player",190446)
	local brain_freeze = brain_freeze_remains > 0
	local temp_up = UnitBuffID("player",198111)
	local rune_of_power_up = UnitBuffID("player",116014)

	local ice_lance_effect_raw = GetSpellEffect(30455)
	local ice_lance_effect = ice_lance_effect_raw * (fof and 3 or 1)

	local freezing_rain = UnitBuffID("player",270232)
	local ice_nova_enabled = IsPlayerSpell(157997)
	local lonely_winter_enabled = IsPlayerSpell(205024)
	local ebonbolt_enabled = IsPlayerSpell(257537)
	local spike_enabled = IsPlayerSpell(199786)
	local ring_enabled = IsPlayerSpell(113724)
	local comet_enabled = IsPlayerSpell(153595)
	local ebonbolt_enabled = IsPlayerSpell(257537)
	local veins_remains = _buffRemains("player",12472)
	local veins = veins_remains > 0

	local klepto_enabled = IsPlayerSpell(198100)

	local spike_range = 40

	local sheep_range = 30

	local ring_range = 30

	local frostbolt_cast_time = _castTime(116)
	local ebonbolt_cast_time = _castTime(257537)
	local poly_cast_time = _castTime(118)
	local ring_cast_time = _castTime(113724)
	local spike_cast_time = _castTime(199786)
	local fireball_cast_time = _castTime(133)
	local scorch_cast_time = _castTime(2948)
	local rune_of_power_cast_time = _castTime(116011)

	local comet_in_flight = comet_cd > 27
	local comet_in_flight_remains = (3 - ( 30 - comet_cd )) - buffer

	local orb_out = orb_cd > 50

	local enemies_on_player,enemy_melee_on_player,enemy_ranged_on_player,enemy_cds_on_player = EnemiesAttacking("player")

	local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
	local player_cast_target = UnitSpellTarget("player")
	local player_cast_time_left = _castTimeLeft("player")
	local player_cast_percent_complete = _castPctDone("player")
	local player_interruptable = PlayerCanBeKicked()

	if player_cast_id == 118 then
		poly_cast_delay = time
		poly_cast_target = player_cast_target
	end

	if player_cast_id == 113724 then
		ring_cast_delay = time
	end

	--gui setting, disable movement stop for cc
	local move_setting = SQUID.stop_to_cc

	local cc_casts = {118,113724}
	local player_casting_non_cc = player_cast and not tContains(cc_casts,player_cast_id)
	local player_casting_cc = player_cast and tContains(cc_casts,player_cast_id)

	local shatter_casts = {116,257537,199786}
	local player_casting_shatterable_damage = player_cast and tContains(shatter_casts,player_cast_id)
	local player_casting_guaranteed_shatter = player_cast and tContains(shatter_casts,player_cast_id) -- and ??? fixme

	--ice barrier absorb
	local ice_barrier_up,_,_,_,_,_,_,_,_,_,_,_,_,_,_,ice_barrier_absorb = UnitBuffID("player",11426)
	local barrier_remains = ice_barrier_up and ice_barrier_absorb or 0

	local sheeped_target
	local sheeped_target_duration = 0
	for i=1,#Enemies do
		local remains = _debuffRemains(Enemies[i],118,"player")
		-- if _debuffRemains(Enemies[i],82691,"player") > remains then remains = _debuffRemains(Enemies[i],82691,"player") end
		if remains > 0 then
			sheeped_target = Enemies[i]
			sheeped_target_duration = remains
		end
	end

	local their_healer = theirHealer
	local their_healer_cc
	local their_healer_cc_remains = 0
	local their_healer_incapacitate_dr
	local their_healer_incapacitate_dr_remains = 0
	local their_healer_disorient_dr
	local their_healer_disorient_dr_remains = 0
	local their_healer_important_lockout
	if their_healer then
		if not UnitIsDeadOrGhost(their_healer) then
			their_healer_cc_remains = _CCremains(their_healer)
			their_healer_cc = their_healer_cc_remains > 0
			their_healer_incapacitate_dr = _incapacitateDR(their_healer)
			their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
			their_healer_disorient_dr = _disorientDR(their_healer)
			their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

			local class = select(2,UnitClass(their_healer))

			local locked,remaining,school = UnitIsLocked(their_healer)

			if locked and remaining > .25 then
				if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
				or ( class == "SHAMAN" and school == "Nature" )
				or ( class == "PALADIN" and school == "Holy" )
				or ( class == "MONK" and school == "Nature" )
				or ( class == "DRUID" and school == "Nature" )  then
					their_healer_important_lockout = true
				end
			end
		else -- no healer if he dead
			their_healer = nil
		end
	end

	if not their_healer then
		their_healer_cc = true
		their_healer_cc_remains = 100 - (lowestEnemy*1.5)
		their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
		their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
	end

	local friendly_rogue
	for i=1,#Friends do if select(2,UnitClass(Friends[i])) == "ROGUE" then
		friendly_rogue = Friends[i]
	end end

	local friendly_rogue_blind_cd
	if friendly_rogue then
		friendly_rogue_blind_cd = UnitCooldown(friendly_rogue,2094)
	end

	local our_healer
	local our_healer_cc
	if ourHealer then
		our_healer = ourHealer
		if _CCcheck(ourHealer) then our_healer_cc = true end
	end

	-- enemy players count
	local enemy_players = 0
	for i=1,#Enemies do if unit_is_player(Enemies[i]) then
		enemy_players = enemy_players + 1
	end end

	-- team clone cast count
	local team_clone_cast = {}
	for i=1,#Friends do if UnitCastingInfo(Friends[i]) == "Cyclone" then
		local ut = UnitSpellTarget(Friends[i])
		if ut then
			team_clone_cast[ut] = true
		end
	end end

	local not_moving_duration = 0 

	if _isMoving("player") then
		not_moving_duration = 0
		last_move = time
	else
		if not last_move then last_move = time end
		not_moving_duration = time - last_move
	end

	local function comet_storm(unit)
		if comet_cd > gcd then return false end
		if breakable_cc_around(unit,8.5) then return false end
		-- if player_casting_shatterable_damage and comet_cd == 0 and player_cast_time_left > .5 then SpellStopCasting() end
		if _Cast(153595,unit) then
			return true
		end
	end

	local function ice_nova(unit)
		if ice_nova_cd > gcd then return false end
		if breakable_cc_around(unit,8.25) then return false end
		if _Cast(157997,unit) then
			return true
		end
	end

	local function pet_freeze(unit)
		if freeze_cd > 0 then return false end
		if not pet_exists then return false end
		if not _immuneMagic(unit) and not _rootImmuneCheck(unit) and _rootDR(unit) > .25 then
			local x,y,z = ObjectPosition(unit)
			local px,py,pz = unpack(pet_position)
			local freeze_x,freeze_y,freeze_z
			if GetDistanceBetweenPositions(x,y,z,px,py,pz) < 49 then
				local step = (math.pi*2) / 8
				for dist=.5, 4, .5 do
					if freeze_x and freeze_y and freeze_z then break end
					for i=0, math.pi*2, step do
						local fx, fy, fz = GroundZ (x + dist * math.cos(i), y + dist * math.sin(i), z)
						if fx and fy and fz and not TraceLine(fx, fy, fz+1.7, px, py, pz+1.7, 0x100111) and not TraceLine(fx, fy, fz+1.7, x, y, z+1.7, 0x100111) and GetDistanceBetweenPositions(fx,fy,fz,px,py,pz) < 45 then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
							freeze_x, freeze_y, freeze_z = fx, fy, fz
							break
						end
					end
				end
			end
			if freeze_x and freeze_y and freeze_z then
				CastSpellByID(33395)
				ClickPosition(freeze_x,freeze_y,freeze_z)
				_targetLastTarget()
				return true
			end
		end
	end

	local function frozen_orb(unit)
		if orb_cd > gcd then return false end
		if breakable_cc_around(unit,12) then return false end
		if _aeCastInMovingDirection(198149,unit,GetUnitSpeed(unit)/3,40,3) then return true end
	end

	local function cone_of_cold(unit)
		if coc_cd > gcd then return false end
		if bcc_facing(unit,10,45) then return false end
		if UnitIsFacing("player",unit,45) and _distance(unit) < 8 then
			if _Cast(120) then return true end
		end
	end

	local function unit_freeze_remains(unit)
										--petfreeze				--flurry                      --nova               --glacial spike
		return max( _debuffRemains(unit,33395), _debuffRemains(unit,228358), _debuffRemains(unit,122), _debuffRemains(unit,228600) )

	end

	local function unit_frozen(unit)

		return unit_freeze_remains(unit) > buffer + .1
	
	end

	local t = current_target

	local m_i_r = t and magic_immunity_remains(t,true) or 0

	local target_dist = _distance(t)

	local function valid_magic(after,unit)

		if not unit then unit = t end
		if not unit then return false end
		if not UnitIsVisible(unit) then return false end

		if UnitIsDeadOrGhost(unit) then return false end
			
		if arena and not unit_is_player(unit) then return false end

		if not arena and not UnitAffectingCombat(unit) and not _isDummy(unit) and not unit_is_player(unit) then return false end

		if UnitCanAttack("player",unit)
		and (not _breakableCC(unit) or not arena and not unit_is_player(unit))
		and (unit == t and m_i_r <= after or magic_immunity_remains(unit,true) <= after) then
			return true
		end

	end

	--Keybindz
	if freeze_healer then
		if their_healer then
			if pet_freeze(their_healer) then
				Squid_Alert("Pet Freeze","(Healer)",nil,nil,33395)
				return 
			end
		else
			local str = "|cFFa665cdHealer Not Found!"
			Squid_Alert(str,"(Freeze)",nil,nil,33395)
		end
	end

	if freeze_focus then
		if current_focus then
			if pet_freeze(current_focus) then
				Squid_Alert("Pet Freeze","(Focus)",nil,nil,33395)
				return 
			end
		else
			local str = "|cFFa665cdFocus Not Found!"
			Squid_Alert(str,"(Freeze)",nil,nil,33395)
		end
	end

	if freeze_target then
		if current_target then
			if pet_freeze(current_target) then
				Squid_Alert("Pet Freeze","(Target)",nil,nil,33395)
				return 
			end
		else
			local str = "|cFFa665cdTarget Not Found!"
			Squid_Alert(str,"(Freeze)",nil,nil,33395)
		end
	end

	if meteor_key then
		if valid_magic(0) then
			frozen_orb(current_target)
		end
	end

	mage_next_cc_target = nil
	mage_next_cc_nooverride = nil
	mage_next_cc = nil
	mage_next_cc_dr = nil
	mage_next_cc_time = nil

	if _silenceCheck("player") then return end

	local bcc12 = _bccAM(12)

	local ttd = squid_ttd

	--nova stealth
	if not bcc12 then
		for i=1,#Enemies do if _stealthCheck(Enemies[i]) and _distance(Enemies[i]) < 8 then
			if _Cast(122) then
				Squid_Alert_Big("Nova " .. UnitClass(Enemies[i]),"(Stealth)",1,nil,122)
			end
		end end
	end

	--nova thing from beyond
	if not bcc12 and (not legendary_cloaked or time - legendary_cloaked > 4.5) and UnitDebuffID("player",319695) then
		for i=1,#things_from_beyond do
			local thing = things_from_beyond[i]
			if _realDistance(thing) < 11.25 then
				if _Cast(122) then
					Squid_Alert_Big("Frost Nova","(Thing From Beyond)",4,nil,122)
				end
			end
		end
	end

	local mage_stop_moving = false

	if IsMounted() or IsFlying() or UnitBuffID("player",66) or UnitBuffID("player",32612) or UnitBuffID("player",45438) or UnitBuffID("player",110960) or not player_has_control() then return end --32612

	local thp = _HP(t)

	--magic defensive remains
	local MDR = valid_magic(0) and magic_defensive_remains(t) or 0

	local active_enemies = t and Enemies_Around_Unit(t,10) + 1 or 0

	local current_cast = UnitCastingInfo("player")

	--engage load mode when the enemy team is locked down
	local load_mode = valid_magic(0) and ( ( their_healer and ( their_healer_cc_remains >= 1.5 or their_healer_important_lockout ) ) or veins_remains > 0 or orb_out or _stunRemains(t) > 0 or _HP(t) < 30 * ((their_healer or not arena) and 1 or 2.3) or unit_is_unit(their_healer,t) and _HP(t) < 60 + ( ( _stunCheck(t) or _drRemains(t,"stun") > 14 ) and 35 or 0 ) )

	--engage load mode when burst mode is forced
	if Squid_Burst then load_mode = true end

	local load_target = valid_magic(0) and ( _stunCheck(t) or _HP(t) < 30 * ( their_healer_cc and 2 or 1 ) )

	--disable load mode when the enemy trades a defensive, unless already stunned or combusting
	if load_mode and _stunRemains(t) == 0 and combustion_remains == 0 then
		
		--not wasting this precious load on your magic defenses
		if MDR > 0 then
			load_mode = nil
		end

	end

	load_mode_active = load_mode

	local fcast_hp = 15
	fcast_hp = fcast_hp + (our_healer_cc and 25 or 0)

	if _spellCooldown(45438) > 6 then fcast_hp = 0 end

	if not our_healer then fcast_hp = 5 end

	local dont_cast_frost = player_interruptable and player_hp < fcast_hp

	-- comet_target (target comet storm was recently used on)

	local function cc(unit)

		local player_forced

		if cc_focus_key and unit_is_unit(unit,current_focus) then player_forced = true end
		if cc_offtarget_key or cc_healer_key then player_forced = true end

		if not arena and not unit_is_player(unit) and not player_forced then return 69 end

		--stop if no unit
		if not unit or not UnitIsVisible(unit) then return 69 end

		--do not sheep? (ext. func)
		if DoNotSheep(unit) then return 69 end

		--dist to unit
		local dist = _distance(unit)

		local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit) )

		--this function should not only cc, but also return the time until cc needs to happen
		--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
		local time_to_cc = 0

		--check cc
		local ccr = _CCremains(unit)
		local cc = ccr > 0 
		
		--incap drs
		local idr = _incapacitateDR(unit)
		local idr_remains = _drRemains(unit,"incapacitate")

		--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
		local immune_sheep = _isBeast(unit) or _isDummy(unit) or UnitBuffID(unit, 197625)

		--meteor?
		local standing_in_meteor = UnitDebuffID(unit,155158)

		--yea dont cc into it
		if standing_in_meteor then return 69 end
		
		--orb?
		local standing_in_orb = UnitDebuffID(unit,289308)

		--nope
		if standing_in_orb then return 69 end

		--banner?
		local banner = UnitBuffID(unit,236321)

		--yea dont cc into it...unless
		if banner then return 69 end

		--incap on unit?
		local incap = _incapacitateCheck(unit)

		--healer?
		local is_healer = _isHealer(unit) 

		--lockout?
		local lockout = IsLocked(unit,true)

		--los?
		local los = _LoS(unit)

		--druid?
		local is_druid = select(2,UnitClass(unit)) == "DRUID"

		--charmed friend?
		local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

		if friendly then return 69 end

		--ring to followup cc, if the unit is a beast, or we are locked on sheep
		local time_til_ring_ready = 69
		if immunity_remains < ring_cast_time and (not ring_cast_delay or time - ring_cast_delay > .25) and (not poly_cast_delay or time - poly_cast_delay > .25 or arcane_lockout > 0) and (not UnitDebuffID(unit,33786) or (_debuffRemains(unit,33786) < ring_cast_time and _debuffRemains(33786) > ring_cast_time-(buffer*1.5))) then
			if idr >= .5 or lowestEnemy < 35 and idr >= .25 then
				if arcane_lockout > 0 or immune_sheep or ccr > ring_cast_time - buffer or (sheeped_target and not unit_is_unit(unit,sheeped_target)) then
					local poly_cast_time_extra = poly_cast_time + buffer
					local max_overlap = ring_cast_time + (buffer*2.65) + (player_interruptable and idr >= .5 and poly_cast_time_extra or 0) --arcane_lockout < ring_cast_time and
					local ring_ready = ring_enabled and ring_cd <= gcd and ccr > ring_cast_time-buffer and ccr <= max_overlap and (idr == 1 or (not los or arcane_lockout > gcd_remains or player_interruptable) and idr >= .5)

					if ring_ready and dist < ring_range then
						--alert when moving, stop casting scorch when not
						local can_ring = ring_of_frost(unit)
						if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Ring)",nil,nil,113724)
						elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
						mage_stop_moving = can_ring
						time_to_cc = 0
						if not mage_next_cc then
							mage_next_cc = 113724
						end
						mage_next_cc_time = 0
					end

					time_til_ring_ready = ccr > ring_cast_time + buffer and math.max(ring_cd,ccr,idr == 1 and 0 or idr == .5 and arcane_lockout > gcd_remains and 0 or idr_remains) or 69
				end
			end
		end

		--sheep, if drs are available, and the unit is not immune
		local time_til_poly_ready = 69
		local max_overlap = poly_cast_time + (buffer*2.55) + (player_interruptable and idr >= .5 and ( ring_cd <= gcd or SQUID.auto_juke ) and ring_cast_time + buffer + ( SQUID.auto_juke and buffer or 0 ) or 0) -- + (idr >= .5 and ring_cd < gcd and ccr > ring_cast_time and ring_cast_time or 0)
		if los and (not ring_cast_delay or time - ring_cast_delay > .3 or ring_cd > gcd_remains) and (not poly_cast_delay or time - poly_cast_delay > .15) then --no sheep into lockout, unless they're casting another school
			if not immune_sheep and (lockout <= poly_cast_time + (buffer*2.5) + (player_interruptable and poly_cast_time or 0) or UnitCastingInfo(unit)) then
				
				local sheep_dr_ready = idr == 1 or (idr >= .25 and idr_remains > 17.25 - (ccr >= poly_cast_time and 8 * idr or 0) - (incap and ccr >= poly_cast_time-.2 and 6 * idr or 0) - ((100-lowestEnemy) * .038) + (idr == .25 and 1 or 0) ) or ( idr_remains < poly_cast_time-(buffer/2) and ( idr_remains ~= 0 or idr == 1 ) )
				
				-- print(sheep_dr_ready, idr, idr_remains)
				-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
				local no_sheeps_out = not sheeped_target or unit_is_unit(unit,sheeped_target) or _incapacitateDR(sheeped_target) < .25 or (is_healer and idr == 1) or (not _isHealer(sheeped_target) and _incapacitateDR(sheeped_target) <= .5 and _drRemains(sheeped_target,"incapacitate") > 3 and _drRemains(sheeped_target,"incapacitate") < 16.5)
				if sheep_dr_ready and no_sheeps_out then
					
					if ccr < max_overlap and dist < sheep_range then
						if arcane_lockout <= buffer then
							if immunity_remains <= poly_cast_time+(buffer*.45) then
								--alert when moving, stop casting scorch when not
								if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Sheep)",nil,nil,118) mage_stop_moving = true
								elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
								mage_stop_moving = true
								if (not poly_cast_delay or time-poly_cast_delay > .2) and _Cast(118,unit) then
									Squid_Alert("Sheeping",UnitClass(unit),nil,3,118)
								end
								time_to_cc = 0
								if not mage_next_cc then
									mage_next_cc = 118
								end
								mage_next_cc_time = 0
							end
						else
							time_to_cc = math.max(arcane_lockout,time_to_cc)
						end
					else
						time_to_cc = math.max(ccr,time_to_cc)
					end

					local immune_val = 0
					if immunity_remains > 0 then
						immune_val = max ( immunity_remains - poly_cast_time - (buffer * .45), 0 )
					end

					time_til_poly_ready = math.max(ccr-max_overlap,idr_remains < 17 and idr_remains or 0,arcane_lockout,immune_val)

					if immune_sheep and not is_healer then time_til_poly_ready = 69 end

				end
			end
		end

		local val = math.min(time_til_ring_ready,time_til_poly_ready)

		--next cc unit used for drawings
		mage_next_cc_target = unit
			
		--default to sheep if no other cc defined above
		if not mage_next_cc then mage_next_cc = 118 end

		--display dr
		if mage_next_cc == 118 or mage_next_cc == 113724 then
			mage_next_cc_dr = idr
			mage_next_cc_time = val >= 69 and idr_remains or val
		end

		return val
		
	end

	--designate highest prio to cc on healer (returning 69 will fall back to off dps cc)
	local function healer_cc()
		
		local healers = {}

		for i=1,#Enemies do if _isHealer(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) then
			local unit = Enemies[i]
			if _distance(unit) < sheep_range then
				local friends_attacking = UnitEnemiesAttacking(unit)
				local unit_hp = _HP(unit)
				if friends_attacking == 0 then 
					table.insert(healers,unit)
				end
			end
		end end

		local soonest = 69
		for i=1,#healers do
			local val = cc(healers[i])

			if val < soonest then
				soonest = val
			end

		end

		return soonest

	end

	--cc off dps while waiting for dr on healer, or to secure cc on healer while they have interrupts available
	local function off_cc()

		if only_cc_healers then return 69 end

		local units = {}

		for i=1,#Enemies do
			local e = Enemies[i]
			if unit_is_player(e) then--or (UnitIsHunterPet(e) and combustion_cd <= 2) then
				if not unit_is_unit(e,current_target) and _distance(e) < sheep_range and _LoS(e) then
					local friends_attacking = UnitEnemiesAttacking(e)
					local unit_hp = _HP(e)
					if friends_attacking == 0 then
						local min_hp = 70
						min_hp = min_hp - (our_healer_cc and 20 or 0)
						min_hp = min_hp - (_CDcheck(e) and 20 or 0)
						min_hp = min_hp - (lowestFriend < 40 and 20 or 0)
						if unit_hp > min_hp then
							table.insert(units,e)
						end
					end
				end
			end
		end

		local soonest = 69
		for i=1,#units do
			local val = cc(units[i])

			if val < soonest then
				soonest = val
			end
		end

		return soonest

	end

	local function pet_control()
		
		if not lonely_winter_enabled and not pet_exists then
			if _Cast(31687) then
				Squid_Alert("Summon Pet",nil,nil,nil,31687)
			end
		end

		if not pet_exists then return end

		local pull_back

		if pet_cast_id and UnitIsVisible(pet_cast_target) then
			if _breakableCC(pet_cast_target) then
				pull_back = true
			end
		end

		if pull_back then
			if not pet_follow_sent or time - pet_follow_sent > 1 then
				PetFollow()
				pet_follow_sent = time
			end
		elseif valid_magic(2) then
			if not pet_attack_sent or time - pet_attack_sent > 1 then
				PetAttack(t)
				pet_attack_sent = time
			end
		else
			if not pet_follow_sent or time - pet_follow_sent > 1.5 then
				PetFollow()
				pet_follow_sent = time
			end
		end

	end

	local function priority_shit(max_cast_time)
		
		local target_stun = UnitExists(t) and _stunRemains(t) or 0

		if UnitExists(t) and _isDummy(t) then target_stun = 10 end

		--on use with veins
		if veins then

			local race = UnitRace("player")
			
			if race == "Orc" then
				SQ_CastSpellByName("Blood Fury")
			end

			if UnitBuffID("player",313948) then
				RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
				Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
			end

			if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
				Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
			end

			if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
			or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
			or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
				UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
				Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
			end

			if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
			or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
			or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
				UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
				Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
			end

			if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
				Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
			end

			if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
				Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
			end

			if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
				Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
			end

			if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
			or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
				UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
				Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
			end

			if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
				Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
			end

			if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
				Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
			end

			if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
				Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
			end

		end

		if not _stealthCheck("player") then

			if not utilities_only then
				
				--shatter comet storm damage (ice nova / pet freeze / flurry)
				if comet_in_flight and comet_in_flight_remains > 1.3 then
					local ct = comet_target
					if UnitIsVisible(ct) then
						if not unit_frozen(ct) then
							--flurry if immune to roots
							if _rootImmuneCheck(ct) and brain_freeze then
								if _Cast(44614,ct,nil,true) then
									Squid_Alert("Flurry","(Comet Shatter)",nil,nil,44614)
									return
								end
							--ice nova
							elseif ice_nova(ct) or ice_nova_cd <= gcd_remains or ice_nova_cd > 24 then return true
							--pet freeze
							elseif not _rootImmuneCheck(ct) and comet_in_flight_remains <= 1.5 + buffer then
								if pet_freeze(ct) then
									Squid_Alert("Pet Freeze","(Comet Shatter)",nil,nil,33395)
									return
								end
							end
						end
					end
				end

				--orb it up
				if (their_healer_cc or not their_healer) and load_mode and valid_magic(0) and (unit_is_player(t) or _isDummy(t)) and (not _slowImmuneCheck(t) or target_stun > 0) then
					frozen_orb(t)
				end

				--comet storm at the appropriate time
				if load_mode and valid_magic(0.3) and (unit_is_player(t) or _isDummy(t)) then
					if target_stun > 0 or _isSlowed(t) then
						if ice_nova_cd <= gcd or freeze_cd <= gcd then
							comet_storm(t)
						end
					end
				end

			end

			--essences
			if max_cast_time >= gcd then
				--breath of the dying
				if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains and valid_magic(0) then
					local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t));
					if hp < 20 or (hp < 90 and _HP(t) > 80) or load_mode then
						if hp < 20 or _HP(t) > 80 or load_mode then
							if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) then
								if _Cast(310690,t,true) then
									Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
								end
							end
						end
					end
				end
				if IsPlayerSpell(295373) then
					local stacks = _buffStacks("player",295378)
					if valid_magic(0) and (load_mode or (GetSpellCharges(295373) == 2 and stacks < 2) or stacks == 0 or _HP(t) < 8*stacks) then
						local str = stacks == 1 and "1 Stack" or stacks .. " Stacks"
						if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) then
							if _Cast(295373,t,true) then
								Squid_Alert("Crucible of Flame",str,nil,nil,295373)
							end
						end
					end
				end
			end
		end
	end

	local function standard_rotation(max_cast_time)

		local target_stun = UnitExists(t) and _stunRemains(t) or 0

		--ice barrier high prio
		local barrier_hp = 25
		barrier_hp = barrier_hp + (enemies_on_player * 50)
		barrier_hp = barrier_hp + (not our_healer and 75 or our_healer_cc and 75 or 0)
		barrier_hp = barrier_hp + (enemy_cds_on_player * 100)
		barrier_hp = barrier_hp - (load_target and 40 or 0)

		--why die before using ice barrier?
		if barrier_hp < 5 then
			barrier_hp = 5
		end

		--why use ice barrier when invincible?
		if player_immune then barrier_hp = 0 end

		if max_cast_time > gcd and player_hp < barrier_hp and barrier_remains < 12000 and (not temp_up or _HP("player") < 30) then
			if _Cast(11426) then
				Squid_Alert("Ice Barrier",nil,nil,nil,11426)
				return
			end
		end

		local shattering_target

		--flurry to shatter
		if valid_magic(0) and not shattering_target and max_cast_time > gcd then
			if ( brain_freeze or player_cast_id == 257537 ) and ( player_casting_shatterable_damage or load_mode and not fof and ( dont_cast_frost or _isMoving("player") ) and not unit_frozen(t) ) then
				SQ_CastSpellByID(44614,t)
				shattering_target = true
			end
		end

		--pet freeze to shatter
		if valid_magic(0) and load_mode and not shattering_target then
			if player_casting_shatterable_damage and player_cast_time_left < buffer * 2 then
				if pet_freeze(t) then
					Squid_Alert("Pet Freeze","(Shatter " .. player_cast .. ")",nil,nil,33395)
					shattering_target = true
				end
			end
		end

		--prio ice lance
		if valid_magic(0) then
			if fof_stacks >= 2 - (load_mode and 1 or 0) or unit_frozen(t) then
				if _Cast(30455,t) then return end
			end
		end

		--temp shield
		local temp_hp = 5
		temp_hp = temp_hp + ( (enemies_on_player * 15) * (not our_healer and 1.85 or our_healer_cc and 2 or 1) )
		temp_hp = temp_hp + (not our_healer and 15 or our_healer_cc and 30 or 0)
		temp_hp = temp_hp + (enemy_cds_on_player * 40)

		if auto_temp and player_hp < temp_hp and barrier_remains < 5500 then
			if _Cast(198111) then
				Squid_Alert_Big("Temp Shield",nil,nil,nil,198111)
				return
			end
		end

		--pre barrier or temp doesnt matter
		if gpy_on_player then 
			if not temp_up and _Cast(11426) then
				Squid_Alert_Big("Ice Barrier","Greater Pyro",nil,nil,11426)
				return
			elseif barrier_remains < 35000 and _Cast(198111) then
				Squid_Alert_Big("Temp Shield","Greater Pyro",nil,nil,198111)
				return
			end
		end

		--pre barr or temp doesnt matter
		if big_dmg_inc and (our_healer_cc or not our_healer or rly_big_dmg_inc or _HP("player") < 50) then
			local spell = GetSpellInfo(big_dmg_inc)
			if barrier_remains < 9000 and _Cast(198111) then
				Squid_Alert_Big("Temp Shield",spell,nil,nil,198111)
				return
			elseif not temp_up and _Cast(11426) then
				Squid_Alert_Big("Ice Barrier",spell,nil,nil,11426)
				return
			end
		end

		--pre barr or temp doesnt matter
		if _debuffRemains("player",274838) > 5.5 then
			if not temp_up and _Cast(11426) then
				Squid_Alert_Big("Ice Barrier","Feral Frenzy",nil,nil,11426)
				return
			elseif barrier_remains < 11000 and _Cast(198111) then
				Squid_Alert_Big("Temp Shield","Feral Frenzy",nil,nil,198111)
				return
			end
		end

		--pre barr cc
		if cc_flying_towards_player then
			local spell = GetSpellInfo(cc_flying_towards_player)
			if barrier_remains < 18000 and _Cast(11426) then
				Squid_Alert_Big("Ice Barrier",spell,nil,nil,11426)
				return
			end
		end

		--ray
		if load_mode and max_cast_time > 3.25 and valid_magic(0) and not _slowImmuneCheck(t) then
			if not dont_cast_frost then
				if _Cast(205021,t) then
					Squid_Alert("Ray of Frost",nil,nil,nil,205021)
				end
			end
		end

		--ebonbolt
		if max_cast_time > ebonbolt_cast_time and ebonbolt_enabled and load_mode and not fof and valid_magic(ebonbolt_cast_time) then
			if _Cast(257537,t) then return end
		end

		--cone
		for i=1,#Enemies do if not _slowImmuneCheck(Enemies[i]) and not _immuneMagic(Enemies[i]) and not _CCcheck(Enemies[i]) and not _rootCheck(Enemies[i]) then
			if cone_of_cold(Enemies[i]) then
				Squid_Alert("Cone of Cold",UnitClass(Enemies[i]),nil,nil,120)
				return
			end
		end end

		--spellsteals
		if not combustion and valid_magic(0) and max_cast_time > gcd then
			local ss = Basic_Spellsteal(t)
			if ss and _Cast(30449,t,nil,true) then
				Squid_Alert("Spellsteal " .. UnitClass(t),"("..GetSpellInfo(ss)..")",nil,nil,30449)
			end
		end

		--frostbolt fallthru
		if max_cast_time > frostbolt_cast_time and not dont_cast_frost and valid_magic(frostbolt_cast_time) then
			_Cast(116,t)
		end

		--rebuff intellect
		local someone_missing_int
		for i=1,#Friends do if not UnitBuffID(Friends[i],1459) and _distance(Friends[i]) < 40 and not UnitCanAttack("player",Friends[i]) and (not combat or not _isMeleeDps(Friends[i])) then
			someone_missing_int = true
		end end
		-- dont rebuff while casting
		if max_cast_time > gcd and someone_missing_int and not UnitCastingInfo("player") then 
			if _Cast(1459,"player") then 
				Squid_Alert("Rebuff",nil,nil,nil,1459)
				return
			end
		end

		--conjure food
		if GetItemCount(113509) == 0 then
			if UnitBuffID("player",32727) and GetNumGroupMembers() > 1 then
				_Cast(190336)
			end
			if Free_Bag_Slots() > 0 and (not food_already_clicked or time - food_already_clicked > 2 or (GetItemCount(113509) >= 20 and GetItemCount(113509) <= 40)) then
				InteractUnit("Refreshment Table")
				food_already_clicked = time
			end
		end

		--dispel dots
		local function low_prio_dispel(unit)
			local agony_stacks = _debuffStacks(unit,980)
			if agony_stacks >= 6 then
				return 980
			end
		end

		if remove_curse_cd <= gcd_remains and max_cast_time > gcd then
			for i=1,#Friends do
				local dispel = low_prio_dispel(Friends[i])
				if dispel and _LoS(Friends[i]) then
					if _Cast(475,Friends[i]) then
						Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
					end
				end
			end
		end

	end

	--burst mode
	if valid_magic(0) and Squid_Burst then

		--lucid dreams
		if IsPlayerSpell(298357) then
			if _Cast( 298357 ) then
				Squid_Alert( "Memory of Lucid Dreams", nil, nil, nil, 298357 )
				return
			end
		end

		--combust
		if veins_cd <= .5 then
			SQ_CastSpellByID ( 12472 )
			Squid_Alert_Big( "Icy Veins", nil, nil, nil, 12472 )
		end

		--racials
		local race = UnitRace("player")
		if race == "Orc" then
			SQ_CastSpellByName("Blood Fury")
		end

		--items
		if UnitBuffID("player",313948) then
			RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
			Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
		end

		if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
			Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
		end

		if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
		or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
		or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 ) then
			UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
			UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
			UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
			Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
		end

		if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
		or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
		or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
			UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
			UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
			UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
			Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
		end

		if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
			Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
		end

		if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
			Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
		end

		if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
			Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
		end

		if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
		or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
			UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
			UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
			Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
		end

		if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
			Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
		end

		if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
			Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
		end

		if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
			Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
		end

	end

	local dispellable ={
	51514,	--hex
	199954,	--curse of frag
	80240,	--havoc
	51514,	--hex
	211015,	--hex cockroach
	210873,	--hex compy
	211010,	--hex snake
	211004,	--hex spider
	277784,	--hex wicker mongrel
	277778,	--hex zandalari tendonripper
	309328,	--hex living honey
	};

	local function remove_curse(unit)
		local lessDelay = minDelayTime/1.3;
		for i=1,#dispellable do
			local debuff,_,_,five,six,seven = UnitDebuffID(unit,dispellable[i]);
			if debuff and seven-time < six-lessDelay then
				return dispellable[i];
			end
		end
	end

	--dispel
	if remove_curse_cd <= gcd_remains then
		for i=1,#Friends do
			local dispel = remove_curse(Friends[i])
			if dispel and _LoS(Friends[i]) then
				if _Cast(475,Friends[i]) then
					Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
				end
				if (player_casting_crittable_damage or (player_cast_id == 203286 and player_cast_time_left > 1)) and player_cast_time_left > gcd_remains then
					SpellStopCasting()
				end
			end
		end
	end

	local function should_klepto(unit)
	
		local value = 0

		local stun = _stunRemains(unit)

		if unit_is_unit(unit,current_target) then
			value = value + _buffRemains(unit,774)*min(max(stun,1.5),2) -- rejuv duration
			value = value + _buffRemains(unit,155777)*min(max(stun,1.5),2) -- rejuv germination duration
			value = value + (_buffRemains(unit,33763) * (.65 + (_buffStacks(unit,203554) / 4))) -- lifebloom duration * stacks
			--safegaurd
			local buff,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID(unit,286342)
			if buff and absorb > 20000 then
				value = value + 20 + (15 * (absorb / 20000))
			end
			value = value + _buffRemains(unit,198111)*3 -- some value for temp based on duration
			value = value + _buffRemains(unit,305497)*.35 -- half value for thorns duration
			--high value for ghost wolf / es / riptide when stunned
			if stun >= 1 then
				value = value + (UnitBuffID(unit,2645) and _isHealer(unit) and 45 or 0)
				value = value + (UnitBuffID(unit,974) and _isHealer(unit) and 30 or 0)
				value = value + (UnitBuffID(unit,61295) and _isHealer(unit) and 15 or 0)
			elseif _HP(unit) < 30 then
				--es and riptide still have value when they rly low
				value = value + (UnitBuffID(unit,974) and _isHealer(unit) and 15 or 0)
				value = value + (UnitBuffID(unit,61295) and _isHealer(unit) and 10 or 0)
			end
			value = value * (load_mode and 1.35 or 1)
			value = value * (_HP(unit) < 50 and 1.35 or 1)
			value = value * (_stunCheck(unit) and 1.5 or 1)
		end

		value = value + _buffRemains(unit,190319)*11 -- high value for combust
		
		--big value for bop when being targeted by melee
		value = value + (_buffRemains(unit,1022) > 0 and enemy_melee_on_player > 0 and _buffRemains(unit,1022)*10 or 0)
		
		value = value + (UnitBuffID(unit,210294) and 69 or 0) -- always klept divine favor

		value = value * ( (not theirHealer or their_healer_cc) and 1.5 or 1 )

		return value >= 42

	end

	--klepto
	if klepto_enabled then
		for i=1,#Enemies do 
			local e = Enemies[i]
			if not _immuneCheck(e) and should_klepto(e) then
				if _Cast(30449,e,nil,true) then
					Squid_Alert_Big("Klepto",UnitClass(e),1,nil,30449)
				end
			end
		end
	end

	--priority cc, and define max cast time here
	local max_cast_time = 69
	if auto_cc then
		max_cast_time = healer_cc()
		if max_cast_time > poly_cast_time then
			max_cast_time = min ( max_cast_time, off_cc() )
		end
	end

	if max_cast_time < 69 then max_cast_time = max_cast_time - buffer end
	if max_cast_time < 0 then max_cast_time = 0 end

	-- print(max_cast_time)

	--stop moving!
	if mage_stop_moving and move_setting and not _silenceCheck("player") then
		StopMovingAndLock()
	else
		SetMovementLocked(false)
	end

	--still use gcds and scorch while moving
	if _isMoving("player") then max_cast_time = gcd+.1 end

	if cc_healer_key then
		if UnitExists(theirHealer) then
			cc(theirHealer)
			return
		else
			Squid_Alert("|cFFc31d39No Healers Found",nil,nil,nil,118)
		end
	end
	if cc_focus_key then
		if UnitExists(current_focus) then
			cc(current_focus)
			return
		else
			Squid_Alert("|cFFc31d39No Focus Target",nil,nil,nil,118)
		end
	end
	if cc_offtarget_key then
		local off_target
		for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) and not unit_is_unit(Enemies[i],current_focus) then
			off_target = Enemies[i]
			break
		end end
		if UnitExists(off_target) then
			cc(off_target)
			return
		else
			Squid_Alert("|cFFc31d39No off target found",nil,nil,nil,118)
		end
	end

	--nova healer out of game
	if not poly_cast_delay or time - poly_cast_delay > .1 or not unit_is_unit(their_healer,poly_cast_target) then
		if not bcc12 and their_healer and valid_magic(69) then
			if not unit_is_unit(their_healer,t) and _realDistance(their_healer) < 11 and _LoS(their_healer) and not _CCcheck(their_healer) and (_distance(their_healer,t) > 42 or not _LoS(their_healer,t)) then
				if _Cast(122) then
					Squid_Alert_Big("Frost Nova Healer","(Bad Position)",4,3.5,122)
					return
				end
			end
		end
	end

	--nova subterfuge
	if not bcc12 then
		for i=1,#Enemies do 
			if UnitBuffID(Enemies[i],115192) and not _immuneMagic(Enemies[i]) and not _rootImmuneCheck(Enemies[i]) and _LoS(Enemies[i]) then
				if _realDistance(Enemies[i]) < 11.15 then
					if _Cast(122) then
						Squid_Alert_Big("Frost Nova","(Subterfuge)",nil,3.5,122)
					end
				end
			end 
		end
	end

	--nova melee
	if not combustion and not bcc12 then
		local p_slowed = _isSlowed("player")
		for i=1,#Enemies do
			local e = Enemies[i]
			if _isMeleeDps(e) and not _immuneMagic(e) and (select(2,UnitClass(e)) ~= "DRUID" or lowestFriend < 45) and not _rootImmuneCheck(e) then
				local d = _realDistance(e)
				if lowestFriend < 50 + ((not our_healer or our_healer_cc) and 30 or 0) + (_CDcheck(e) and 30 or 0) - (UnitEnemiesAttacking(e) * 40) - (unit_is_unit(e,current_target) and _amIfacing(e) and 40 or 0) then
					if d < 11 and _LoS(e) and (d > 8 or d > 2 and moving_away_from(e,max(7-d-(p_slowed and 1.5 or 0),2))) and (_isMoving("player") or _isMoving(e)) then
						if _Cast(122) then
							Squid_Alert_Big("Frost Nova","(Melee, Kiting)",nil,3.5,122)
						end
					end
				end
			end 
		end
	end

	object_first_detected = object_first_detected or {}

	for k,v in pairs(object_first_detected) do
		if time - v > 8 then
			object_first_detected[k] = nil
		end
	end 

	--totem stomp
	function Stomp(totem,name)
		local hp = UnitHealth(totem)
		local maxhp = UnitHealthMax(totem)
		if hp <= 1 then return false; end
		if not object_first_detected[totem] then
			object_first_detected[totem] = time
		else
			if time - object_first_detected[totem] > minDelayTime / 1.5 then
				--Lance
				if hp <= ice_lance_effect then
					if _Cast(30455,totem,nil,true) then
						Squid_Alert_Big("Stomp " .. name,"(Ice Lance)",4,nil,30455)
						fb_used=time
						return
					end
				end
			end
		end
	end

	local totems = {
	101398,	--Psyfiend
	119052,	--War Banner
	104818,	--Ancestral Protection Totem
	53006,	--Spirit Link Totem
	-- 2630,	--Earthbind Totem
	-- 60561,	--Earthgrab Totem
	-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
	5925,	--Grounding Totem
	-- 105425,	--Skyfury Totem
	105427,	--Skyfury Totem
	-- 5913,	--Tremor Totem
	105451,	--Counterstrike Totem
	}

	-- if arena then
		for i=1,#Pets do
			local e = Pets[i]
			local name = UnitName(e);
			local id = ObjectID(e)
			--only kill cap totems when they're casting
			if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) or (name == "Twisted Appendage" and lowestFriend < 50 + (not our_healer and 40 or our_healer_cc and 40 or 0) and lowestEnemy > 30) then
				Stomp(e,name)
			end
			--root abomination
			if id == 149555 and _rootDR(e) >= .5 and _CCremains(e) + _rootRemains(e) < gcd and _distance(e) < 8 and not bcc12 and _LoS(e) then
				if _Cast(122) then
					Squid_Alert("Nova","Abomination",nil,nil,122)
					return
				end
			end
		end
	-- end

	--Prio Spellsteal
	for i=1,#Enemies do if not _immuneMagic(Enemies[i]) then
		local ss = Prio_Spellsteal(Enemies[i]) 
		if ss and _Cast(30449,Enemies[i],nil,true) then
			Squid_Alert("Spellsteal " .. UnitClass(Enemies[i]),"("..GetSpellInfo(ss)..")",nil,nil,30449)
		end
	end end

	pet_control()

	priority_shit(max_cast_time)

	if not utilities_only then
		standard_rotation(max_cast_time)
	end

	--testing
	-- if UnitExists("focus") then pet_freeze("focus") end

endfunction Squid_ArcaneMagePvP()

	local time = GetTime()
	local latency = squid_avg_latency
	local groupsize = GetNumGroupMembers()
	local msperframe = 2/GetFramerate()
	local buffer = latency + msperframe + .1
	local haste = UnitSpellHaste("player")
	local gcd = 1.5/(1+(haste/100))
	local gcd_remains = GetGCD()
	local combat = UnitAffectingCombat("player")
	local player_hp = _HP("player")
	local player_immune = _immuneCheck("player",nil,true)
	local corruption = GetNetCorruption()

	local GetItemInfo_OG = GetItemInfo
	local GetItemInfo = function ( itemid ) local info = GetItemInfo_OG( itemid ) or ""; return info end

	--Auto Targeting
	local function dynamicTargeting(range)
		--Target enemies above 75% or below 35% preferably
		local bestUnit = bestUnit or nil
		if bestUnit == nil then
			if #Enemies > 0 then
				for i = 1, #Enemies do
					local thisUnit = Enemies[i]
					if _distance('player', thisUnit) <= range and _LoS('player', Enemies[i]) and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
						bestUnit = thisUnit
					end
				end
			end
		end
		if not UnitExists("target") and UnitAffectingCombat('player') then
			TargetUnit(bestUnit)
		end
	end
	local auto_target = SQUID.auto_target
	if auto_target then
		dynamicTargeting(40)
	end

	-- local tContains = tContains
	-- local IsPlayerSpell = IsPlayerSpell
	-- local UnitClass = UnitClass --this breaks shit???
	-- local UnitIsVisible = UnitIsVisible
	-- local UnitCastingInfo = UnitCastingInfo
	-- local UnitChannelInfo = UnitChannelInfo
	-- local GetSpellInfo = GetSpellInfo
	-- local UnitName = UnitName
	-- local UnitIsPlayer = UnitIsPlayer
	-- local UnitCastingInfo = UnitCastingInfo

	-- local _LoS = _LoS
	-- local _isHealer = _isHealer
	-- local GetItemInfo = GetItemInfo
	-- local GetItemCount = GetItemCount
	-- local UnitIsFriend = UnitIsFriend
	-- local UnitInParty = UnitInParty
	-- local unit_is_unit = unit_is_unit
	-- local _HP = _HP
	-- local _CCremains = _CCremains
	-- local _breakableCC = _breakableCC
	-- local unit_is_unit = unit_is_unit
	-- local IsSpellOnGCD = IsSpellOnGCD
	-- local UnitEnemiesAttacking = UnitEnemiesAttacking
	-- local Interrupt = Interrupt
	-- local PhysicalInterrupt = PhysicalInterrupt
	-- local _Cast = _Cast
	-- local _distance = _distance
	-- local GetGCD = GetGCD
	-- local _castTimeLeft = _castTimeLeft
	-- local _isHealer = _isHealer
	-- local PVE_Interrupt = PVE_Interrupt
	-- local _immuneMagic = _immuneMagic
	-- local UnitBuffID = UnitBuffID
	-- local UnitDebuffID = UnitDebuffID
	-- local _meleeRange = _meleeRange
	-- local _stealthCheck = _stealthCheck
	-- local _debuffRemains = _debuffRemains

	-- local _isMeleeDps = _isMeleeDps
	-- local _slowImmuneCheck = _slowImmuneCheck
	-- local moving_away_from = moving_away_from
	-- local ObjectID = ObjectID
	-- local _rootDR = _rootDR
	-- local _incapacitateDR = _incapacitateDR
	-- local _drRemains = _drRemains

	mage_next_cc_target = nil
	mage_next_cc_nooverride = nil
	mage_next_cc = nil
	mage_next_cc_dr = nil
	mage_next_cc_time = nil

	if _silenceCheck("player") then return end

	local bcc12 = _bccAM(12)

	local ttd = squid_ttd

	--nova stealth
	if not bcc12 then
		for i=1,#Enemies do if _stealthCheck(Enemies[i]) and _distance(Enemies[i]) < 8 then
			if _Cast(122) then
				Squid_Alert_Big("Nova " .. UnitClass(Enemies[i]),"(Stealth)",1,nil,122)
			end
		end end
	end

	--nova thing from beyond
	if not bcc12 and (not legendary_cloaked or time - legendary_cloaked > 4.5) then
		for i=1,#things_from_beyond do
			local thing = things_from_beyond[i]
			if _realDistance(thing) < 11.5 then
				if _Cast(122) then
					Squid_Alert_Big("Frost Nova","(Thing From Beyond)",4,nil,122)
				end
			end
		end
	end

	if UnitAffectingCombat("player") and UnitCastingInfo("player") == "Pyroblast" and _castTimeLeft("player") > .75 then
		SpellStopCasting()
		Squid_Alert("Stopcasting","(Hardcasting Pyro)",nil,nil,11366)
	end

	local mage_stop_moving = false

	if IsMounted() or IsFlying() or UnitBuffID("player",66) or UnitBuffID("player",32612) or UnitBuffID("player",45438) or UnitBuffID("player",110960) or not player_has_control() then return end --32612

	--equipped items
	local equipped_items = {}

	local trinkets = {
	174103,	--Manifesto of Madness
	167380,	--Notorious Gladiator's Badge
	172669,	--Corrupted Gladiator's Badge
	165058,	--Sinister Gladiator's Badge
	172666,	--Corrupted Gladiator's Medallion
	167377,	--Notorious Gladiator's Medallion
	165055,	--Sinister Gladiator's Medallion
	159615,	--Ignition Mage's Fuse
	161411,	--Tzane's Barkspines
	161377,	--Azurethos' Singed Plumage
	166793,	--Ancient Knot of Wisdom (HORDE) (278267 SPELLID)
	161417,	--Ancient Knot of Wisdom (ALLIANCE) (278267 SPELLID)
	169318,	--Shockbiter's Fang
	168973,	--Neural Synapse Enhancer
	159630,	--Balefire Branch
	}

	for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end

	local extra_items = {
	159624,	--Rotcrusted Voodoo Doll
	169305,	--Aquipotent Nautilus
	168905,	--Shiver Venom Relic
	173944,	--Forbidden Obsidian Claw
	167677,	--Harmonic Dematerializer
	167835,	--Malformed Herald's Legwraps
	168989,	--Hyperthread Wristwraps (300142 SPELLID)
	167672,	--Cyclotronic Blast (293491 SPELLID)
	165576,	--Tidestorm Codex (289885 SPELLID)
	}

	for i=1,#extra_items do if IsEquippedItem ( extra_items[i] ) then table.insert( equipped_items, extra_items[i] ) end end

	--begin arcane

	local arcane_lockout = _spellCooldown(118) > gcd_remains and _spellCooldown(118) or 0
	
	local ring_enabled = IsPlayerSpell(113724)

	local ring_cd = _spellCooldown(113724)

	local auto_cc = SQUID.auto_cc

	if UnitBuffID("player",190319) then
		CancelSpellByName("Combustion")
		Squid_Alert("Cancel Aura","(Combustion)",nil,nil,190319)
	end

	local presence_of_mind = UnitBuffID("player",205025)

	local remove_curse_cd = _spellCooldown(475)

	local arcane_charges = UnitPower("player",16)

	local mana = (100 * UnitPower("player") / UnitPowerMax("player"));

	local clearcasting = UnitBuffID("player",276743)

	local temp_up = UnitBuffID("player",198111)

	local chrono_shift_enabled = IsPlayerSpell(235711)

	local arcane_power_up = UnitBuffID("player",12042)

	local arcane_orb_enabled = IsPlayerSpell(153626)
	local arcane_orb_cd = _spellCooldown(153626)

	local sheep_range = 30

	local ring_range = 30

	mage_next_cc_target = nil
	mage_next_cc_nooverride = nil
	mage_next_cc = nil
	mage_next_cc_dr = nil
	mage_next_cc_time = nil

	local poly_cast_time = _castTime(118)
	local ring_cast_time = _castTime(113724)
	local arcane_blast_cast_time = _castTime(30451)
	local arcane_missiles_cast_time = 2
	local rune_of_power_cast_time = _castTime(116011)

	-- local fb_flying
	-- if fireball_target_dist and fireball_thrown and time - fireball_thrown < .075 + (.0485 * fireball_target_dist) then
	-- 	fb_flying = true
	-- end

	-- local pyro_flying
	-- if pyro_target_dist and pyro_thrown and time - pyro_thrown < .075 + (.04 * pyro_target_dist) then
	-- 	pyro_flying = true
	-- end

	-- local pf_flying
	-- if pf_target_dist and pf_thrown and time - pf_thrown < .135 + (.0465 * pf_target_dist) then
	-- 	pf_flying = true
	-- end

	-- if pf_flying then
	-- 	print(math.random(1,10))
	-- end
	-- if pyro_flying then
	-- 	print(math.random(1,10))
	-- end
	-- if fb_flying then
	-- 	print( math.random(1,10))
	-- end

	-- if phoenix_flames_enabled then return end

	local enemies_on_player,enemy_melee_on_player,enemy_ranged_on_player,enemy_cds_on_player = EnemiesAttacking("player")

	local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
	local player_cast_target = UnitSpellTarget("player")
	local player_cast_time_left = _castTimeLeft("player")
	local player_cast_percent_complete = _castPctDone("player")
	local player_interruptable = PlayerCanBeKicked()

	if player_cast_id == 118 then
		poly_cast_delay = time
		poly_cast_target = player_cast_target
	end

	if player_cast_id == 113724 then
		ring_cast_delay = time
	end

	if player_cast_id == 133 then
		fireball_cast_delay = time
	end

	--gui setting, disable movement stop for cc
	local move_setting = SQUID.stop_to_cc

	-- This pretty much negates one of the main selling points of my mage script, blinking to secure a greater pyro.
	-- Same code in core .lua file would have done the same with a flat return in the wrong place.
	-- Bandaid fix won't work - yet I don't see anywhere in the code that it would stopcasting a Greater Pyro at this point.
	-- Solution I've considered is determining a whitelist of spells to stop current cast for, such as:
	-- CC on you that will interrupt it anyways, CC on someone on your team that is more important than the damage you're putting out,
	-- damage from the enemy team that is more important than what you're casting, etc. This logic needs thought put into it.
	-- if (player_cast_id == 203286 and cast_percent > 80) then return; end

	local cc_casts = {118,113724}
	local player_casting_non_cc = player_cast and not tContains(cc_casts,player_cast_id)
	local player_casting_cc = player_cast and tContains(cc_casts,player_cast_id)

	--prismatic barrier absorb
	local prismatic_barrier_up,_,_,_,_,_,_,_,_,_,_,_,_,_,_,prismatic_barrier_absorb = UnitBuffID("player",235450)
	barrier_remains = prismatic_barrier_up and prismatic_barrier_absorb or 0

	local sheeped_target
	local sheeped_target_duration = 0
	for i=1,#Enemies do
		local remains = _debuffRemains(Enemies[i],118,"player")
		if remains > 0 then
			sheeped_target = Enemies[i]
			sheeped_target_duration = remains
		end
	end

	local their_healer = theirHealer
	local their_healer_cc
	local their_healer_cc_remains = 0
	local their_healer_incapacitate_dr
	local their_healer_incapacitate_dr_remains = 0
	local their_healer_important_lockout
	if their_healer then
		their_healer_cc_remains = _CCremains(their_healer)
		their_healer_cc = their_healer_cc_remains > 0
		their_healer_incapacitate_dr = _incapacitateDR(their_healer)
		their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
		
		local class = select(2,UnitClass(their_healer))

		local locked,remaining,school = UnitIsLocked(their_healer)

		if locked and remaining > .15 then
			if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
			or ( class == "SHAMAN" and school == "Nature" )
			or ( class == "PALADIN" and school == "Holy" )
			or ( class == "MONK" and school == "Nature" )
			or ( class == "DRUID" and school == "Nature" )  then
				their_healer_important_lockout = true
			end
		end

	end

	if not their_healer then
		their_healer_cc = true
		their_healer_cc_remains = 100 - (lowestEnemy*1.5)
		their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
		their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
	end

	local our_healer
	local our_healer_cc
	if ourHealer then
		our_healer = ourHealer
		if _CCcheck(ourHealer) then our_healer_cc = true end
	end

	if not our_healer then our_healer_cc = true end

	local not_moving_duration = 0 

	if _isMoving("player") then
		not_moving_duration = 0
		last_move = time
	else
		if not last_move then last_move = time end
		not_moving_duration = time - last_move
	end

	local t = current_target
	
	-- local function _valid(unit,immune)
	-- 	if not unit or not UnitExists(unit) then return false end
	-- 	if UnitIsDead(unit) or UnitIsDeadOrGhost(unit) then return false end
	-- 	return UnitCanAttack("player",unit)
	-- 	and not UnitIsFriend("player",unit)
	-- 	and not _breakableCC(unit)
	-- 	and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
	-- 	and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
	-- end

	local m_i_r = t and magic_immunity_remains(t) or 0

	local target_dist = _distance(t)

	local valid_magic = function(after,unit)

		if not unit then unit = t end
		if not unit then return false end
		if not UnitIsVisible(unit) then return false end

		if UnitIsDeadOrGhost(unit) then return false end
			
		if arena and not UnitIsPlayer(unit) then return false end

		if not arena and not UnitAffectingCombat(unit) and not _isDummy(unit) and not UnitIsPlayer(unit) then return false end

		if UnitCanAttack("player",unit)
		and (not _breakableCC(unit) or not arena and not UnitIsPlayer(unit))
		and (unit == t and m_i_r <= after or magic_immunity_remains(unit) <= after) then
			return true
		end

	end

	local thp = _HP(t)

	--magic defensive remains
	local MDR = valid_magic(0) and magic_defensive_remains(t) or 0

	local active_enemies = t and Enemies_Around_Unit(t,10) + 1 or 0

	local current_cast = UnitCastingInfo("player")

	--engage load mode when the enemy team is locked down
	local load_mode = valid_magic(0) and ( ( their_healer and ( their_healer_cc_remains >= 3 or their_healer_important_lockout ) ) or arcane_power_up or UnitDebuffID(t,210824,"player") or _stunRemains(t) > 0 or _HP(t) < 25 * (their_healer and 1 or 3.2) )

	--disable load mode when the enemy trades a defensive, unless already stunned or combusting
	if load_mode and _stunRemains(t) == 0 and combustion_remains == 0 then
		
		--not wasting this precious load on your magic defenses
		if MDR > 0 then
			load_mode = nil
		end

	end

	load_mode_active = load_mode

	local function arcane_orb(unit)
		if arena and not UnitIsPlayer(unit) then return false end
		if arcane_lockout > 0 then return false end
		if arcane_orb_enabled then
			if arcane_orb_cd <= gcd_remains then
				local d = _distance(unit)
				local total,bcc = Enemies_Around_Unit(unit,12)
				if d < 26 and bcc == 0 then
					if _LoS(unit) then
						if arcane_orb_cd == 0 then
							local f = ObjectFacing("player")
							FaceDirection(GetAnglesBetweenObjects("player",unit),true)
							CastSpellByID(153626)
							FaceDirection(f,true)
							Squid_Alert("Arcane Orb",UnitClass(unit),nil,nil,153626)
						end
						return "wait"
					end
				end
			end
		end
	end

	local function cc(unit)
		
		local player_exists

		for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then player_exists = true end end

		local player_forced

		if cc_focus_key and unit_is_unit(unit,current_focus) then player_forced = true end
		if cc_offtarget_key or cc_healer_key then player_forced = true end

		if not arena and not UnitIsPlayer(unit) and not player_forced then return 69 end

		--stop if no unit
		if not UnitIsVisible(unit) then return 69 end

		--dist to unit
		local dist = _distance(unit)

		--stop function if unit can't be cc'd
		-- if _immuneMagic(unit,true) or not _LoS(unit) or dist > 39.25 then return 69 end

		local immunity_remains = magic_immunity_remains(unit,true)

		--this function should not only cc, but also return the time until cc needs to happen
		--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
		local time_to_cc = 0

		--check cc
		local ccr = _CCremains(unit)
		local cc = ccr > 0 
		
		--incap drs
		local idr = _incapacitateDR(unit)
		local idr_remains = _drRemains(unit,"incapacitate")

		--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
		local immune_sheep = _isBeast(unit) or _isDummy(unit) or UnitBuffID(unit, 197625)

		--meteor?
		local standing_in_meteor = UnitDebuffID(unit,155158)

		--yea dont cc into it
		if standing_in_meteor then return 69 end

		--banner?
		local banner = UnitBuffID(unit,236321)

		--yea dont cc into it...unless
		if banner then return 69 end

		--incap on unit?
		local incap = _incapacitateCheck(unit)

		--healer?
		local is_healer = _isHealer(unit) 

		--lockout?
		local lockout = IsLocked(unit,true)

		--los?
		local los = _LoS(unit)

		--ring to followup cc, if the unit is a beast, or we are locked on sheep
		local time_til_ring_ready = 69
		if immunity_remains == 0 and (not UnitDebuffID(unit,33786) or (_debuffRemains(unit,33786) < ring_cast_time and _debuffRemains(33786) > ring_cast_time-(buffer*3.5))) then
			if idr >= .5 or lowestEnemy < 30 and idr >= .25 then
				if arcane_lockout > 0 or immune_sheep or ccr > ring_cast_time or (sheeped_target and not unit_is_unit(unit,sheeped_target)) then
					local poly_cast_time_extra = poly_cast_time + .5
					local max_overlap = ring_cast_time + (buffer*3.5) + (idr >= .5 and poly_cast_time_extra or 0) --arcane_lockout < ring_cast_time and
					local ring_ready = ring_enabled and ring_cd < gcd and ring_cd <= gcd_remains and ccr > ring_cast_time-.05 and ccr < max_overlap and (idr == 1 or not los and idr >= .5 or arcane_lockout > gcd_remains and idr >= .5)

					if ring_ready and dist < ring_range and (not _isMoving(unit) or UnitDebuffID(unit,31661)) then
						--alert when moving, stop casting scorch when not
						if not poly_cast_delay or time-poly_cast_delay > .2 then
							local can_ring = ring_of_frost(unit)
							if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Ring)",nil,nil,113724)
							elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
							mage_stop_moving = can_ring
							if not mage_next_cc then
								mage_next_cc = 113724
							end
							mage_next_cc_time = 0
						end
						time_to_cc = 0
					end

					time_til_ring_ready = ccr > ring_cast_time + buffer and math.max(ring_cd,ccr,idr == 1 and 0 or idr == .5 and arcane_lockout > gcd_remains and 0 or idr_remains) or 69
				end
			end
		end

		--sheep, if drs are available, and the unit is not immune
		local time_til_poly_ready = 69
		if immunity_remains <= poly_cast_time+(buffer*.45) and los then --no sheep into lockout, unless they're casting another school
			if not immune_sheep and (lockout <= poly_cast_time + (buffer*2) or UnitCastingInfo(unit)) then
				
				local sheep_dr_ready = idr == 1 or (idr >= .25 and idr_remains > 17.25 - (ccr >= poly_cast_time and 6 * idr or 0) - (incap and ccr >= poly_cast_time-.2 and 6 * idr or 0) - ((100-lowestEnemy) * .038) + (idr == .25 and 1 or 0) ) or idr_remains < poly_cast_time-(buffer/2)
				
				-- print(sheep_dr_ready, idr, idr_remains)
				-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
				local no_sheeps_out = not sheeped_target or unit_is_unit(unit,sheeped_target) or _incapacitateDR(sheeped_target) <= .25 or (is_healer and idr == 1 and not _isHealer(sheeped_target)) or (_incapacitateDR(sheeped_target) <= .5 and _drRemains(sheeped_target,"incapacitate") > 3 and _drRemains(sheeped_target,"incapacitate") < 16.5)
				if sheep_dr_ready and no_sheeps_out then
					local max_overlap = poly_cast_time + (buffer*2.85) + .145 -- + (idr >= .5 and ring_cd < gcd and ccr > ring_cast_time and ring_cast_time or 0)
					if ccr < max_overlap and dist < sheep_range then
						if arcane_lockout <= buffer then
							--alert when moving, stop casting scorch when not
							if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Sheep)",nil,nil,118) mage_stop_moving = true
							elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
							mage_stop_moving = true
							if (not poly_cast_delay or time-poly_cast_delay > .2) and _Cast(118,unit) then
								Squid_Alert("Sheeping",UnitClass(unit),nil,3,118)
							end
							time_to_cc = 0
							if not mage_next_cc then
								mage_next_cc = 118
							end
							mage_next_cc_time = 0
						else
							time_to_cc = math.max(arcane_lockout,time_to_cc)
						end
					else
						time_to_cc = math.max(ccr,time_to_cc)
					end

					time_til_poly_ready = math.max(ccr-max_overlap,idr_remains < 17 and idr_remains or 0,arcane_lockout)

					if immune_sheep and not is_healer then time_til_poly_ready = 69 end

				end
			end
		end

		local val = math.min(time_til_ring_ready,time_til_poly_ready)

		--next cc unit used for drawings
		mage_next_cc_target = unit
			
		--default to sheep if no other cc defined above
		if not mage_next_cc then mage_next_cc = 118 end

		--display incap dr for sheeps
		if mage_next_cc == 118 or mage_next_cc == 113724 then
			mage_next_cc_dr = idr
			mage_next_cc_time = val >= 69 and idr_remains or val
		end

		return val
		
	end

	local function priority_cc()
		
		local player_exists

		for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then player_exists = true end end

		if not arena and not player_exists then return 69 end

		--healer
		local unit = their_healer

		--focus target if there is no healer
		if not unit then unit = current_focus end

		if unit_is_unit(unit,current_target) then
			unit = current_focus
		end

		local idr
		local idr_r
		if unit then
			idr = _incapacitateDR(unit)
			idr_r = _drRemains(unit,"incapacitate")
		end

		if unit_is_unit(unit,current_target) then
			--off target
			for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) then
				unit=Enemies[i]
				break
			end end
		else
			if unit then
				if idr < .25 or ( idr_r > 3 and idr_r < 15 ) or _distance(unit) > 39 or (not _LoS(unit) and ring_cd > gcd) then
					--off target
					for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) then
						unit=Enemies[i]
						break
					end end
				end
			end
		end

		if unit_is_unit(unit,current_target) then
			unit=nil
		end

		--stop function if no healer and no fuckus
		if not unit then return 69 end

		if unit and UnitIsDeadOrGhost(unit) then return 69 end

		return cc(unit)

	end

	local function priority_shit(max_cast_time)
		
		local target_stun = UnitExists(t) and _stunRemains(t) or 0

		if UnitExists(t) and _isDummy(t) then target_stun = 10 end

		local stuns_on_team

		--badge w/ ap
		if arcane_power_up then
			UseItemByName("Notorious Gladiator's Badge")
			UseItemByName("Sinister Gladiator's Badge")
			UseItemByName("Corrupted Gladiator's Badge")
		end

		--klepto
		-- if klepto_enabled and valid_magic(0) and should_klepto(t) and max_cast_time >= gcd then
		-- 	if _Cast(30449,t,nil,true) then
		-- 		Squid_Alert_Big("Klepto",UnitClass(t),1,nil,30449)
		-- 	end
		-- end

		--arcane orb
		if valid_magic(0) then
			if arcane_orb(t) == "wait" then return end
		end

		--charged up in load mode
		if load_mode and arcane_charges <= 1 then
			if _Cast(205032) then
				Squid_Alert("Charged Up",nil,nil,nil,205032)
			end
		end

		--pump w/ pom
		if presence_of_mind then
			if valid_magic(0) then
				_Cast(30451,t,true)
			end
		end

		--essences
		if max_cast_time >= gcd then
			--breath of the undying
			if valid_magic(0) then
				_Cast(310690,t,true)
			end
			--crucible of flame
			if valid_magic(0) and (load_mode or GetSpellCharges(295373) == 2 or _buffStacks("player",295378) == 0 or _HP(t) < 8*_buffStacks("player",295378)) then
				_Cast(295373,t,true)
			end
		end

	end

	local function standard_rotation(max_cast_time)

		local target_stun = UnitExists(t) and _stunRemains(t) or 0

		--pris barrier
		local prismatic_hp = 40
		prismatic_hp = prismatic_hp + (enemies_on_player * 25)
		prismatic_hp = prismatic_hp + (not our_healer and 15 or our_healer_cc and 50 or 0)
		prismatic_hp = prismatic_hp + (enemy_cds_on_player * 50)
		prismatic_hp = prismatic_hp - (load_mode and 45 or 0)

		if max_cast_time >= gcd and player_hp < prismatic_hp and barrier_remains < 5000 and (not temp_up or _HP("player") < 25) then
			if _Cast(235450) then
				Squid_Alert("Prismatic Barrier",nil,nil,nil,235450)
			end
		end

		if _buffRemains("player",235450) < 10 then
			if _Cast(235450) then
				Squid_Alert("Prismatic Barrier",nil,nil,nil,235450)
			end
		end

		--temp shield
		local temp_hp = 25
		temp_hp = temp_hp + (enemies_on_player * 20)
		temp_hp = temp_hp + ((our_healer_cc and 40 or 0) or (not our_healer and 40 or 0))
		temp_hp = temp_hp + (enemy_cds_on_player * 40)

		if player_hp < temp_hp then
			if _Cast(198111) then
				Squid_Alert_Big("Temp Shield",nil,nil,nil,198111)
			end
		end

		if gpy_on_player then 
			if _Cast(198111) then
				Squid_Alert_Big("Temp Shield","Greater Pyro",nil,nil,198111)
			end
		end

		--maintain slow with barrage
		if max_cast_time >= gcd and chrono_shift_enabled and valid_magic(0) and not _slowImmuneCheck(t) and _debuffRemains(t,236299,"player") < 1.8 then
			_Cast(44425,t,true)
		end

		--slow off dps to peel
		if lowestFriend < 70 then
			if chrono_shift_enabled then
				for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _breakableCC(Enemies[i]) and not _isSlowed(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) then
					if _Cast(44425,Enemies[i],true) then
						Squid_Alert("Chrono Shift "..UnitClass(Enemies[i]),"(Peel)",nil,nil,44425)
					end
				end end
			else
				for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _isSlowed(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) then
					if _Cast(31589,Enemies[i]) then
						Squid_Alert("Slow "..UnitClass(Enemies[i]),"(Peel)",nil,nil,31589)
					end
				end end
			end
		end

		--arcane orb
		if valid_magic(0) then
			if arcane_orb(t) == "wait" then return end
		end

		--missiles with clearcasting
		if max_cast_time >= gcd and valid_magic(0) and (load_mode or mana > 80 or clearcasting) then
			_Cast(5143,t,true)
		end

		--touch of the magi blasts
		if max_cast_time > arcane_blast_cast_time and IsPlayerSpell(210725) and valid_magic(arcane_blast_cast_time) then
			_Cast(30451,t,true)
		end

		--Arcane Spellsteal
		if max_cast_time >= gcd then
			for i=1,#Enemies do if not _immuneMagic(Enemies[i]) then
				local ss = Arcane_Spellsteal(Enemies[i])
				if ss and _Cast(30449,Enemies[i],nil,true) then
					Squid_Alert("Spellsteal " .. UnitClass(Enemies[i]),"("..GetSpellInfo(ss)..")",nil,nil,30449)
				end
			end end
		end

		--barrage
		if max_cast_time >= gcd and valid_magic(0) then
			_Cast(44425,t,true)
		end

		--rebuff intellect
		if max_cast_time >= gcd then
			local someone_missing_int
			for i=1,#Friends do if not UnitBuffID(Friends[i],1459) and _distance(Friends[i]) < 40 and not UnitCanAttack("player",Friends[i]) then
				someone_missing_int = true
			end end
			-- dont rebuff while casting
			if someone_missing_int and not UnitCastingInfo("player") then 
				if _Cast(1459,"player") then 
					Squid_Alert("Rebuff",nil,nil,nil,1459)
					return
				end
			end
		end

		--blast
		if max_cast_time >= arcane_blast_cast_time and valid_magic(0) and arcane_charges <= 3 then
			_Cast(30451,t,true)
		end

		--arcane explosion filler
		if not bcc12 and mana > 65 and Enemies_Around_Unit("player",10) > 0 then
			_Cast(1449)
		end

		--conjure food
		if GetItemCount(113509) == 0 then
			if UnitBuffID("player",32727) and GetNumGroupMembers() > 1 then
				_Cast(190336)
			end
			if Free_Bag_Slots() > 0 then
				InteractUnit("Refreshment Table")
			end
		end

		--dispel agony etc

	end

	--priority cc, and define max cast time here
	local max_cast_time = 69
	if auto_cc then
		max_cast_time = priority_cc()
	end

	--stop moving!
	if mage_stop_moving and move_setting and not _silenceCheck("player") then
		StopMovingAndLock()
	else
		SetMovementLocked(false)
	end

	--still use gcds and scorch while moving
	if _isMoving("player") then max_cast_time = math.max(_castTime(2948) + .01,gcd + .01) end

	if cc_healer_key then
		if UnitExists(theirHealer) then
			cc(theirHealer)
			return
		else
			Squid_Alert("|cFFc31d39No Healers Found",nil,nil,nil,118)
		end
	end
	if cc_focus_key then
		if UnitExists(current_focus) then
			cc(current_focus)
			return
		else
			Squid_Alert("|cFFc31d39No Focus Target",nil,nil,nil,118)
		end
	end
	if cc_offtarget_key then
		local off_target
		for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) and not unit_is_unit(Enemies[i],current_focus) then
			off_target = Enemies[i]
			break
		end end
		if UnitExists(off_target) then
			cc(off_target)
			return
		else
			Squid_Alert("|cFFc31d39No off target found",nil,nil,nil,118)
		end
	end

	--priority nova
	if not poly_cast_delay or time - poly_cast_delay > .1 or not unit_is_unit(their_healer,poly_cast_target) then
		if their_healer and valid_magic(69) and not bcc12 then
			if not unit_is_unit(their_healer,t) and _distance(their_healer) < 8 and _LoS(their_healer) and not _CCcheck(their_healer) and (not _LoS(their_healer,t) or _distance(their_healer,t) > 42) then
				if _Cast(122) then
					Squid_Alert_Big("Frost Nova Healer","(Bad Position)",4,3.5,122)
				end
			end
		end
	end

	--nova melee
	if not combustion and not bcc12 and lowestFriend < 75 then
		for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _immuneMagic(Enemies[i]) and _distance(Enemies[i]) < 8 and (select(2,UnitClass(Enemies[i])) ~= "DRUID" or lowestFriend < 45) then
			if _CDcheck(Enemies[i]) or lowestFriend < 40 then
				_Cast(122)
			end
		end end
	end

	--totem stomp
	function Stomp(totem,name)
		local hp = UnitHealth(totem)
		local maxhp = UnitHealthMax(totem)
		if hp <= 1 then return false; end
		--Barrage
		if hp <= 17000 then
			if _Cast(44425,totem,nil,true) then
				Squid_Alert_Big("Stomp " .. name,"(Barrage)",4,3.3,44425)
				return
			end
		end
	end

	local totems = {
	101398,	--Psyfiend
	119052,	--War Banner
	104818,	--Ancestral Protection Totem
	53006,	--Spirit Link Totem
	-- 2630,	--Earthbind Totem
	-- 60561,	--Earthgrab Totem
	-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
	5925,	--Grounding Totem
	105425,	--Skyfury Totem
	-- 5913,	--Tremor Totem
	105451,	--Counterstrike Totem
	}

	if arena then
		for i=1,#Pets do
			local e = Pets[i]
			local name = UnitName(e);
			local id = UnitCreatureID(e)
			--only kill cap totems when they're casting
			if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
				Stomp(e,name)
			end
			--root abomination
			if id == 149555 and _rootDR(e) >= .5 and _CCremains(e) + _rootRemains(e) < gcd and _distance(e) < 8 and not bcc12 then
				if _Cast(122) then
					Squid_Alert("Nova","Abomination",nil,nil,122)
					return
				end
			end
		end
	end

	local dispellable ={
	51514,	--hex
	199954,	--curse of frag
	80240,	--havoc
	211015,	--hex cockroach
	210873,	--hex compy
	211010,	--hex snake
	211004,	--hex spider
	277784,	--hex wicker mongrel
	277778,	--hex zandalari tendonripper
	309328,	--hex living honey
	};

	local function remove_curse(unit)
		local lessDelay = minDelayTime/1.3;
		for i=1,#dispellable do
			local debuff,_,_,five,six,seven = UnitDebuffID(unit,dispellable[i]);
			if debuff and seven-time < six-lessDelay then
				return dispellable[i];
			end
		end
		if _buffStacks(unit,980) >= 6 then
			return 980
		end
	end

	--dispel
	if remove_curse_cd <= gcd_remains then
		for i=1,#Friends do
			local dispel = remove_curse(Friends[i])
			if dispel and _LoS(Friends[i]) and _Cast(475,Friends[i]) then
				Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
			end
		end
	end

	if auto_cc then

		local off_target
		for i=1,#Enemies do if not unit_is_unit(current_target,Enemies[i]) and _distance(Enemies[i]) < 40 and not UnitIsDead(Enemies[i]) then
			off_target=Enemies[i]
			break
		end end

		if off_target then
			cc(off_target)
		end

	end

	-- print(mage_next_cc_target,mage_next_cc,mage_next_cc_dr,mage_next_cc_time)

	-- print(max_cast_time)

	priority_shit(max_cast_time)

	standard_rotation(max_cast_time)

endfunction Squid_FireMagePvE()

	local eating = UnitBuffID("player",167152)
	if eating then return end
	
	--todo

	local time = GetTime()
	local latency = squid_avg_latency
	local groupsize = GetNumGroupMembers()
	local msperframe = 2/GetFramerate()
	local buffer = latency + msperframe + .11
	local haste = UnitSpellHaste("player")
	local gcd = 1.5/(1+(haste/100))
	local gcd_remains = GetGCD()
	local combat = player_combat
	local player_hp = _HP("player")

	local player_combat = UnitAffectingCombat("player")

	local GetItemInfo_OG = GetItemInfo
	local GetItemInfo = function ( itemid ) local info = GetItemInfo_OG( itemid ) or ""; return info end

	local UnitAffectingCombat = UnitAffectingCombat
	local _HP = _HP
	local squid_ttd = squid_ttd
	local _distance = _distance
	local _realDistance = _realDistance
	local UnitBuffID = UnitBuffID
	local UnitDebuffID = UnitDebuffID
	local UnitCanAttack = UnitCanAttack
	local _isMeleeDps = _isMeleeDps

	local auto_combust = SQUID.auto_combust

	if UnitBuffID("player",296510) then
		CancelSpellByName(GetSpellInfo(296510))
	end

	--dbm pull timer
	local dbm_countdown = 1000
	if DBM then
		local numBars = DBM.Bars.numBars
		if numBars and numBars ~= 0 then dbm_countdown = 1001 end
		local bars = DBM.Bars.hugeBars
		if bars then
			local last = bars.last
			if last then
				local timer = last.timer
				dbm_countdown = timer
			end
		end
		if dbm_countdown == 1000 or dbm_countdown == 1001 then
			bars = DBM.Bars.smallBars
		end
		if bars then
			local last = bars.last
			if last then
				local timer = last.timer
				dbm_countdown = timer
			end
		end
	end

	--min combust hp
	local min_combust_health = SQUID.min_combust_hp

	--traits info
	local blaster_master_enabled = AzeritePowerTaken(215)

	--solomode
	local solo_mode = SQUID.solo_mode_enabled

	--reset cc draws when switching to pve rotation
	mage_next_cc_target = nil
	mage_next_cc_nooverride = nil
	mage_next_cc = nil
	mage_next_cc_dr = nil
	mage_next_cc_time = nil

	if IsMounted() or IsFlying() or UnitBuffID("player",66) or UnitBuffID("player",32612) or UnitBuffID("player",45438) or UnitBuffID("player",110960) or not player_has_control() then return end

	local function debug_print(str) if squid_debug then print(str) end end
	local function dynamicTargeting(range)
		--Target enemies above 75% or below 35% preferably
		local bestUnit = bestUnit or nil
		if bestUnit == nil then
			if #Enemies > 0 then
				for i = 1, #Enemies do
					local thisUnit = Enemies[i]
					if _distance('player', thisUnit) <= range and _LoS('player', Enemies[i]) and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
						bestUnit = thisUnit
					end
				end
			end
		end
		if not UnitExists("target") and UnitAffectingCombat('player') then
			TargetUnit(bestUnit)
		end
	end
	local auto_target = SQUID.auto_target
	if auto_target then
		dynamicTargeting(40)
	end

	local fire_lockout = _spellCooldown(133) > gcd_remains and _spellCooldown(133) or 0
	local arcane_lockout = _spellCooldown(118) > gcd_remains and _spellCooldown(118) or 0
	local ring_cd = _spellCooldown(113724)
	local db_cd = _spellCooldown(31661)
	local meteor_cd = _spellCooldown(153561)
	local remove_curse_cd = _spellCooldown(475)
	local combustion_cd = _spellCooldown(190319)
	local shifting_power_cd = _spellCooldown(314791)

	local rune_of_power_base_cd = 40
	local rune_of_power_max_charges = 2
	local rune_of_power_total_cd = rune_of_power_base_cd * rune_of_power_max_charges
	local rune_of_power_charges = GetSpellCharges(116011)
	local rune_of_power_charges_frac = _spellChargeFrac(116011)
	local rune_of_power_next_charge_cd = (math.ceil(rune_of_power_charges_frac) - rune_of_power_charges_frac) * rune_of_power_base_cd
	local rune_of_power_full_recharge_time = rune_of_power_total_cd - (rune_of_power_charges_frac*rune_of_power_base_cd)
	local rune_of_power_cd = gcd_remains
	if rune_of_power_charges == 0 then rune_of_power_cd = rune_of_power_next_charge_cd end

	local heating_up = UnitBuffID("player",48107)
	local heating_up_remains = _buffRemains("player",48107)
	local tinder_up = UnitBuffID("player",203277)
	local flamecannon_stacks = _buffStacks("player",203285)
	local temp_up = UnitBuffID("player",198111)
	local rune_of_power_up = UnitBuffID("player",116014)
	local rune_of_power_remains = ( rune_of_power_up and player_rop and 10 - ( time - player_rop ) or 0 )
	local blaster_master_remains = _buffRemains("player",274598) - (buffer/2)
	local blaster_master_up = UnitBuffID("player",274598)
	local blaster_master_stacks = _buffStacks("player",274598)

	local hot_streak = UnitBuffID("player",48108) or UnitBuffID("player",333100)
	local hot_streak_remains = _buffRemains("player",48108)
	local pyroclasm_remains = _buffRemains("player",269651)
	local pyroclasm = pyroclasm_remains > 0
	local searing_touch_enabled = IsPlayerSpell(269644)
	local rune_of_power_enabled = IsPlayerSpell(116011)
	local ring_enabled = IsPlayerSpell(113724)
	local tinder_enabled = IsPlayerSpell(203275)
	local firestarter_enabled = IsPlayerSpell(205026)
	local flame_on = IsPlayerSpell(205029)
	local meteor_enabled = IsPlayerSpell(153561)
	local shifting_power_enabled = IsPlayerSpell(314791)
	local combustion_remains = _buffRemains("player",190319)
	local combustion = combustion_remains > 0
	local infernal_cascade_remains = _buffRemains('player', 336821)
	local infernal_cascade = infernal_cascade_remains > 0

	local fire_blast_base_cd = flame_on and 10 or 12
	-- fire_blast_base_cd = fire_blast_base_cd * (1-(haste/100-.04))
	fire_blast_base_cd = fire_blast_base_cd - ( haste * 0.076954715597427 )

	local fire_blast_charges,fire_blast_max_charges = GetSpellCharges(108853)
	local fire_blast_total_cd = fire_blast_base_cd * fire_blast_max_charges
	local fire_blast_charges_frac = _spellChargeFrac(108853)
	local fire_blast_full_recharge_time = fire_blast_total_cd - (fire_blast_charges_frac*fire_blast_base_cd)
	local fire_blast_next_charge_cd = (math.ceil(fire_blast_charges_frac) - fire_blast_charges_frac) * fire_blast_base_cd

	-- print(fire_blast_full_recharge_time)
	-- if not cd_printed or time - cd_printed > 1 then
	-- 	print( fire_blast_next_charge_cd )
	-- 	print( fire_blast_full_recharge_time )
	-- 	cd_printed = time
	-- end

	-- print(pyro_flying)

	local alexstraszas_fury_enabled = IsPlayerSpell(235870)
	local flame_patch_enabled = IsPlayerSpell(205037)
	local kindling_enabled = IsPlayerSpell(155148)

	local phoenix_flames_enabled = IsPlayerSpell(257541)
	local phoenix_flames_base_cd = 30
	local phoenix_flames_charges,phoenix_flames_max_charges = GetSpellCharges(257541)
	if not phoenix_flames_enabled then
		phoenix_flames_charges = 0
		phoenix_flames_max_charges = 0
	end
	local phoenix_flames_total_cd = phoenix_flames_base_cd * phoenix_flames_max_charges
	local phoenix_flames_charges_frac = _spellChargeFrac(257541)
	local phoenix_flames_full_recharge_time = phoenix_flames_total_cd - (phoenix_flames_charges_frac*phoenix_flames_base_cd)
	local phoenix_flames_next_charge_cd = (math.ceil(phoenix_flames_charges_frac) - phoenix_flames_charges_frac) * phoenix_flames_base_cd

	local meteor_in_flight = meteor_cd > 42
	local meteor_in_flight_remains = (3 - ( 45 - meteor_cd )) - buffer

	local combustion_learned = IsPlayerSpell(190319)

	-- print(meteor_in_flight_remains,meteor_in_flight)

	local flamecannon_value = (flamecannon_stacks * 3)	

	local gpy_range = 40

	local sheep_range = 30

	local ring_range = 30

	gpy_range = gpy_range + flamecannon_value

	sheep_range = sheep_range + flamecannon_value

	ring_range = ring_range + flamecannon_value

	local poly_cast_time = _castTime(118)
	local ring_cast_time = _castTime(113724)
	local greater_pyro_cast_time = _castTime(203286)
	local fireball_cast_time = _castTime(133)
	local scorch_cast_time = _castTime(2948)
	local rune_of_power_cast_time = _castTime(116011)
	local pyro_cast_time = _castTime(11366)
	local flamestrike_cast_time = _castTime(2120)

	local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
	local player_cast_target = UnitSpellTarget("player")
	local player_cast_time_left = _castTimeLeft("player")
	local player_cast_percent_complete = _castPctDone("player")

	local crit_casts = {2948,133}
	local player_casting_crittable_damage = player_cast and tContains(crit_casts,player_cast_id)
	local player_casting_guaranteed_crit = player_cast and tContains(crit_casts,player_cast_id) and (combustion or (player_cast_id == 2948 and UnitIsVisible(player_cast_target) and _HP(player_cast_target) < 30 and IsPlayerSpell(269644)))

	local single_target = SQUID.single_target

	--blazing barrier absorb
	local blazing_barrier_up,_,_,_,_,_,_,_,_,_,_,_,_,_,_,blazing_barrier_absorb = UnitBuffID("player",235313)
	barrier_remains = blazing_barrier_up and blazing_barrier_absorb or 0

	local crit_inc = fb_flying or pf_flying or pyro_flying

	--stopcasting hardcast pyro	
	if not pyroclasm and player_combat and UnitCastingInfo("player") == "Pyroblast" and _castTimeLeft("player") > 1.25 then
		SpellStopCasting()
		Squid_Alert("Stopcasting","(Hardcasting Pyro)",nil,nil,11366)
	end

	local scorch_execute_ready
	if searing_touch_enabled then
		for i=1,#Enemies do
			if _HP(Enemies[i]) < 30 and valid_attackable(Enemies[i]) and _distance(Enemies[i]) < 40 and _LoS(Enemies[i]) and _amIfacing(Enemies[i]) and squid_ttd(Enemies[i]) > scorch_cast_time then
				scorch_execute_ready = true
				break
			end
		end
	end

	if _isMoving("player") then
		not_moving_duration = 0
		last_move = time
	else
		if not last_move then last_move = time end
		not_moving_duration = time - last_move
	end

	local function ready_to_attack(unit)
		-- local whitelist = {
		-- "Spirit of Gold",
		-- "Reanimation Totem",
		-- "Soulspawn",
		-- "Crackling Shard",
		-- "Horrific Hemorrhage",
		-- "Synthesis Growth",
		-- "Corrupted Neuron",
		-- }
		-- if tContains(whitelist,ObjectName(unit)) then
		-- 	return true
		-- else
		-- 	return UnitAffectingCombat(unit)
		-- end
		return valid_attackable(unit)
	end
	
	local t = current_target

	if UnitIsVisible(t) then
		if not UnitCanAttack("player",t) or (dbm_countdown == 1000 and not _isDummy(t) and not ready_to_attack(t)) then
			t = nil
		end
	end

	local all_explosives = {}
	for i=1,#Enemies do 
		if ObjectID(Enemies[i]) == 120651 and UnitCastingInfo(Enemies[i]) and _LoS(Enemies[i]) and _distance(Enemies[i]) < 35 and _amIfacing(Enemies[i]) then
			table.insert(all_explosives,{pointer=Enemies[i],hp=_HP(Enemies[i]),cast_left=_castTimeLeft(Enemies[i])})
		end
	end

	table.sort(all_explosives,function(x,y) return x.cast_left < y.cast_left end)

	local explosive = #all_explosives >= 4 and all_explosives[1].pointer or nil

	local important_explosive
	for i=1,#all_explosives do
		if all_explosives[i].cast_left < buffer then
			if not fb_used or time - fb_used > .2 then
				if _Cast(108853,all_explosives[i].pointer,nil,true) then
					Squid_Alert("Fire Blast","(Explosive)",nil,nil,108853)
					fb_used = time
					debug_print("returning on fire_blast (explosive, 1)")
					return
				end
			end
		end
		if all_explosives[i].hp > ( all_explosives[i].cast_left * 25 ) - ( #all_explosives * 13 ) then
			important_explosive = all_explosives[i].pointer
			break
		end
	end

	if important_explosive then 
		explosive = important_explosive
	end

	explosive_draw = explosive

	--use fire blast when on full stacks
	if combustion and ready_to_attack(t) then
		if fire_blast_charges_frac >= fire_blast_max_charges-.5 and not hot_streak and not heating_up and not pf_flying and not fb_flying and not pyro_flying then
			if not fb_used or time - fb_used > .35 + latency then
				local t = explosive or t
				if _Cast( 108853, t, true ) then
					--print("Combust Fireblast 1")
					fb_used = time
					debug_print("returning on fire_blast (combust, 1)")
					return true
				end
			end
		end
	end
	
	--target time to die
	local t_ttd = ( t and squid_ttd(t) or 0 )

	--target hp
	local t_hp = ( t and _HP( t ) or 100 )

	--target actual hp
	local t_ahp = ( t and UnitHealth(t) or UnitHealth("player") )

	--target is boss
	local t_is_boss = ( t and UnitClassification( t ) == "worldboss" )

	--enemies around t
	local enemies_around_target = Enemies_Around_Unit(t,12,true)

	--target is dummy
	local t_is_dummy = ( t and _isDummy( t ) )

	--facing target
	local facing_target = t and _amIfacing(t)

	--distance to targ
	local t_dist = t and _distance( t ) or 99

	--active enemies
	local active_enemies = #Enemies

	--min flamestrike units
	local fs_count

	--not combusting
	local not_combusting_target

	-- # Default consumables
	-- potion=potion_of_unbridled_fury
	-- flask=greater_flask_of_endless_fathoms
	-- food=biltong
	-- augmentation=battle_scarred

	--potions, sorted by best to worst
	--pots need update
	local potions = {
	169299,	--potion of unbridled fury
	168498,	--superior int pot
	163222,	--int pot
	}
	local best_pot = nil
	for i=1,#potions do if GetItemCount( potions[i] ) > 0 then
		best_pot = potions[i]
		break
	end end

	--FIX ME
	-- SQUID.pre_pot_enabled = true

	--simc vars
	local disable_combustion = not combustion_learned
	local combustion_rop_cutoff
	local combustion_on_use
	local font_double_on_use
	local font_of_power_precombat_channel
	local on_use_cutoff
	local hold_combustion_threshold = 20
	local time_to_combustion
	local fire_blast_pooling
	local phoenix_pooling
	local combustion_shifting_power = 2
	local combustion_flamestrike = 0
	local full_reduction = 10

	--more
	local firestarter_active = firestarter_enabled and t and t_hp >= 90
	local firestarter_remains = firestarter_enabled and t and squid_ttp( t, 90 ) or 0

	--equipped items
	local equipped_items = {}

	local trinkets = {
	174103,	--Manifesto of Madness
	167380,	--Notorious Gladiator's Badge
	172669,	--Corrupted Gladiator's Badge
	165058,	--Sinister Gladiator's Badge
	175884,	--Sinful Aspirant's Weed
	172666,	--Corrupted Gladiator's Medallion
	167377,	--Notorious Gladiator's Medallion
	165055,	--Sinister Gladiator's Medallion
	159615,	--Ignition Mage's Fuse
	161411,	--Tzane's Barkspines
	161377,	--Azurethos' Singed Plumage
	166793,	--Ancient Knot of Wisdom (HORDE) (278267 SPELLID)
	161417,	--Ancient Knot of Wisdom (ALLIANCE) (278267 SPELLID)
	169318,	--Shockbiter's Fang
	168973,	--Neural Synapse Enhancer
	159630,	--Balefire Branch
	}
	local combustion_trinket_equipped

	for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then combustion_trinket_equipped = true table.insert( equipped_items, trinkets[i] ) end end

	local extra_items = {
	159624,	--Rotcrusted Voodoo Doll
	169305,	--Aquipotent Nautilus
	168905,	--Shiver Venom Relic
	173944,	--Forbidden Obsidian Claw
	167677,	--Harmonic Dematerializer
	167835,	--Malformed Herald's Legwraps
	168989,	--Hyperthread Wristwraps (300142 SPELLID)
	167672,	--Cyclotronic Blast (293491 SPELLID)
	165576,	--Tidestorm Codex (289885 SPELLID)
	}

	for i=1,#extra_items do if IsEquippedItem ( extra_items[i] ) then table.insert( equipped_items, extra_items[i] ) end end


	-- actions.precombat+=/variable,name=disable_combustion,op=reset
	-- disable_combustion = nil (FIXME)
	-- # This variable sets the time at which Rune of Power should start being saved for the next Combustion phase
	-- actions.precombat+=/variable,name=combustion_rop_cutoff,op=set,value=60
	combustion_rop_cutoff = 60
	
	combustion_on_use = combustion_trinket_equipped
	-- actions.precombat+=/variable,name=font_double_on_use,op=set,value=equipped.azsharas_font_of_power&variable.combustion_on_use
	font_double_on_use = font_equipped and combustion_on_use == 1
	-- # This variable determines when Azshara's Font of Power is used before the pull if bfa.font_of_power_precombat_channel is not specified.
	-- actions.precombat+=/variable,name=font_of_power_precombat_channel,op=set,value=18,if=variable.font_double_on_use&variable.font_of_power_precombat_channel=0
	font_of_power_precombat_channel = font_double_on_use and 18 or nil
	-- # Items that are used outside of Combustion are not used after this time if they would put a trinket used with Combustion on a sharded cooldown.
	-- actions.precombat+=/variable,name=on_use_cutoff,op=set,value=20*variable.combustion_on_use&!variable.font_double_on_use+40*variable.font_double_on_use+25*equipped.azsharas_font_of_power&!variable.font_double_on_use+8*equipped.manifesto_of_madness&!variable.font_double_on_use
	on_use_cutoff = ( 20 * ( combustion_on_use and not font_double_on_use and 1 or 0 ) + 40 * ( font_double_on_use and 1 or 0 ) + 25 * ( font_equipped and not font_double_on_use and 1 or 0 ) + 8 * ( IsEquippedItem(174103) and not font_double_on_use and 1 or 0 ) )
	-- # Combustion is only used without Worldvein Resonance or Memory of Lucid Dreams if it will be available at least this many seconds before the essence's cooldown is ready.
	-- actions.precombat+=/variable,name=hold_combustion_threshold,op=reset,default=20
	-- hold_combustion_threshold = 20

	-- actions+=/variable,name=time_to_combustion,op=set,value=cooldown.combustion.remains
	time_to_combustion = combustion_cd

	-- actions+=/variable,name=fire_blast_pooling,value=talent.rune_of_power.enabled&cooldown.rune_of_power.remains<cooldown.fire_blast.full_recharge_time&(variable.time_to_combustion>variable.combustion_rop_cutoff|variable.disable_combustion|firestarter.active)&(cooldown.rune_of_power.remains<target.time_to_die|action.rune_of_power.charges>0)|!variable.disable_combustion&variable.time_to_combustion<action.fire_blast.full_recharge_time+cooldown.fire_blast.duration*azerite.blaster_master.enabled&!firestarter.active&variable.time_to_combustion<target.time_to_die|talent.firestarter.enabled&firestarter.active&firestarter.remains<cooldown.fire_blast.full_recharge_time+cooldown.fire_blast.duration*azerite.blaster_master.enabled
	fire_blast_pooling = rune_of_power_enabled and rune_of_power_cd < fire_blast_full_recharge_time and ( time_to_combustion > combustion_rop_cutoff or disable_combustion or firestarter_active ) and ( rune_of_power_cd < t_ttd or rune_of_power_charges > 0 ) or not disable_combustion and time_to_combustion < fire_blast_full_recharge_time + fire_blast_base_cd * ( blaster_master_enabled and 1 or 0 ) and not firestarter_active and time_to_combustion < t_ttd or firestarter_enabled and firestarter_active and firestarter_remains < fire_blast_full_recharge_time + fire_blast_next_charge_cd * ( blaster_master_enabled and 1 or 0 )
	-- actions+=/variable,name=phoenix_pooling,value=talent.rune_of_power.enabled&cooldown.rune_of_power.remains<cooldown.phoenix_flames.full_recharge_time&(variable.time_to_combustion>variable.combustion_rop_cutoff|variable.disable_combustion)&(cooldown.rune_of_power.remains<target.time_to_die|action.rune_of_power.charges>0)|!variable.disable_combustion&variable.time_to_combustion<action.phoenix_flames.full_recharge_time&variable.time_to_combustion<target.time_to_die
	phoenix_pooling = rune_of_power_enabled and rune_of_power_cd < phoenix_flames_full_recharge_time and ( time_to_combustion > combustion_rop_cutoff or disable_combustion ) and ( rune_of_power_cd < t_ttd or rune_of_power_charges > 0 ) or not disable_combustion and time_to_combustion < phoenix_flames_full_recharge_time and time_to_combustion < t_ttd
	
	--variable,name=phoenix_pooling,value=!variable.disable_combustion&variable.time_to_combustion<action.phoenix_flames.full_recharge_time-action.shifting_power.full_reduction*
	--(cooldown.shifting_power.remains<variable.time_to_combustion)&variable.time_to_combustion<fight_remains|runeforge.sun_kings_blessing|time<5
	--phoenix_pooling = not disable_combustion and time_to_combustion < phoenix_flames_full_recharge_time - full_reduction * ((_spellCooldown(314791) < time_to_combustion) and 1 or 0) and time_to_combustion < t_ttd

	--	variable,name=combustion_flamestrike,op=set,if=variable.combustion_flamestrike=0,value=3*talent.flame_patch+6*!talent.flame_patch
	-- This variable specifies the number of targets at which Hot Streak Flamestrikes are used during Combustion.
	if combustion_flamestrike == 0 then
		combustion_flamestrike = 3 * (flame_patch_enabled and 1 or 0) + 6 * (not flame_patch_enabled and 1 or 0)
	end

	if pool_them_fbs then
		fire_blast_pooling = true
	end

	if not combustion_learned then
		fire_blast_pooling,phoenix_pooling = nil,nil
	end

	if not auto_combust then
		time_to_combustion = max( time_to_combustion, 40 )
	end

	if solo_mode and not Squid_Burst then
		time_to_combustion = 400
		disable_combustion = true
	end

	local flamestrike_ready

	-- # Executed before combat begins. Accepts non-harmful actions only.
	local function precombat()

		if not combat then
			-- actions.precombat+=/arcane_intellect
			local someone_missing_int
			for i=1,#Friends do if not UnitBuffID( Friends[i], 1459 ) and _distance( Friends[i] ) < 40 and not UnitIsCharmed( Friends[i] ) then
				someone_missing_int = true
			end end
			-- dont rebuff while casting
			if someone_missing_int and not UnitCastingInfo( "player" ) then
				if not recent_buff or time - recent_buff > 6 then
					if _Cast( 1459, "player" ) then
						recent_buff = time
						Squid_Alert( "Rebuff", nil, nil, nil, 1459 )

						return true
					end
				end
			end
		end
		
		if not t then return end
		-- actions.precombat=flask
		-- actions.precombat+=/food
		-- actions.precombat+=/augmentation
		
		
		-- actions.precombat+=/snapshot_stats
		if not player_combat then
			-- actions.precombat+=/use_item,name=azsharas_font_of_power,if=!variable.disable_combustion
			-- if font_equipped and not disable_combustion then
			-- 	if GetItemCD (( 169314 ) ) == 0 then
			-- 		UseItemByName( tostring( GetItemInfo( 169314 ) ) ) 
			-- 		Squid_Alert( "Font of Power", nil, nil, nil, 296962 )
			-- 	end
			-- end
			-- actions.precombat+=/mirror_image
			if dbm_countdown <= 6 and _Cast( 55342 ) then
				Squid_Alert( "Mirror Image", nil, nil, nil, 55342 )
				return true
			end
			-- actions.precombat+=/potion
			if dbm_countdown <= 6 and t and UnitClassification(t) == "worldboss" and combustion_cd < 5 and best_pot and SQUID.pre_pot_enabled then
				if GetItemCD ( ( best_pot ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( best_pot ) ) )
					Squid_Alert( "Pre Pot", nil, nil, nil, 300714 )
				end
			end
			-- actions.precombat+=/pyroblast
			if dbm_countdown <= pyro_cast_time + latency + ( t_dist * .015 ) then
				_Cast( 11366, t, true )
			end
		end
	end

	local function items_combustion()

		if UnitCastingInfo("player") or UnitChannelInfo("player") then return end

		-- actions.items_combustion=use_item,name=ignition_mages_fuse
		--[[
		if tContains( equipped_items, 159615 ) and GetItemCD ( ( 159615 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 159615 ) ) )
			Squid_Alert( "Ignition Mage's Fuse", nil, nil, nil, 271117 )
		end
		--]]
		-- actions.items_combustion+=/cancel_buff,use_off_gcd=1,name=manifesto_of_madness_chapter_one,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,name=azurethos_singed_plumage,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,effect_name=gladiators_badge,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,effect_name=gladiators_medallion,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,name=balefire_branch,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,name=shockbiters_fang,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,name=tzanes_barkspines,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,name=ancient_knot_of_wisdom,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,name=neural_synapse_enhancer,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		-- actions.items_combustion+=/use_item,use_off_gcd=1,name=malformed_heralds_legwraps,if=buff.combustion.up|action.meteor.in_flight&action.meteor.in_flight_remains<=0.5
		if combustion or meteor_in_flight and ( meteor_in_flight_remains <= .85 or hot_streak and fire_blast_charges_frac >= fire_blast_max_charges - .3 ) or lucid_dreams_up and meteor_cd > gcd and not meteor_in_flight or worldvein_major and worldvein_cd >= 48 then

			if UnitBuffID("player",313948) then
				RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
				Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
			end

			if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
				Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
			end

			if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
			or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
			or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 ) 
			or ( tContains( equipped_items, 175884 ) and GetItemCD ( ( 175884 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
				UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
				UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
				Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
			end

			if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
			or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
			or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
				UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
				Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
			end

			if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
				Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
			end

			if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
				Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
			end

			if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
				Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
			end

			if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
			or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
				UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
				Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
			end

			if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
				Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
			end

			if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
				Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
			end

			if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
				Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
			end

		end

	end

	local function items_high_priority()
		if UnitCastingInfo("player") or UnitChannelInfo("player") then return end
		
		-- want an accurate time to combust here so we don't use alt on use right before combust
		-- actions+=/variable,name=time_to_combustion,op=set,value=cooldown.combustion.remains
		local time_to_combustion = combustion_cd
		if solo_mode and not Squid_Burst then
			time_to_combustion = 400
		end

		-- actions.items_high_priority=call_action_list,name=items_combustion,if=!variable.disable_combustion&(talent.rune_of_power.enabled&variable.time_to_combustion<=action.rune_of_power.cast_time|variable.time_to_combustion<=0)&!firestarter.active|buff.combustion.up
		if not disable_combustion and ( rune_of_power_enabled and time_to_combustion <= rune_of_power_cast_time or time_to_combustion <= 0 ) and not firestarter_active or combustion then
			items_combustion()
		end
		if Squid_Burst and ( tContains( equipped_items, 172669 ) or tContains( equipped_items, 167380 ) or tContains( equipped_items, 165058 ) ) then
			if GetItemCD(172669) <= 6 or GetItemCD(167380) <= 6 or GetItemCD(165058) <= 6 then
				return
			end
		end
		-- actions.items_high_priority+=/use_items
		-- actions.items_high_priority+=/use_item,name=manifesto_of_madness,if=!equipped.azsharas_font_of_power&variable.time_to_combustion<8
		if not font_equipped and time_to_combustion < 8 then
			if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
				Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
				return true
			end
		end
		-- actions.items_high_priority+=/use_item,name=azsharas_font_of_power,if=variable.time_to_combustion<=5+15*variable.font_double_on_use&!variable.disable_combustion
		if font_equipped then
			-- if time_to_combustion <= 5 + 15 * (font_double_on_use and not disable_combustion and 1 or 0) then
			-- 	if GetItemCD ( ( 169314 ) ) == 0 then
			-- 		UseItemByName( tostring( GetItemInfo ( 169314 ) ) )
			-- 		Squid_Alert( "Font of Power", nil, nil, nil, 296962 )
			-- 		return true
			-- 	end
			-- end
		end
		-- actions.items_high_priority+=/use_item,name=rotcrusted_voodoo_doll,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
		-- actions.items_high_priority+=/use_item,name=aquipotent_nautilus,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
		-- actions.items_high_priority+=/use_item,name=shiver_venom_relic,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
		-- actions.items_high_priority+=/use_item,name=forbidden_obsidian_claw,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
		if t_ttd > 7.5 and ( time_to_combustion > on_use_cutoff or disable_combustion ) and ( not Squid_Burst or combustion_cd > 20 ) then
			if tContains( equipped_items, 159624 ) and GetItemCD ( ( 159624 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 159624 ) ) )
				Squid_Alert( "Voodoo Doll", nil, nil, nil, 271462 )
				return true
			end
			if tContains( equipped_items, 169305 ) and GetItemCD ( ( 169305 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 169305 ) ) )
				Squid_Alert( "Aquipotent Nautilus", nil, nil, nil, 306146 )
				return true
			end
			if tContains( equipped_items, 168905 ) and GetItemCD ( ( 168905 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 168905 ) ) )
				Squid_Alert( "Shiver Venom Relic", nil, nil, nil, 301834 )
				return true
			end
			if tContains( equipped_items, 173944 ) and GetItemCD ( ( 173944 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 173944 ) ) )
				Squid_Alert( "Obsidian Claw", nil, nil, nil, 313148 )
				return true
			end
		end

		-- actions.items_high_priority+=/use_item,effect_name=harmonic_dematerializer
		if tContains( equipped_items, 167677 ) and GetItemCD ( ( 167677 ) ) == 0 then
			UseItemByName( tostring( GetItemInfo ( 167677 ) ) )
			Squid_Alert( "Harmonic Dematerializer", nil, nil, nil, 293512 )
			return true
		end

		-- actions.items_high_priority+=/use_item,name=malformed_heralds_legwraps,if=variable.time_to_combustion>=55&buff.combustion.down&variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
		-- actions.items_high_priority+=/use_item,name=ancient_knot_of_wisdom,if=variable.time_to_combustion>=55&buff.combustion.down&variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
		if time_to_combustion >= 55 and not combustion and time_to_combustion > on_use_cutoff or disable_combustion then
			if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
				Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
				return true
			end
			if tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
				Squid_Alert( "Ancient Knot of Wisdom", nil, nil, nil, 278267 )
				return true
			end
			if tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
				Squid_Alert( "Ancient Knot of Wisdom", nil, nil, nil, 278267 )
				return true
			end
		end
		
		-- actions.items_high_priority+=/use_item,name=neural_synapse_enhancer,if=variable.time_to_combustion>=45&buff.combustion.down&variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
		if time_to_combustion >= 45 and not combustion and time_to_combustion > on_use_cutoff or disable_combustion then
			if _HP("player") > 10 then
				if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
					Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
					return true
				end
			end
		end

	end

	local function active_talents()
		if not t then debug_print("returning on fire_blast (combust, 1)") return end
		-- actions.active_talents=living_bomb,if=active_enemies>1&buff.combustion.down&(variable.time_to_combustion>cooldown.living_bomb.duration|variable.time_to_combustion<=0|variable.disable_combustion)
		if (not single_target or not t_is_boss) and enemies_around_target > 1 and not combustion and ( time_to_combustion > 9.9 or time_to_combustion <= 0 or disable_combustion ) and (not hot_streak or hot_streak_remains > gcd + buffer) then
			if _Cast( 44457, t ) then return true end
		end
		-- actions.active_talents+=/meteor,if=buff.rune_of_power.up&(firestarter.remains>cooldown.meteor.duration|!firestarter.active)|cooldown.rune_of_power.remains>target.time_to_die&action.rune_of_power.charges<1|(cooldown.meteor.duration<variable.time_to_combustion|variable.time_to_combustion<=0|variable.disable_combustion)&!talent.rune_of_power.enabled&(cooldown.meteor.duration<firestarter.remains|!talent.firestarter.enabled|!firestarter.active)
		if meteor_enabled then
			if ( 45 < time_to_combustion or time_to_combustion <= 0 or disable_combustion ) or max(rune_of_power_cd,combustion_cd) > t_ttd and t_is_boss and rune_of_power_charges < 1 or ( 45 < time_to_combustion or time_to_combustion <= 0 or disable_combustion ) and not rune_of_power_enabled and ( 45 < firestarter_remains or not firestarter_enabled or not firestarter_active ) then
				if t_ttd > 3 or combustion or rune_of_power_up then
					if not _isMoving(t) and _AeCast( 153561, t, 40, 8 ) then
						Squid_Alert( "Meteor", nil, nil, nil, 153561 )
						return true
					elseif _isMoving(t) and _aeCastInMovingDirection( 153561, t, GetUnitSpeed(t)/1.15, 40 ) then
						Squid_Alert( "Meteor", nil, nil, nil, 153561 )
						return true
					end
				end
			end
		end
	end

	if meteor_key then
		if current_target then
			if _AeCast( 153561, current_target, 38.5, 8 ) then
				Squid_Alert( "Meteor", nil, nil, nil, 153561 )
				return true
			end
		end
	end

	-- had to split combustion phase into 2 parts, too many upvalues. this is 2nd part
	local function combustion_phase_2()
		
		-- actions.combustion_phase+=/flamestrike,if=((talent.flame_patch.enabled&active_enemies>2)|active_enemies>6)&buff.hot_streak.react&!azerite.blaster_master.enabled
		fs_count = ( flame_patch_enabled and 3 or 8 + ( ( t_ahp > min_combust_health or t_is_boss ) and 6 or 0 ) ) 
		if not single_target and hot_streak and not blaster_master_enabled then
			-- if active_enemies >= fs_count then flamestrike_ready = true end
			if aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ), fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
				return true
			end
		end
		
		-- actions.combustion_phase+=/pyroblast,if=buff.pyroclasm.react&buff.combustion.remains>cast_time
		if pyroclasm and combustion_remains > pyro_cast_time and pyroclasm_remains > pyro_cast_time + .25 and ( not flamestrike_ready or gcd_remains <= 0 ) then
			local t = important_explosive or t
			if _Cast( 11366, t, true ) then debug_print("returning on pyro (combust 2, 1)") return true end
		end
		
		if facing_target then
			-- actions.combustion_phase+=/pyroblast,if=buff.hot_streak.react
			if hot_streak and ( not flame_strike_ready or gcd_remains <= .025 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyro (combust 2, 2)") return true end
			end
			-- actions.combustion_phase+=/pyroblast,if=prev_gcd.1.scorch&buff.heating_up.up
			if not meteor_in_flight and heating_up and player_casting_guaranteed_crit and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyro (combust 2, 3)") return true end
			end
		end

		-- actions.combustion_phase+=/phoenix_flames
		if (fire_blast_charges <= 1 or combustion_remains <= gcd+buffer) and (not fb_used or time - fb_used > .2 + latency) then
			if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on pf (combust 2, 1)") return true end
		end

		if phoenix_flames_charges == phoenix_flames_max_charges and (not fb_used or time - fb_used > .2 + latency) and not hot_streak and not heating_up then
			if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on pf (combust 2, 2)") return true end
		end

		-- actions.combustion_phase+=/scorch,if=buff.combustion.remains>cast_time&buff.combustion.up|buff.combustion.down
		if combustion_remains > scorch_cast_time and fire_blast_charges == 0 then
			-- local t = explosive or t -- no scorch explosive?
			if _Cast( 2948, t, true ) then --[[print("Combust Scorch 1")]] return true end
		end
		
		-- actions.combustion_phase+=/living_bomb,if=buff.combustion.remains<gcd.max&active_enemies>1
		if (not single_target or not t_is_boss) and combustion_remains < gcd and enemies_around_target > 1 then
			if _Cast( 44457, t ) then return true end
		end
		
		-- actions.combustion_phase+=/dragons_breath,if=buff.combustion.remains<gcd.max&buff.combustion.up
		if combustion_remains < gcd and combustion then
			if t_dist < 6.5 and facing_target then
				if _Cast( 31661 ) then return true end
			end
		end
		
		-- actions.combustion_phase+=/scorch,if=target.health.pct<=30&talent.searing_touch.enabled
		if ( scorch_execute_ready or combustion_remains > scorch_cast_time ) and searing_touch_enabled then
			if fire_blast_charges == 0 and fire_blast_next_charge_cd > .5 or not combustion then
				--other enemies
				for i=1,#Enemies do
					if ready_to_attack(Enemies[i]) and _HP(Enemies[i]) < 30 and squid_ttd(Enemies[i]) > scorch_cast_time then
						if _Cast( 2948, Enemies[i], true ) then --[[print("Combustion Scorch Execute")]] return true end
					end 
				end
				--target
				if _Cast( 2948, t, true ) then --[[print("Combust Scorch 2")]] return true end
			end
		end

	end

	local function combustion_phase()
		-- print("doing it!")
		-- if t and t_ttd < 3 and not combustion and not lucid_dreams_up and not Squid_Burst then return end
		--counterspell for lucid dreams proc
		-- if not SQUID.i_am_kane then
		-- 	if lucid_minor or lucid_major then
		-- 		if not wristwraps_used or time - wristwraps_used > .5 then
		-- 			if fire_blast_full_recharge_time > fire_blast_base_cd + gcd_remains + ( ( hot_streak or combustion and ( pyro_flying or fb_flying ) and heating_up ) and gcd or 0) + (not rune_of_power_up and rune_of_power_cast_time or 0) + (meteor_enabled and meteor_cd < gcd and gcd or 0) and ( not combustion or not ( tContains( equipped_items, 168989 ) and GetItemCD ( ( 168989 ) ) == 0 ) ) then
		-- 				if t_is_boss or groupsize ~= 5 then
		-- 					if _spellCooldown(2139) == 0 then
		-- 						local e
		-- 						for i=1,#Enemies do 
		-- 							e = Enemies[i]
		-- 							if not UnitCastingInfo(e) and not UnitChannelInfo(e) then
		-- 								if _Cast( 2139, e, true ) then return end
		-- 							end
		-- 						end
		-- 					end
		-- 				end
		-- 			end
		-- 		end
		-- 	end
		-- end
		--use fire blast when sitting on full stacks
		if fire_blast_charges == fire_blast_max_charges and phoenix_flames_charges == phoenix_flames_max_charges and not hot_streak and not heating_up then
			if not fb_used or time - fb_used > .2 + latency then
				local t = explosive or t
				if _Cast( 108853, t, true ) then
					--print("Combust Fireblast 1")
					fb_used = time
					debug_print("returning on fire_blast (combust, 1)")
					return true
				end
			end
		end
		-- # Combustion phase prepares abilities with a delay, then launches into the Combustion sequence
		-- actions.combustion_phase=lights_judgment,if=buff.combustion.down
		-- actions.combustion_phase+=/bag_of_tricks,if=buff.combustion.down
		-- actions.combustion_phase+=/living_bomb,if=active_enemies>1&buff.combustion.down
		if not combustion then
			local player_race = UnitRace("player")
			if player_race == "Lightforged Draenei" and _Cast( 255647, t, true ) then
				Squid_Alert( "Light's Judgment", nil, nil, nil, 255647 )
			end
			if player_race == "Vulpera" and _Cast( 312411, t, true ) then
				Squid_Alert( "Bag of Tricks", nil, nil, nil, 312411 )
			end
			if enemies_around_target > 1 and (not lucid_dreams_up or lucid_dreams_remains > 10) then
				if _Cast( 44457, t ) then return true end
			end
		end
		-- # During Combustion, Fire Blasts are used to generate Hot Streaks and minimize the amount of time spent executing other spells. For standard Fire, Fire Blasts are only used when Heating Up is active or when a Scorch cast is in progress and Heating Up and Hot Streak are not active. With Blaster Master and Flame On, Fire Blasts can additionally be used while Hot Streak and Heating Up are not active and a Pyroblast is in the air and also while casting Scorch even if Heating Up is already active. The latter allows two Hot Streak Pyroblasts to be cast in succession after the Scorch. Additionally with Blaster Master and Flame On, Fire Blasts should not be used unless Blaster Master is about to expire or there are more than enough Fire Blasts to extend Blaster Master to the end of Combustion.
		-- actions.combustion_phase+=/fire_blast,use_while_casting=1,use_off_gcd=1,if=charges>=1&((action.fire_blast.charges_fractional+(buff.combustion.remains-buff.blaster_master.duration)%cooldown.fire_blast.duration-(buff.combustion.remains)%(buff.blaster_master.duration-0.5))>=0|!azerite.blaster_master.enabled|!talent.flame_on.enabled|buff.combustion.remains<=buff.blaster_master.duration|buff.blaster_master.remains<0.5|equipped.hyperthread_wristwraps&cooldown.hyperthread_wristwraps_300142.remains<5)&buff.combustion.up&(!action.scorch.executing&!action.pyroblast.in_flight&buff.heating_up.up|action.scorch.executing&buff.hot_streak.down&(buff.heating_up.down|azerite.blaster_master.enabled)|azerite.blaster_master.enabled&talent.flame_on.enabled&action.pyroblast.in_flight&buff.heating_up.down&buff.hot_streak.down)
		if fire_blast_charges >= 1 and ( ( fire_blast_charges_frac + ( combustion_remains - 3 ) % fire_blast_base_cd - ( combustion_remains ) % ( 3 - 0.5 ) ) >= 0 or not blaster_master_enabled or not flame_on or combustion_remains <= blaster_master_remains or blaster_master_remains < 0.5 or tContains( equipped_items, 168989 ) and GetItemCD( 168989 ) < 5 ) and combustion and ( player_cast_id ~= 2948 and not pyro_flying and heating_up or player_cast_id == 2948 and not hot_streak and ( not heating_up or blaster_master_enabled ) or blaster_blaster_enabled and flame_on and pyro_flying and not hot_streak ) then
			if not hot_streak and (player_cast_id ~= 2948 or not heating_up) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						fb_used = time
						debug_print("returning on fire_blast (combust, 2)")
						return true
					end
				end
			end
		end
		--use fire blast if capped on charges when not using meteor or rop
		if fire_blast_charges == fire_blast_max_charges and not meteor_enabled and not rune_of_power_enabled and not hot_streak then
			if not fb_used or time - fb_used > .25 + latency then
				if _Cast( 108853, t, true ) then
					--print("Combust Fireblast 2")
					fb_used = time
					debug_print("returning on fire_blast (combust, 3)")
					return true
				end
			end
		end
		-- actions.combustion_phase+=/rune_of_power,if=buff.combustion.down
		-- if not combustion then
		-- 	if not _isMoving("player") and _Cast( 116011 ) then
		-- 		Squid_Alert( "Rune of Power", nil, nil, nil, 116011 )
		-- 		return true
		-- 	end
		-- end
		-- # A Fire Blast should be used to apply Blaster Master while casting Rune of Power when using Blaster Master, Flame On, and Meteor. If only Memory of Lucid Dreams Minor is equipped, this line is ignored because it will sometimes result in going into Combustion with few Fire Blast charges.
		-- actions.combustion_phase+=/fire_blast,use_while_casting=1,if=azerite.blaster_master.enabled&(essence.memory_of_lucid_dreams.major|!essence.memory_of_lucid_dreams.minor)&talent.meteor.enabled&talent.flame_on.enabled&buff.blaster_master.down&(talent.rune_of_power.enabled&action.rune_of_power.executing&action.rune_of_power.execute_remains<0.6|(variable.time_to_combustion<=0|buff.combustion.up)&!talent.rune_of_power.enabled&!action.pyroblast.in_flight&!action.fireball.in_flight)
		if fire_blast_charges_frac >= 1.9 then
			if blaster_master_enabled and meteor_enabled and flame_on and blaster_master_remains < .25 and ( rune_of_power_enabled and player_cast_id == 116011 and player_cast_time_left < 0.6 or ( time_to_combustion <= 0 or combustion ) and not rune_of_power_enabled and not pyro_flying and not fb_flying ) and (not hot_streak or blaster_master_stacks >= 2) then
				if not fb_used or time - fb_used > .25 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						--print("Combust Fireblast 5")
						fb_used = time
						debug_print("returning on fire_blast (combust, 4)")
						return true
					end
				end
			end
		end
		-- actions.combustion_phase+=/call_action_list,name=active_talents
		if active_talents() then return true end
		-- actions.combustion_phase+=/combustion,use_off_gcd=1,use_while_casting=1,if=((action.meteor.in_flight&action.meteor.in_flight_remains<=0.5)|!talent.meteor.enabled)&(buff.rune_of_power.up|!talent.rune_of_power.enabled)
		-- removing the delay on combusting while meteor is in flight
		if ( meteor_in_flight and ( meteor_in_flight_remains <= 1.5 + latency or hot_streak and fire_blast_charges_frac >= fire_blast_max_charges - 1 or SQUID.wildi_mode ) ) or not meteor_enabled or Squid_Burst then
			if _spellCooldown( 190319 ) <= .2 and player_cast_time_left <= buffer + .3 then
				CastSpellByID( 190319 )
				Squid_Alert_Big( "Combustion", nil, nil, nil, 190319 )
				debug_print("returning on combustion (combust, 44)")
				return true
			end
		end
		-- actions.combustion_phase+=/potion
		if best_pot and SQUID.pre_pot_enabled then
			if GetItemCD ( ( best_pot ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( best_pot ) ) )
				Squid_Alert( tostring( GetItemInfo ( best_pot ) ), nil, nil, nil, 300714 )
				-- return true
			end
		end
		-- actions.combustion_phase+=/blood_fury
		-- actions.combustion_phase+=/berserking
		-- actions.combustion_phase+=/fireblood
		-- actions.combustion_phase+=/ancestral_call
		_Cast( 33697 )
		_Cast( 26297 )
		_Cast( 265221 )
		_Cast( 274738 )

		-- if meteor_in_flight and meteor_in_flight_remains < scorch_cast_time and time_to_combustion <= scorch_cast_time then
		-- 	if _Cast( 2948, t, true ) then return true end
		-- end

		--maintain blaster master during meteor drop > combust gap
		-- if not hot_streak and blaster_master_enabled and ( meteor_in_flight or not meteor_enabled ) and ( rune_of_power_up or not rune_of_power_enabled ) and blaster_master_up and blaster_master_remains < .25 then
		-- 	if not fb_used or time - fb_used > .15 then
		-- 		if _Cast( 108853, t, true ) then
		-- 			fb_used = time
		-- 			return true
		-- 		end
		-- 	end
		-- end

		combustion_phase_2() -- combustion pt 2!
		
		if time_to_combustion <= gcd then debug_print("returning on tiem to combust (combust, 44)") return end

	end

	local function rop_phase()
		-- actions.rop_phase=rune_of_power
		if not rune_of_power_up and _Cast( 116011 ) then debug_print("returning on rop (rop_phase, 1)") return true end
		-- actions.rop_phase+=/flamestrike,if=(talent.flame_patch.enabled&active_enemies>1|active_enemies>4)&buff.hot_streak.react
		fs_count = ( flame_patch_enabled and 2 or 6 + ( ( t_ahp > min_combust_health or t_is_boss ) and 6 or 0 ) )
		if not single_target and hot_streak then
			-- if active_enemies >= fs_count then flamestrike_ready = true end
			if aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ), fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
				debug_print("returning on fs (rop, 1)")
				return true
			end
		end
		if rune_of_power_remains > fireball_cast_time + buffer and (not scorch_execute_ready or worldvein_major and combustion_cd < worldvein_cd) then
			-- alert that we are holding a hot streak so the player stands still for fireball
			if hot_streak and fire_blast_charges_frac < 2.75 and not pyro_flying and not firestarter_active and player_cast_id ~= 133 and _isMoving("player") and t_ttd > fireball_cast_time + gcd and t_hp > 30 then
				Squid_Alert_Big("Stand Still","(Fireball > Pyro)",nil,.35,133)
			end
			-- hot streak < fireball cast
			if hot_streak and hot_streak_remains <= fireball_cast_time + buffer and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyro (rop, 1)") return true end
			end
			-- fireball with hot streak proc
			if not fireball_cast_delay or time - fireball_cast_delay > .2 then
				if hot_streak and not _isMoving("player") and not UnitCastingInfo("player") and facing_target and t_ttd > fireball_cast_time + gcd then
					if _Cast( 133, t) then debug_print("returning on fb (rop, 1)") return true end
				end
			end
			-- actions.standard_rotation+=/pyroblast,if=buff.hot_streak.react&(prev_gcd.1.fireball|firestarter.active|action.pyroblast.in_flight)
			if facing_target and hot_streak and ( player_cast_id == 133 or firestarter_active or pyro_flying or fire_blast_charges_frac >= 2.75 or scorch_execute_ready ) and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyro (rop, 2)") return true end
			end
		else
			-- actions.rop_phase+=/pyroblast,if=buff.hot_streak.react
			if hot_streak and facing_target and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyro (rop, 3)") return true end
			end
		end
		-- actions.rop_phase+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=!(talent.flame_patch.enabled&active_enemies>2|active_enemies>5)&(!firestarter.active&(variable.time_to_combustion>0|variable.disable_combustion))&(!buff.heating_up.react&!buff.hot_streak.react&!prev_off_gcd.fire_blast&(action.fire_blast.charges>=2|(action.phoenix_flames.charges>=1&talent.phoenix_flames.enabled)|(talent.alexstraszas_fury.enabled&cooldown.dragons_breath.ready)|(talent.searing_touch.enabled&target.health.pct<=30)))
		if not ( flame_patch_enabled and active_enemies > 2 or active_enemies > 5 ) and ( not firestarter_active and ( time_to_combustion > 0 or disable_combustion ) ) and ( not heating_up and not hot_streak and PlayerSpellCasts[1] ~= 108853 and ( fire_blast_charges >= 2 or ( phoenix_flames_charges >= 1 and phoenix_flames_enabled ) or ( alexstraszas_fury_enabled and db_cd <= gcd_remains ) or ( scorch_execute_ready ) ) ) then
			if not fb_used or time - fb_used > .2 + latency then
				local t = explosive or t
				if _Cast( 108853, t, true ) then
					-- print("RoP Fireblast 1")
					fb_used = time
					debug_print("returning on fire_blast (rop, 1)")
					return true
				end
			end
		end
		-- actions.rop_phase+=/call_action_list,name=active_talents
		active_talents()
		-- actions.rop_phase+=/pyroblast,if=buff.pyroclasm.react&cast_time<buff.pyroclasm.remains&buff.rune_of_power.remains>cast_time
		if pyroclasm and pyro_cast_time < pyroclasm_remains and rune_of_power_remains > pyro_cast_time and ( not flamestrike_ready or gcd_remains <= 0 ) then
			local t = important_explosive or t
			if _Cast( 11366, t, true ) then debug_print("returning on pyro (rop, 4)") return true end
		end
		-- actions.rop_phase+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=!(talent.flame_patch.enabled&active_enemies>2|active_enemies>5)&(!firestarter.active&(variable.time_to_combustion>0|variable.disable_combustion))&(buff.heating_up.react&(target.health.pct>=30|!talent.searing_touch.enabled))
		if not ( flame_patch_enabled and active_enemies > 2 or active_enemies > 5 ) and ( not firestarter_active and ( time_to_combustion > 0 or disable_combustion ) ) and ( heating_up and ( not scorch_execute_ready ) ) then
			if not fb_used or time - fb_used > .2 + latency then
				local t = explosive or t
				if _Cast( 108853, t, true ) then
					-- print("RoP Fireblast 2")
					fb_used = time
					debug_print("returning on fire_blast (rop, 2)")
					return true
				end
			end
		end
		-- actions.rop_phase+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=!(talent.flame_patch.enabled&active_enemies>2|active_enemies>5)&(!firestarter.active&(variable.time_to_combustion>0|variable.disable_combustion))&talent.searing_touch.enabled&target.health.pct<=30&(buff.heating_up.react&!action.scorch.executing|!buff.heating_up.react&!buff.hot_streak.react)
		if not ( flame_patch_enabled and active_enemies > 2 or active_enemies > 5 ) and ( not firestarter_active and ( time_to_combustion > 0 or disable_combustion ) ) and scorch_execute_ready and ( heating_up and player_cast_id ~= 2948 or heating_up and not hot_streak ) then
			if not fb_used or time - fb_used > .2 + latency then
				local t = explosive or t
				if _Cast( 108853, t, true ) then
					-- print("RoP Fireblast 3")
					fb_used = time
					debug_print("returning on fire_blast (rop, 3)")
					return true
				end
			end
		end
		-- actions.rop_phase+=/pyroblast,if=prev_gcd.1.scorch&buff.heating_up.up&talent.searing_touch.enabled&target.health.pct<=30&(!talent.flame_patch.enabled|active_enemies=1)
		if player_casting_guaranteed_crit and ( not flame_patch_enabled or active_enemies == 1 ) and ( not flamestrike_ready or gcd_remains <= 0 ) then
			local t = important_explosive or t
			if _Cast( 11366, t, nil, true ) then debug_print("returning on pyro (rop, 4)") return true end
			debug_print("returning on pyro weird return (rop, 123)")
			return true
		end
		-- actions.rop_phase+=/phoenix_flames,if=!prev_gcd.1.phoenix_flames&buff.heating_up.react
		if Prev_GCD( 1 ) ~= 257541 and heating_up and combustion and (not fb_used or time - fb_used > .2 + latency) then
			if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on PF (rop, 1)") return true end
		end
		-- actions.rop_phase+=/scorch,if=target.health.pct<=30&talent.searing_touch.enabled
		if searing_touch_enabled and not hot_streak then
			for i=1,#Enemies do if ready_to_attack(Enemies[i]) and _HP(Enemies[i]) < 30 and squid_ttd(Enemies[i]) > scorch_cast_time then
				if _Cast( 2948, Enemies[i], true ) then debug_print("returning on scorch (rop, 1)") return true end
			end end
		end
		if t_hp <= 30 and searing_touch_enabled and not hot_streak then
			if _Cast( 2948, t, true ) then debug_print("returning on scorch (rop, 2)") return true end
		end
		-- actions.rop_phase+=/dragons_breath,if=active_enemies>2
		-- if active_enemies > 2 and facing_target and t_dist < 6.5 then
		-- 	if _Cast( 31661 ) then return true end
		-- end
		-- # When Hardcasting Flame Strike, Fire Blasts should be used to generate Hot Streaks and to extend Blaster Master.
		-- actions.rop_phase+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=(talent.flame_patch.enabled&active_enemies>2|active_enemies>5)&((variable.time_to_combustion>0|variable.disable_combustion)&!firestarter.active)&buff.hot_streak.down&(!azerite.blaster_master.enabled|buff.blaster_master.remains<0.5)
		if ( flame_patch_enabled and active_enemies >= 4 or active_enemies > 6 ) and not hot_streak and ( not blaster_master_enabled or blaster_master_remains <= buffer ) then
			if not fb_used or time - fb_used > .2 + latency then
				local t = explosive or t
				if _Cast( 108853, t, true ) then
					--print("RoP Fireblast 4")
					fb_used = time
					debug_print("returning on fire_blast (rop, 4)")
					return true
				end
			end
		end
		-- actions.rop_phase+=/flamestrike,if=talent.flame_patch.enabled&active_enemies>2|active_enemies>5
		if not single_target and flame_patch_enabled then
			fs_count = 4
			if aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ), fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
				debug_print("returning on flamestrike (rop, 1)")
				return true
			end
		end
		-- actions.rop_phase+=/fireball
		if _Cast( 133, t) then debug_print("returning on fireball (rop, 1)") return true end
		-- alert that we are not scorching because it would waste a heating up proc
		if not scorch_execute_ready then
			if heating_up and not hot_streak and fire_blast_charges == 0 and fire_blast_next_charge_cd >= scorch_cast_time - buffer then
				Squid_Alert_Big("Stand Still","(Fireball)",nil,.35,133)
			end
		end
		-- scorch while moving if it's a viable option
		if not heating_up or fire_blast_charges > 0 or fire_blast_next_charge_cd < scorch_cast_time - buffer then
			if _Cast( 2948, t, true ) then debug_print("returning on scorch (rop, 44)") return true end
		end
	end

	local function items_low_priority()
		if UnitCastingInfo("player") or UnitChannelInfo("player") then return end
		-- actions.items_low_priority=use_item,name=tidestorm_codex,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion|talent.firestarter.enabled&firestarter.remains>variable.on_use_cutoff
		-- actions.items_low_priority+=/use_item,effect_name=cyclotronic_blast,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion|talent.firestarter.enabled&firestarter.remains>variable.on_use_cutoff
		if time_to_combustion > on_use_cutoff or disable_combustion or firestarter_enabled and firestarter_remains > on_use_cutoff then
			if tContains( equipped_items, 165576 ) and GetItemCD ( ( 165576 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 165576 ) ) )
				Squid_Alert( "Tidestorm Codex", nil, nil, nil, 289885 )
				return true
			end
			if tContains( equipped_items, 167672 ) and GetItemCD ( ( 167672 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 167672 ) ) )
				Squid_Alert( "Cyclotronic Blast", nil, nil, nil, 293491 )
				return true
			end
		end
	end

	local function standard_rotation_2()
		-- actions.standard_rotation+=/call_action_list,name=active_talents
		active_talents()
		-- actions.standard_rotation+=/dragons_breath,if=active_enemies>1
		-- if facing_target and t_dist < 6.5 and active_enemies > 1 then
		-- 	if _Cast( 31661 ) then return true end
		-- end
		-- actions.standard_rotation+=/call_action_list,name=items_low_priority
		items_low_priority()
		-- fireball prio with worldvein combust
		if t_ttd > fireball_cast_time and not heating_up and worldvein_major and combustion_cd > worldvein_cd then
			if _Cast(133,t,true) then debug_print("returning on fireball (standard_rotation 2 , 1)") return true end
		end
		-- actions.standard_rotation+=/scorch,if=target.health.pct<=30&talent.searing_touch.enabled
		if searing_touch_enabled and not hot_streak then
			for i=1,#Enemies do if ready_to_attack(Enemies[i]) and _HP(Enemies[i]) < 30 and squid_ttd(Enemies[i]) > scorch_cast_time then
				if _Cast( 2948, Enemies[i], true ) then debug_print("returning on scorch (standard_rotation 2 , 1)") return true end
			end end
		end
		if t_hp <= 30 and searing_touch_enabled and not hot_streak then
			if _Cast( 2948, t, true ) then debug_print("returning on scorch (standard_rotation 2 , 2)") return true end
		end
		-- -- # When Hardcasting Flame Strike, Fire Blasts should be used to generate Hot Streaks and to extend Blaster Master.
		-- -- actions.standard_rotation+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=!variable.fire_blast_pooling&(talent.flame_patch.enabled&active_enemies>2|active_enemies>9)&((variable.time_to_combustion>0|variable.disable_combustion)&!firestarter.active)&buff.hot_streak.down&(!azerite.blaster_master.enabled|buff.blaster_master.remains<0.5)
		-- if ( flame_patch_enabled and active_enemies > 2 or active_enemies > 9 ) and not hot_streak and ( not blaster_master_enabled or blaster_master_remains <= buffer * 1.08 ) and ( not fire_blast_pooling or fire_blast_charges_frac >= 3 - blaster_master_stacks - (heating_up and heating_up_remains <= buffer and 1 or 0) - .1 and ( rune_of_power_next_charge_cd > fire_blast_next_charge_cd or combustion_cd <= 10 and not auto_combust or auto_combust and not_combusting_target and t_ttd > 3 )  ) then
		-- 	if not fb_used or time - fb_used > .25 + latency then
		-- 		local t = explosive or t
		-- 		if _Cast( 108853, t, true ) then
		-- 			--print("Standard Fireblast 3")
		-- 			fb_used = time
		-- 			debug_print("returning on fireblast (standard_rotation 2 , 1)")
		-- 			return true
		-- 		end
		-- 	end
		-- end
		-- # With enough targets, it is a gain to cast Flamestrike as filler instead of Fireball.
		-- actions.standard_rotation+=/flamestrike,if=talent.flame_patch.enabled&active_enemies>2|active_enemies>9
		fs_count = ( flame_patch_enabled and 4 or 11 + ( ( t_ahp > min_combust_health or t_is_boss ) and 6 or 0 ) )
		if not single_target and aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ) , fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
			debug_print("returning on flamestrike (standard_rotation 2 , 1)")
			return true
		end
		-- actions.standard_rotation+=/fireball
		if _Cast( 133, t) then debug_print("returning on fireball (standard_rotation 2 , 22)") return true end
		-- actions.standard_rotation+=/scorch
		if _Cast( 2948, t, true ) then debug_print("returning on scorch (standard_rotation 2 , 22)") return true end
	end

	local function standard_rotation()
		-- actions.standard_rotation=flamestrike,if=((talent.flame_patch.enabled&active_enemies>1&!firestarter.active)|active_enemies>4)&buff.hot_streak.react
		fs_count = ( flame_patch_enabled and not firestarter_active and 4 or 6 + ( ( t_ahp > min_combust_health or t_is_boss ) and 6 or 0 ) )
		if not single_target and hot_streak then
			-- if active_enemies >= fs_count then flamestrike_ready = true end
			if aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ), fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
				debug_print("returning on flamestrike (standard_rotation, 1)")
				return true
			end
		end
		-- alert that we are holding a hot streak so the player stands still for fireball
		if not scorch_execute_ready then
			if hot_streak and fire_blast_charges_frac < 2.75 and not pyro_flying and not firestarter_active and player_cast_id ~= 133 and _isMoving("player") and t_ttd > fireball_cast_time + gcd and t_hp > 30 then
				Squid_Alert_Big("Stand Still","(Fireball > Pyro)",nil,.35,133)
			end
		end
		-- actions.standard_rotation+=/pyroblast,if=buff.hot_streak.react&buff.hot_streak.remains<action.fireball.execute_time
		if hot_streak and hot_streak_remains <= fireball_cast_time + buffer and ( not flamestrike_ready or gcd_remains <= 0 ) then
			local t = important_explosive or t
			if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 1)") return true end
		end
		-- queue up fireball with pyro
		if not scorch_execute_ready then
			if not fireball_cast_delay or time - fireball_cast_delay > .2 then
				if hot_streak and not _isMoving("player") and not UnitCastingInfo("player") and facing_target and t_ttd > fireball_cast_time + gcd + (solo_mode and 6 or 0) and not UnitBuffID("player",333100) then
					if _Cast( 133, t) then debug_print("returning on fireball (standard_rotation, 1)") return true end
				end
			end
		end
		-- actions.standard_rotation+=/pyroblast,if=buff.hot_streak.react&(prev_gcd.1.fireball|firestarter.active|action.pyroblast.in_flight)
		if facing_target and hot_streak and ( player_cast_id == 133 or UnitBuffID("player",333100) or firestarter_active or pyro_flying or fire_blast_charges_frac >= 2.75 or scorch_execute_ready or (solo_mode and _isMoving("player"))) and ( not flamestrike_ready or gcd_remains <= 0 ) then
			local t = important_explosive or t
			if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 2)") return true end
		end
		-- actions.standard_rotation+=/phoenix_flames,if=charges>=3&active_enemies>2&!variable.phoenix_pooling
		if phoenix_flames_enabled and phoenix_flames_charges >= 3 and active_enemies > 3 and not phoenix_pooling and (not heating_up or combustion) and (not fb_used or time - fb_used > .2 + latency) and (not fb_used or time - fb_used > .2 + latency) then
			if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on phoenix_flames (standard_rotation, 1)") return true end
		end
		-- actions.standard_rotation+=/pyroblast,if=buff.hot_streak.react&target.health.pct<=30&talent.searing_touch.enabled
		if facing_target and hot_streak and scorch_execute_ready and ( not flamestrike_ready or gcd_remains <= 0 ) then
			local t = important_explosive or t
			if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 3)") return true end
		end
		-- actions.standard_rotation+=/pyroblast,if=buff.pyroclasm.react&cast_time<buff.pyroclasm.remains
		if pyroclasm and pyro_cast_time < pyroclasm_remains and ( not flamestrike_ready or gcd_remains <= 0 ) then
			local t = important_explosive or t
			if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 4)") return true end
		end
		-- actions.standard_rotation+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=((variable.time_to_combustion>0|variable.disable_combustion)&buff.rune_of_power.down&!firestarter.active)&!talent.kindling.enabled&!variable.fire_blast_pooling&(((action.fireball.executing|action.pyroblast.executing)&(buff.heating_up.react))|(talent.searing_touch.enabled&target.health.pct<=30&(buff.heating_up.react&!action.scorch.executing|!buff.hot_streak.react&!buff.heating_up.react&action.scorch.executing&!action.pyroblast.in_flight&!action.fireball.in_flight)))
		if ( ( time_to_combustion > 0 or disable_combustion ) and not rune_of_power_up and not firestarter_active ) and not kindling_enabled and not fire_blast_pooling and ( ( ( player_cast_id == 133 or player_cast_id == 11366 ) and ( heating_up ) ) or ( scorch_execute_ready and ( heating_up and player_cast_id ~= 2948 or not hot_streak and not heating_up and player_cast_id == 2948 and not pyro_flying and not fb_flying ) ) ) then
			if not fb_used or time - fb_used > .2 + latency then
				local t = explosive or t
				if _Cast( 108853, t, true ) then
					--print("Standard Fireblast 1")
					fb_used = time
					debug_print("returning on fire_blast (standard_rotation, 1)")
					return true
				end
			end
		end
		-- actions.standard_rotation+=/fire_blast,if=talent.kindling.enabled&buff.heating_up.react&!firestarter.active&(variable.time_to_combustion>full_recharge_time+2+talent.kindling.enabled|variable.disable_combustion|(!talent.rune_of_power.enabled|cooldown.rune_of_power.remains>target.time_to_die&action.rune_of_power.charges<1)&variable.time_to_combustion>target.time_to_die)
		if kindling_enabled and heating_up and not firestarter_active and ( time_to_combustion > fire_blast_full_recharge_time + 2 + ( kindling_enabled and 1 or 0 ) or disable_combustion or ( not rune_of_power_enabled or rune_of_power_next_charge_cd > t_ttd and rune_of_power_charges < 1 ) and time_to_combustion > t_ttd ) then
			if not fb_used or time - fb_used > .2 + latency then
				local t = explosive or t
				if _Cast( 108853, t, true ) then
					fb_used = time
					debug_print("returning on fire_blast (standard_rotation, 2)")
					return true
				end
			end
		end
		-- actions.standard_rotation+=/fire_blast,if=talent.kindling.enabled&buff.heating_up.react&!firestarter.active&(variable.time_to_combustion>full_recharge_time+2+talent.kindling.enabled|variable.disable_combustion|(!talent.rune_of_power.enabled|cooldown.rune_of_power.remains>target.time_to_die&action.rune_of_power.charges<1)&variable.time_to_combustion>target.time_to_die)
		if solo_mode and not hot_streak then
			if not firestarter_active and fire_blast_charges >= 2 - (heating_up and 1 or 0) and not UnitBuffID("player",203277) and (not player_casting_crittable_damage or player_cast_time_left > .5 or heating_up) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						fb_used = time
						debug_print("returning on fire_blast (standard_rotation, 3)")
						return true
					end
				end
			end
		end
		-- actions.standard_rotation+=/pyroblast,if=prev_gcd.1.scorch&buff.heating_up.up&talent.searing_touch.enabled&target.health.pct<=30&((talent.flame_patch.enabled&active_enemies=1&!firestarter.active)|(active_enemies<4&!talent.flame_patch.enabled))
		if player_cast_id == 2948 and heating_up and player_casting_guaranteed_crit and ( ( flame_patch_enabled and active_enemies == 1 and not firestarter_active ) or ( active_enemies < 4 and not flame_patch_enabled ) ) then
			if facing_target and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 6)") return true end
			end
		end
		-- actions.standard_rotation+=/phoenix_flames,if=(buff.heating_up.react|(!buff.hot_streak.react&(action.fire_blast.charges>0|talent.searing_touch.enabled&target.health.pct<=30)))&!variable.phoenix_pooling
		if not hot_streak then
			if ( heating_up or ( not hot_streak and ( fire_blast_charges > 0 or scorch_execute_ready ) ) ) and not phoenix_pooling and (combustion or active_enemies > 4 and not heating_up or phoenix_flames_charges == phoenix_flames_max_charges and not heating_up) and (not fb_used or time - fb_used > .2 + latency) then
				if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on phoenix_flames (standard_rotation, 69)") return true end
			end
		end
		standard_rotation_2()
	end

	local function actions()

		--blazing barrier high prio
		local blazing_hp = 70
		blazing_hp = blazing_hp - (combustion and 40 or 0)
		blazing_hp = blazing_hp - (rune_of_power_up and 20 or 0)

		if (not player_afk or player_combat) and player_hp < blazing_hp and barrier_remains < 5000 then
			if _Cast(235313) then
				Squid_Alert("Blazing Barrier",nil,nil,nil,235313)
				debug_print("returning on blazing_barrier (actions , 1)")
				return
			end
		end

		if not t then debug_print("returning on no valid target (actions , 1)") return end

		-- use the radiant spark
		-- if UnitHealth(t) >= UnitHealth("player")/3.5 then
		-- 	if _Cast(307443,t,true) then
		-- 		Squid_Alert("Radiant Spark", nil, nil, nil, 307443)
		-- 		return true
		-- 	end
		-- end

		-- actions+=/call_action_list,name=items_high_priority
		if items_high_priority() then debug_print("returning on items_high_priority") return true end

		--shifting_power,if=buff.combustion.down&variable.time_to_combustion>full_reduction&(cooldown.rune_of_power.remains>full_reduction|!talent.rune_of_power)&!(buff.infernal_cascade.up&
		--buff.hot_streak.react)&(active_enemies<variable.combustion_shifting_power|active_enemies<variable.combustion_flamestrike|variable.time_to_combustion-full_reduction>cooldown)
		if IsPlayerSpell(314791) and not combustion and time_to_combustion > full_reduction and (rune_of_power_cd > full_reduction or not rune_of_power_enabled) and not (infernal_cascade and hot_streak) and
			(Enemies_Around_Unit('player', 18) < combustion_shifting_power or Enemies_Around_Unit('player', 18) < combustion_flamestrike or time_to_combustion - full_reduction > _spellCooldown(314791)) then
				if fire_blast_charges_frac <= 1.2 then
					_Cast(314791)
				end
		end
		
		-- actions+=/mirror_image,if=buff.combustion.down
		if not combustion and _HP("player") < 40 and t and _distance(t) < 40 then
			if _Cast( 55342 ) then
				Squid_Alert( "Mirror Image", nil, nil, nil, 55342 )
				debug_print("returning on mirror img (actions , 1)")
				return true
			end
		end
		-- actions+=/rune_of_power,if=talent.firestarter.enabled&firestarter.remains>full_recharge_time|variable.time_to_combustion>variable.combustion_rop_cutoff&buff.combustion.down|target.time_to_die<variable.time_to_combustion&buff.combustion.down|variable.disable_combustion
		if firestarter_enabled and firestarter_remains > rune_of_power_full_recharge_time or time_to_combustion > combustion_rop_cutoff and not combustion or t_ttd < time_to_combustion and t_is_boss and not combustion then
			if t_ttd > 8.5 - (time_to_combustion > 45 + gcd_remains and meteor_enabled and meteor_cd <= 3 and 3 or 0) or t_is_boss and instance_type ~= "party" then
				if not _isMoving("player") and _Cast( 116011 ) then
					Squid_Alert( "Rune of Power", nil, nil, nil, 116011 )
					debug_print("returning on rune_of_power~1459")
					return true
				end
			end
		end
		-- actions+=/call_action_list,name=combustion_phase,if=!variable.disable_combustion&(talent.rune_of_power.enabled&variable.time_to_combustion<=action.rune_of_power.cast_time|variable.time_to_combustion<=0)&!firestarter.active|buff.combustion.up
		if combustion_learned and ( time_to_combustion <= 2.5 or combustion ) then
			if (not disable_combustion or combustion or Squid_Burst) and ( rune_of_power_enabled and time_to_combustion <= rune_of_power_cast_time or time_to_combustion <= 0 ) and not firestarter_enabled or combustion or Squid_Burst then
				if ( ( t and t_ttd < 9 and not t_is_dummy ) or not auto_combust or UnitHealth(t) < min_combust_health ) and not Squid_Burst and not combustion then 
					--do nothing
					not_combusting_target = true
					debug_print("returning on not combusting target? (actions , 1)")
				else
					combustion_phase()
					return
				end
			end
		end
		-- # During Firestarter, Fire Blasts are used similarly to during Combustion. Generally, they are used to generate Hot Streaks when crits will not be wasted and with Blaster Master, they should be spread out to maintain the Blaster Master buff.
		-- actions+=/fire_blast,use_while_casting=1,use_off_gcd=1,if=firestarter.active&charges>=1&(!variable.fire_blast_pooling|buff.rune_of_power.up)&(!azerite.blaster_master.enabled|buff.blaster_master.remains<0.5)&(!action.fireball.executing&!action.pyroblast.in_flight&buff.heating_up.up|action.fireball.executing&buff.hot_streak.down|action.pyroblast.in_flight&buff.heating_up.down&buff.hot_streak.down)
		if firestarter_enabled and not hot_streak and not crit_inc then
			if firestarter_active and fire_blast_charges >= 1 and ( not fire_blast_pooling or rune_of_power_up ) and ( not blaster_master_enabled or blaster_master_remains < 0.5 ) and ( player_cast_id ~= 133 and not pyro_flying and heating_up or player_cast_id == 133 and not hot_streak or pyro_flying and not heating_up and not hot_streak ) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						--print("Actions Fireblast 2")
						fb_used = time
						debug_print("returning on fire_blast (actions, 1)")
						return true
					end
				end
			end
		end		
		-- actions+=/call_action_list,name=rop_phase,if=buff.rune_of_power.up&buff.combustion.down
		if rune_of_power_up and not combustion then
			rop_phase()
			debug_print("returning on rop_phase (actions, 1)")
			return
		end
		
		-- actions+=/call_action_list,name=standard_rotation
		standard_rotation()

	end

	precombat()

	if UnitIsVisible( t ) then
		if ( ready_to_attack( t ) or t_is_dummy and dbm_countdown == 1000 and player_combat ) then
			actions()
		end
	end

	--low prio blazing bar
	if not player_afk and barrier_remains < 5000 and not combustion and (not player_combat or player_hp < 15) then
		if _Cast(235313) then
			Squid_Alert("Blazing Barrier",nil,nil,nil,235313)
			return
		end
	end

	-- head=grasping_crown_of_the_deep,id=159252,bonus_id=1617/4820/4775,azerite_powers=168/215/30/13
	-- neck=heart_of_azeroth,id=158075,bonus_id=4929/5814/4936/1600,azerite_level=65
	-- shoulders=amice_of_the_reef_witch,id=168338,bonus_id=4824/1517/4775,azerite_powers=215/168/30/13
	-- back=cloak_of_blessed_depths,id=168602,bonus_id=4800/1517
	-- chest=vestments_of_creeping_terror,id=168337,bonus_id=4824/1517/4775,azerite_powers=378/215/30/13
	-- wrists=hyperthread_wristwraps,id=168989,bonus_id=4779/1472
	-- hands=poens_deepsea_gloves,id=170333,bonus_id=1512
	-- waist=vims_scalecrusher_belt,id=170367,bonus_id=1512
	-- legs=malformed_heralds_legwraps,id=167835,bonus_id=4800/1547
	-- feet=akanas_reefstrider_soles,id=170140,bonus_id=1512
	-- finger1=overclocking_bit_band,id=169159,bonus_id=4779/1472,enchant=accord_of_versatility
	-- finger2=logic_loop_of_division,id=169157,bonus_id=4779/1472,enchant=accord_of_versatility
	-- trinket1=azsharas_font_of_power,id=169314,bonus_id=4800/1517
	-- trinket2=leviathans_lure,id=169304,bonus_id=4800/1517
	-- main_hand=fang_of_the_behemoth,id=168397,bonus_id=4800/1517,enchant=torrent_of_elements
	-- off_hand=stormtamers_orb,id=168896,bonus_id=4800/1517

	-- # Gear Summary
	-- # gear_ilvl=436.44
	-- # gear_stamina=12616
	-- # gear_intellect=8749
	-- # gear_crit_rating=1362
	-- # gear_haste_rating=1235
	-- # gear_mastery_rating=422
	-- # gear_versatility_rating=552
	-- # gear_armor=1672


endfunction Squid_Monk()

	if IsMounted() or IsAoEPending() then return end

	local spec = GetSpecialization()
	local time = GetTime()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
	local gcd_remains = GetGCD()

	--Windwalker
	if spec == 3 then

		local energy = UnitPower("player")
		local energy_max = UnitPowerMax("player")
		local energy_deficit = energy_max-energy
		local energy_regen = GetPowerRegen()
		local energy_time_to_max = energy_deficit / energy_regen
		local chi = UnitPower("player",12)
		local chi_max = UnitPowerMax("player",12)
		local chi_deficit = chi_max-chi

		local rising_sun_kick = 107428
		local fists_of_fury = 113656
		local whirling_dragon_punch = 152175
		local tiger_palm = 100780
		local spinning_crane_kick = 101546
		local tigers_last = 116841
		local blackout_kick = 100784
		local detox = 218164
		local chi_wave = 115098
		local fist_of_the_white_tiger = 261947
		local disable = 116095
		local provoke = 115546
		local diffuse_magic = 122783
		local leg_sweep = 119381
		local touch_of_death = 115080
		local touch_of_karma = 122470
		local roll = 109132
		local storm_earth_and_fire = 137639
		local transcendence = 101643
		local transcendence_transfer = 119996
		local ring_of_peace = 175697
		local vivify = 116670
		local reverse_harm = 287771

		local alpha_tiger_up = UnitBuffID("player",287504)
		local storm_earth_and_fire_up = UnitBuffID("player",137639)
		local swift_roundhouse_stacks = _buffStacks("player",277669)
		local port_up = UnitBuffID("player",101643)
		
		function port_in_los(unit)
			local x,y,z
			if port_up then
				x=portcoords.x
				y=portcoords.y
				z=portcoords.z
				local X,Y,Z = ObjectPosition(unit)
				return los_coords(x,y,z,X,Y,Z)
			end
		end

		function port_distance(unit)
			local x,y,z
			if port_up then
				x=portcoords.x
				y=portcoords.y
				z=portcoords.z
				local X,Y,Z = ObjectPosition(unit)
				return GetDistanceBetweenPositions(x,y,z,X,Y,Z)
			end
		end

		function port_distance_deficit(unit)
			local port = port_distance(unit)
			local player = _realDistance(unit)
			return player-port
		end

		local alpha_tiger_enabled = IsPlayerSpell(287503)
		local tigers_lust_enabled = IsPlayerSpell(116841)

		local spear_hand_strike_cd = _spellCooldown(116705)
		local roll_cd = _spellCooldown(109132)
		local touch_of_death_cd = _spellCooldown(115080)

		local storm_earth_and_fire_charges = GetSpellCharges(storm_earth_and_fire)
		local storm_earth_and_fire_charges_frac = _spellChargeFrac(storm_earth_and_fire)
		local fists_of_fury_cd = _spellCooldown(fists_of_fury)
		local rising_sun_kick_cd = _spellCooldown(rising_sun_kick)
		local time_to_next_sef = 180-(_spellChargeFrac(137639)*90)
		local player_hp = _HP("player")

		local function _valid(unit,immune)
			if not unit or not UnitIsVisible(unit) then return false end
			return unit 
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit) 
			and not _breakableCC(unit)
			and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
			and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
		end

		local function can_i_kick(unit)
			local dist = _realDistance(unit)
			local time_left_to_kick = _castTimeLeft(unit) - (dist * .1)
			if spear_hand_strike_cd > 0 then return false end
			if dist < 6 then 
				return true
			end
			if dist < 20 and dist > 15 and _spellCooldown(109132) < time_left_to_kick then
				return true
			end
		end

		if _rootCheck("player") or _isSlowed("player") then
			_Cast(116841,"player")
		end
		
		local t = current_target
		if t and not UnitCanAttack("player",t) then t=nil end

		local validtar = _valid(t,1)
		local validmagic = _valid(t,2)
		local target_hp = _HP(t)
		local melee_range = _meleeRange(t)
		local dist = _distance(t)
		local bcc9 = _bccAM(9)

		local active_enemies = EnemiesAroundMe(6)

		local not_dmg = {
		"Roll",
		"Flying Serpent Kick",
		"Leg Sweep",
		"Storm, Earth, and Fire",
		"Storm, Earth, and Fire: Fixate",
		"Paralysis",
		"Ring of Peace",
		"Tiger's Lust",
		"Touch of Death",
		"Touch of Karma",
		"Transcendence",
		"Transcendence: Transfer",
		"Disable",
		"Crackling Jade Lightning",
		"Fortifying Brew",
		"Vivify",
		}

		prev_gcd = nil

		for i=1,#PlayerSpellCasts do
			if not tContains(not_dmg,PlayerSpellCasts[i].name) and IsSpellOnGCD(PlayerSpellCasts[i].name) and time-PlayerSpellCasts[i].time < 5 then
				prev_gcd = PlayerSpellCasts[i].name
				break;
			end
		end

		local function monk_cast(spell,unit,requiresfacing,forcefacing)
			local spellName=GetSpellInfo(spell)
			if prev_gcd ~= spellName then
				if spell == 152175 and current_target and UnitDebuffID(current_target,115080,"player") and _debuffRemains(current_target,115080,"player") < 1.5 then
					SpellStopCasting()
					CastSpellByID(spell,unit)
				end
				_Cast(spell,unit,requiresfacing,forcefacing)
			end
		end

		local function currentlyrolling() 
			local crackling,check = IsUsableSpell(117952)
			return not crackling and not check
		end

		local function currentlyflying()
			return IsUsableSpell(115057) and _spellCooldown(101545) >= 23.5
		end

		if forced_fsk and time-forced_fsk <= 1.5 and currentlyflying() then
			if t then
				if _distance(t) < 4 and not bcc9 then
					_Cast(115057)
				end
			end
		end

		-- if currentlyrolling() then
		-- 	currently_rolling_lock = true
		-- 	SetMovementLocked(true)
		-- elseif not currentlyrolling() and currently_rolling_lock == true then
		-- 	SetMovementLocked(false)
		-- 	currently_rolling_lock=nil
		-- end

		if validtar and (dist > 11 or (dist > 8 and GetUnitSpeed(t) >= GetUnitSpeed("player") and not _slowImmuneCheck(t))) then
			if _movingTowards(t,.102,nil,nil,true) and moving_towards_unit_duration(t,.102) > .05 then
				if roll_cd >= 2 or dist > 18 then
					if fsk_to_unit(t) then
						Squid_Alert("Flying Serpent Kick","(Gapclose)",nil,nil,101545)
						return
					end
				end
				if dist <= 18 and roll_to_unit(t) then
					Squid_Alert("Roll","(Gapclose)",nil,nil,109132)
				end
			end
		end

		-- if UnitExists("focus") then roll_to_unit("focus",true) end
		if validtar then
			if UnitIsPlayer(t) then
				if (select(4,GetUnitSpeed(t)) >= select(4,GetUnitSpeed("player")) or not _slowCheck(t)) and not _slowImmuneCheck(t) then
					_Cast(116095,t,true)
				end
			end
		end

		-- 	# Executed every time the actor is available.
		-- actions=auto_attack
		if validtar and (not auto_attack or time-auto_attack > 1) then
			StartAttack()
			if storm_earth_and_fire_up then
				_Cast(221771,t)
			end
			auto_attack=time
		end
		-- # Touch of Karma on cooldown, if Good Karma is enabled equal to 100% of maximum health
		-- actions+=/touch_of_karma,interval=90,pct_health=0.5
		-- if player_hp < 7 then
		-- 	if validtar and not UnitBuffID(t,1022) then
		--  		if _Cast(touch_of_karma,t,nil,true) then
		--  			Squid_Alert("Karma " .. UnitClass(t),"(DANGER)",2,4,122470)
		--  		end
		--  	end
		-- 	for i=1,#Enemies do
		-- 		if not _immuneCheck(Enemies[i]) and not UnitBuffID(Enemies[i],1022) then
		-- 			if _Cast(touch_of_karma,Enemies[i],nil,true) then
		-- 				Squid_Alert("Karma " .. UnitClass(Enemies[i]),"(DANGER)",2,4,122470)
		-- 			end
		-- 		end
		-- 	end
		-- end
		-- # Potion if Serenity or Storm, Earth, and Fire are up or you are running serenity and a main stat trinket procs, or you are under the effect of bloodlust, or target time to die is greater or equal to 60
		-- actions+=/potion,if=buff.serenity.up|buff.storm_earth_and_fire.up|(!talent.serenity.enabled&trinket.proc.agility.react)|buff.bloodlust.react|target.time_to_die<=60
		-- actions+=/call_action_list,name=serenity,if=buff.serenity.up
		-- actions+=/fist_of_the_white_tiger,if=(energy.time_to_max<1|(talent.serenity.enabled&cooldown.serenity.remains<2))&chi.max-chi>=3
		if validtar then
			if energy_time_to_max < 1 and chi_deficit >= 3 then
				_Cast(fist_of_the_white_tiger,t,true)
			end
		end
		-- actions+=/tiger_palm,target_if=min:debuff.mark_of_the_crane.remains,if=(energy.time_to_max<1|(talent.serenity.enabled&cooldown.serenity.remains<2))&chi.max-chi>=2&!prev_gcd.1.tiger_palm
		if validtar and energy_time_to_max < 1 and chi_deficit >= 2 then
			monk_cast(100780,t,true)
		end

		local focused_azerite_beam = IsPlayerSpell(295258)
		local focused_azerite_beam_castable

		if validmagic and active_enemies > 2 and focused_azerite_beam then
			local facing = am_i_facing_angle(t)
			if _distance(t) < 10 and facing and not facing_bcc(t) then
				focused_azerite_beam_castable=true
			end
		end

		local function essences()
			-- actions.cleave+=/focused_azerite_beam
			if focused_azerite_beam_castable then
				_Cast(295258)
			end
		end

		local function cd()
			-- # Cooldowns
			-- actions.cd=invoke_xuen_the_white_tiger
			if validtar and (target_hp < 80 or their_healer_cc or not arena) then
				_Cast(123904)
			end
			-- actions.cd+=/use_item,name=variable_intensity_gigavolt_oscillating_reactor
			-- actions.cd+=/blood_fury
			-- actions.cd+=/berserking
			-- # Use Arcane Torrent if you are missing at least 1 Chi and won't cap energy within 0.5 seconds
			-- actions.cd+=/arcane_torrent,if=chi.max-chi>=1&energy.time_to_max>=0.5
			-- actions.cd+=/lights_judgment
			-- actions.cd+=/fireblood
			-- actions.cd+=/ancestral_call
			-- actions.cd+=/touch_of_death,if=target.time_to_die>9
			if arena then
				if validtar then
					--touch of death in arena
					if fists_of_fury_cd <= 3 and chi >= 3 and rising_sun_kick_cd <= gcd then
						_Cast(115080,t,true)
					end
				end
			else
				if fists_of_fury_cd <= gcd*2 and chi >= 2 and rising_sun_kick_cd <= gcd*3 then
					if touch_of_death_cd <= gcd then
						CastSpellByID(201318)
						_Cast(115080,t,true)
					end
				end
			end
			-- actions.cd+=/storm_earth_and_fire,if=cooldown.storm_earth_and_fire.charges=2|(cooldown.fists_of_fury.remains<=6&chi>=3&cooldown.rising_sun_kick.remains<=1)|target.time_to_die<=15
			if validtar then
				if storm_earth_and_fire_charges == 2 or (fists_of_fury_cd <= 6 and chi >= 3 and rising_sun_kick_cd <= gcd and time_to_next_sef < _spellCooldown(115080)) or (_HP(t) < 35 and their_healer_cc) or UnitDebuffID(t,115080,"player") then
					_Cast(137639,t,true)
				end
			end
			-- actions.cd+=/serenity,if=cooldown.rising_sun_kick.remains<=2|target.time_to_die<=12
			-- actions.cd+=/call_action_list,name=essences
			essences()
		end

		local function st()
			-- actions.st=whirling_dragon_punch
			if validtar and dist < 4.5 and fists_of_fury_cd > 0 and rising_sun_kick_cd > 0 and not bcc9 then
				monk_cast(whirling_dragon_punch)
			end
			-- actions.st+=/rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains,if=chi>=5
			if validtar and chi >= 5 then
				monk_cast(107428,t,true)
			end
			--maintain alpha tiger
			if alpha_tiger_enabled and not alpha_tiger_up then
				if arena then
					for i=1,#Pets do if not UnitDebuffID(Pets[i],290512,"player") and not _breakableCC(Pets[i]) then
						monk_cast(100780,Pets[i],nil,true)
					end end
				else
					for i=1,#Enemies do if not UnitDebuffID(Enemies[i],290512,"player") and not _breakableCC(Enemies[i]) then
						monk_cast(100780,Enemies[i],nil,true)
					end end
				end
			end
			-- actions.st+=/fists_of_fury,if=energy.time_to_max>3
			if validtar and dist < 4.8 and not _slowImmuneCheck(t) and (energy_time_to_max > 1.5 or chi >= 4 or UnitDebuffID(t,115080,"player") or storm_earth_and_fire_up) and fists_of_fury_cd < 2 then
				monk_cast(fists_of_fury,t,true)
			end
			-- actions.st+=/rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains
			if validtar then
				monk_cast(rising_sun_kick,t,true)
			end
			-- actions.st+=/spinning_crane_kick,if=!prev_gcd.1.spinning_crane_kick&buff.dance_of_chiji.up
			if validtar and dist <= 6 and not bcc9 and UnitBuffID("player",286587) then
				monk_cast(spinning_crane_kick)
			end
			-- actions.st+=/rushing_jade_wind,if=buff.rushing_jade_wind.down&active_enemies>1
			-- actions.st+=/reverse_harm,if=chi.max-chi>=2
			if t then
				if chi_deficit >= 2 and (melee_range or dist > 6) then
					monk_cast(reverse_harm)
				end
			end
			-- actions.st+=/fist_of_the_white_tiger,if=chi<=2
			if validtar and chi <= 2 then
				monk_cast(fist_of_the_white_tiger,t,true)
			end
			-- actions.st+=/energizing_elixir,if=chi<=3&energy<50
			if chi <= 3 and energy < 50 then
				_Cast(115288)
			end
			-- actions.st+=/blackout_kick,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.blackout_kick&(cooldown.rising_sun_kick.remains>3|chi>=3)&(cooldown.fists_of_fury.remains>4|chi>=4|(chi=2&prev_gcd.1.tiger_palm))&buff.swift_roundhouse.stack<2
			if validtar and (rising_sun_kick_cd > 3 or chi >= 3) and (fists_of_fury_cd > 4 or chi >= 4 or (chi == 2 and prev_gcd == "Tiger Palm")) and swift_roundhouse_stacks < 2 then
				monk_cast(blackout_kick,t,true)
			end
			-- actions.st+=/chi_wave
			monk_cast(chi_wave,t,true)
			-- actions.st+=/chi_burst,if=chi.max-chi>=1&active_enemies=1|chi.max-chi>=2
			if chi_deficit >= 1 and active_enemies == 1 or chi_deficit >= 2 then
				if validmagic and not bcc9 then
					monk_cast(123986)
				end
			end
			-- actions.st+=/tiger_palm,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.tiger_palm&chi.max-chi>=2
			if validtar and chi_deficit >= 2 then
				monk_cast(tiger_palm,t,true)
			end
			-- actions.st+=/flying_serpent_kick,if=prev_gcd.1.blackout_kick&chi>3&buff.swift_roundhouse.stack<2,interrupt=1
		end

		local function aoe()

		end

		-- actions+=/call_action_list,name=cd
		cd()
		-- # Call the ST action list if there are 2 or less enemies
		-- actions+=/call_action_list,name=st,if=active_enemies<3
		-- if arena or active_enemies < 2 or _isDummy(t) then
		st()
		-- else
		-- 	aoe()
		-- end
		-- -- # Call the AoE action list if there are 3 or more enemies
		-- actions+=/call_action_list,name=aoe,if=active_enemies>=3

		-- # Actions.AoE is intended for use with Hectic_Add_Cleave and currently needs to be optimized
		-- actions.aoe=rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains,if=(talent.whirling_dragon_punch.enabled&cooldown.whirling_dragon_punch.remains<5)&cooldown.fists_of_fury.remains>3
		-- actions.aoe+=/whirling_dragon_punch
		-- actions.aoe+=/energizing_elixir,if=!prev_gcd.1.tiger_palm&chi<=1&energy<50
		-- actions.aoe+=/fists_of_fury,if=energy.time_to_max>3
		-- actions.aoe+=/rushing_jade_wind,if=buff.rushing_jade_wind.down
		-- actions.aoe+=/spinning_crane_kick,if=!prev_gcd.1.spinning_crane_kick&(((chi>3|cooldown.fists_of_fury.remains>6)&(chi>=5|cooldown.fists_of_fury.remains>2))|energy.time_to_max<=3)
		-- actions.aoe+=/reverse_harm,if=chi.max-chi>=2
		-- actions.aoe+=/chi_burst,if=chi<=3
		-- actions.aoe+=/fist_of_the_white_tiger,if=chi.max-chi>=3
		-- actions.aoe+=/tiger_palm,target_if=min:debuff.mark_of_the_crane.remains,if=chi.max-chi>=2&(!talent.hit_combo.enabled|!prev_gcd.1.tiger_palm)
		-- actions.aoe+=/chi_wave
		-- actions.aoe+=/flying_serpent_kick,if=buff.bok_proc.down,interrupt=1
		-- actions.aoe+=/blackout_kick,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.blackout_kick&(buff.bok_proc.up|(talent.hit_combo.enabled&prev_gcd.1.tiger_palm&chi<4))

		-- # Cooldowns
		-- actions.cd=invoke_xuen_the_white_tiger
		-- actions.cd+=/use_item,name=variable_intensity_gigavolt_oscillating_reactor
		-- actions.cd+=/blood_fury
		-- actions.cd+=/berserking
		-- # Use Arcane Torrent if you are missing at least 1 Chi and won't cap energy within 0.5 seconds
		-- actions.cd+=/arcane_torrent,if=chi.max-chi>=1&energy.time_to_max>=0.5
		-- actions.cd+=/lights_judgment
		-- actions.cd+=/fireblood
		-- actions.cd+=/ancestral_call
		-- actions.cd+=/touch_of_death,if=target.time_to_die>9
		-- actions.cd+=/storm_earth_and_fire,if=cooldown.storm_earth_and_fire.charges=2|(cooldown.fists_of_fury.remains<=6&chi>=3&cooldown.rising_sun_kick.remains<=1)|target.time_to_die<=15
		-- actions.cd+=/serenity,if=cooldown.rising_sun_kick.remains<=2|target.time_to_die<=12
		-- actions.cd+=/call_action_list,name=essences

		-- actions.essences=concentrated_flame
		-- actions.essences+=/blood_of_the_enemy
		-- actions.essences+=/guardian_of_azeroth
		-- actions.essences+=/focused_azerite_beam
		-- actions.essences+=/purifying_blast
		-- actions.essences+=/the_unbound_force
		-- actions.essences+=/ripple_in_space
		-- actions.essences+=/worldvein_resonance
		-- actions.essences+=/memory_of_lucid_dreams,if=energy<40&buff.storm_earth_and_fire.up

		-- # Serenity priority
		-- actions.serenity=rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains,if=active_enemies<3|prev_gcd.1.spinning_crane_kick
		-- actions.serenity+=/fists_of_fury,if=(buff.bloodlust.up&prev_gcd.1.rising_sun_kick)|buff.serenity.remains<1|(active_enemies>1&active_enemies<5)
		-- actions.serenity+=/spinning_crane_kick,if=!prev_gcd.1.spinning_crane_kick&(active_enemies>=3|(active_enemies=2&prev_gcd.1.blackout_kick))
		-- actions.serenity+=/blackout_kick,target_if=min:debuff.mark_of_the_crane.remains

		-- actions.st=whirling_dragon_punch
		-- actions.st+=/rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains,if=chi>=5
		-- actions.st+=/fists_of_fury,if=energy.time_to_max>3
		-- actions.st+=/rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains
		-- actions.st+=/spinning_crane_kick,if=!prev_gcd.1.spinning_crane_kick&buff.dance_of_chiji.up
		-- actions.st+=/rushing_jade_wind,if=buff.rushing_jade_wind.down&active_enemies>1
		-- actions.st+=/reverse_harm,if=chi.max-chi>=2
		-- actions.st+=/fist_of_the_white_tiger,if=chi<=2
		-- actions.st+=/energizing_elixir,if=chi<=3&energy<50
		-- actions.st+=/blackout_kick,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.blackout_kick&(cooldown.rising_sun_kick.remains>3|chi>=3)&(cooldown.fists_of_fury.remains>4|chi>=4|(chi=2&prev_gcd.1.tiger_palm))&buff.swift_roundhouse.stack<2
		-- actions.st+=/chi_wave
		-- actions.st+=/chi_burst,if=chi.max-chi>=1&active_enemies=1|chi.max-chi>=2
		-- actions.st+=/tiger_palm,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.tiger_palm&chi.max-chi>=2
		-- actions.st+=/flying_serpent_kick,if=prev_gcd.1.blackout_kick&chi>3&buff.swift_roundhouse.stack<2,interrupt=1
			
	end

endfunction Squid_Paladin()

	if IsMounted() or IsFlying() or UnitBuffID("player",32727) then return false end
	local spec = GetSpecialization()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local gcd_remains = GetGCD()
	local time = GetTime()

	--Ret
	if spec == 3 then

		local combat = UnitAffectingCombat("player")
		local power = UnitPower("player",9)

		local hammer_of_wrath_enabled = IsPlayerSpell(24275)
		local inquisition_enabled = IsPlayerSpell(84963)
		local crusade_enabled = IsPlayerSpell(231895)
		local rv_enabled = IsPlayerSpell(267610)

		local inquisition_remains = _buffRemains("player",84963)

		local sh_stacks = _buffStacks("player",114250)

		local wings_up = UnitBuffID("player",31884)
		local inquisition_up = inquisition_remains > 0
		local empyrean_power_up = UnitBuffID("player",286393)
		local wings_auto_crit = UnitBuffID("player",294027)

		local consecration_cd = IsPlayerSpell(205228) and _spellCooldown(205228) or 69

		local how_cd = _spellCooldown(24275)
		local wings_cd = not crusade_enabled and _spellCooldown(31884) or _spellCooldown(231895)
		local boj_cd = _spellCooldown(184575)
		local judgment_cd = _spellCooldown(20271)

		local cs_charges_frac = _spellChargeFrac(35395)

		local active_enemies = 0
		for i=1,#Enemies do if UnitAffectingCombat(Enemies[i]) then
			active_enemies = active_enemies + 1
		end end

		local t = current_target
		local t_hp = 100
		local t_ttd = 0
		local t_judgment 
		if t then
			t_judgment = UnitDebuffID(t,197277,"player")
			t_ttd = squid_ttd(t)
			t_hp = _HP(t)
			if not valid_attackable(t) then
				t = nil
			end
		end

		if sh_stacks >= 4 then
			for i=1,#Friends do if _HP(Friends[i]) < 60 then
				_Cast(19750,Friends[i])
			end end
		end

		local function cooldowns()
			if not t then return end
			-- actions.cooldowns=potion,if=(cooldown.guardian_of_azeroth.remains>90|!essence.condensed_lifeforce.major)&(buff.bloodlust.react|buff.avenging_wrath.up&buff.avenging_wrath.remains>18|buff.crusade.up&buff.crusade.remains<25)
			-- actions.cooldowns+=/lights_judgment,if=spell_targets.lights_judgment>=2|(!raid_event.adds.exists|raid_event.adds.in>75)
			-- actions.cooldowns+=/fireblood,if=buff.avenging_wrath.up|buff.crusade.up&buff.crusade.stack=10
			-- actions.cooldowns+=/shield_of_vengeance,if=buff.seething_rage.down&buff.memory_of_lucid_dreams.down
			if combat then
				_Cast(184662)
			end
			-- actions.cooldowns+=/use_item,name=ashvanes_razor_coral,if=debuff.razor_coral_debuff.down|(buff.avenging_wrath.remains>=20|buff.crusade.stack=10&buff.crusade.remains>15)&(cooldown.guardian_of_azeroth.remains>90|target.time_to_die<30|!essence.condensed_lifeforce.major)
			-- actions.cooldowns+=/the_unbound_force,if=time<=2|buff.reckless_force.up
			-- actions.cooldowns+=/blood_of_the_enemy,if=buff.avenging_wrath.up|buff.crusade.up&buff.crusade.stack=10
			-- actions.cooldowns+=/guardian_of_azeroth,if=!talent.crusade.enabled&(cooldown.avenging_wrath.remains<5&holy_power>=3&(buff.inquisition.up|!talent.inquisition.enabled)|cooldown.avenging_wrath.remains>=45)|(talent.crusade.enabled&cooldown.crusade.remains<gcd&holy_power>=4|holy_power>=3&time<10&talent.wake_of_ashes.enabled|cooldown.crusade.remains>=45)
			-- actions.cooldowns+=/worldvein_resonance,if=cooldown.avenging_wrath.remains<gcd&holy_power>=3|talent.crusade.enabled&cooldown.crusade.remains<gcd&holy_power>=4|cooldown.avenging_wrath.remains>=45|cooldown.crusade.remains>=45
			-- actions.cooldowns+=/focused_azerite_beam,if=(!raid_event.adds.exists|raid_event.adds.in>30|spell_targets.divine_storm>=2)&!(buff.avenging_wrath.up|buff.crusade.up)&(cooldown.blade_of_justice.remains>gcd*3&cooldown.judgment.remains>gcd*3)
			-- actions.cooldowns+=/memory_of_lucid_dreams,if=(buff.avenging_wrath.up|buff.crusade.up&buff.crusade.stack=10)&holy_power<=3
			-- actions.cooldowns+=/purifying_blast,if=(!raid_event.adds.exists|raid_event.adds.in>30|spell_targets.divine_storm>=2)
			-- actions.cooldowns+=/use_item,effect_name=cyclotronic_blast,if=!(buff.avenging_wrath.up|buff.crusade.up)&(cooldown.blade_of_justice.remains>gcd*3&cooldown.judgment.remains>gcd*3)
			-- actions.cooldowns+=/avenging_wrath,if=(!talent.inquisition.enabled|buff.inquisition.up)&holy_power>=3
			if t_ttd > 10 and (not inquisition_enabled or inquisition_up) and power >= 3 then
				_Cast(31884)
			end
			-- actions.cooldowns+=/crusade,if=holy_power>=4|holy_power>=3&time<10&talent.wake_of_ashes.enabled
		end

		local wings_pool
		local ds_castable
		local function finishers()
			if not t then return end
			-- actions.finishers=variable,name=wings_pool,value=!equipped.169314&(!talent.crusade.enabled&cooldown.avenging_wrath.remains>gcd*3|cooldown.crusade.remains>gcd*3)|equipped.169314&(!talent.crusade.enabled&cooldown.avenging_wrath.remains>gcd*6|cooldown.crusade.remains>gcd*6)
			wings_pool = not IsEquippedItem(169314) and (not crusade_enabled or wings_cd > gcd * 3) or IsEquippedItem(169314) and (not crusade_enabled and wings_cd > gcd * 6)
			-- actions.finishers+=/variable,name=ds_castable,value=spell_targets.divine_storm>=2&!talent.righteous_verdict.enabled|spell_targets.divine_storm>=3&talent.righteous_verdict.enabled|buff.empyrean_power.up&debuff.judgment.down&buff.divine_purpose.down&buff.avenging_wrath_autocrit.down
			local ds_targets = Enemies_Around_Unit("player",8)
			ds_castable = ds_targets >= 2 and not rv_enabled or ds_targets >= 3 and rv_enabled or empyrean_power_up and not t_judgment and not divine_purpose_up and not wings_auto_crit
			-- actions.finishers+=/inquisition,if=buff.avenging_wrath.down&(buff.inquisition.down|buff.inquisition.remains<8&holy_power>=3|talent.execution_sentence.enabled&cooldown.execution_sentence.remains<10&buff.inquisition.remains<15|cooldown.avenging_wrath.remains<15&buff.inquisition.remains<20&holy_power>=3)
			if not wings_up and (not inquisition_up or inquisition_remains < 8 and power >= 3 or es_enabled and es_cd < 10 and inquisition_remains < 15 or wings_cd < 15 and inquisition_remains < 20 and power >= 3) then
				_Cast(84963)
			end 
			-- actions.finishers+=/execution_sentence,if=spell_targets.divine_storm<=2&(!talent.crusade.enabled&cooldown.avenging_wrath.remains>10|talent.crusade.enabled&buff.crusade.down&cooldown.crusade.remains>10|buff.crusade.stack>=7)
			if ds_targets <= 2 then
				_Cast(267798,t,true)
			end
			-- actions.finishers+=/divine_storm,if=variable.ds_castable&variable.wings_pool&((!talent.execution_sentence.enabled|(spell_targets.divine_storm>=2|cooldown.execution_sentence.remains>gcd*2))|(cooldown.avenging_wrath.remains>gcd*3&cooldown.avenging_wrath.remains<10|cooldown.crusade.remains>gcd*3&cooldown.crusade.remains<10|buff.crusade.up&buff.crusade.stack<10))
			if ds_castable and wings_pool then
				_Cast(53385)
			end
			-- actions.finishers+=/templars_verdict,if=variable.wings_pool&(!talent.execution_sentence.enabled|cooldown.execution_sentence.remains>gcd*2|cooldown.avenging_wrath.remains>gcd*3&cooldown.avenging_wrath.remains<10|cooldown.crusade.remains>gcd*3&cooldown.crusade.remains<10|buff.crusade.up&buff.crusade.stack<10)
			if wings_pool then
				_Cast(85256,t,true)
			end
		end

		local HoW
		local function generators()
			if not t then return end
			-- actions.generators=variable,name=HoW,value=(!talent.hammer_of_wrath.enabled|target.health.pct>=20&!(buff.avenging_wrath.up|buff.crusade.up))
			HoW = not hammer_of_wrath_enabled or t_hp >= 20 and not wings_up
			-- actions.generators+=/call_action_list,name=finishers,if=holy_power>=5|buff.memory_of_lucid_dreams.up|buff.seething_rage.up|talent.inquisition.enabled&buff.inquisition.down&holy_power>=3
			if power >= 5 or lucid_dreams_up or seething_rage_up or inquisition_enabled and not inquisition_up and power >= 3 then
				finishers()
			end
			-- actions.generators+=/wake_of_ashes,if=(!raid_event.adds.exists|raid_event.adds.in>15|spell_targets.wake_of_ashes>=2)&(holy_power<=0|holy_power=1&cooldown.blade_of_justice.remains>gcd)&(cooldown.avenging_wrath.remains>10|talent.crusade.enabled&cooldown.crusade.remains>10)
			local woa_targets = 0
			for i=1,#Enemies do if _distance(Enemies[i]) <= 11 and _amIfacing(Enemies[i]) then
				woa_targets = woa_targets + 1
			end end
			if (woa_targets >= 2 or active_enemies <= 1) and (power <= 0 or power == 1 and boj_cd > gcd) and wings_cd > 10 then
				_Cast(255937)
			end
			-- actions.generators+=/blade_of_justice,if=holy_power<=2|(holy_power=3&(cooldown.hammer_of_wrath.remains>gcd*2|variable.HoW))
			if power <= 2 or (power == 3 and (how_cd > gcd * 2 or HoW)) then
				_Cast(184575,t,true)
			end
			-- actions.generators+=/judgment,if=holy_power<=2|(holy_power<=4&(cooldown.blade_of_justice.remains>gcd*2|variable.HoW))
			if power <= 2 or (power <= 4 and (boj_cd > gcd*2 or HoW)) then
				_Cast(20271,t,true)
			end
			-- actions.generators+=/hammer_of_wrath,if=holy_power<=4
			if power <= 4 then
				_Cast(24275,t,true)
			end
			-- actions.generators+=/consecration,if=holy_power<=2|holy_power<=3&cooldown.blade_of_justice.remains>gcd*2|holy_power=4&cooldown.blade_of_justice.remains>gcd*2&cooldown.judgment.remains>gcd*2
			if power <= 2 or power <= 3 and boj_cd > gcd * 2 or power == 4 and boj_cd > gcd * 2 and judgment_cd > gcd * 2 then
				_Cast(26573)
			end
			-- actions.generators+=/call_action_list,name=finishers,if=talent.hammer_of_wrath.enabled&target.health.pct<=20|buff.avenging_wrath.up|buff.crusade.up
			if hammer_of_wrath_enabled and t_hp <= 20 and wings_up then
				finishers()
			end
			-- actions.generators+=/crusader_strike,if=cooldown.crusader_strike.charges_fractional>=1.75&(holy_power<=2|holy_power<=3&cooldown.blade_of_justice.remains>gcd*2|holy_power=4&cooldown.blade_of_justice.remains>gcd*2&cooldown.judgment.remains>gcd*2&cooldown.consecration.remains>gcd*2)
			if cs_charges_frac >= 1.75 and (power <= 2 or power <= 3 and boj_cd > gcd * 2 or power == 4 and boj_cd > gcd * 2 and judgment_cd > gcd * 2 and consecration_cd > gcd * 2) then
				_Cast(35395,t,true)
			end
			-- actions.generators+=/call_action_list,name=finishers
			finishers()
			-- actions.generators+=/concentrated_flame
			-- actions.generators+=/reaping_flames
			-- actions.generators+=/crusader_strike,if=holy_power<=4
			if power <= 4 then
				_Cast(35395,t,true)
			end
			-- actions.generators+=/arcane_torrent,if=holy_power<=4
		end

		-- actions+=/call_action_list,name=cooldowns
		cooldowns()
		-- actions+=/call_action_list,name=generators
		generators()

	--Holy
	elseif spec == 1 then

		if Free_Bag_Slots() > 0 then
			InteractUnit("Refreshment Table")
		end
				
		local combat = UnitAffectingCombat("player")
		local hpmax = UnitHealthMax("player")
		local mana = (100 * UnitPower("player") / UnitPowerMax("player"));
		local latency = squid_avg_latency
		local groupsize = GetNumGroupMembers()
		local msperframe = 2/GetFramerate()
		local buffer = latency + msperframe + .1
		local player_hp = _HP("player")
		local player_hpdeficit = hpmax-UnitHealth("player")
		local player_mastery = GetMasteryEffect()
		local player_interruptable = PlayerCanBeKicked()

		local avenging_wrath_remains = _buffRemains("player",31884)
		local avenging_wrath = avenging_wrath_remains > 0

		local infusion_up = UnitBuffID("player",54149)

		local holy_shock_cd = _spellCooldown(20473)

		local breaking_dawn = AzeritePowerTaken(394)

		if not holy_shock_value or time-holy_shock_value_checked > .5 then
			holy_shock_value = GetSpellEffect(20473)
			if holy_shock_value then
				holy_shock_value = holy_shock_value*1.5
			end
			if not holy_shock_value then
				holy_shock_value = UnitStat("player",4)*3.3
			end
			holy_shock_value_checked=time
		end

		if Squid_Burst then
			_Cast(31884)
		end

		local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
		local player_cast_target = UnitSpellTarget("player")
		local player_cast_time_left = _castTimeLeft("player")

		if player_cast_id == 20066 then
			--premonition
			if premonitionUsed then
				local time_since_prem = time - premonitionUsed
				local time_til_prem_proc = 1.5-time_since_prem
				if player_cast_time_left < time_til_prem_proc then
					if premonitionPointer and UnitIsVisible(premonitionPointer) and unit_is_unit(player_cast_target,premonitionPointer) then
						Squid_Alert_Big("Stopcasting","(Premonition)",4,3,305498)
						SpellStopCasting()
					end
				end
			end
		end

		local rep_cast_time = _castTime(20066)

		local function cc(unit,player_forced)

			--stop if no unit
			if not unit or not UnitIsVisible(unit) then return 69 end

			--do not sheep? (ext. func)
			if DoNotSheep(unit) then return 69 end

			--dist to unit
			local dist = _distance(unit)

			local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit) )

			--druid?
			local is_druid = select(2,UnitClass(unit)) == "DRUID"

			--check cc
			local ccr = _CCremains(unit)
			local cc = ccr > 0 
			
			--incap drs
			local idr = _incapacitateDR(unit)
			local idr_remains = _drRemains(unit,"incapacitate")

			--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
			local immune_sheep = _isBeast(unit) or _isDummy(unit)

			--meteor?
			local standing_in_meteor = UnitDebuffID(unit,155158)

			--yea dont cc into it
			if standing_in_meteor then return 69 end

			--banner?
			local banner = UnitBuffID(unit,236321)

			--yea dont cc into it...unless
			if banner then return 69 end

			--incap on unit?
			local incap = _incapacitateCheck(unit)

			--healer?
			local is_healer = _isHealer(unit) 

			--lockout?
			local lockout = IsLocked(unit,true)

			--los?
			local los = _LoS(unit)

			--charmed friend?
			local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

			if friendly then return 69 end

			-- friends attacking?
			local friends_attacking = UnitEnemiesAttacking(unit)
			local unit_hp = _HP(unit)
			if unit_hp < lowestEnemy - 15 or friends_attacking > 0 then 
				return 69
			end

			--sheep, if drs are available, and the unit is not immune
			local max_overlap = rep_cast_time + (buffer*2.55) + .5 + (not player_interruptable and 1.25 or 0) -- + (idr >= .5 and ring_cd < gcd and ccr > ring_cast_time and ring_cast_time or 0)
			if los then --no sheep into lockout, unless they're casting another school
				if not immune_sheep then
					
					local sheep_dr_ready = idr == 1 or (idr >= .25 and idr_remains > 17.25 - (ccr >= rep_cast_time and 8 * idr or 0) - (incap and ccr >= rep_cast_time-.2 and 6 * idr or 0) - ((100-lowestEnemy) * .038) + (idr == .25 and 2 or 0) ) or ( idr_remains < rep_cast_time-(buffer/2) and ( idr_remains ~= 0 or idr == 1 ) )

					if sheep_dr_ready then
						if dist < 29 and ccr < max_overlap then
							if immunity_remains <= rep_cast_time+(buffer*.45) then
								--alert when moving, stop casting scorch when not
								if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Rep)",nil,nil,20066) end
								if _Cast(20066,unit) then
									Squid_Alert("Repping",UnitClass(unit),nil,3,20066)
								end
							end
						end
					end
				end
			end
			
		end

		if cc_healer_key then
			if UnitIsVisible(theirHealer) and not _immuneMagic(theirHealer) and not UnitBuffID(theirHealer,8178) and not UnitDebuffID(theirHealer,33786) then
				-- if _stunDR(theirHealer) == 1 or _stunRemains(theirHealer) > 0 and _stunRemains(theirHealer) < buffer * 1.5 or _drRemains(theirHealer,"stun") > 17.99 then
					if _CCremains(theirHealer) < buffer * 1.5 then
						if _Cast(853,theirHealer,nil,true) then
							Squid_Alert_Big("HoJ " .. UnitClass(theirHealer),"(Manual)",2,3.5,853)
							return
						end
					end
				-- end
				cc(theirHealer)
			end
			return
		end

		if cc_focus_key then
			if UnitIsVisible(current_focus) and not _immuneMagic(current_focus) and not UnitBuffID(current_focus,8178) and not UnitDebuffID(current_focus,33786) then
				-- if _stunDR(current_focus) == 1 or _stunRemains(current_focus) > 0 and _stunRemains(current_focus) < buffer * 1.5 or _drRemains(current_focus,"stun") > 17.99 then
					if _CCremains(current_focus) < buffer * 1.5 then
						if _Cast(853,current_focus,nil,true) then
							Squid_Alert_Big("HoJ " .. UnitClass(current_focus),"(Manual)",2,3.5,853)
							return
						end
					end
				-- end
				cc(current_focus)
			end
			return
		end

		--CC Trinket
		local trinketPointer
		local recentTrinket
		for i=1,#TrinketTracker do
			local pointer = TrinketTracker[i].pointer
			local trinketTime = TrinketTracker[i].time
			if UnitIsVisible(pointer) and _isHealer(pointer) and unit_can_attack("player",pointer) then
				recentTrinket = time-trinketTime <= gcd*2.4
				timeSinceTrinket = time-trinketTime
				trinketPointer = pointer
			end
		end

		if recentTrinket then
			if trinketPointer and not unit_is_unit(trinketPointer,"target") and _LoS(trinketPointer) and gcd_remains <= .25 then
				--HoJ
				if _spellCooldown(853) <= gcd and (_stunDR(trinketPointer) == 1 or _drRemains(trinketPointer,"stun") > 17) then
					if _Cast(853,trinketPointer,nil,true) then
						Squid_Alert_Big("HoJ " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,853)
						return
					end
				end
			end
		end

		local their_healer = theirHealer
		local their_healer_cc
		local their_healer_cc_remains = 0
		local their_healer_incapacitate_dr
		local their_healer_incapacitate_dr_remains = 0
		local their_healer_disorient_dr
		local their_healer_disorient_dr_remains = 0
		if their_healer then
			their_healer_cc_remains = _CCremains(their_healer)
			their_healer_cc = their_healer_cc_remains > 0
			their_healer_incapacitate_dr = _incapacitateDR(their_healer)
			their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
			their_healer_disorient_dr = _disorientDR(their_healer)
			their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")
		end

		if not their_healer then
			their_healer_cc = true
			their_healer_cc_remains = 100 - (lowestEnemy*1.5)
			their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
			their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
		end

		local kt_stun_remains = 0
		local team_kt
		for i=1,#Enemies do
			local ea = UnitEnemiesAttacking(Enemies[i])
			if ea > 0 then
				local stun = _stunRemains(Enemies[i])
				if stun > kt_stun_remains then
					kt_stun_remains = stun
				end
				team_kt = Enemies[i]
			end
		end

		local load_mode = ( (their_healer and their_healer_cc_remains >= 1.5) or kt_stun_remains > 0 or lowestEnemy < 30 * (their_healer and 1 or 2.85) )

		--Bop Karma
		local MonkWithKarma
		if arena then
			for i=1,#Enemies do if UnitBuffID(Enemies[i],125174) then
				MonkWithKarma=Enemies[i];
			end end
			if MonkWithKarma then
				local FriendWithKarma
				for i=1,#Friends do if UnitDebuffID(Friends[i],122470) then
					FriendWithKarma=Friends[i];
				end end
				if FriendWithKarma then
					local current = _HP(MonkWithKarma)
					local hp = 70
					hp = hp + (their_healer_cc and 25 or 0)
					if unit_is_unit("player",FriendWithKarma) then
						hp=hp-20
					end
					if current < hp and FriendWithKarma then
						if hp < 50 then
							if current < 15 then
								_Cast(642);
							end
							_Cast(1022,FriendWithKarma)
						else
							_Cast(1022,FriendWithKarma)
						end
					end
				end
			end
		end

		-- 294027
		--pets lower prio than players if they need healing heal them
		local glimmers = {}
		local lowfriends = {}
		for i=1,#Friends do
			local e = Friends[i];
			--darkest dephts check
			if not UnitDebuffID(e,292127)
			and not UnitIsDeadOrGhost(e) then

				-- mastery benefit based on distance
				-- local dist = _distance(e)
				-- local distance_benefit = 40-(dist-10)
				-- distance_benefit = (100 * distance_benefit / 40)
				-- if distance_benefit > 100 then distance_benefit = 100 end
				-- if distance_benefit < 0 then distance_benefit = 0 end

				-- local mastery_benefit = (player_mastery*(distance_benefit/100))/100

		 		--lowGlimmer friend
				local priority = 0;	
				local glimmer = _buffRemains(e,287280,"player")
				local hpdeficit = UnitHealthMax(e)-UnitHealth(e)

				priority = priority + (30-glimmer)
				priority = priority + (unit_is_unit("player",e) and 1 or 0)
				priority = priority + (UnitGroupRolesAssigned(e) == "TANK" and 1 or 0)

				if hpdeficit >= hpmax/1.5 and unit_is_unit(e,"player") then
					hpdeficit=hpdeficit*1.5  -- increased healing priority for player below 55%
				end

				if not UnitBuffID(e,53563,"player") and hpdeficit >= hpmax/1.5 then
					hpdeficit=hpdeficit*1.25 -- increase healing priority for units without beacon
				end

				if UnitGroupRolesAssigned(e) == "TANK" then
					hpdeficit = hpdeficit / 1.15 -- slightly reduce healing priority for tank
				end

				--increase hp deficit based on mastery effect (this is not how i want to do this)
				-- hpdeficit = hpdeficit + (hpdeficit * mastery_benefit)

				table.insert(lowfriends,{pointer=e,hpdeficit=hpdeficit,glimmer=glimmer,mastery_benefit=mastery_benefit,hp=_HP(e)})
				table.insert(glimmers,{pointer=e,priority=priority,hpdeficit=hpdeficit,glimmer=glimmer,mastery_benefit=mastery_benefit});
			end
		end
		table.sort(glimmers, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hpdeficit > y.hpdeficit) end)
		table.sort(lowfriends, function(x,y) return x.hpdeficit > y.hpdeficit end)

		local function _valid(unit) 
			return UnitIsVisible(unit) 
			and UnitCanAttack("player",unit) 
			and not UnitIsDeadOrGhost(unit) 
			and not _breakableCC(unit)
			and not _immuneCheck(unit)
			and (arena or UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))
		end

		local beacontarget
		for i=1,#lowfriends do
			if UnitBuffID(lowfriends[i].pointer,53563,"player") then
				beacontarget = lowfriends[i].pointer
			end
		end

		--auto bops in pve
		local bopme = {
		265091, -- savage cleave
		}
		--m+
		if groupsize <= 5 and not arena then
			for i=1,#lowfriends do
				for n=1,#bopme do
					if UnitDebuffID(lowfriends[i].pointer,bopme[n]) then
						if _Cast(1022,lowfriends[i].pointer) then
							Squid_Alert_Big("Bop",GetSpellInfo(bopme[n]))
						end
					end
				end
			end
		end

		local player_locked = IsLocked("player")

		if arena then
			--vitality
			for i=1,#lowfriends do if not _immuneCheck(lowfriends[i].pointer) then
				local units, _, _, cds = EnemiesAttacking(lowfriends[i].pointer)
				local vhp = 30
				vhp = vhp + (cds * 20)
				vhp = vhp + (units * 15)
				vhp = vhp + (player_locked and 20 or 0)
				if lowfriends[i].hp < vhp then
					_Cast(296230,lowfriends[i].pointer)
				end
			end end
		end

		--loh
		if not arena then
			for i=1,#lowfriends do if lowfriends[i].hpdeficit >= hpmax then
				if select(2,UnitClass(lowfriends[i].pointer)) ~= "PALADIN" or UnitGroupRolesAssigned(lowfriends[i].pointer) ~= "TANK" then
					_Cast(633,lowfriends[i].pointer)
				end
			end end
		end

		

		if arena and lowestFriend > 30 then

			--Freedom
			if lowestFriend > 35 then
				for i=1,#Friends do
					if _shouldFreedom(Friends[i]) then
						_Cast(1044,Friends[i]);
					end
				end
			end

			--Dispel
			for i=1,#Friends do
				local d = _shouldCleanse(Friends[i])
				if d then
					if _Cast(4987,Friends[i]) then
						Squid_Alert("Cleanse",GetSpellInfo(d),4,nil,4987)
						return
					end
				end
			end

		end

		local bestTarget
		local bestTargetAmt = 0
		if arena then
			for i=1,#Enemies do
				local targs = UnitEnemiesAttacking(Enemies[i])
				if targs >= groupsize - 1 and targs > bestTargetAmt then
					bestTarget=Enemies[i];
					bestTargetAmt=targs;
				end
			end
		else
			if lowestEnemyName then
				bestTarget=lowestEnemyName
			end
		end

		--crucible
		if lowestFriend > 45 or lowestEnemy < 6*_buffStacks("player",295378) then
			if arena and bestTarget and not _breakableCC(bestTarget) then
				if load_mode or _buffStacks("player",295378) == 0 then
					if _spellCooldown(295373) <= gcd then
						_Cast(295373,bestTarget,nil,true)
					end
				end
			end
		end

		--Judgment Execute
		-- if arena and ( SQUID.auto_paladin or IsPlayerSpell(198054) ) and bestTarget and not _breakableCC(bestTarget) and _spellCooldown(275773) <= 1.5 and (lowestFriend > 74 or UnitBuffID("player",216331)) then
		-- 	if _valid(bestTarget) and _LoS(bestTarget) then
		-- 		_Cast(275773,bestTarget,nil,true);
		-- 	elseif _valid("target") then
		-- 		_Cast(275773,"target",nil,true);
		-- 	end
		-- end

		-- mastery benefit
		-- (100 * UnitHealth(unit) / UnitHealthMax(unit))

		local raid_hp_deficit = 0
		for i=1,#glimmers do
			raid_hp_deficit = raid_hp_deficit + glimmers[i].hpdeficit
		end

		--blessing of sac tank
		-- for i=1,#lowfriends do if lowfriends[i].hpdeficit > holy_shock_value*3.5 then
		-- 	if UnitGroupRolesAssigned(lowfriends[i].pointer) == "TANK" then
		-- 		_Cast(6940,lowfriends[i].pointer)
		-- 	end
		-- end end

		--wall after sac
		if _spellCooldown(6940) > 110 then
			CastSpellByID(498)
		end

		if not arena or SQUID.auto_paladin then
			if combat then
				if groupsize > 5 then

					--holy avenger
					if SQUID.auto_holy_avenger then
						if raid_hp_deficit > (hpmax*1.5 - (arena and hpmax*1.2 or 0)) or (not arena and avenging_wrath_remains >= 12) then
							_Cast(105809)
						end
					end

					--wingz
					if SQUID.auto_wings then
						if raid_hp_deficit > (hpmax*2.5 - (arena and hpmax*1.7 or 0)) or (_spellCooldown(105809) <= 8 and not arena) then
							if not avenging_wrath then
								_Cast(31884)
							end
						end
					end

					--aura mast
					if avenging_wrath_remains < 4 then
						if SQUID.auto_aura_mastery then
							if raid_hp_deficit > hpmax*4 then
								_Cast(31821)
							end
						end
					end

				else

					--holy avenger
					if SQUID.auto_holy_avenger then
						if raid_hp_deficit > hpmax*3.5 or avenging_wrath_remains >= 12 then
							_Cast(105809)
						end
					end

					--wingz
					if SQUID.auto_wings then
						if raid_hp_deficit > hpmax * 2 or _spellCooldown(105809) <= 8 and raid_hp_deficit < hpmax*1.25 then
							if not avenging_wrath then
								_Cast(31884)
							end
						end
					end

					--aura mast
					if avenging_wrath_remains < 4 then
						if SQUID.auto_aura_mastery then
							if raid_hp_deficit > hpmax then
								_Cast(31821)
							end
						end
					end

				end
			end
		end

		--pvp holy shock offense
		-- local bcconteam
		-- for i=1,#Friends do if select(2,UnitClass(Friends[i])) == "HUNTER" or select(2,UnitClass(Friends[i])) == "MAGE" then
		-- 	bcconteam=true
		-- end end 
		-- if lowestFriend > 80 and groupsize <= 2 and not bcconteam then
		-- 	for i=1,#Enemies do if not _breakableCC(Enemies[i]) and _debuffRemains(Enemies[i],287280,"player") < 8 then
		-- 		_Cast(20473,Enemies[i],nil,true)
		-- 	end end
		-- end

		--favor / holy light
		if not arena or SQUID.auto_paladin then
			if groupsize <= 3 then
				if infusion_up then
					if not _isMoving("player") then
						for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value/2 then
							if lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
								CastSpellByID(210294)
							end
							_Cast(82326,lowfriends[i].pointer)
						end end
					end
				end
			elseif groupsize <= 5 then
				if infusion_up and holy_shock_cd > gcd_remains then
					if not _isMoving("player") then
						for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value/1.5 then
							if lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
								CastSpellByID(210294)
							end
							_Cast(19750,lowfriends[i].pointer)
						end end
					end
				end
			end
		end

		local shortestglimmer = 0
		for i=1,#glimmers do if glimmers[i].glimmer > shortestglimmer then
			shortestglimmer = glimmers[i].glimmer
		end end

		local retard_dmg_mode = healer_dmg_key

		-- judgment
		if not arena then
			if retard_dmg_mode or lowestFriend > 40 and groupsize <= 5 then
				if _valid(current_target) then
					_Cast(275773,current_target,nil,true)
				else 
					for i=1,#Enemies do if valid_attackable(Enemies[i]) then
						_Cast(275773,Enemies[i],nil,true)
					end end
				end
			end
		end

		-- cons
		if not arena then
			if groupsize <= 5 and (retard_dmg_mode or lowestFriend > 70) and ( not sq_consecrate or time - sq_consecrate > 4 ) and Enemies_Around_Unit("player",6) >= 2 then
				if _Cast(26573) then
					sq_consecrate = time
				end
			end
		end

		--glimmers out
		local glimmers_out = 0
		for i=1,#glimmers do if glimmers[i].glimmer > 0 then
			glimmers_out = glimmers_out + 1
		end end

		-- --holy shock
		if not arena or SQUID.auto_paladin then
			--holy shock to keep ppl alive
			for i=1,#lowfriends do if _HP(lowfriends[i].pointer) < 55 then
				if _Cast(20473,lowfriends[i].pointer) then return end
			end end
			if instance_type ~= "none" or lowestFriend < 80 then
				--glimmer teammates as long is it is an effective heal
				for i=1,#glimmers do if glimmers[i].hpdeficit > holy_shock_value or glimmers[i].glimmer <= gcd and not retard_dmg_mode and glimmers_out < 8 then
					if _Cast(20473,glimmers[i].pointer) then return end
				end end
			end
			--glimmer teammates as long is it is an effective heal
			for i=1,#lowfriends do if lowfriends[i].hpdeficit > holy_shock_value/1.25 then
				if _Cast(20473,lowfriends[i].pointer) then return end
			end end
			if instance_type ~= "none" or lowestFriend < 80 then
				--target glimmer when no one needs healing
				if groupsize <= 5 then
					if _valid(current_target) and shortestglimmer >= min(groupsize,8) and (_debuffRemains(current_target,287280,"player") < 15 or UnitDebuffID(current_target,214222,"player")) then
						if _Cast(20473,current_target,nil,true) then return end
					end
					--retard dmg mode
					if retard_dmg_mode then
						for i=1,#Enemies do if valid_attackable(Enemies[i]) then
							local e = Enemies[i]
							if _debuffRemains(e,287280,"player") < 12 then
								if _Cast(20473,e,nil,true) then return end
							end
						end end
						for i=1,#Enemies do if valid_attackable(Enemies[i]) then
							local e = Enemies[i]
							if _Cast(20473,e,nil,true) then return end
						end end
					end
				end
				--glimmer teammates to maintain
				if not retard_dmg_mode then
					for i=1,#glimmers do if glimmers[i].hpdeficit > holy_shock_value / 1.45 or glimmers[i].glimmer <= min(groupsize,8) * 1.45 and glimmers_out < 8 then
						if _Cast(20473,glimmers[i].pointer) then return end
					end end
				end
				if groupsize <= 5 then
					--spread glimmer to enemies
					if shortestglimmer >= groupsize or retard_dmg_mode then
						for i=1,#Enemies do if valid_attackable(Enemies[i]) then
							local e = Enemies[i]
							if _debuffRemains(e,287280,"player") < 12 then
								if _Cast(20473,e,nil,true) then return end
							end
						end end
					end
					--target glimmer when no one needs healing
					if _valid(current_target) and (shortestglimmer >= min(groupsize,8) or retard_dmg_mode) then
						if _Cast(20473,current_target,nil,true) then return end
					end
				end
				--smal heal
				for i=1,#lowfriends do if lowfriends[i].hpdeficit > holy_shock_value/2 then
					if _Cast(20473,lowfriends[i].pointer) then return end
				end end
				if holy_shock_cd <= .5 then return end
				--overcharge
				if combat then
					_Cast(296072)
				end
			end
		end

		-- --Crusader Strike
		if UnitBuffID("player",216331) then
			for i=1,#Pets do if not _breakableCC(Pets[i]) then
				if _Cast(35395,Pets[i],nil,true) then return end
			end end
		end

		-- --bestow
		if (not arena or SQUID.auto_paladin) then
			for i=1,#lowfriends do if lowfriends[i].hp < 90 then
				_Cast(223306,lowfriends[i].pointer)
			end end
		end

		-- if (not arena or SQUID.auto_paladin) and IsPlayerSpell(183778) then
		-- 	if groupsize <= 5 then
		-- 		for i=1,#Pets do if UnitAffectingCombat(Pets[i]) and _buffStacks(Pets[i],196941,"player") < 10 then
		-- 			if _Cast(275773,Pets[i],nil,true) then return end
		-- 		end end
		-- 	else
		-- 		for i=1,#Pets do if _buffStacks(Pets[i],196941,"player") < 10 then
		-- 			if _Cast(275773,Pets[i],nil,true) then return end
		-- 		end end
		-- 	end
		-- end

		-- --Crusader Strike
		if not arena or _HP("player") > 35 then
			if ( IsPlayerSpell(196926) or retard_dmg_mode ) and ( holy_shock_cd >= gcd and GetSpellCharges(35395) == 2 or retard_dmg_mode ) then
				for i=1,#Pets do if not _breakableCC(Pets[i]) then
					if _spellCooldown(35395) < .2 and _amIfacing(Pets[i]) then
						CastSpellByID(35395,Pets[i]);
					end
				end end
			end
		end

		-- cons
		if not arena then
			if lowestFriend > 70 and ( not sq_consecrate or time - sq_consecrate > 6 ) and Enemies_Around_Unit("player",6) >= 2 then
				if _Cast(26573) then
					sq_consecrate = time
				end
			end
		end

		local hpdeficit = function(unit)
			return UnitHealthMax(unit)-UnitHealth(unit)
		end

		lod_heal = math.min(holy_shock_value/3,player_hpdeficit)

		if beacontarget then
			lod_heal = lod_heal + math.min(holy_shock_value/3,hpdeficit(beacontarget))
		else
			_Cast(53563,"player")
		end

		--light of dawn
		if combat and (not arena or SQUID.auto_paladin) then

			lod_range = breaking_dawn and 40 or 15
			lod_range = lod_range + (lod_range * (UnitBuffID("player",214202) and .5 or 0))
			for i=1,#lowfriends do
				if _realDistance(lowfriends[i].pointer) < lod_range+.5 and _amIfacing(lowfriends[i].pointer) and lowfriends[i].hpdeficit >= holy_shock_value/3 then
					lod_heal=lod_heal+math.min(holy_shock_value/3,lowfriends[i].hpdeficit)
				end
			end
			if not arena or AutoFollow then
				if lod_heal >= holy_shock_value/2 then
					_Cast(85222)
				end
			end

		end

		-- --shock offense
		-- if lowestFriend > 80 then
		-- 	for i=1,#Enemies do if UnitDebuffID(Enemies[i],214222) then
		-- 		_Cast(20473,Enemies[i])
		-- 	end end
		-- end

		-- --Crusader Strike
		if not arena or _HP("player") > 35 then
			if IsPlayerSpell(196926) and holy_shock_cd >= gcd then
				for i=1,#Pets do if not _breakableCC(Pets[i]) then
					if _spellCooldown(35395) < .2 and _amIfacing(Pets[i]) then
						CastSpellByID(35395,Pets[i]);
					end
				end end
			end
		end

		-- --flash of light
		if not arena then
			if UnitBuffID("player",54149) then
				for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value then
					if IsPlayerSpell(210294) and lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
						CastSpellByID(210294)
					end
					_Cast(19750,lowfriends[i].pointer)
				end end
				-- for i=1,#glimmers do if glimmers[i].hp < 
			end
		end

		-- --beacons
		-- if not arena or SQUID.auto_paladin then
		-- 	local top = 0
		-- 	local topdog
		-- 	for i=1,#glimmers do
		-- 		local e = EnemiesAttacking(glimmers[i].pointer)
		-- 		if e > top then
		-- 			top = e
		-- 			topdog = glimmers[i].pointer
		-- 		end
		-- 	end
		-- 	if topdog and not UnitBuffID(topdog,53563,"player") then
		-- 		_Cast(53563,topdog)
		-- 	end
		-- end



		--favor / holy light
		if not arena or SQUID.auto_paladin then
			if groupsize <= 3 then
				if UnitBuffID("player",54149) then
					if not _isMoving("player") then
						for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value/2 then
							if lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
								CastSpellByID(210294)
							end
							_Cast(82326,lowfriends[i].pointer)
						end end
					end
				end
			elseif groupsize <= 5 then
				if UnitBuffID("player",54149) then
					if not _isMoving("player") then
						for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value/2 then
							if lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
								CastSpellByID(210294)
							end
							_Cast(19750,lowfriends[i].pointer)
						end end
					end
				end
			end
		end

		if arena and SQUID.auto_paladin then
			if holy_shock_cd > 1.25 and lowestFriend > 65 - ( not player_interruptable and 20 or 0 ) then
				for i=1,#lowfriends do
					local f = lowfriends[i].pointer
					if _HP(f) < 80 then
						_Cast(82326,f)
					end
				end
			end
		end

		-- judge
		if not arena then
			if lowestFriend > 55 then
				if _valid(current_target) then
					_Cast(275773,current_target,nil,true)
				else
					for i=1,#Enemies do if valid_attackable(Enemies[i]) and not _breakableCC(Enemies[i]) and not _immuneMagic(Enemies[i]) then
						_Cast(275773,Enemies[i],nil,true)
					end end
				end
			end
		end

		-- cons
		if not arena then
			if groupsize <= 5 and lowestFriend > 70 and Enemies_Around_Unit("player",8) >= 2 then
				_Cast(26573)
			end
		end

		if (not arena) then
			for i=1,#lowfriends do
				if lowfriends[i].hpdeficit >= holy_shock_value/1.2 then
					_Cast(19750,lowfriends[i].pointer)
				end
			end
		elseif SQUID.auto_paladin and lowestFriend > 60 - ((IsPlayerSpell(296230) and _spellCooldown(296230) <= 2 or GetItemCD(158320) <= 1) and 30 or 0) and holy_shock_cd > 1.3 then
			for i=1,#lowfriends do
				if lowfriends[i].hpdeficit >= holy_shock_value/1.2 then
					_Cast(82326,lowfriends[i].pointer)
				end
			end
		end

		-- --lotm
		if (not arena or SQUID.auto_paladin) and mana > 15 and (not arena and player_hp > 65 or player_hp > 70) then
			for i=1,#lowfriends do if lowfriends[i].hp <= 65 and not unit_is_unit("player",lowfriends[i].pointer) then
				_Cast(183998,lowfriends[i].pointer)
			end end
		end

		-- --rol
		if not arena or SQUID.auto_paladin then
			if combat and not UnitBuffID("player",214202) then
				_Cast(214202)
			end
		end

		if UnitBuffID("player",216331) and _spellCooldown(275773) <= 1.5 then
			if lowestEnemy and not _immuneMagic(lowestEnemyName) then
				if _Cast(275773,lowestEnemyName,true) then return; end
			end
			for i=1,#Enemies do if not _immuneMagic(Enemies[i]) then
				_Cast(275773,Enemies[i],true);
			end end
		end

	--Prot
	elseif spec == 2 then

		local t="target"
		lowThreat = {};
		for i=1,#Enemies do
			local e=Enemies[i];
			if UnitCreatureType(e) ~= "Critter"
			--Check they're not retard mobs
			and UnitAffectingCombat(e) then
		 		--lowThreat enemy--
				local priority=0;
				if unit_is_unit(e,"target") then
					priority=priority+1;
				end
				--threat prio
				local threat = UnitThreatSituation("player",e)
				if threat then priority = priority + threat else priority = priority + 4 end
				table.insert(lowThreat,{pointer=e,priority=priority,hp=_HP(e)});
			end
		end
		table.sort(lowThreat, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)

		local lowFriends = {}
		for i=1,#lowFriends do
			local e = Friends[i];
			if UnitIsPlayer(e) then
				local priority = 0;	
				local hp = _HP(e)

				if hp < 65 and unit_is_unit("player",e) then
					priority = priority + 1
				end

				table.insert(lowFriends,{pointer=e,priority=priority,hp=hp});
			end
		end
		table.sort(lowFriends, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)

		local function _valid(unit) return UnitExists(unit) and UnitCanAttack("player",unit) and not UnitIsDeadOrGhost(unit) and not _breakableCC(unit) and (arena or UnitAffectingCombat(unit) or UnitName(unit) == "Training Dummy" or UnitIsPlayer(unit)); end

		local sotr_charges_frac = _spellChargeFrac(53600)
		local judgment_charges_frac = _spellChargeFrac(275779)
		local judgment_cd = _spellCooldown(275779)
		local judgment_full_recharge_time = (GetSpellCharges(275779)*6) - (judgment_charges_frac*6)
		local avengers_valor_up = UnitBuffID("player",197561)
		local avenging_wrath = UnitBuffID("player",31884)
		local avenging_wrath_remains = _buffRemains("player",31884)
		local consecration_up = UnitBuffID("player",188370)

		if lowThreat[1] then t=lowThreat[1].pointer end

		--dispel poisons
		for i=1,#Friends do
			local poison = cleanse_poisons(Friends[i])
			if poison then
				if _Cast(213644,Friends[i]) then
					Squid_Alert("Dispelled " .. UnitClass(Friends[i]),"("..poison..")",2)
				end
			end
		end

		if _valid(t) then
			-- # Executed every time the actor is available.

			-- actions=auto_attack
			if not auto_attack or GetTime()-auto_attack > 2 then
				StartAttack()
			end

			_Cast(62124,t)

			local function cooldowns(t)
				-- actions.cooldowns=fireblood,if=buff.avenging_wrath.up
				-- actions.cooldowns+=/use_item,name=azsharas_font_of_power,if=cooldown.seraphim.remains<=10|!talent.seraphim.enabled
				-- actions.cooldowns+=/seraphim,if=cooldown.shield_of_the_righteous.charges_fractional>=2
				-- actions.cooldowns+=/avenging_wrath,if=buff.seraphim.up|cooldown.seraphim.remains<2|!talent.seraphim.enabled
				_Cast(31884)
				-- actions.cooldowns+=/bastion_of_light,if=cooldown.shield_of_the_righteous.charges_fractional<=0.5
				if IsPlayerSpell(213652) then
					if _spellCooldown(213652) < 2 then
						local addhp = avenging_wrath and 20 or 0
						for i=1,#lowFriends do
							if lowFriends[i].hp < 70-addhp then
								_Cast(213652,lowFriends[i].pointer)
							end
						end
					end
				else
					if _HP("player") < 85 then
						_Cast(184092)
					end
				end
				-- actions.cooldowns+=/potion,if=buff.avenging_wrath.up
				-- actions.cooldowns+=/use_items,if=buff.seraphim.up|!talent.seraphim.enabled
				-- actions.cooldowns+=/use_item,name=grongs_primal_rage,if=((cooldown.judgment.full_recharge_time>4|(!talent.crusaders_judgment.enabled&prev_gcd.1.judgment))&cooldown.avengers_shield.remains>4&buff.seraphim.remains>4)|(buff.seraphim.remains<4)
				-- actions.cooldowns+=/use_item,name=merekthas_fang,if=!buff.avenging_wrath.up&(buff.seraphim.up|!talent.seraphim.enabled)
				-- actions.cooldowns+=/use_item,name=razdunks_big_red_button
			end
			-- actions+=/call_action_list,name=cooldowns
			cooldowns(t)
			-- # Dumping SotR charges
			-- actions+=/shield_of_the_righteous,if=(buff.avengers_valor.up&cooldown.shield_of_the_righteous.charges_fractional>=2.5)&(cooldown.seraphim.remains>gcd|!talent.seraphim.enabled)
			if avengers_valor_up and sotr_charges_frac >= 2.5 then
				_Cast(53600)
			end
			-- actions+=/shield_of_the_righteous,if=(buff.avenging_wrath.up&!talent.seraphim.enabled)|buff.seraphim.up&buff.avengers_valor.up
			if avengers_valor_up then
				_Cast(53600)
			end
			-- actions+=/shield_of_the_righteous,if=(buff.avenging_wrath.up&buff.avenging_wrath.remains<4&!talent.seraphim.enabled)|(buff.seraphim.remains<4&buff.seraphim.up)
			if avenging_wrath and avenging_wrath_remains < 4 then
				_Cast(53600)
			end
			-- actions+=/lights_judgment,if=buff.seraphim.up&buff.seraphim.remains<3
			-- actions+=/consecration,if=!consecration.up
			if not consecration_up then
				_Cast(26573)
			end
			-- actions+=/judgment,if=(cooldown.judgment.remains<gcd&cooldown.judgment.charges_fractional>1&cooldown_react)|!talent.crusaders_judgment.enabled
			if (judgment_cd < gcd and judgment_charges_frac > 1) or not IsPlayerSpell(204023) then
				_Cast(275779,t,nil,true)
			end
			-- actions+=/avengers_shield,if=cooldown_react
			_Cast(31935,t,nil,true)
			-- actions+=/judgment,if=cooldown_react|!talent.crusaders_judgment.enabled
			if not IsPlayerSpell(204023) then
				_Cast(275779,t,nil,true)
			end
			-- actions+=/lights_judgment,if=!talent.seraphim.enabled|buff.seraphim.up
			-- actions+=/blessed_hammer,strikes=3
			-- actions+=/hammer_of_the_righteous
			_Cast(53595,t,nil,true)
			-- actions+=/consecration
			_Cast(26573)
		end
	end

endfunction Squid_Shaman()

	if IsMounted() or IsFlying() or IsAoEPending() then return end

	local spec = GetSpecialization()
	local time = GetTime()
	local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
	local gcd_remains = GetGCD()

	--Elemental
	if spec == 1 then

		local t = current_target

		local function _valid(unit) return unit and UnitCanAttack("player",unit) and not UnitIsDeadOrGhost(unit) and not _breakableCC(unit) and not _immuneMagic(unit) and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit)))); end

		local flameshocks = {}
		local lowhp = {}
		local mostaround = {}
		for i=1,#Enemies do
			local e = Enemies[i];
			if _valid(e) then
				--low flameshock priority
				local priority = 0;
				local around = Enemies_Around_Unit(e,8)
				local fs = _debuffRemains(e,188389,"player")
				local hp = _HP(e)
				local istarget = unit_is_unit(e,t)

				priority=priority+(24-fs)
				priority=priority+(istarget and 1 or 0)

				table.insert(flameshocks,{pointer=e,priority=priority,hp=hp,fs=fs});
				
				--low hp priority
				table.insert(lowhp,{pointer=e,hp=hp,fs=fs})

				--most around priority
				around=around+(istarget and 1 or 0)
				table.insert(mostaround,{pointer=e,around=around,hp=hp,fs=fs})
			end
		end
		table.sort(flameshocks, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)
		table.sort(lowhp, function(x,y) return x.hp < y.hp end)
		table.sort(mostaround, function(x,y) return x.around > y.around end)

		local maelstrom = UnitPower("player")
		local maelstrom_max = UnitPowerMax("player")
		local maelstrom_deficit = maelstrom_max - maelstrom
		
		local lava_shock_rank = GetNumAzeritePowerTaken(178)
		local lava_shock_enabled = lava_shock_rank > 0
		local tectonic_thunder_rank = GetNumAzeritePowerTaken(417)
		local tectonic_thunder_enabled = tectonic_thunder_rank > 0

		local primal_elementalist = IsPlayerSpell(117013)
		local elemental_blast_enabled = IsPlayerSpell(117014)
		local echo_of_the_elements = IsPlayerSpell(108283)
		local master_of_the_elements = IsPlayerSpell(16166)
		local aftershock = IsPlayerSpell(273221)
		local liquid_magma_totem = IsPlayerSpell(192222)
		local surge_of_power_enabled = IsPlayerSpell(262303)
		local call_the_thunder = IsPlayerSpell(260897)
		local totem_mastery_enabled = IsPlayerSpell(210643)

		local ghost_wolf = UnitBuffID("player",2645)
		local tectonic_thunder_up = UnitBuffID("player",286976)
		local lava_shock_stacks = _buffStacks("player",273453)
		local lava_surge = UnitBuffID("player",77762)
		local lava_surge_remains = _buffRemains("player",77762)
		local stormkeeper = UnitBuffID("player",191634)
		local stormkeeper_stacks = _buffStacks("player",191634)
		local stormkeeper_remains = _buffRemains("player",191634)
		local surge_of_power = UnitBuffID("player",285514)
		local master_of_the_elements_up = UnitBuffID("player",260734)
		local totem_mastery = UnitBuffID("player",202192) and UnitBuffID("player",210652) and UnitBuffID("player",210658) and UnitBuffID("player",210659)
		local flame_shock_remains = 0
		if _valid(t) then flame_shock_remains = _debuffRemains(t,188389,"player") end
		local flame_shock_ticking = flame_shock_remains > 1.6

		local fire_elemental_cd = _spellCooldown(198067)
		local lava_burst_charges = GetSpellCharges(51505)

		local hex_cast_time = _castTime(51514)

		local their_healer = theirHealer
		local their_healer_cc
		local their_healer_cc_remains = 0
		local their_healer_incapacitate_dr
		local their_healer_incapacitate_dr_remains = 0
		if their_healer then
			their_healer_cc_remains = _CCremains(their_healer)
			their_healer_cc = their_healer_cc_remains > 0
			their_healer_incapacitate_dr = _incapacitateDR(their_healer)
			their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
		end

		if ghost_wolf then return end

		--hex healer / off target on cd
		if their_healer then
			if not _isBeast(their_healer) and _CCremains(their_healer) <= hex_cast_time and _drRemains(their_healer,"incapacitate") < hex_cast_time then
				_Cast(51514,their_healer)
			end
		else
			local off_target
			for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) then
				off_target=Enemies[i]
			end end
			if off_target then
				if not _isBeast(off_target) and _CCremains(off_target) <= hex_cast_time and _drRemains(off_target,"incapacitate") < hex_cast_time then
					_Cast(51514,off_target)
				end
				--off target cc treated as healer cc when there is no healer
				their_healer_cc_remains = _CCremains(off_target)
			end
		end

		local function get_totem_mastery_remaining ()
			local cd = 0
			if totem_mastery_placed then
				cd = 120 - (time-totem_mastery_placed)
			end
			cd= cd> 0 and cd or 0
			return cd
		end

		local totem_mastery_remains = get_totem_mastery_remaining ()

		local function get_chain_lightning_targets(unit)
			
			local count = 1
			local already_counted = {ObjectPointer(unit)}

			local nearby = {}
			for i=1,#Enemies do if not tContains(already_counted,Enemies[i]) then
				local e=Enemies[i]
				local d=_distance(unit,e)
				table.insert(nearby,{pointer=e,distance=d})
			end end
			table.sort(nearby, function(x,y) return x.distance < y.distance end)

			if nearby[2] and nearby[2].distance > 5 then
				nearby[2] = nearby[1]
			end

			if not nearby[2] then nearby[2]=nearby[1] end

			if nearby[2] then
				if nearby[2].distance < 9.5 then
					table.insert(already_counted,nearby[2].pointer)
					unit=nearby[2].pointer
				end
			end

			for n=1,3 do

				nearby = {}
				for i=1,#Enemies do if not tContains(already_counted,Enemies[i]) then
					local e=Enemies[i]
					local d=_distance(unit,e)
					table.insert(nearby,{pointer=e,distance=d})
				end end
				table.sort(nearby, function(x,y) return x.distance < y.distance end)

				if nearby[1] then
					if nearby[1].distance < 9.5 then
						table.insert(already_counted,nearby[1].pointer)
						unit=nearby[1].pointer
					end
				end

			end

			return #already_counted

		end

		local spell_targets_chain_lightning = 0

		if _valid(t) then spell_targets_chain_lightning = get_chain_lightning_targets(t) end

		if arena and time_in_combat < 5 then

			local precombat = _valid(t) and _distance(t) < 30

			-- actions.precombat+=/earth_elemental,if=!talent.primal_elementalist.enabled
			if precombat and not primal_elementalist then
				_Cast(198103)
			end
			-- actions.precombat+=/stormkeeper,if=talent.stormkeeper.enabled&(raid_event.adds.count<3|raid_event.adds.in>50)
			if precombat and stormkeeper_enabled then
				if spell_targets_chain_lightning < 3 then
					_Cast(191634)
				end
			end
			-- actions.precombat+=/fire_elemental,if=!talent.storm_elemental.enabled
			if not storm_elemental and precombat then
				_Cast(198067)
			end
			-- actions.precombat+=/storm_elemental,if=talent.storm_elemental.enabled
			-- actions.precombat+=/elemental_blast,if=talent.elemental_blast.enabled
			if precombat and elemental_blast_enabled then
				_Cast(117014)
			end
			-- actions.precombat+=/lava_burst,if=!talent.elemental_blast.enabled&spell_targets.chain_lightning<3
			-- actions.precombat+=/chain_lightning,if=spell_targets.chain_lightning>2

		end

		if _valid(t) then
			-- actions+=/totem_mastery,if=talent.totem_mastery.enabled&buff.resonance_totem.remains<2
			if totem_mastery_remains < 2 then
				_Cast(210643)
			end
			--lasso target
			if their_healer_cc_remains >= 4 then
				RunMacroText("/use 14")
				RunMacroText("/use 13")
				_Cast(305483,t,true)
			end
			--breath of the dying
			if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains then
				local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t))
				if hp < 20 or _HP(t) > 80 then
					if _Cast(310690,t,true) then
						Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
					end
				end
			end
			-- actions+=/fire_elemental,if=!talent.storm_elemental.enabled
			if not storm_elemental then
				_Cast(198067)
			end
			-- actions+=/storm_elemental,if=talent.storm_elemental.enabled&(!talent.icefury.enabled|!buff.icefury.up&!cooldown.icefury.up)&(!talent.ascendance.enabled|!cooldown.ascendance.up)
			-- actions+=/earth_elemental,if=!talent.primal_elementalist.enabled|talent.primal_elementalist.enabled&(cooldown.fire_elemental.remains<120&!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120&talent.storm_elemental.enabled)
			if not primal_elementalist or primal_elementalist and fire_elemental_cd < 120 then
				_Cast(198103)
			end
			-- actions+=/concentrated_flame
			_Cast(295373,t,true)
			-- actions+=/blood_of_the_enemy
			-- actions+=/guardian_of_azeroth
			-- actions+=/focused_azerite_beam
			-- actions+=/purifying_blast
			-- actions+=/the_unbound_force
			-- actions+=/memory_of_lucid_dreams
			-- actions+=/ripple_in_space
			-- actions+=/worldvein_resonance
			-- actions+=/blood_fury,if=!talent.ascendance.enabled|buff.ascendance.up|cooldown.ascendance.remains>50
			-- actions+=/berserking,if=!talent.ascendance.enabled|buff.ascendance.up
			-- actions+=/fireblood,if=!talent.ascendance.enabled|buff.ascendance.up|cooldown.ascendance.remains>50
			-- actions+=/ancestral_call,if=!talent.ascendance.enabled|buff.ascendance.up|cooldown.ascendance.remains>50


			local function aoe(t)
				-- # Multi target action priority list
				-- actions.aoe=stormkeeper,if=talent.stormkeeper.enabled
				if stormkeeper_enabled then
					_Cast(191634)
				end
				-- # Spread Flame Shock in <= 4 target fights, but not during SE uptime,unless you're fighting 3 targets and have less than 14 Wind Gust stacks.
				-- actions.aoe+=/flame_shock,target_if=refreshable&(spell_targets.chain_lightning<(5-!talent.totem_mastery.enabled)|!talent.storm_elemental.enabled&(cooldown.fire_elemental.remains>(120+14*spell_haste)|cooldown.fire_elemental.remains<(24-14*spell_haste)))&(!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120|spell_targets.chain_lightning=3&buff.wind_gust.stack<14)
				for i=1,#flameshocks do
					local e=flameshocks[i]
					if e.fs < 1.7 then
						_Cast(188389,e.pointer,nil,true)
					end
				end
				-- actions.aoe+=/ascendance,if=talent.ascendance.enabled&(talent.storm_elemental.enabled&cooldown.storm_elemental.remains<120&cooldown.storm_elemental.remains>15|!talent.storm_elemental.enabled)&(!talent.icefury.enabled|!buff.icefury.up&!cooldown.icefury.up)
				-- actions.aoe+=/liquid_magma_totem,if=talent.liquid_magma_totem.enabled
				if liquid_magma_totem then _Cast(192222) end
				-- # Try to game Earthquake with Master of the Elements buff when fighting 3 targets. Don't overcap Maelstrom!
				-- actions.aoe+=/earthquake,if=!talent.master_of_the_elements.enabled|buff.stormkeeper.up|maelstrom>=(100-4*spell_targets.chain_lightning)|buff.master_of_the_elements.up|spell_targets.chain_lightning>3
				if not master_of_the_elements or stormkeeper or maelstrom >= (100-4*spell_targets_chain_lightning) or master_of_the_elements_up or spell_targets_chain_lightning > 3 then
					for i=1,#mostaround do
						local e=mostaround[i]
						if e.around >= 3 and not breakable_cc_around(e.pointer,10) then
							_AeCast(61882,e.pointer,40,8)
						end
					end 
				end
				-- # Make sure you don't lose a Stormkeeper.
				-- actions.aoe+=/chain_lightning,if=buff.stormkeeper.remains<3*gcd*buff.stormkeeper.stack
				if stormkeeper and stormkeeper_remains < 3*gcd*stormkeeper_stacks then
					_Cast(188443,t,true)
				end
				-- # Only cast Lava Burst on three targets if it is an instant and Storm Elemental is NOT active.
				-- actions.aoe+=/lava_burst,if=buff.lava_surge.up&spell_targets.chain_lightning<4&(!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120)&dot.flame_shock.ticking
				if lava_surge and spell_targets_chain_lightning < 4 then
					for i=1,#lowhp do
						local e=lowhp[i]
						if e.fs > 0 then
							_Cast(51505,e.pointer,nil,true)
						end
					end
				end
				-- actions.aoe+=/icefury,if=spell_targets.chain_lightning<4&!buff.ascendance.up
				-- actions.aoe+=/frost_shock,if=spell_targets.chain_lightning<4&buff.icefury.up&!buff.ascendance.up
				-- # Use Elemental Blast against up to 3 targets as long as Storm Elemental is not active.
				-- actions.aoe+=/elemental_blast,if=talent.elemental_blast.enabled&spell_targets.chain_lightning<4&(!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120)
				if elemental_blast_enabled and spell_targets_chain_lightning < 4 then
					_Cast(117014,t,true)
				end
				-- actions.aoe+=/lava_beam,if=talent.ascendance.enabled
				-- actions.aoe+=/chain_lightning
				_Cast(188443,t,true)
				-- actions.aoe+=/lava_burst,moving=1,if=talent.ascendance.enabled
				if lava_surge then
					for i=1,#lowhp do
						local e=lowhp[i]
						if e.fs > 0 then
							_Cast(51505,e.pointer,nil,true)
						end
					end
				end
				-- actions.aoe+=/flame_shock,moving=1,target_if=refreshable
				for i=1,#flameshocks do
					local e=flameshocks[i]
					if e.fs < 3.4*spell_targets_chain_lightning then
						_Cast(188389,e.pointer,nil,true)
					end
				end
				-- actions.aoe+=/frost_shock,moving=1
				if _spellCooldown(188389) == 0 then
					_Cast(196840,t,true)
				end
			end

			local function single_target(t)
				-- # Single Target Action Priority List
				-- # Ensure FS is active unless you have 14 or more stacks of Wind Gust from Storm Elemental. (Edge case: upcoming Asc but active SE; don't )
				-- actions.single_target=flame_shock,target_if=(!ticking|talent.storm_elemental.enabled&cooldown.storm_elemental.remains<2*gcd|dot.flame_shock.remains<=gcd|talent.ascendance.enabled&dot.flame_shock.remains<(cooldown.ascendance.remains+buff.ascendance.duration)&cooldown.ascendance.remains<4&(!talent.storm_elemental.enabled|talent.storm_elemental.enabled&cooldown.storm_elemental.remains<120))&(buff.wind_gust.stack<14|azerite.igneous_potential.rank>=2|buff.lava_surge.up|!buff.bloodlust.up)&!buff.surge_of_power.up
				if not flame_shock_ticking and not surge_of_power then
					_Cast(188389,t,true)
				end
				-- # Use Ascendance after you've spent all Lava Burst charges and only if neither Storm Elemental nor Icefury are currently active.
				-- actions.single_target+=/ascendance,if=talent.ascendance.enabled&(time>=60|buff.bloodlust.up)&cooldown.lava_burst.remains>0&(cooldown.storm_elemental.remains<120|!talent.storm_elemental.enabled)&(!talent.icefury.enabled|!buff.icefury.up&!cooldown.icefury.up)
				-- # Don't use Elemental Blast if you could cast a Master of the Elements empowered Earth Shock instead. Don't cast Elemental Blast during Storm Elemental unless you have 3x Natural Harmony. But in this case stop using Elemental Blast once you reach 14 stacks of Wind Gust.
				-- actions.single_target+=/elemental_blast,if=talent.elemental_blast.enabled&(talent.master_of_the_elements.enabled&buff.master_of_the_elements.up&maelstrom<60|!talent.master_of_the_elements.enabled)&(!(cooldown.storm_elemental.remains>120&talent.storm_elemental.enabled)|azerite.natural_harmony.rank=3&buff.wind_gust.stack<14)
				-- # Keep SK for large or soon add waves. Unless you have Surge of Power, in which case you want to double buff Lightning Bolt by pooling Maelstrom beforehand. Example sequence: 100MS, ES, SK, LB, LvB, ES, LB
				-- actions.single_target+=/stormkeeper,if=talent.stormkeeper.enabled&(raid_event.adds.count<3|raid_event.adds.in>50)&(!talent.surge_of_power.enabled|buff.surge_of_power.up|maelstrom>=44)
				if _HP(t) < 85 then
					_Cast(191634)
				end
				-- actions.single_target+=/liquid_magma_totem,if=talent.liquid_magma_totem.enabled&(raid_event.adds.count<3|raid_event.adds.in>50)
				if liquid_magma_totem then
					_Cast(192222)
				end
				-- # Combine Stormkeeper with Master of the Elements or Surge of Power unless you have the Lava Shock trait and multiple stacks.
				-- actions.single_target+=/lightning_bolt,if=buff.stormkeeper.up&spell_targets.chain_lightning<2&(azerite.lava_shock.rank*buff.lava_shock.stack)<26&(buff.master_of_the_elements.up&!talent.surge_of_power.enabled|buff.surge_of_power.up)
				if stormkeeper and spell_targets_chain_lightning < 2 and (lava_shock_rank * lava_shock_stacks) < 26 and (master_of_the_elements or surge_of_power) then
					_Cast(188196,t,true)
				end
				-- # Use Earthquake versus 2 targets, unless you have Lava Shock. Use Earthquake versus 1 target if you have Tectonic Thunder 3 times and NO Surge of Power enabled and NO Lava Shock.
				-- actions.single_target+=/earthquake,if=(spell_targets.chain_lightning>1|azerite.tectonic_thunder.rank>=3&!talent.surge_of_power.enabled&azerite.lava_shock.rank<1)&azerite.lava_shock.rank*buff.lava_shock.stack<(36+3*azerite.tectonic_thunder.rank*spell_targets.chain_lightning)&(!talent.surge_of_power.enabled|!dot.flame_shock.refreshable|cooldown.storm_elemental.remains>120)&(!talent.master_of_the_elements.enabled|buff.master_of_the_elements.up|cooldown.lava_burst.remains>0&maelstrom>=92+30*talent.call_the_thunder.enabled)
				if (spell_targets_chain_lightning > 1 or tectonic_thunder_rank >= 3 and not surge_of_power_enabled and lava_shock_rank < 1) and lava_shock_rank*lava_shock_stacks < (36+3*tectonic_thunder_rank*spell_targets_chain_lightning) and (not surge_of_power_enabled or flame_shock_ticking) and (not master_of_the_elements or master_of_the_elements or _spellCooldown(51505) > GetGCD() and maelstrom >= 92+30*(call_the_thunder and 1 or 0)) then
					if not breakable_cc_around(t,10) then
						_AeCast(61882,t,40,8)
					end
				end
				-- # Cast Earth Shock with Master of the Elements talent but no active Surge of Power buff, and active Stormkeeper buff and Lava Burst coming off CD within the next GCD, and either active Master of the Elements buff, or no available Lava Burst while near MS cap, or single target and multiple Lava Shock traits and many stacks.
				-- actions.single_target+=/earth_shock,if=!buff.surge_of_power.up&talent.master_of_the_elements.enabled&(buff.master_of_the_elements.up|cooldown.lava_burst.remains>0&maelstrom>=92+30*talent.call_the_thunder.enabled|spell_targets.chain_lightning<2&(azerite.lava_shock.rank*buff.lava_shock.stack<26)&buff.stormkeeper.up&cooldown.lava_burst.remains<=gcd)
				if not surge_of_power and master_of_the_elements and (master_of_the_elements_up or _spellCooldown(51505) > GetGCD() and maelstrom >= 92+30*(call_the_thunder and 1 or 0) or spell_targets_chain_lightning < 2 and (lava_shock_rank*lava_shock_stacks < 26) and stormkeeper and _spellCooldown(51505) <= gcd) then
					_Cast(8042,t,true)
				end
				-- # You know what? I had some short explanation here once. But then the condition grew, and I had to split the one Earth Shock line into four...so you have to deal with this abomination now: Cast Earth Shock without Master of the Elements talent, and without having triple Igneous Potential and active Ascendance, and active Stormkeeper buff or near MS cap, or Storm Elemental is inactive, and we can't expect to get an additional use of Storm Elemental in the remaining fight from Surge of Power.
				-- actions.single_target+=/earth_shock,if=!talent.master_of_the_elements.enabled&!(azerite.igneous_potential.rank>2&buff.ascendance.up)&(buff.stormkeeper.up|maelstrom>=90+30*talent.call_the_thunder.enabled|!(cooldown.storm_elemental.remains>120&talent.storm_elemental.enabled)&expected_combat_length-time-cooldown.storm_elemental.remains-150*floor((expected_combat_length-time-cooldown.storm_elemental.remains)%150)>=30*(1+(azerite.echo_of_the_elementals.rank>=2)))
				if not master_of_the_elements and (stormkeeper or maelstrom >= 90+30*(call_the_thunder and 1 or 0)) then
					_Cast(8042,t,true)
				end
				-- # Use Earth Shock if Surge of Power is talented, but neither it nor a DPS Elemental is active at the moment, and Lava Burst is ready or will be ready within the next GCD.
				-- actions.single_target+=/earth_shock,if=talent.surge_of_power.enabled&!buff.surge_of_power.up&cooldown.lava_burst.remains<=gcd&(!talent.storm_elemental.enabled&!(cooldown.fire_elemental.remains>120)|talent.storm_elemental.enabled&!(cooldown.storm_elemental.remains>120))
				-- actions.single_target+=/lightning_lasso
				-- # Spam Lightning Bolts during Storm Elemental duration, if you don't have Igneous Potential or have it only once, and don't use Lightning Bolt during Bloodlust if you have a Lava Surge Proc.
				-- actions.single_target+=/lightning_bolt,if=cooldown.storm_elemental.remains>120&talent.storm_elemental.enabled&(azerite.igneous_potential.rank<2|!buff.lava_surge.up&buff.bloodlust.up)
				-- # Cast Lightning Bolt regardless of the previous condition if you'd lose a Stormkeeper stack or have Stormkeeper and Master of the Elements active.
				-- actions.single_target+=/lightning_bolt,if=(buff.stormkeeper.remains<1.1*gcd*buff.stormkeeper.stack|buff.stormkeeper.up&buff.master_of_the_elements.up)
				if stormkeeper and stormkeeper_remains < 1.1*gcd*stormkeeper_stacks or stormkeeper and master_of_the_elements then
					_Cast(188196,t,true)
				end
				-- # Use Frost Shock with Icefury and Master of the Elements.
				-- actions.single_target+=/frost_shock,if=talent.icefury.enabled&talent.master_of_the_elements.enabled&buff.icefury.up&buff.master_of_the_elements.up
				-- actions.single_target+=/lava_burst,if=buff.ascendance.up
				-- # Utilize Surge of Power to spread Flame Shock if multiple enemies are present.
				-- actions.single_target+=/flame_shock,target_if=refreshable&active_enemies>1&buff.surge_of_power.up
				if surge_of_power then
					for i=1,#flameshocks do
						local e=flameshocks[i]
						if e.fs < 4.8 then
							_Cast(188389,e.pointer,nil,true)
						end
					end
				end
				-- # Use Lava Burst with Surge of Power if the last potential usage of Storm Elemental hasn't a full duration OR if you could get another usage of the DPS Elemental if the remaining fight was 16% longer.
				-- actions.single_target+=/lava_burst,if=talent.storm_elemental.enabled&cooldown_react&buff.surge_of_power.up&(expected_combat_length-time-cooldown.storm_elemental.remains-150*floor((expected_combat_length-time-cooldown.storm_elemental.remains)%150)<30*(1+(azerite.echo_of_the_elementals.rank>=2))|(1.16*(expected_combat_length-time)-cooldown.storm_elemental.remains-150*floor((1.16*(expected_combat_length-time)-cooldown.storm_elemental.remains)%150))<(expected_combat_length-time-cooldown.storm_elemental.remains-150*floor((expected_combat_length-time-cooldown.storm_elemental.remains)%150)))
				-- # Use Lava Burst with Surge of Power if the last potential usage of Fire Elemental hasn't a full duration OR if you could get another usage of the DPS Elemental if the remaining fight was 16% longer.
				-- actions.single_target+=/lava_burst,if=!talent.storm_elemental.enabled&cooldown_react&buff.surge_of_power.up&(expected_combat_length-time-cooldown.fire_elemental.remains-150*floor((expected_combat_length-time-cooldown.fire_elemental.remains)%150)<30*(1+(azerite.echo_of_the_elementals.rank>=2))|(1.16*(expected_combat_length-time)-cooldown.fire_elemental.remains-150*floor((1.16*(expected_combat_length-time)-cooldown.fire_elemental.remains)%150))<(expected_combat_length-time-cooldown.fire_elemental.remains-150*floor((expected_combat_length-time-cooldown.fire_elemental.remains)%150)))
				if not storm_elemental and surge_of_power then
					_Cast(51505,t,true)
				end
				-- actions.single_target+=/lightning_bolt,if=buff.surge_of_power.up
				if surge_of_power then
					_Cast(188196,t,true)
				end
				-- actions.single_target+=/lava_burst,if=cooldown_react&!talent.master_of_the_elements.enabled
				if not master_of_the_elements then
					if flame_shock_ticking then
						_Cast(51505,t,true)
					end
				end
				-- # Slightly game Icefury buff to hopefully buff some empowered Frost Shocks with Master of the Elements.
				-- actions.single_target+=/icefury,if=talent.icefury.enabled&!(maelstrom>75&cooldown.lava_burst.remains<=0)&(!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120)
				-- actions.single_target+=/lava_burst,if=cooldown_react&charges>talent.echo_of_the_elements.enabled
				if flame_shock_ticking and lava_burst_charges > (echo_of_the_elements and 1 or 0) then
					_Cast(51505,t,true)
				end
				-- # Slightly delay using Icefury empowered Frost Shocks to empower them with Master of the Elements too.
				-- actions.single_target+=/frost_shock,if=talent.icefury.enabled&buff.icefury.up&buff.icefury.remains<1.1*gcd*buff.icefury.stack
				-- actions.single_target+=/lava_burst,if=cooldown_react
				if flame_shock_ticking then
					_Cast(51505,t,true)
				end
				-- # Don't accidentally use Surge of Power with Flame Shock during single target.
				-- actions.single_target+=/flame_shock,target_if=refreshable&!buff.surge_of_power.up
				if not surge_of_power and flame_shock_remains <= 6.4 then
					_Cast(188389,t,true)
				end
				-- actions.single_target+=/totem_mastery,if=talent.totem_mastery.enabled&(buff.resonance_totem.remains<6|(buff.resonance_totem.remains<(buff.ascendance.duration+cooldown.ascendance.remains)&cooldown.ascendance.remains<15))
				if totem_mastery_enabled and totem_mastery_remains < 6 then
					_Cast(210643)
				end 
				-- actions.single_target+=/frost_shock,if=talent.icefury.enabled&buff.icefury.up&(buff.icefury.remains<gcd*4*buff.icefury.stack|buff.stormkeeper.up|!talent.master_of_the_elements.enabled)
				-- actions.single_target+=/chain_lightning,if=buff.tectonic_thunder.up&!buff.stormkeeper.up&spell_targets.chain_lightning>1
				if tectonic_thunder_up and not stormkeeper and spell_targets_chain_lightning > 1 then
					_Cast(188443,t,true)
				end 
				-- actions.single_target+=/lightning_bolt
				_Cast(188196,t,true)
				-- actions.single_target+=/flame_shock,moving=1,target_if=refreshable
				if flame_shock_remains < 11.2 then
					_Cast(188389,t,true)
				end
				-- actions.single_target+=/flame_shock,moving=1,if=movement.distance>6
				-- # Frost Shock is our movement filler.
				-- actions.single_target+=/frost_shock,moving=1
				if _spellCooldown(188389) == 0 then
					if _isMoving("player") then
						_Cast(196840,t,true)
					end
				end
			end

			-- actions+=/run_action_list,name=aoe,if=active_enemies>2&(spell_targets.chain_lightning>2|spell_targets.lava_beam>2)
			if spell_targets_chain_lightning > 2 then
				aoe(t)
			end

			-- actions+=/run_action_list,name=single_target
			single_target(t)

		end

	end

endfunction Squid_Warrior()
	
	if UnitIsDeadOrGhost("player") or (IsMounted() and not SQUID.cap_bot) or IsFlying() then return end

	local spec = GetSpecialization()
	
	--Covenant ids and spells
	local covenant = {
        ids = {
            none = 0,
            kyrian = 1,
            venthyr = 2,
            nightFae = 3,
            necroLord = 4,
        },
        kyrian = {
            spearOfBastian = 307865,
            callSteward = 324739,
		},
		venthyr = {
			condemn = 330325,
			doorOfShadows = 300728,

		},
	}

	--Warrior Skills
	local warrior = {
		battleShout = 6673,
		berserkerRage = 18499,
		challengingShout = 1161,
		charge = 100,
		execute = 163201,
		hamstring = 1715,
		heroicLeap = 6544,
		heroicThrow = 57755,
		ignorePain = 190456,
		intervene = 3411,
		intimidatingShout = 5246,
		pummel = 6552,
		rallyingCry = 316825,
		shatteringThrow = 64382,
		shieldBlock = 2565,
		shieldSlam = 23922,
		slam = 1464,
		spellReflection = 23920,
		taunt = 355,
		victoryRush = 34428,
		whirlwind = 1680,

		buffs = {
			ignorePain = 190456,
			shieldBlock = 132404,
			victorious = 32216,

			--Torghast
			voraciousCullingBlade = 329214, --Execute regardless of health
			umbralEarTrumpet = 329283,
		},
	}
	local arms = {
		avatar = 107574,
		bladestorm = 227847,
		colossusSmash = 167105,
		deadlyCalm = 262228,
		dieByTheSword = 315948,
		mortalStrike = 12294,
		overPower = 7384,
		piercingHowl = 12323,
		ravager = 152277,
		sharpenBlade = 198817,
		skullSplitter = 260643,
		stormBolt = 107570,
		sweepingStrikes = 316433,
		warBreaker = 262161,

		buffs = {
			avatar = 107574,
			deadlyCalm = 262228,
			overPower = 7384,
			suddenDeath = 52437,
		},

		debuffs = {
			colossusSmash = 208086,
			deepWounds = 262115,
			rend = 772,
		},
	}
		local prot = {
			avatar = 107574,
			demoShout = 1160,
			lastStand = 12975,
			revenge = 6572,
			shieldWall = 871,
			shockWave = 46968,
			thunderClap = 6343,

		}

	--Local functions
	local function _valid(unit,immune) 
		return unit
		and UnitCanAttack("player",unit)
		and not UnitIsDeadOrGhost(unit) 
		and not _breakableCC(unit,true)
		and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
		and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
	end
	local function debuff_remains(unit, spellID)
		if not UnitDebuffID(unit, spellID) then
			return 0;
		else
			return _debuffRemains(unit, spellID);
		end
	end
	local function buff_remains(unit, spellID)
		if not UnitBuffID(unit, spellID) then
			return 0;
		else
			return _buffRemains(unit, spellID);
		end
	end
	local function valid_enemies_around(unit, dist)
		local count = 0
		for i = 1, #Enemies do
			if _valid(Enemies[i]) and _distance(Enemies[i], unit) <= dist and not _breakableCC(Enemies[i], false) then
				count = count + 1
			end
		end
		return count;
	end
	local function dynamicTargeting(range)
		--Target enemies above 75% or below 35% preferably
		local bestUnit = bestUnit or nil
		if bestUnit == nil then
			if #Enemies > 0 then
				for i = 1, #Enemies do
					local thisUnit = Enemies[i]
					if _distance('player', thisUnit) <= range and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
						bestUnit = thisUnit
					end
				end
			end
		end
		if not UnitExists("target") and UnitAffectingCombat('player') then
			TargetUnit(bestUnit)
		end
	end
	local function is_instance_boss(unit)
		if IsInInstance() then
			local _, _, encountersTotal = GetInstanceLockTimeRemaining()
			for i = 1, encountersTotal do
				if unit == 'player' then
					local bosses = select(1, GetInstanceLockTimeRemainingEncounter(i))
				end
				if (UnitIsVisible(unit) or false) then
					local boss = GetInstanceLockTimeRemainingEncounter(i)
					local tar = UnitName(unit)
					if tar == boss then return true end
				end
			end
			for j = 1, 5 do
				local num = 'boss' .. j
				if unit_is_unit(num, unit) then return true end
			end
		end
		return false    
	end
	local function encounter_name(index)
		--Total of 10 Encounters
		if inInstance and instanceType == 'raid' and instanceName == "Castle Nathria" then
			local boss = GetInstanceLockTimeRemainingEncounter(index)
			return boss
		end
	end
	local function is_boss(unit)
		if unit == nil then 
			unit = t 
		end
		--Probably needs locales set for totems
		if (UnitIsVisible(unit) or false) and UnitCreatureType(unit) ~= 'Totem' then
			local unitClass = UnitClassification(unit)
			local hMax = UnitHealthMax(unit)
			local pMax = UnitHealthMax('player')
			local instance = select(2, IsInInstance())
			return is_instance_boss(unit) 
					or _isDummy(unit)
					or not UnitIsTrivial(unit) and instance ~= 'party' and (unitClass == "rare" and hMax > 4 * pMax) or UnitLevel(unit) < 0
		end
		return false
	end
	function ItemLinkToName(link)
		return gsub(link, "^.*%[(.*)%].*$", "%1");
	end
	local function IsItemInBags(search)
		for bag = 0, 4 do
			for slot = 1, GetContainerNumSlots(bag) do
				local item = GetContainerItemLink(bag, slot)
				if item and item:find(search) then
					return true
				end
			end
		end
		return false
	end
	local function FindItem(item)
		if (not item) then return; end
		item = string.lower(ItemLinkToName(item));
		local link;
		for i = 1, 23 do
			link = GetInventoryItemLink("player", i);
			if (link) then
				if (item == string.lower(ItemLinkToName(link)))then
					return i, nil, GetInventoryItemTexture('player', i), GetInventoryItemCount('player', i);
				end
			end
		end
		local count, bag, slot, texture;
		local totalcount = 0;
		local MAX_CONTAINER_ITEMS = 0;
		for i = 1, 4 do
			MAX_CONTAINER_ITEMS = MAX_CONTAINER_ITEMS + GetContainerNumSlots(i)
		end
		for i = 0, NUM_BAG_FRAMES do
			for j = 1, MAX_CONTAINER_ITEMS do
				link = GetContainerItemLink(i, j);
				if (link) then
					if (item == string.lower(ItemLinkToName(link))) then
						bag, slot = i, j;
						texture, count = GetContainerItemInfo(i, j);
						totalcount = totalcount + count;
					end
				end
			end
		end
		return bag, slot, texture, totalcount;
	end

	local t=current_target
	local covenantID = C_Covenants.GetActiveCovenantID()
	local t_is_boss = (t and is_boss(t) or false)

	local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
	local gcd_remains = GetGCD()
	local rage = UnitPower("player")
	local inInstance, instanceType = IsInInstance()
	local instanceName, instanceType, difficultyID, difficultyName, maxPlayers, dynamicDifficulty, isDynamic, instanceID, instanceGroupSize, LfgDungeonID = GetInstanceInfo()
	local phialInBags = IsItemInBags("Phial of Serenity")
	local phialCountInBags = select(4, FindItem("Phial of Serenity"))


	--All Spec Actions
	---------------------------------------------------------------------------------------------------------
	local auto_target = SQUID.auto_target
	if auto_target then
		dynamicTargeting(10)
	end

	--buff
	for i=1,#Friends do 
		if not UnitBuffID(Friends[i],6673) and _distance(Friends[i]) < 40 then
			_Cast(6673)
		end
	end

	--hams
	if not disarm_check('player') and _valid(t, 1) and GetUnitSpeed("player") <= GetUnitSpeed(t) or _rootCheck("player") then
		if UnitIsPlayer(t) and not _slowCheck(t) and not _slowImmuneCheck(t) then
			_Cast(1715,t,true)
		end
	end

	--victory rush
	if not disarm_check('player') and _valid(t, 1) and _meleeRange('player', t) then
		if UnitBuffID('player', warrior.buffs.victorious) and _HP('player') <= 80 then
			_Cast(warrior.victoryRush, t, true)
		end
	end

	--Refresh pots no matter what if we run out
	if not phialInBags and _spellCooldown(covenant.kyrian.callSteward) == 0 then
		_Cast(covenant.kyrian.callSteward)
	--Refresh Pots while not in combat
	elseif phialCountInBags < 3 and _spellCooldown(covenant.kyrian.callSteward) == 0 and not UnitAffectingCombat('player') then
		_Cast(covenant.kyrian.callSteward)
	end
	---------------------------------------------------------------------------------------------------------

	--Torghast Stuff
	local inTorghast = inInstance and instanceType == 'scenario' and instanceName == 'Torghast, Tower of the Damned'
	if inTorghast then
		local torg_reflect_list = {
			[292926] = true, --Eternal Torment .. FUCKING HURTS
		}
		--Spell Reflection
		for i = 1, #Enemies do
			local unitTarget = UnitTarget(Enemies[i])
			local castID = select(9, UnitCastingInfo(Enemies[i]))
			if UnitCastingInfo(Enemies[i]) then
				if unit_is_unit('player', unitTarget) and torg_reflect_list[castID] then
					Squid_Alert("Reflecting this BULLSHIT.")
					_Cast(warrior.spellReflection)
				end
			end
		end
	end
	--Arms
	if spec == 1 then
		
		local auto_charge = SQUID.auto_charge
		local auto_leap = SQUID.auto_leap

		--zerk
		if _spellCooldown(18499) == 0 and _shouldZerk() then
			if _Cast(18499,_,_,_,true) then
				Squid_Alert("Berserker Rage","(CC)",2)
			end
		end

		local auto_burst = SQUID.auto_burst

		if IsMounted() then return end

		local cs = UnitDebuffID(current_target,208086,"player")
		local cs_remains = _debuffRemains(current_target,208086,"player")
		local Warbreaker = IsPlayerSpell(262161)
		local WarbreakerCD = _spellCooldown(262161)
		local BladestormCD = _spellCooldown(227847)
		local csCD = _spellCooldown(167105)
		local wbCD = _spellCooldown(262161)
		local flame_ticking = UnitDebuffID(current_target,295367,"player")
		local spell_targets_whirlwind = EnemiesAroundMe(8)
		local executeHp = 20 + (IsPlayerSpell(281001) and 15 or 0)
		local deadly_calm_taken = IsPlayerSpell(262228)
		local deadly_calm = UnitBuffID("player",262228)
		local crushing_assault = UnitBuffID("player",278826)
		local overpower = UnitBuffID("player",7384)
		local overpower_stacks = _buffStacks("player",7384)
		local sudden_death = UnitBuffID("player",52437)
		local dreadnaught_taken = IsPlayerSpell(262150)
		local massacre_taken = IsPlayerSpell(281001)
		local executioners_precision_stacks = _buffStacks("player",242188)
		local fervor_of_battle = IsPlayerSpell(202316)
		local rend_remains = _debuffRemains(t,772,"player")
		local defensive_stance = UnitBuffID("player",197690)
		local player_hp = _HP("player")
		local bcc = _bccAM(11)
		local their_healer_cc
		if theirHealer and (_CCcheck(theirHealer) or IsLocked(theirHealer)) then their_healer_cc = true end
		if not theirHealer then their_healer_cc=true end
		local enemies_attacking_me = EnemiesAttacking("player")
		local our_healer_cc = ourHealer and _CCcheck(ourHealer)
		local execute_phase = t ~= nil and (covenantID == covenant.ids.venthyr and (_HP(t) <= executeHp or _HP(t) >= 80)) or (covenantID ~= covenant.ids.venthyr and _HP(t) <= executeHp)
		local melee_range = _valid(t, 1) and _meleeRange(t)

		local should_colossus_smash = melee_range and not bcc and (their_healer_cc or _HP(t) < 90)

		local peel_hp = 45
		for i=1,#Enemies do if _CDcheck(Enemies[i]) then peel_hp = peel_hp + 40 end end
		peel_hp = peel_hp + (our_healer_cc and 40 or 0)

		--banner
		if arena and IsPlayerSpell(236320) then
			if ourHealer then
				local banner = should_banner(ourHealer)
				if banner then
					if banner == "wait" then 
						return;
					else
						if _Cast(236320) then
							Squid_Alert("War Banner","("..GetSpellInfo(banner)..")",2)
						end
					end
				end
			else
				for i=1,#Friends do 
					local banner = should_banner(Friends[i])
					if banner then
						if banner == "wait" then
							return;
						else
							if _Cast(236320) then
								Squid_Alert("War Banner","("..GetSpellInfo(banner)..")",2)
							end
						end
					end
				end
			end
		end

		--Stomp
		local function Stomp(totem,name)
			if S then return false; end
			local hp = UnitHealth(totem)
			local maxhp = UnitHealthMax(totem)
			if hp <= 1 then return false; end
			if maxhp <= 1000 then
				--Hamstring
				if maxhp <= 2400 then
					if _Cast(1715,totem,nil,true) then
						Squid_Alert(name .. " Stomped","(Hamstring)",1)
						return
					end
				end
				--Heroic Throw
				if _Cast(57755,totem,nil,true) then
					Squid_Alert(name .. " Stomped","(Throw)",1)
					return
				end
			else
				--Overpower
				if _Cast(7384,totem,nil,true) then
					Squid_Alert(name .. " Stomped","(Overpower)",1)
					return
				end
				--Slam
				if _Cast(1464,totem,nil,true) then
					Squid_Alert(name .. " Stomped","(Slam)",1)
					return
				end
			end
		end

		local totems = {
			101398,	--Psyfiend
			119052,	--War Banner
			104818,	--Ancestral Protection Totem
			53006,	--Spirit Link Totem
			2630,	--Earthbind Totem
			60561,	--Earthgrab Totem
			-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
			5925,	--Grounding Totem
			105425,	--Skyfury Totem
			5913,	--Tremor Totem
			105451,	--Counterstrike Totem
		}

		if arena then
			for i=1,#Pets do
				local e = Pets[i]
				local name = UnitName(e);
				local id = UnitCreatureID(e)
				--only kill cap totems when they're casting
				if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
					Stomp(e,name)
				end
			end
		end

		if (arena or instanceType == 'pvp') and IsPlayerSpell(236077) then
			for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _CCcheck(Enemies[i]) then
				if UnitBuffID(Enemies[i],184364) and _meleeRange('player', Enemies[i]) then
					if _Cast(236077,Enemies[i],nil,true) then
						Squid_Alert("Disarm " .. UnitClass(Enemies[i]), "(Enraged Regen)",2)
					end
				end
				if unit_is_unit(Enemies[i],current_target) and UnitClass(Enemies[i]) == "Death Knight" and their_healer_cc and _HP(Enemies[i]) < 70 and _meleeRange('player', Enemies[i]) then
					if _Cast(236077,Enemies[i],nil,true) then
						Squid_Alert("Disarm " .. UnitClass(Enemies[i]), "(Offensive)",2)
					end
				end 
			end end
		end

		local should_peel = lowestFriend < peel_hp

		if should_peel then
			--disarm
			if (arena or instanceType == 'pvp') and IsPlayerSpell(236077) then
				for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _CCcheck(Enemies[i]) then
					if _CDcheck(Enemies[i]) or lowestFriend < 60 and _meleeRange('player', Enemies[i]) then
						if _Cast(236077,Enemies[i],nil,true) then
							Squid_Alert("Disarm " .. UnitClass(Enemies[i]), "(Peel)",2)
						end
					end
				end end
			end
			--piercing howl
			if not (instanceType == 'party' or instanceType == 'raid') then
				for i = 1, #Enemies do if not _slowImmuneCheck(Enemies[i]) and not _isHealer(Enemies[i]) then
					if not _isSlowed(Enemies[i]) and _spellCooldown(arms.piercingHowl) == 0 and _distance('player', Enemies[i]) <= 12 then
						if _Cast(arms.piercingHowl) then
							Squid_Alert("Piercing Howl " .. UnitClass(Enemies[i]), "(Peel)", 2)
						end
					end end
				end
			end
			--hamstring
			if arena or instanceType == 'pvp' then
				for i=1,#Enemies do if not _immunePhysical(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) and not _isHealer(Enemies[i]) then
					if not _isSlowed(Enemies[i]) and _meleeRange('player', Enemies[i]) then
						if _Cast(1715,Enemies[i],nil,true) then
							Squid_Alert("Hamstring " .. UnitClass(Enemies[i]), "(Peel)",2)
						end
					end
				end end
			end
			--rally
			if not instanceType == 'raid' and lowestFriend < 25 then
				if lowestFriendName and _distance(lowestFriendName) < 40 then
					if not _immunePhysical(lowestFriendName) then
						if _Cast(97462) then
							Squid_Alert("Rallying Cry " .. UnitClass(lowestFriendName),"(Danger)",2)
						end
					end
				end
			end
		end

		if bcc and UnitBuffID("player",260708) then
			RunMacroText("/cancelaura sweeping strikes")
		end

		local _, _, _, _, _, _, id = GetSpellInfo("Condemn")

		-- # Executed every time the actor is available.
		if _valid(t, 1) and not disarm_check('player') then

			local time = GetTime()

			local dist = _distance(t)

			local function execute(t)
				--skullsplitter,if=rage<60&(!talent.deadly_calm.enabled|buff.deadly_calm.down)
				if IsPlayerSpell(260643) and rage < 60 and (not deadly_calm_taken or not UnitBuffID('player', arms.buffs.deadlyCalm)) and _spellCooldown(arms.skullSplitter) == 0 then
					_Cast(arms.skullSplitter, t, true)
				end
				--ravager,if=buff.avatar.remains<18&!dot.ravager.remains
				if IsPlayerSpell(152277) and buff_remains('player', arms.buffs.avatar) < 18 and _spellCooldown(arms.ravager) == 0 then
					_AeCast(arms.ravager, t, 40, 8)
				end
				--cleave,if=spell_targets.whirlwind>1&dot.deep_wounds.remains<gcd
				if IsPlayerSpell(845) and valid_enemies_around('player', 8) > 1 and debuff_remains(t, arms.debuffs.deepWounds) < gcd then
					_Cast(arms.cleave, t, true)
				end
				--warbreaker if not on cooldown
				if Warbreaker and WarbreakerCD == 0 then
					_Cast(arms.warbreaker, t, true)
				elseif _spellCooldown(arms.colossusSmash) == 0 then
					_Cast(arms.colossusSmash, t, true)
				end
				--Condemn
				if covenantID == covenant.ids.venthyr and execute_phase then
					if (debuff_remains(t, arms.debuffs.colossusSmash) > 1 and rage >= 40) or (buff_remains('player', arms.buffs.suddenDeath) > 1) or rage > 65 then
						if _amIfacing(t) then
							SQ_CastSpellByName("Execute", t)
						end
					end
				end
				--overpower,if=charges=2
				if _spellChargeFrac(arms.overPower) == 2 then
					_Cast(arms.overPower, t, true)
				end
				--bladestorm,if=buff.deadly_calm.down&rage<50
				if not IsPlayerSpell(152277) and not arena and not UnitBuffID('player', arms.buffs.deadlyCalm) and rage < 50 and _spellCooldown(arms.bladestorm) <= gcd_remains then
					_Cast(arms.bladestorm)
				end
				--mortal_strike,if=dot.deep_wounds.remains<=gcd
				if debuff_remains(t, arms.debuffs.deepWounds) <= gcd and _spellCooldown(arms.mortalStrike) <= gcd_remains then
					if rage >= GetSpellCost(arms.mortalStrike) then
						_Cast(arms.mortalStrike, t, true)
					end
				end
				--skullsplitter,if=rage<40
				if IsPlayerSpell(260643) and rage < 40 and _spellCooldown(arms.skullSplitter) <= gcd_remains then
					_Cast(arms.skullSplitter, t, true)
				end
				--overpower,if=charges=2
				if _spellChargeFrac(arms.overPower) >= 1 then
					_Cast(arms.overPower, t, true)
				end
				--Execute phase for venthyr
				if execute_phase and covenantID == covenant.ids.venthyr then
					if _meleeRange('player', t) and _valid(t, 1) and rage >= GetSpellCost(covenant.venthyr.condemn) then
						if _amIfacing(t) then
							SQ_CastSpellByName("Execute", t)
						end
					end
				--Normal Execute Phase
				elseif rage >= GetSpellCost(warrior.execute) and execute_phase then
					if _meleeRange('player', t) and _valid(t, 1) then
						_Cast(warrior.execute, t, true)
					end
				--Torghast Execute Buff any % of HP
				elseif UnitBuffID('player', warrior.buffs.voraciousCullingBlade) and rage >= GetSpellCost(warrior.execute) then
					if _meleeRange('player', t) and _valid(t, 1) then
						_Cast(warrior.execute, t, true)
					end
				end
			end
			local function single_target(t)
				--cleave,if=spell_targets.whirlwind>1&dot.deep_wounds.remains<gcd
				if IsPlayerSpell(845) and valid_enemies_around('player', 8) > 1 and debuff_remains(t, arms.debuffs.deepWounds) < gcd then
					_Cast(arms.cleave, t, true)
				end
				--warbreaker if not on cooldown
				if Warbreaker and WarbreakerCD <= gcd_remains then
					_Cast(arms.warBreaker, t)
				elseif _spellCooldown(arms.colossusSmash) <= gcd_remains then
					_Cast(arms.colossusSmash, t, true)
				end
				--ravager,if=buff.avatar.remains<18&!dot.ravager.remains
				if IsPlayerSpell(152277) and buff_remains('player', arms.buffs.avatar) < 18 and _spellCooldown(arms.ravager) <= gcd_remains then
					_AeCast(arms.ravager, t, 40, 8)
				end
				--overpower,if=charges=2
				if _spellChargeFrac(arms.overPower) == 2 then
					_Cast(arms.overPower, t, true)
				end
				--	bladestorm,if=buff.deadly_calm.down&(debuff.colossus_smash.up&rage<30|rage<70)
				if not IsPlayerSpell(152277) and not UnitBuffID('player', arms.buffs.deadlyCalm) and (UnitBuffID(t, arms.debuffs.colossusSmash) and rage < 30 or rage < 70) then
					if _spellCooldown(arms.bladestorm) == 0 then
						_Cast(arms.bladestorm)
					end
				end
				--	mortal_strike,if=buff.overpower.stack>=2&buff.deadly_calm.down|(dot.deep_wounds.remains<=gcd&cooldown.colossus_smash.remains>gcd)
				if _buffStacks('player', arms.buffs.overPower) >= 2 and not UnitBuffID('player', arms.buffs.deadlyCalm) or (debuff_remains(t, arms.debuffs.deepWounds) <= gcd) then
					--arena sharpen blade
					if IsPlayerSpell(arms.sharpenBlade) and _spellCooldown(arms.sharpenBlade) <= gcd_remains then
						_Cast(arms.sharpenBlade, t, true)
					end
					--cooldown.colossus_smash.remains>gcd
					if rage >= GetSpellCost(arms.mortalStrike) and WarBreaker and WarbreakerCD > gcd then
						_Cast(arms.mortalStrike, t, true)
					elseif rage >= GetSpellCost(arms.mortalStrike) and not Warbreaker and _spellCooldown(arms.colossusSmash) > gcd then
						_Cast(arms.mortalStrike, t, true)
					end
				end
				--deadly_calm
				--skullsplitter,if=rage<60&buff.deadly_calm.down
				if IsPlayerSpell(260643) and rage < 60 and not UnitBuffID('player', arms.buffs.deadlyCalm) and _spellCooldown(arms.skullSplitter) == 0 then
					_Cast(arms.skullSplitter, t, true)
				end
				--overpower
				if _spellChargeFrac(arms.overPower) >= 1 then
					_Cast(arms.overPower, t, true)
				end
				--Execute phase for venthyr
				if execute_phase and covenantID == covenant.ids.venthyr then
					if _meleeRange('player', t) and _valid(t, 1) and rage >= GetSpellCost(covenant.venthyr.condemn) then
						if _amIfacing(t) then
							SQ_CastSpellByName("Execute", t)
						end
					end
				--Normal Execute Phase
				elseif execute_phase and rage >= GetSpellCost(warrior.execute) then
					if _meleeRange('player', t) and _valid(t, 1) then
						_Cast(warrior.execute, t, true)
					end
				--Torghast Execute Buff any % of HP
				elseif UnitBuffID('player', warrior.buffs.voraciousCullingBlade) and rage >= 40 then
					if _meleeRange('player', t) and _valid(t, 1) then
						_Cast(warrior.execute, t, true)
					end
				end
				--mortal_strike
				if rage >= GetSpellCost(arms.mortalStrike) and _spellCooldown(arms.mortalStrike) <= gcd_remains then
					_Cast(arms.mortalStrike, t, true)
				end
				--whirlwind,if=talent.fervor_of_battle.enabled&rage>60
				if fervor_of_battle and rage > 60 then
					_Cast(warrior.whirlwind)
				end
				if rage >= GetSpellCost(warrior.slam) and _spellCooldown(arms.mortalStrike) > gcd_remains then
					_Cast(warrior.slam, t, true)
				end
			end

			--bladestorm root
			if _rootCheck("player") then
				if UnitRace("player") == "Gnome" and _spellCooldown(20589) == 0 then
					if _Cast(20589) then
						Squid_Alert("Escape Artist","(Rooted)",3)
					end
				elseif not bcc then
					if _Cast(227847) then
						Squid_Alert("Bladestorm","(Rooted)",3)
					end
				end
			end

			if GetUnitSpeed("player") >= 22
			and IsFalling() 
			and (not lastGapClose or time-lastGapClose >= .4) 
			and dist > 10 then
				NeedsToLeap = time;
			end

			if NeedsToLeap and time - NeedsToLeap < 1 then
				if _AeCast(6544,t,40,3) then
					Squid_Alert("Heroic Leap","(Knocked)",2)
				end
			end

			-- actions=charge
			if not lastGapClose or time-lastGapClose >= 2.5 then
				if dist > 8 then
					if _movingTowards(t,.11) and moving_towards_unit_duration(t,.11) > .2 then
						if _spellCooldown(100) == 0 or _spellCooldown(100) > 18 then
							if auto_charge and _Cast(100,t,true) then
								Squid_Alert("Charge","(Gapclose)")
							end
						else
							if (dist > 10 or _isSlowed("player")) and not breakable_cc_around(t,10) then
								if auto_leap and _aeCastInMovingDirection(6544,t,GetUnitSpeed(t)/3.56,40) then
									Squid_Alert("Heroic Leap","(Gapclose)")
								end
							end
						end
					end
				end
			end

			-- _Cast(100,t);
			-- actions+=/auto_attack
			if not auto_attack or time - auto_attack > 2 then
				StartAttack()
				auto_attack=time
			end

			--UnitCooldown
			--AMS, BLINK

			--stance
			if not defensive_stance then
				if (player_hp < 80 or our_healer_cc) and enemies_attacking_me > 0 then
					_Cast(197690)
				end
			else
				if player_hp > 60 and lowestEnemy < 35 and lowestEnemyName and _meleeRange(lowestEnemyName) then
					_Cast(197690)
				end
				if (player_hp > 85 and not our_healer_cc) or (enemies_attacking_me == 0 and player_hp > 70) then
					_Cast(197690)
				end
			end

			--Sudden Death Procs, lets make sure we got Colossus Smash up or the cd is about to come off cd
			if execute_phase and covenantID == covenant.ids.venthyr then
				if _meleeRange('player', t) and _valid(t, 1) and rage >= GetSpellCost(covenant.venthyr.condemn) then
					if _debuffRemains(t, arms.debuffs.colossusSmash, 'player') > gcd then
						if _amIfacing(t) then
							SQ_CastSpellByName("Execute", t)
						end
					elseif not UnitDebuffID(t, arms.debuffs.colossusSmash, 'player') and (wbCD > _buffRemains('player', arms.buffs.suddenDeath) or csCD > _buffRemains('player', arms.buffs.suddenDeath)) then
						if _amIfacing(t) then
							SQ_CastSpellByName("Execute", t)
						end
					end
				end
			end

			--Solo ignore pain
			if _HP('player') <= 80 and _spellCooldown(warrior.ignorePain) == 0 and rage >= 40 then
				_Cast(warrior.ignorePain)
			end
			--Use Badge for PvE
			if not arena and _meleeRange('player', t) and _valid(t, 1) then
				if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
					UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
				end
			end
			-- actions+=/avatar,if=cooldown.colossus_smash.remains<8|(talent.warbreaker.enabled&cooldown.warbreaker.remains<8)
			if _meleeRange('player', t) and _valid(t, 1) and is_boss(t) then
				if Warbreaker and WarbreakerCD < 8 then
					_Cast(arms.avatar)
				end
				if not Warbreaker and _spellCooldown(167105) < 8 and is_boss(t) then
					_Cast(arms.avatar)
				end
			end
			--arena burst
			if arena and _meleeRange('player', t) and _valid(t, 1) and auto_burst then
				if Warbreaker and WarbreakerCD < 8 then
					_Cast(arms.avatar)
					--Use Badge with avatar
					if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
						UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
					end
				end
				if not Warbreaker and _spellCooldown(167105) < 8 then
					_Cast(arms.avatar)
					--Use Badge with avatar
					if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
						UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
					end
				end
			end
			
			-- actions+=/sweeping_strikes,if=spell_targets.whirlwind>1&(cooldown.bladestorm.remains>10|cooldown.colossus_smash.remains>8|azerite.test_of_might.enabled)
			if _meleeRange(t) and _valid(t, 1) then
				if not bcc and spell_targets_whirlwind > 1 and (BladestormCD > 15 or IsPlayerSpell(arms.ravager)) then
					_Cast(arms.sweepingStrikes);
				end
			end
			--spear of bastian
			if IsPlayerSpell(covenant.kyrian.spearOfBastian) and time_in_combat > 3 then
				if valid_enemies_around('player', 5) >= 3 or is_boss(t) then
					if _spellCooldown(covenant.kyrian.spearOfBastian) == 0 then
						_AeCast(covenant.kyrian.spearOfBastian, t, 25, 5, false, true)
					end
				end
			end

			--Execute action list
			if _meleeRange('player', t) and _valid(t, 1) then
				if execute_phase then
					execute(t)
				end
			end
			--Single Target
			if not execute_phase and _meleeRange('player', t) and _valid(t, 1) then
				single_target(t)
			end
		end
	end
	--Prot
	if spec == 3 then

		--Tier 1
		local warMachineEnable = IsPlayerSpell(316733)
		local punishEnabled = IsPlayerSpell(275334)
		local devastatorEnabled = IsPlayerSpell(236279)
		--Tier 2
		local doubleTimeEnabled = IsPlayerSpell(103827)
		local rumblingEarthEnabled = IsPlayerSpell(275339)
		local stormBoltEnabled = IsPlayerSpell(107570)
		--Tier 3
		local bestServedColdEnabled = IsPlayerSpell(202560)
		local boomingVoiceEnabled = IsPlayerSpell(202743)
		local dragonRoarEnabled = IsPlayerSpell(118000)
		--Tier 4
		local cracklingThunderEnabled = IsPlayerSpell(2023201)
		local boundingStrideEnabled = IsPlayerSpell(202163)
		local menaceEnabled = IsPlayerSpell(275338)
		--Tier 5
		local neverSurrenderEnabled = IsPlayerSpell(202561)
		local indomitableEnabled = IsPlayerSpell(202095)
		local impendingVictoryEnabled = IsPlayerSpell(202168)
		--Tier 6
		local intoTheFrayEnabled = IsPlayerSpell(202603)
		local unstoppableForceEnabled = IsPlayerSpell(275336)
		local ravagerEnabled = IsPlayerSpell(228920)
		--Tier 7
		local angerManagementEnabled = IsPlayerSpell(152278)
		local heavyRepercussionsEnabled = IsPlayerSpell(203177)
		local bolsterEnabled = IsPlayerSpell(280001)

		local ignore_pain_up = buff_remains('player', warrior.ignorePain) >= 2


		function defaultList(t)

			local time = GetTime()
			
			--auto attack
			if _valid(current_target) then
				if not auto_atack_sent or time - auto_atack_sent > 1 then
					StartAttack()
					auto_atack_sent = time
				end
			end
			--use_items,if=cooldown.avatar.remains<=gcd|buff.avatar.up

			--auto taunt
			for i = 1, #Enemies do
				if _distance('player', Enemies[i]) <= 30 then
					local taunt = Enemies[i]
					if inInstance and instanceType == 'party' and UnitThreatSituation("player", taunt) ~= nil and UnitThreatSituation("player", taunt) <= 2 and UnitAffectingCombat(taunt) then
						_Cast(warrior.taunt, taunt)
					end
				end
			end

			--ignore_pain,if=buff.ignore_pain.down
			if not UnitBuffID('player', warrior.ignorePain) and rage >= GetSpellCost(warrior.ignorePain) and _spellCooldown(warrior.ignorePain) == 0 then
				_Cast(warrior.ignorePain)
			end

			--avatar on bosses
			if _spellCooldown(prot.avatar) == 0 and _meleeRange('player', t) and _valid(t, 1) then
				if is_boss(t) then
					_Cast(prot.avatar)
				end
			end

			--spear of bastian
			if IsPlayerSpell(covenant.kyrian.spearOfBastian) and time_in_combat > 3 then
				if valid_enemies_around('player', 5) >= 3 or is_boss(t) then
					if _spellCooldown(covenant.kyrian.spearOfBastian) == 0 then
						_AeCast(covenant.kyrian.spearOfBastian, t, 25, 5, false, true)
					end
				end
			end

			--run_action_list,name=aoe,if=spell_targets.thunder_clap>=3
			if valid_enemies_around('player', 8) >= 3 and _meleeRange('player', t) then
				aoe(t)
			elseif _meleeRange('player', t) and _valid(t, 1) then
				st(t)
			end
			--call_action_list,name=st
		end

		function aoe(t)
			--Shockwave
			if _spellCooldown(prot.shockWave) == 0 and valid_enemies_around('player', 6) >= 3 then
				_Cast(prot.shockWave, t, true)
			end
			--thunder clap
			if _spellCooldown(prot.thunderClap) == 0 then
				_Cast(prot.thunderClap)
			end
			--demoralizing_shout,if=talent.booming_voice.enabled
			if boomingVoiceEnabled and _spellCooldown(prot.demoShout) == 0 and rage <= 61 then
				_Cast(prot.demoShout)
			end
			--revenge
			if rage >= GetSpellCost(prot.revenge) and ignore_pain_up or UnitBuffID('player', 5302) then
				_Cast(prot.revenge, t, true)
			end
			--shield_block,if=cooldown.shield_slam.ready&buff.shield_block.down
			if not UnitBuffID('player', warrior.buffs.shieldBlock) and _spellChargeFrac(warrior.shieldBlock) >= 1 then
				if rage >= GetSpellCost(warrior.shieldBlock) then
					_Cast(warrior.shieldBlock)
				end
			end
			--shield slam
			if _spellCooldown(warrior.shieldSlam) == 0 then
				_Cast(warrior.shieldSlam, t, true)
			end
		end

		function st(t)
			--thunder_clap,if=spell_targets.thunder_clap=2&talent.unstoppable_force.enabled&buff.avatar.up
			if valid_enemies_around('player', 8) >= 2 and unstoppableForceEnabled and UnitBuffID('player', prot.avatar) then
				_Cast(prot.thunderClap)
			end
			--shield_block,if=cooldown.shield_slam.ready&buff.shield_block.down
			if not UnitBuffID('player', warrior.buffs.shieldBlock) and _spellChargeFrac(warrior.shieldBlock) >= 1 then
				if rage >= GetSpellCost(warrior.shieldBlock) then
					_Cast(warrior.shieldBlock)
				end
			end
			--shield_slam,if=buff.shield_block.up
			if buff_remains('player', warrior.buffs.shieldBlock) > 0 then
				_Cast(warrior.shieldSlam, t, true)
			end
			--thunder_clap,if=(talent.unstoppable_force.enabled&buff.avatar.up)
			if unstoppableForceEnabled and UnitBuffID('player', prot.avatar) then
				_Cast(prot.thunderClap)
			end
			--demoralizing_shout,if=talent.booming_voice.enabled
			if boomingVoiceEnabled and _spellCooldown(prot.demoShout) == 0 and rage <= 61 then
				_Cast(prot.demoShout)
			end
			--shield slam
			if _spellCooldown(warrior.shieldSlam) == 0 then
				_Cast(warrior.shieldSlam, t, true)
			end
			--execute
			if _HP(t) <= 20 and rage >= GetSpellCost(warrior.execute) and ignore_pain_up then
				_Cast(warrior.execute, t, true)
			end
			--revenge,if=rage>=70
			if rage >= 70 or UnitBuffID('player', 5302) and ignore_pain_up then
				_Cast(prot.revenge, t, true)
			end
			--thunda clap
			if _spellCooldown(prot.thunderClap) == 0 then
				_Cast(prot.thunderClap)
			end
			--revenge
			if rage >= GetSpellCost(prot.revenge) and ignore_pain_up or UnitBuffID('player', 5302) then
				_Cast(prot.revenge, t, true)
			end
			--devastate
			if not devastatorEnabled then
				_Cast(prot.devastate, t, true)
			end
		end

		if _valid(t, 1) and _meleeRange(t) then
			defaultList(t)
		end
	end

end
--[[ 
	ToDO
	Add corruption/agony while moving if < amount we want
	Add blacklist
	Add use covenant damage
	Add use covenant utility
	Shard Sniping -- if non boss is about to die use drain soul on it
	Add important coil interrupts
	solo drain life usage

	if seed of corruption cast time < gcds required to cast corruption on the targets that need it and the targets are in range

	now time - get condition met time >= gcd
	
	haunt > ua > agony > corruption > siphon > phantom > soul rot
	if PS cd < 10 and 

	dump with full dots + PS or soul rot, otherwise hold 3 shards
	redo seed of corruption
	171557 -- shade id
]]--
function Squid_Warlock()
	local spec = GetSpecialization()
	local auto_cds = SQUID.warlock_cds
	local inInstance, instanceType = IsInInstance()
	local buffer = ((1000/GetFramerate())/1000)*10 --ms per frame * 10 (10 fps buffer)
	local latency = squid_avg_latency+buffer+.09 --90ms + fps buffer, since latency only updates every 30s, and script only runs once per frame.
	local delay = latency+buffer
	local t_ttd = squid_ttd(t)
	local single_target_only = SQUID.single_target

	--Tables
	local racials = {
		berserking = 26297,
		bloodFury = 33702,
    }
 
	local covenantID = C_Covenants.GetActiveCovenantID()
	local covenants = {
        ids = {
            none = 0,
            kyrian = 1,
            venthyr = 2,
            nightFae = 3,
            necroLord = 4,
		},
		--Kyrian
		kyrian = {
			scouringTithe = 312321,
		},
		--Venthyr
		venthyr = {
			impendingCatastrophe = 321792,
		},
		--Night Fae
		nightFae = {
			soulRot = 325640,
			soulShape = 310143,
		},
		--Necrolord
		necroLord = {
			decimatingBolt = 325289,
		},
	}

	local warlock = {
		axeToss = 119914,
		banish = 710,
		corruption = 172,
		createHealhstone = 6201,
		createSoulWell = 29893,
		curseOfExhaustion = 334275,
		curseOfTongues = 1714,
		curseOfWeakness = 702,
		demonicCircle = 48018,
		demonicCircleTeleport = 48020,
		demonicGateway = 111771,
		drainLife = 234153,
		eyeOfKillrogg = 126,
		fear = 5782,
		felDomination = 333889,
		healthFunnel = 755,
		ritualOfDoom = 342601,
		ritualOfSummoning = 698,
		shadowBolt = 686,
		shadowFury = 30283,
		soulStone = 20707,
		subjugateDemon = 1098,
		summonImp = 688,
		summonVoidWalker = 697,
		summonFelhunter = 691,
		summonSuccubus = 712,
		summonFelguard = 30146,

		buffs = {

		},

		debuffs = {
			corruption = 146739,
		},

	}

	local aff = {
		agony = 980,
		maleficRapture = 324536,
		seedOfCorruption = 27243,
		summonDarkglare = 205180,
		unstableAffliction = 316099,

		--Talents
		burningRush = 111400,
		darkPact = 108416,
		darkSoulMisery = 113860,
		drainSoul = 198590,
		grimoireOfSacrifice = 108503,
		haunt = 48181,
		howlOfTerror = 5484,
		inevitableDemise = 334319,
		mortalCoil = 6789,
		phantomSingularity = 205179,
		siphonLife = 63106,
		vileTaint = 278350,

		--PvP Talents
		demonArmor = 285933,
		rampantAffliction = 335052,
		rapidContagion = 344566,


		buffs = {
			darkSoulMisery = 113860,
			inevitableDemise = 334320,
		},

		debuffs = {
			agony = 980,
			corruption = 146739,
			haunt = 48181,
			phantomSingularity = 205179,
			seedOfCorruption = 27243,
			shadowEmbrace = 32390,
			siphonLife = 63106,
			unstableAffliction = 316099,
			unstableAfflictionRampantAffliction = 342938,
			vileTaint = 278350,
		},
	}

	local destro = {
		immolate = 348,
	}

	local demo = {

		callDreadStalkers = 104316,
		demonBolt = 264178,
		handOfGuldan = 105174,
		implosion = 196277,
		summonDemonicTyrant = 265187,

		--Talents
		bilescourgeBombers = 267211,
		burningRush = 111400,
		darkPact = 108416,
		demonicStrength = 267171,
		demonSkin = 219272,
		doom = 603,
		grimoireFelguard = 111898,
		howlOfTerror = 5484,
		mortalCoil = 6789,
		netherPortal = 267217,
		powerSiphon = 264130,
		soulStrike = 264057,
		summonVilefiend = 264119,

		buffs = {
			demonicCalling = 205146, --Free Call Dreadstalkers + Instant
			demonicCore = 264173, --Demonbolt buff
			demonicPower = 265273, --Tyrant buff
			netherPortal = 267218,
		},
		debuffs = {
			doom = 603,
		},
	}

	local raid = {
        bossDebuffs = {
            --Sludgefist
            destructiveImpact = 331314, -- Sludgefist Destructive Impact, Damage taken increased by 100%. Stunned.
            --Huntsman
            destabilize = 334695,  --334695 - Destabilize 100% damage taken increased per stack
            brokenBonds = 345902,  -- broken bond
        },
	}
	
	local dot_blacklist = {

	}
	

	local function _valid(unit,immune)
		if ObjectID(unit) == 164589 then return true end
		return unit
		and UnitCanAttack("player",unit)
		and not UnitIsDeadOrGhost(unit) 
		and not _breakableCC(unit,true)
		and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
		and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit)))); 
	end
	local function valid_enemies_around(unit, dist)
        local count = 0
        for i = 1, #Enemies do
            if _valid(Enemies[i]) and _distance(Enemies[i], unit) <= dist and not _breakableCC(Enemies[i], false) then
                count = count + 1
            end
        end
        return count;
    end
	local function debuff_count(spellID, range)
		local count = 0
		for i = 1, #Enemies do
			if _debuffRemains(Enemies[i], spellID) > 0 and _distance('player', Enemies[i]) <= range then
				count = count + 1
			end
		end
		return count
	end
	local function dynamicTargeting(range)
        --Target enemies above 75% or below 35% preferably
        local bestUnit = bestUnit or nil
        if bestUnit == nil then
            if #Enemies > 0 then
                for i = 1, #Enemies do
                    local thisUnit = Enemies[i]
                    if _distance('player', thisUnit) <= range and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
                        bestUnit = thisUnit
                    end
                end
            end
        end
        if not UnitExists("target") and UnitAffectingCombat('player') then
            TargetUnit(bestUnit)
        end
    end
    local function is_instance_boss(unit)
        if IsInInstance() then
            local _, _, encountersTotal = GetInstanceLockTimeRemaining()
            for i = 1, encountersTotal do
                if unit == 'player' then
                    local bosses = select(1, GetInstanceLockTimeRemainingEncounter(i))
                end
                if (UnitIsVisible(unit) or false) then
                    local boss = GetInstanceLockTimeRemainingEncounter(i)
                    local tar = UnitName(unit)
                    if tar == boss then return true end
                end
            end
            for j = 1, 5 do
                local num = 'boss' .. j
                if unit_is_unit(num, unit) then return true end
            end
        end
        return false    
    end
    local function encounter_name(index)
        --Total of 10 Encounters
        if inInstance and instanceType == 'raid' and instanceName == "Castle Nathria" then
            local boss = GetInstanceLockTimeRemainingEncounter(index)
            return boss
        end
    end
    local function is_boss(unit)
        if unit == nil then 
            unit = t 
        end
        --Probably needs locales set for totems
        if (UnitIsVisible(unit) or false) and UnitCreatureType(unit) ~= 'Totem' then
            local unitClass = UnitClassification(unit)
            local hMax = UnitHealthMax(unit)
            local pMax = UnitHealthMax('player')
            local instance = select(2, IsInInstance())
            return is_instance_boss(unit) 
                    or _isDummy(unit)
					or not UnitIsTrivial(unit) and instance ~= 'party' and (unitClass == "rare" and hMax > 4 * pMax) or UnitLevel(unit) < 0
					or UnitIsPlayer(unit)
        end
        return false
	end
	local function dot_shade(unit)
		local shade_id = 171557
		if ObjectID(unit) ~= shade_id then
			return true
		end
		if ObjectID(unit) == shade_id then
			if not UnitDebuffID(unit, raid.bossDebuffs.destabilize) then
				return false
			elseif UnitDebuffID(unit, raid.bossDebuffs.destabilize) and _debuffStacks(unit, raid.bossDebuffs.destabilize) < 2 and _breakableCC(unit, false) then
				return false
			elseif UnitDebuffID(unit, raid.bossDebuffs.destabilize) and _debuffStacks(unit, raid.bossDebuffs.destabilize) > 2 and _breakableCC(unit, false) then
				return false
			elseif UnitDebuffID(unit, raid.bossDebuffs.destabilize) and _debuffStacks(unit, raid.bossDebuffs.destabilize) > 2 and not _breakableCC(unit, false) then
				return true
			end
		end
	end
	--Player
	local player_hp = _HP('player')
	local shards = UnitPower("player",7)
	local race = UnitRace('player')
	local haste = UnitSpellHaste("player")
    local gcd = 1.5/(1+(haste/100))
	local gcd_remains = GetGCD()
	local combat_time = time_in_combat
	local ttd = squid_ttd
	if not UnitAffectingCombat('player') then
		combat_time = 0
	end
	local solo = #Friends == 1

	local t = current_target
	local t_is_boss = (t and is_boss(t) or false)
	--Warlock Globals
	local fear_cast_time = _castTime(warlock.fear)

	local time = GetTime()
	function warlock_exhaust()
		Curse_Of_Exhaustion = GetTime()
	end
	function warlock_tongues()
		Curse_of_Tongues = GetTime()
	end
	function warlock_weak()
		Curse_Of_Weakness = GetTime()
	end
	function warlock_use_covenant_damage()
		Warlock_Use_Covenant_Damage = GetTime()
	end
	if Curse_Of_Exhaustion and time - Curse_Of_Exhaustion > 2 then
		Curse_Of_Exhaustion = nil
	end
	if Curse_of_Tongues and time - Curse_of_Tongues > 2 then
		Curse_of_Tongues = nil
	end
	if Curse_Of_Weakness and time - Curse_Of_Weakness > 2 then
		Curse_Of_Weakness = nil
	end
	if Warlock_Use_Covenant_Damage and time - Warlock_Use_Covenant_Damage > 2 then
		Warlock_Use_Covenant_Damage = nil
	end

	if Curse_Of_Exhaustion then
		if not SpellRecentlyUsed(warlock.curseOfExhaustion, 2) then
			Squid_Alert("Casting Curse of Exhaustion on the next global.",nil,nil,.35)
			_Cast(warlock.curseOfExhaustion, t, false)
		end
	end
	if Curse_of_Tongues then
		if not SpellRecentlyUsed(warlock.curseOfTongues, 2) then
			Squid_Alert("Casting Curse of Tongues on the next global.",nil,nil,.35)
			_Cast(warlock.curseOfTongues, t, false)
		end
	end
	if Curse_Of_Weakness then
		if not SpellRecentlyUsed(warlock.curseOfWeakness, 2) then
			Squid_Alert("Casting Curse of Weakness on the next global.",nil,nil,.35)
			_Cast(warlock.curseOfWeakness, t, false)
		end
	end
	if Warlock_Use_Covenant_Damage then
		if covenantID == covenants.ids.kyrian then
			Squid_Alert("Casting Scouring Tithe on the next global.",nil,nil,.35)
			_Cast(covenants.kyrian.scouringTithe, t, true)
		elseif covenantID == covenants.ids.venthyr then
			Squid_Alert("Casting Impending Catastrophe on the next global.",nil,nil,.35)
			_Cast(covenants.venthyr.impendingCatastrophe, t, true)
		elseif covenantID == covenants.ids.nightFae then
			Squid_Alert("Casting Soul Rot on the next global.",nil,nil,.35)
			_Cast(covenants.nightFae.soulRot, t, true)
		elseif covenantID == covenants.ids.necroLord then
			Squid_Alert("Casting Decimating Bolt on the next global.",nil,nil,.35)
			_Cast(covenants.necroLord.decimatingBolt, t, true)
		end
	end

	if shadowfury_key then
		RunMacroText("/cast [@cursor] shadowfury")
	end
	if gateway_key then
		RunMacroText("/cast [@cursor] demonic gateway")
	end
	local use_darkmoon_deck = false
	local darkmoon_ids = {
		311468, --5
		311469, --6
		311470, --7
		311471, --8
	}
	for i = 1, #darkmoon_ids do if UnitAffectingCombat('player') and UnitBuffID('player', darkmoon_ids[i]) then use_darkmoon_deck = true end end

	--equipped items
	local equipped_items = {}
	local trinkets = {
		173069, --Darkmoon Deck: Putrescence
	}
	--Use darkmoon if 5+
	for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end

	--Arena Pre Combat
	if arena then
		-- drop soulwell
		if GetItemCount(5512) == 0 and UnitBuffID("player",32727) then
			CastSpellByID(29893)
			InteractUnit("Soulwell")
		end
		--Maintain demon armor
		local demon_armor = UnitBuffID("player",285933)
		if not demon_armor and IsPlayerSpell(285933) then
			_Cast(285933)
		end

		if SQUID.cap_bot then
		-- get pet
			if not UnitExists("pet") or UnitIsDeadOrGhost("pet") then
				CastSpellByID(691)
			end
		end
	end

	--Arena Combat
	if arena then
		if theirHealer then
			if not _breakableCC(theirHealer) then
				if not pattack or GetTime() - pattack > 1 then
					PetAttack(theirHealer)
					pattack = GetTime()
				end
			else
				PetFollow()
			end
		end
		--Curses of Weakness on Melee/Hunter
		for i = 1, #Enemies do
			if _LoS(Enemies[i], 'player') and _distance('player', Enemies[i]) <= 40 then
				local class = select(2,UnitClass(Enemies[i]))
				if _valid(Enemies[i], 2) and _isMeleeDps(Enemies[i]) then
					if _debuffRemains(Enemies[i], 702, 'player') == 0 then
						_Cast(warlock.curseOfWeakness, Enemies[i])
					end
				elseif _valid(Enemies[i], 2) and (_isRangedDps(Enemies[i]) and class ~= nil and class == 'HUNTER') then
					if _debuffRemains(Enemies[i], 702, 'player') == 0 then
						_Cast(warlock.curseOfWeakness, Enemies[i], false)
					end
				end
			end
		end

		--Curse of Tongues
		for i = 1, #Enemies do
			if _LoS(Enemies[i], 'player') and _distance('player', Enemies[i]) <= 40 then
				if _valid(Enemies[i], 2) and _isRangedDps(Enemies[i]) then
					if _debuffRemains(Enemies[i], 1714, 'player') == 0 then
						_Cast(warlock.curseOfTongues, Enemies[i], false)
					end
				end
			end
		end
	end

	--Fears
	if arena and spec ~= 1 then
		--feared target
		local feared_target
		local feared_target_remains = 0
		for i=1,#Enemies do 
			if UnitDebuffID(Enemies[i],118699,"player") then
				feared_target = Enemies[i]
				feared_target_remains = _debuffRemains(Enemies[i],118699,"player")
			end
		end
		
		local their_healer = theirHealer
		local their_healer_cc
		local their_healer_cc_remains = 0
		local their_healer_incapacitate_dr
		local their_healer_incapacitate_dr_remains = 0
		local their_healer_disorient_dr
		local their_healer_disorient_dr_remains = 0
		local their_healer_important_lockout
		if their_healer then
			if not UnitIsDeadOrGhost(their_healer) then
				their_healer_cc_remains = _CCremains(their_healer)
				their_healer_cc = their_healer_cc_remains > 0
				their_healer_incapacitate_dr = _incapacitateDR(their_healer)
				their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
				their_healer_disorient_dr = _disorientDR(their_healer)
				their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

				local class = select(2,UnitClass(their_healer))

				local locked,remaining,school = UnitIsLocked(their_healer)

				if locked and remaining > .25 then
					if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
					or ( class == "SHAMAN" and school == "Nature" )
					or ( class == "PALADIN" and school == "Holy" )
					or ( class == "MONK" and school == "Nature" )
					or ( class == "DRUID" and school == "Nature" )  then
						their_healer_important_lockout = true
					end
				end
			else -- no healer if he dead
				their_healer = nil
			end
		end
		
		local function their_healer_can_dispel(unit,after)
			after = after or 0
			if not UnitIsVisible(their_healer) or not UnitIsVisible(unit) then return false end
			if unit_is_unit(unit,their_healer) then return false end
			local dispels = {
				["DRUID"] = 88423,	--Nature's Cure (Druid)
				["PALADIN"] = 4987,	--Cleanse (Paladin)
				["PRIEST"] = 527,	--Purify (Priest)
				["SHAMAN"] = 77130,	--Purify Spirit (Shaman)
				["MONK"] = 115450,	--Detox (Monk)
			}
			local class = select(2,UnitClass(their_healer))
			local cd = UnitCooldown(their_healer,dispels[class])
			if cd <= after and _distance(unit,their_healer) <= 48 then
				return true
			end
		end

		local fear_range = 30
		
		--5782
		local function cc(unit,player_forced)

			if not arena and not unit_is_player(unit) and not player_forced then return 69 end

			--stop if no unit
			if not unit or not UnitIsVisible(unit) then return 69 end

			--do not sheep? (ext. func)
			-- if DoNotSheep(unit) then return 69 end

			--dist to unit
			local dist = _distance(unit)

			local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit), _buffRemains(unit,48707) )

			--this function should not only cc, but also return the time until cc needs to happen
			--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
			local time_to_cc = 0

			--check cc
			local ccr = _CCremains(unit)
			local cc = ccr > 0 
			
			--incap drs
			local idr = _incapacitateDR(unit)
			local idr_remains = _drRemains(unit,"incapacitate")

			--disorient drs
			local ddr = _disorientDR(unit)
			local ddr_remains = _drRemains(unit,"disorient")

			--banner?
			local banner = UnitBuffID(unit,236321)

			--remaining shep
			local sheep_remains = _debuffRemains(unit,118)

			--remaining fear
			local fear_remains = _debuffRemains(unit,118699)
			local feared = fear_remains > 0 

			--yea dont cc into it...unless
			if banner then return 69 end

			--incap on unit?
			local incap = _incapacitateCheck(unit)

			--healer?
			local is_healer = _isHealer(unit) 

			--lockout? (only important lockout...)
			-- local lockout = IsLocked(unit,true)
			local locked,lockout_remaining,school = UnitIsLocked(unit)

			local important_lockout_remaining = 0
			if locked and lockout_remaining > 0 then
				if ( class == "PRIEST" and school == "Shadow" )
				or ( class == "SHAMAN" and school == "Nature" )
				or ( class == "PALADIN" and school == "Holy" )
				or ( class == "MONK" and school == "Nature" )
				or ( class == "DRUID" and school == "Nature" )
				or ( class == "MAGE" and school == "Arcane" )
				or ( class == "WARLOCK" and school == "Shadowflame" ) then
					important_lockout_remaining = lockout_remaining
				end
			end

			--los?
			local los = _LoS(unit)

			--charmed friend?
			local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

			if friendly then return 69 end

			-- local feared_and_dispellable = fear_remains > 3 + fear_cast_time and their_healer_can_dispel(unit,fear_cast_time - buffer)

			--fear, if drs are available, and the unit is not immune
			local time_til_fear = 69
			local max_overlap = fear_cast_time + (buffer*2)
			if los then
				if (important_lockout_remaining <= fear_cast_time + 1 + (buffer*2.5) or UnitCastingInfo(unit)) then -- need better logic here to determine if the lockout is worth sheeping over, cause it often is.
					
					local fear_dr_ready = ddr == 1 or (ddr >= .25 and ddr_remains > 17.25 - (ccr >= fear_cast_time and 8 * ddr or 0) - (feared and ccr >= fear_cast_time-.2 and 4 * ddr or 0) - ((100-lowestEnemy) * .038) + (ddr == .25 and 1 or 0) ) or ( ddr_remains < fear_cast_time-(buffer/2) and ( ddr_remains ~= 0 or ddr == 1 ) )
					
					-- print(sheep_dr_ready, idr, idr_remains)
					-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
					local no_fears_out = not feared_target or unit_is_unit(unit,feared_target) or _disorientDR(feared_target) < .25 or (is_healer and ddr == 1) or (not _isHealer(feared_target) and _disorientDR(feared_target) <= .25 and _drRemains(feared_target,"disorient") > 3 and _drRemains(feared_target,"disorient") < 16.5)
					if fear_dr_ready and no_fears_out then
						
						if dist < fear_range and ( ccr < max_overlap or feared_and_dispellable ) then
							if immunity_remains <= fear_cast_time+(buffer*.44) then
								--alert when moving
								if _isMoving("player") then Squid_Alert("Stop Moving","(Fear)",nil,nil,5782) end
								if (not fear_cast_delay or time-fear_cast_delay > .2) and _Cast(5782,unit) then
									Squid_Alert_Big("Fearing",UnitClass(unit),nil,3,5782)
								end
								time_to_cc = 0
							end
						else
							time_to_cc = math.max(ccr,time_to_cc)
						end

						local immune_val = 0
						if immunity_remains > 0 then
							immune_val = max ( immunity_remains - fear_cast_time - (buffer * .44), 0 )
						end

						time_til_fear = dist < fear_range + 3 and math.max(ccr-max_overlap,ddr_remains < 17 and ddr_remains or 0,immune_val) or 69 -- "never" if out of range (applied to ring too)

					end
				end
			end
			
			local val = time_til_fear-- math.min(time_til_fear,time_til_poly_ready)

			return val
			
		end
		
		--designate highest prio to cc on healer (returning 69 will fall back to off dps cc)
		local function healer_cc()
			
			local healers = {}

			for i=1,#Enemies do if _isHealer(Enemies[i]) then
				local unit = Enemies[i]
				if _distance(unit) < fear_range then
					-- local friends_attacking = UnitEnemiesAttacking(unit)
					local unit_hp = _HP(unit)
					-- if friends_attacking == 0 and not only_ripped_target(unit) then 
						table.insert(healers,unit)
					-- end
				end
			end end

			local soonest = 69
			for i=1,#healers do
				local val = cc(healers[i])

				if val < soonest then
					soonest = val
				end

			end

			return soonest

		end
		
		--cc off dps while waiting for dr on healer, or to secure cc on healer while they have interrupts available
		local function off_cc()

			if only_cc_healers then return 69 end

			local units = {}

			for i=1,#Enemies do
				local e = Enemies[i]
				if unit_is_player(e) then--or (UnitIsHunterPet(e) and combustion_cd <= 2) then
					if _distance(e) < fear_range and _LoS(e) then
						-- local friends_attacking = UnitEnemiesAttacking(e)
						-- local unit_hp = _HP(e)
						-- if friends_attacking == 0 then
							-- local min_hp = 70
							-- min_hp = min_hp - (our_healer_cc and 20 or 0)
							-- min_hp = min_hp - (_CDcheck(e) and 20 or 0)
							-- min_hp = min_hp - (lowestFriend < 40 and 20 or 0)
							-- if unit_hp > min_hp then
								table.insert(units,e)
							-- end
						-- end
					end
				end
			end

			local soonest = 69
			for i=1,#units do
				local val = cc(units[i])

				if val < soonest then
					soonest = val
				end
			end

			return soonest

		end
		
		--priority cc, and define max cast time here
		local max_cast_time = 69
		max_cast_time = healer_cc()
		if max_cast_time > fear_cast_time * 2 then
			max_cast_time = min ( max_cast_time, off_cc() )
		end

		if max_cast_time < 0 then max_cast_time = 0 end
	end

	--Aff
	if spec == 1 then
		--[[
		**Solo Mode**

		Solo Pet, Party Pet, Raid Pet
		]]--
		local absoluteCorruptionEnabled = IsPlayerSpell(196103)
		local writheInAgonyEnabled = IsPlayerSpell(196102)
		local drainSoulEnabled = IsPlayerSpell(aff.drainSoul)
		local hauntEnabled = IsPlayerSpell(aff.haunt)
		local inevitableDemiseEnabled = IsPlayerSpell(aff.inevitableDemise)
		local phantomSingularityEnabled = IsPlayerSpell(aff.phantomSingularity)
		local siphonLifeEnabled = IsPlayerSpell(63106)
		local sowTheSeedsEnabled = IsPlayerSpell(196226)
		local vileTaintEnabled = IsPlayerSpell(278350)
		local seedExplosionRadius = 9

		--Pvp
		local rampantAfflictionEnabled = IsPlayerSpell(aff.rampantAffliction)
		local ua_aoe = (rampantAfflictionEnabled and debuff_count(aff.unstableAfflictionRampantAffliction, 40) <= 3) or false
		--103673 DarkGlare ID
		local we_are_bursting = UnitBuffID('player', aff.buffs.darkSoulMisery) and SpellRecentlyUsed(aff.summonDarkglare, 20)



		--Aff
		local agony_single_target = debuff_count(aff.agony, 40) <= 3 or false
		local corruption_single_target = ( (not arena and debuff_count(warlock.corruption, 40) <= 2) or (arena and debuff_count(warlock.corruption, 40) <= 3) ) or false
		local siphon_life_single_target = siphonLifeEnabled and debuff_count(aff.siphonLife, 40) <= 3 or false

		local agony_aoe = not absoluteCorruptionEnabled and debuff_count(aff.debuffs.agony, 40) < 3 or false
		if absoluteCorruptionEnabled then
			agony_aoe = debuff_count(aff.debuffs.agony, 40) < 5 or false
		end
		local siphon_aoe = debuff_count(aff.debuffs.siphonLife, 40) <= 3 or false

		local ua_cast_time = _castTime(aff.unstableAffliction)
		local ua_refresh_time = 6 + ua_cast_time
		local corruption_refresh_time = 4 + (gcd * debuff_count(aff.debuffs.corruption, 40))
		local agony_refresh_time = 	5 + (gcd * debuff_count(aff.debuffs.agony, 40) / 3)
		local siphon_life_refresh_time = 4 + (gcd * debuff_count(aff.debuffs.siphonLife, 40))

		local function dots_up_unit(unit)
			local dots_up = false
			if siphonLifeEnabled then
				if (_debuffRemains(unit, aff.debuffs.unstableAffliction, 'player') > 5 or _debuffRemains(unit, aff.debuffs.unstableAfflictionRampantAffliction, 'player') > 5) and _debuffRemains(unit, aff.debuffs.agony, 'player') > 5 and _debuffRemains(unit, aff.debuffs.corruption, 'player') > 5 and _debuffRemains(unit, aff.debuffs.siphonLife, 'player') > 5 and (hauntEnabled and _debuffRemains(unit, aff.debuffs.haunt, 'player') > 5 or not hauntEnabled) then
					dots_up = true;
				end
			elseif absoluteCorruptionEnabled or writheInAgonyEnabled then
				if (_debuffRemains(unit, aff.debuffs.unstableAffliction, 'player') > 5 or _debuffRemains(unit, aff.debuffs.unstableAfflictionRampantAffliction, 'player') > 5) and _debuffRemains(unit, aff.debuffs.agony, 'player') > 5 and ( (not arena and _debuffRemains(unit, aff.debuffs.corruption, 'player') == -1) or (arena and _debuffRemains(unit, aff.debuffs.corruption, 'player') > 5) ) and (hauntEnabled and _debuffRemains(unit, aff.debuffs.haunt, 'player') > 5 or not hauntEnabled) then
					dots_up = true;
				end
			end
			if siphonLifeEnabled then
				if UnitTarget('player') ~= unit then
					if _debuffRemains(unit, aff.debuffs.agony, 'player') > 5 and _debuffRemains(unit, aff.debuffs.corruption, 'player') > 5 and _debuffRemains(unit, aff.debuffs.siphonLife, 'player') > 5 and (hauntEnabled and _debuffRemains(unit, aff.debuffs.haunt, 'player') > 5 or not hauntEnabled) then
						dots_up = true;
					end
				end
			elseif absoluteCorruptionEnabled or writheInAgonyEnabled then
				if UnitTarget('player') ~= unit then
					if _debuffRemains(unit, aff.debuffs.agony, 'player') > 5 and ( (not arena and _debuffRemains(unit, aff.debuffs.corruption, 'player') == -1) or (arena and _debuffRemains(unit, aff.debuffs.corruption, 'player') > 5) ) and (hauntEnabled and _debuffRemains(unit, aff.debuffs.haunt, 'player') > 5 or not hauntEnabled) then
						dots_up = true;
					end
				end
			end
			return dots_up
		end
		local dots_up_t = dots_up_unit(t)

		local function dots_up_count()
			local dotted_units_count = 0
			for i = 1, #Enemies do
				if dots_up_unit(Enemies[i]) then
					dotted_units_count = dotted_units_count + 1
				end
			end
			return dotted_units_count
		end


		local drain_soul_channel_time = 5 / (1 + (haste / 100))
		local drain_soul_tick_rate = drain_soul_channel_time / 5
		
		local function has_drain_soul_ticked()
			local _, _, _, startTime, _, _, _, spellId = UnitChannelInfo("player")
			if spellId == aff.drainSoul then
				if GetTime() - (startTime / 1000) > drain_soul_tick_rate then
					return true;
				end
			end
			return false;
		end
		local function should_stop_drain_soul()
			--if we are casting drain soul and it ticks
			--if we are not casting drain soul at all it should return nil
			if select(8, UnitChannelInfo('player')) == nil then return true end
			if select(8, UnitChannelInfo('player')) == aff.drainSoul then
				if has_drain_soul_ticked() then
					return true and SpellStopCasting();
				end
			end
			return false
		end
		--if=active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled)
		local function corruption_talent_counter()
			local seedsEnabled = 4 - (sowTheSeedsEnabled and 1 or 0)
			local siphonEnabled = 4 - (siphonLifeEnabled and 1 or 0)
			if siphonEnabled == 3 then
				return siphonEnabled
			elseif seedsEnabled == 3 then
				return seedsEnabled
			elseif siphonEnabled == 3 and seedsEnabled == 3 then
				return 3
			else
				return 4
			end
		end
		--Rotation
		local function preCombat()
			--flask

			--food

			--augment

			--summon_pet

			--grimoire_of_sacrifice,if=talent.grimoire_of_sacrifice.enabled
			
			--seed_of_corruption,if=spell_targets.seed_of_corruption_aoe>=3&!equipped.169314

			--haunt

			--shadow_bolt,if=!talent.haunt.enabled&spell_targets.seed_of_corruption_aoe<3&!equipped.169314
		end
		local function covenant()
			if auto_cds then
				--actions.covenant=impending_catastrophe,if=cooldown.summon_darkglare.remains<10|cooldown.summon_darkglare.remains>50
				if covenantID == covenants.ids.venthyr and IsPlayerSpell(covenants.venthyr.impendingCatastrophe) then
					if _spellCooldown(aff.summonDarkglare) < 10 or _spellCooldown(aff.summonDarkglare) > 50 then
						if _spellCooldown(covenants.venthyr.impendingCatastrophe) == 0 then
							if should_stop_drain_soul() then
								if _Cast(covenants.venthyr.impendingCatastrophe, t, true) then return true end
							end
						end
					end
				end
				--actions.covenant+=/decimating_bolt,if=cooldown.summon_darkglare.remains>5&(debuff.haunt.remains>4|!talent.haunt.enabled)
				if covenantID == covenants.ids.necroLord and IsPlayerSpell(covenants.necroLord.decimatingBolt) then
					if _spellCooldown(aff.summonDarkglare) > 5 and (_debuffRemains(t, aff.debuffs.haunt, 'player') > 4 or not hauntEnabled) then
						if _spellCooldown(covenants.necroLord.decimatingBolt) == 0 then
							if should_stop_drain_soul() then
								if _Cast(covenants.necroLord.decimatingBolt, t, true) then return true end
							end
						end
					end
				end
				--actions.covenant+=/soul_rot,if=cooldown.summon_darkglare.remains<5|cooldown.summon_darkglare.remains>50|cooldown.summon_darkglare.remains>25&conduit.corrupting_leer.enabled
				if covenantID == covenants.ids.nightFae and IsPlayerSpell(covenants.nightFae.soulRot) then
					if _spellCooldown(aff.summonDarkglare) < 5 or _spellCooldown(aff.summonDarkglare) > 50 then --add at lvl 60
						if _spellCooldown(covenants.nightFae.soulRot) <= gcd_remains and dots_up_t then
							if should_stop_drain_soul() then
								if _Cast(covenants.nightFae.soulRot, t, false) then return true end
							end
						end
					end
				end
				--actions.covenant+=/scouring_tithe
				if covenantID == covenants.ids.kyrian and IsPlayerSpell(covenants.kyrian.scouringTithe) then
					if _spellCooldown(covenants.kyrian.scouringTithe) == 0 then
						if should_stop_drain_soul() then
							if _Cast(covenants.kyrian.scouringTithe, t, true) then return true end
						end
					end
				end
			end
		end
		local function darkglare_prep()
			if t_is_boss and auto_cds then
				--actions.darkglare_prep=vile_taint,if=cooldown.summon_darkglare.remains<2
				if shards >= 1 and _spellCooldown(aff.summonDarkglare) < 2 and vileTaintEnabled and _spellCooldown(aff.vileTaint) <= gcd_remains then
					if should_stop_drain_soul() then
						--print('return [DGP] - Vile Taint - Should Stop')
						_AeCast(aff.vileTaint, t, 40, 10, true, true)
					end
				end
				--actions.darkglare_prep+=/potion
				--actions.darkglare_prep+=/fireblood
				--actions.darkglare_prep+=/blood_fury
				if race == 'Orc' and _spellCooldown(racials.bloodFury) == 0 then
					if should_stop_drain_soul() then
						--print('return [DGP] - Racial - Should Stop')
						_Cast(racials.bloodFury)
					end
				end
				--actions.darkglare_prep+=/berserking
				if race == 'Troll' and _spellCooldown(racials.berserking) == 0 then
					if should_stop_drain_soul() then
						_Cast(racials.berserking)
					end
				end
				--actions.darkglare_prep+=/call_action_list,name=covenant,if=!covenant.necrolord&cooldown.summon_darkglare.remains<2
				if covenantID ~= covenants.ids.necroLord and _spellCooldown(aff.summonDarkglare) < 2 and dots_up_t and _spellCooldown(aff.phantomSingularity) <= 1 then
					covenant()
				end
				--actions.darkglare_prep+=/dark_soul
				if phantomSingularityEnabled and dots_up_t and covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot) > 4 and _debuffRemains(t, aff.debuffs.phantomSingularity) > 7 and _spellCooldown(aff.darkSoulMisery) == 0 and _spellCooldown(aff.summonDarkglare) == 0 then
					if should_stop_drain_soul() then
						_Cast(aff.darkSoulMisery)
					end
				elseif not phantomSingularityEnabled and dots_up_t and covenantID == covenants.ids.night_fae and _debuffRemains(t, covenants.nightFae.soulRot) > 4 and _spellCooldown(aff.darkSoulMisery) == 0 and _spellCooldown(aff.summonDarkglare) == 0 then
					if should_stop_drain_soul() then
						_Cast(aff.darkSoulMisery)
					end
				elseif phantomSingularityEnabled and dots_up_t and covenantID ~= covenants.ids.nightFae and _debuffRemains(t, aff.debuffs.phantomSingularity) > 7 and _spellCooldown(aff.darkSoulMisery) == 0 and _spellCooldown(aff.summonDarkglare) == 0 then
					if should_stop_drain_soul() then
						_Cast(aff.darkSoulMisery)
					end
				elseif not phantomSingularityEnabled and dots_up_t and covenantID ~= covenants.ids.night_fae and _spellCooldown(aff.darkSoulMisery) == 0 and _spellCooldown(aff.summonDarkglare) == 0 then
					if should_stop_drain_soul() then
						_Cast(aff.darkSoulMisery)
					end
				end
				--actions.darkglare_prep+=/darkglare
				if phantomSingularityEnabled and dots_up_t and covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot) > 4 and _debuffRemains(t, aff.debuffs.phantomSingularity) > 7 and (_spellCooldown(aff.darkSoulMisery) == 0 or _buffRemains('player', aff.buffs.darkSoulMisery) > 15) and _spellCooldown(aff.summonDarkglare) == 0 then
					if should_stop_drain_soul() then
						_Cast(aff.summonDarkglare)
					end
				elseif not phantomSingularityEnabled and dots_up_t and covenantID == covenants.ids.night_fae and _debuffRemains(t, covenants.nightFae.soulRot) > 4 and (_spellCooldown(aff.darkSoulMisery) == 0 or _buffRemains('player', aff.buffs.darkSoulMisery) > 15) and _spellCooldown(aff.summonDarkglare) == 0 then
					if should_stop_drain_soul() then
						_Cast(aff.summonDarkglare)
					end
				elseif phantomSingularityEnabled and dots_up_t and covenantID ~= covenants.ids.nightFae and _debuffRemains(t, aff.debuffs.phantomSingularity) > 7 and (_spellCooldown(aff.darkSoulMisery) == 0 or _buffRemains('player', aff.buffs.darkSoulMisery) > 15) and _spellCooldown(aff.summonDarkglare) == 0 then
					if should_stop_drain_soul() then
						_Cast(aff.summonDarkglare)
					end
				elseif not phantomSingularityEnabled and dots_up_t and covenantID ~= covenants.ids.night_fae and (_spellCooldown(aff.darkSoulMisery) == 0 or _buffRemains('player', aff.buffs.darkSoulMisery) > 15) and _spellCooldown(aff.summonDarkglare) == 0 then
					if should_stop_drain_soul() then
						_Cast(aff.summonDarkglare)
					end
				end
			end
		end
		local function use_items()
			if tContains( equipped_items, 173069 ) and GetItemCD ( ( 173069 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 173069 ) ) )
				Squid_Alert( "Darkmoon Deck: Voracity" )
            end   
		end
		local function se()
			--actions.se=haunt
			if hauntEnabled and _spellCooldown(aff.haunt) <= gcd_remains and not _isMoving('player') then
				if should_stop_drain_soul() then
					if _Cast(aff.haunt, t, true) then return true end
				end
			end
			--actions.se+=/drain_soul,interrupt_global=1,interrupt_if=debuff.shadow_embrace.stack>=3
			if drainSoulEnabled then
				if select(8, UnitChannelInfo('player')) == aff.drainSoul then
					if UnitDebuffID(t, aff.debuffs.shadowEmbrace, 'player') and _debuffStacks(t, aff.debuffs.shadowEmbrace) >= 3 then
						if should_stop_drain_soul() then return true end
					end
				else
					if _debuffStacks(t, aff.debuffs.shadowEmbrace) < 3 or _debuffRemains(t, aff.debuffs.shadowEmbrace, 'player') <= gcd_remains + drain_soul_tick_rate then
						if _Cast(aff.drainSoul, t, true) then return true end
					end
				end
			end
			--actions.se+=/shadow_bolt
			if not drainSoulEnabled and not arena then
				if _Cast(warlock.shadowBolt, t, true) then return true end
			end
		end
		local function shard_sniper()
			for i = 1, #Enemies do
				if _HP(Enemies[i]) < 6 and shards < 2 then
					if drainSoulEnabled then
						_Cast(aff.drainSoul, Enemies[i], true)
					end
				end
			end
		end
		local function arena_pvp()
			--Rapid Contagion
			if IsPlayerSpell(344566) then
				if dots_up_t then
					if _buffRemains('player', aff.buffs.darkSoulMisery) >= 10 and shards >= 3 then
						_Cast(aff.rapidContagion)
					elseif _spellCooldown(aff.darkSoulMisery) > 15 then
						_Cast(aff.rapidContagion)
					end
				end
			end
			--Get Corruption up first
			for i = 1, #Enemies do
				if ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
					if should_stop_drain_soul() then
						--print('return [D2] - Corruption - Should Stop')
						if _Cast(warlock.corruption, Enemies[i], false) then return true end
					end
				end
			end
		end
		local function aoe()
			if instanceType ~= 'pvp' or instanceType ~= arena then
				--Solo Behaviors
				if solo and instanceType == 'none' then
					if dots_up_t and player_hp <= 40 and _distance('player', t) <= 20 and _spellCooldown(aff.mortalCoil) <= gcd_remains then
						if _Cast(aff.mortalCoil, t, true) then return true end
					end
					if player_hp <= 50 and _distance('player', t) <= 40 then
						if _Cast(warlock.drainLife, t, true) then return true end
					end
				end
				--actions.aoe=phantom_singularity
				if auto_cds and dots_up_t and phantomSingularityEnabled and _spellCooldown(aff.phantomSingularity) <= gcd_remains then
					if _distance('player', t) <= 40 then
						if should_stop_drain_soul() then
							--print('return [AoE] - Phantom Singularity - Should Stop')
							if _Cast(aff.phantomSingularity, t) then return true end
						end
					end
				end
				--actions.aoe+=/haunt
				if hauntEnabled and _spellCooldown(aff.haunt) == 0 and select(9, UnitCastingInfo('player')) ~= aff.haunt then
					SpellStopCasting()
				end
				if hauntEnabled and _spellCooldown(aff.haunt) <= gcd_remains and not _isMoving('player') then
					if _distance('player', t) <= 40 then
						if should_stop_drain_soul() then
							--print('return [AoE] - Haunt - Should Stop')
							if _Cast(aff.haunt, t, true) then return true end
						end
					end
				end
				--actions.aoe+=/call_action_list,name=darkglare_prep,if=covenant.venthyr&dot.impending_catastrophe_dot.ticking&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if covenantID == covenants.ids.venthyr and _debuffRemains(t, covenants.venthyr.impendingCatastrophe, 'player') > 1 and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions.aoe+=/call_action_list,name=darkglare_prep,if=covenant.night_fae&dot.soul_rot.ticking&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot, 'player') > 1 and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions.aoe+=/call_action_list,name=darkglare_prep,if=(covenant.necrolord|covenant.kyrian|covenant.none)&dot.phantom_singularity.ticking&dot.phantom_singularity.remains<2
				if (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenantID == covenants.ids.none) and _debuffRemains(t, aff.phantomSingularity, 'player') then
					darkglare_prep()
				end
				--actions.aoe+=/seed_of_corruption,if=talent.sow_the_seeds.enabled&can_seed
				if sowTheSeedsEnabled and shards >= 1 and _debuffRemains(t, aff.debuffs.seedOfCorruption, 'player') <= 0 then
					if not SpellRecentlyUsed(aff.seedOfCorruption, gcd) or PlayerSpellCasts[1].id ~= aff.seedOfCorruption then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								--print('return [AoE] - Sow Enabled - Seed of Corruption - Agony - Should Stop')
								if _Cast(aff.seedOfCorruption, t, false) then return true end
							end
						end
					end
				end
				--actions.aoe+=/seed_of_corruption,if=!talent.sow_the_seeds.enabled&!dot.seed_of_corruption.ticking&!in_flight&dot.corruption.refreshable
				if not arena and not sowTheSeedsEnabled and shards >= 1 and _debuffRemains(t, aff.debuffs.seedOfCorruption, 'player') <= 0 and (_debuffRemains(t, aff.debuffs.corruption, 'player') ~= -1 and _debuffRemains(t, aff.debuffs.corruption, 'player') <= corruption_refresh_time) then
					if not SpellRecentlyUsed(aff.seedOfCorruption, 1.5) or PlayerSpellCasts[1].id ~= aff.seedOfCorruption then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								--print('return [AoE] - Seed of Corruption - Agony - Should Stop')
								if _Cast(aff.seedOfCorruption, t, false) then return true end
							end
						end
					end
				end
				--actions.aoe+=/agony,cycle_targets=1,if=active_dot.agony<4,target_if=!dot.agony.ticking
				if agony_aoe and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
							if should_stop_drain_soul() then
								--print('return [AoE] - Agony AoE - Should Stop')
								if _Cast(aff.agony, Enemies[i], false) then return true end
							end
						end
					end
				--actions.aoe+=/agony,cycle_targets=1,if=active_dot.agony>=4,target_if=refreshable&dot.agony.ticking
				elseif not agony_aoe and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], aff.debuffs.agony, 'player') and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
							if should_stop_drain_soul() then
								--print('return [AoE] - Agony AoE Refresh - Should Stop')
								if _Cast(aff.agony, Enemies[i], false) then return true end
							end
						end
					end
				end
				--actions+=/unstable_affliction,if=dot.unstable_affliction.remains<4
				if not _isMoving('player') and (not rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAffliction, 'player') < ua_refresh_time) or (rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time) then
					if _distance('player', t) <= 40 then
						if should_stop_drain_soul() then
							if _Cast(aff.unstableAffliction, t, false) then return true end
						end
					end
				elseif (arena or instanceType == 'pvp') and ua_aoe and not _isMoving('player') then
					for i = 1, #Enemies do
						if UnitIsPlayer(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time and _distance('player', Enemies[i]) <= 40 then
							if should_stop_drain_soul() then
								if _Cast(aff.unstableAffliction, Enemies[i], false) then return true end
							end
						end
					end
				end
				--actions.aoe+=/vile_taint,if=soul_shard>1
				if vileTaintEnabled and auto_cds and shards > 1 and _spellCooldown(aff.vileTaint) == 0 then
					if _distance('player', t) <= 40 then
						if should_stop_drain_soul() then
							--print('return [AoE] - Vile Taint - Should Stop')
							if _AeCast(aff.vileTaint, t, 40, 10, true, true) then return true end
						end
					end
				end
				--actions.aoe+=/call_action_list,name=covenant,if=!covenant.necrolord
				if covenantID ~= covenants.ids.necroLord then
					if covenant() then return true end
				end 
				--actions.aoe+=/call_action_list,name=darkglare_prep,if=covenant.venthyr&(cooldown.impending_catastrophe.ready|dot.impending_catastrophe_dot.ticking)&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if covenantID == covenants.ids.venthyr and (_spellCooldown(covenants.venthyr.impendingCatastrophe) == 0 or _debuffRemains(t, covenants.venthyr.impendingCatastrophe) > 0) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions.aoe+=/call_action_list,name=darkglare_prep,if=(covenant.necrolord|covenant.kyrian|covenant.none)&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenantID == covenants.ids.none) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
					--actions.aoe+=/call_action_list,name=darkglare_prep,if=covenant.night_fae&(cooldown.soul_rot.ready|dot.soul_rot.ticking)&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if covenantID == covenants.ids.nightFae and (_spellCooldown(covenants.nightFae.soulRot) <= gcd_remains or _debuffRemains(t, covenants.nightFae.soulRot) > 1) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions.aoe+=/call_action_list,name=item
				if dots_up_t and auto_cds and use_darkmoon_deck then
					if use_items() then return true end
				end
				--actions.aoe+=/malefic_rapture,if=dot.vile_taint.ticking
				if shards >= 1 and vileTaintEnabled and _debuffRemains(t, aff.debuffs.vileTaint) > _castTime(aff.maleficRapture) + gcd_remains and _LoS(t) then
					if _distance('player', t) <= 40 then
						if should_stop_drain_soul() then
							if _Cast(aff.maleficRapture) then return true end
						end
					end
				end
				--actions.aoe+=/malefic_rapture,if=dot.soul_rot.ticking&!talent.sow_the_seeds.enabled
				if shards >= 1 and _debuffRemains(t, covenants.nightFae.soulRot) > 1 and not sowTheSeedsEnabled and _LoS(t) then
					if should_stop_drain_soul() then
						if _Cast(aff.maleficRapture) then return true end
					end
				end
				--actions.aoe+=/malefic_rapture,if=!talent.vile_taint.enabled
				if shards >= 1 and not vileTaintEnabled and _LoS(t) then
					if should_stop_drain_soul() then
						if _Cast(aff.maleficRapture) then return true end
					end
				end
				--actions.aoe+=/malefic_rapture,if=soul_shard>4
				if shards >= 4 and _LoS(t) then
					if should_stop_drain_soul() then
						if _Cast(aff.maleficRapture) then return true end
					end
				end
				--actions.aoe+=/siphon_life,cycle_targets=1,if=active_dot.siphon_life<=3,target_if=!dot.siphon_life.ticking
				if siphon_aoe and siphonLifeEnabled and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') <= 0 then
							if should_stop_drain_soul() then
								if _Cast(aff.siphonLife, Enemies[i], false) then return true end
							end
						end
					end
				end
				--actions.aoe+=/call_action_list,name=covenant
				if covenant() then return true end
				--actions.aoe+=/drain_life,if=buff.inevitable_demise.stack>=50|buff.inevitable_demise.up&time_to_die<5|buff.inevitable_demise.stack>=35&dot.soul_rot.ticking
				if inevitableDemiseEnabled and UnitBuffID('player', aff.buffs.inevitableDemise) and _buffStacks('player', aff.buffs.inevitableDemise) >= 50 or UnitBuffID('player', aff.buffs.inevitableDemise) and squid_ttd < 5 or UnitBuffID('player', aff.buffs.inevitableDemise) and _buffStacks('player', aff.buffs.inevitableDemise) >= 35 and _debuffRemains(t, covenants.nightFae.soulRot, 'player') > 1 then
					if _distance('player', t) <= 40 then	
						if should_stop_drain_soul() then
							if _Cast(warlock.drainLife, t, true) then return true end
						end
					end
				end
			end
		end
		local function default()
			--# Executed every time the actor is available.
			--Solo Behaviors
			if solo and instanceType == 'none' then
				if dots_up_t and player_hp <= 40 and _distance('player', t) <= 20 and _spellCooldown(aff.mortalCoil) <= gcd_remains then
					if _Cast(aff.mortalCoil, t, true) then return true end
				end
				if player_hp <= 50 and _distance('player', t) <= 40 then
					if _Cast(warlock.drainLife, t, true) then return true end
				end
			end
			--actions.aoe=phantom_singularity
			if auto_cds and dots_up_t and phantomSingularityEnabled and _spellCooldown(aff.phantomSingularity) <= gcd_remains then
				if _distance('player', t) <= 40 then
					if should_stop_drain_soul() then
						--print('return [AoE] - Phantom Singularity - Should Stop')
						if _Cast(aff.phantomSingularity, t) then return true end
					end
				end
			end
			--actions.aoe+=/haunt
			if hauntEnabled and _spellCooldown(aff.haunt) == 0 and select(9, UnitCastingInfo('player')) ~= aff.haunt then
				SpellStopCasting()
			end
			--actions+=/haunt
			if hauntEnabled and _spellCooldown(aff.haunt) <= gcd_remains and not _isMoving('player') then
				if should_stop_drain_soul() then
					--print('return [D1] - Haunt - Should Stop')
					if _Cast(aff.haunt, t, true) then return true end
				end
			end
			--actions+=/call_action_list,name=darkglare_prep,if=covenant.venthyr&dot.impending_catastrophe_dot.ticking&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
			if covenantID == covenants.ids.venthyr and _debuffRemains(t, covenants.venthyr.impendingCatastrophe, 'player') and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
				darkglare_prep()
			end
			--actions+=/call_action_list,name=darkglare_prep,if=covenant.night_fae&dot.soul_rot.ticking&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
			if covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot, 'player') > 1 and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
				darkglare_prep()
			end
			--actions+=/call_action_list,name=darkglare_prep,if=(covenant.necrolord|covenant.kyrian|covenant.none)&dot.phantom_singularity.ticking&dot.phantom_singularity.remains<2
			if (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenantID == covenants.ids.none) and _debuffRemains(t, aff.phantomSingularity, 'player') then
				darkglare_prep()
			end
			--actions+=/agony,if=dot.agony.remains<4
			if _debuffRemains(t, aff.agony, 'player') <= agony_refresh_time then
				if should_stop_drain_soul() then
					if _Cast(aff.agony, t, false) then return true end
				end
			end
			--actions+=/agony,cycle_targets=1,if=active_enemies>1,target_if=dot.agony.remains<4
			if valid_enemies_around('player', 40) > 1 and agony_single_target and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
						if should_stop_drain_soul() then
							--print('return [D1] - Agony - Should Stop')
							if _Cast(aff.agony, Enemies[i], false) then return true end
						end
					end
				end
				--refresh agony on the amount of mobs we want for single target
			elseif valid_enemies_around('player', 40) > 1 and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and UnitDebuffID(Enemies[i], aff.debuffs.agony, 'player') and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
						if should_stop_drain_soul() then
							--print('return [D1] - Agony Refresh - Should Stop')
							if _Cast(aff.agony, Enemies[i], false) then return true end
						end
					end
				end
			end
			--actions+=/call_action_list,name=darkglare_prep,if=active_enemies>2&covenant.venthyr&(cooldown.impending_catastrophe.ready|dot.impending_catastrophe_dot.ticking)&(dot.phantom_singularity.ticking|!talent.phantom_singularity.enabled)
			if valid_enemies_around('player', 10) > 2 and covenantID == covenants.ids.venthyr and (_spellCooldown(covenants.venthyr.impendingCatastrophe) == 0 or _debuffRemains(t, covenants.venthyr.impendingCatastrophe, 'player') > 1) and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 1 or not phantomSingularityEnabled) then
				darkglare_prep()
			end
			--actions+=/call_action_list,name=darkglare_prep,if=active_enemies>2&(covenant.necrolord|covenant.kyrian|covenant.none)&(dot.phantom_singularity.ticking|!talent.phantom_singularity.enabled)
			if valid_enemies_around('player', 10) > 2 and (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenantID == covenants.ids.none) and _debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 1 or not phantomSingularityEnabled then
				darkglare_prep()
			end
			--actions+=/call_action_list,name=darkglare_prep,if=active_enemies>2&covenant.night_fae&(cooldown.soul_rot.ready|dot.soul_rot.ticking)&(dot.phantom_singularity.ticking|!talent.phantom_singularity.enabled)
			if valid_enemies_around('player', 10) > 2 and covenantID == covenants.ids.nightFae and (_spellCooldown(covenants.nightFae.soulRot) == 0 or _debuffRemains(t, covenants.nightFae.soulRot) > 1) and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
				darkglare_prep()
			end
			--actions+=/seed_of_corruption,if=active_enemies>2&talent.sow_the_seeds.enabled&!dot.seed_of_corruption.ticking&!in_flight
			if valid_enemies_around(t, 10) >= 2 and sowTheSeedsEnabled and _debuffRemains(t, aff.debuffs.seedOfCorruption, 'player') <= 0 then
				if not SpellRecentlyUsed(aff.seedOfCorruption, gcd) or PlayerSpellCasts[1].id ~= aff.seedOfCorruption then
					if should_stop_drain_soul() and not arena then
						--print('return [D1] - Seed of Corruption with Sow Enabled - Should Stop')
						if _Cast(aff.seedOfCorruption, t, false) then return true end
					end
				end
			end
			--actions+=/seed_of_corruption,if=active_enemies>2&talent.siphon_life.enabled&!dot.seed_of_corruption.ticking&!in_flight&dot.corruption.remains<4
			if valid_enemies_around(t, 10) >= 2 and siphonLifeEnabled and _debuffRemains(t, aff.debuffs.seedOfCorruption, 'player') <= 0 and ( _debuffRemains(t, warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(t, warlock.debuffs.corruption, 'player') ~= -1) then
				if not SpellRecentlyUsed(aff.seedOfCorruption, gcd) or PlayerSpellCasts[1].id ~= aff.seedOfCorruption then
					if should_stop_drain_soul() and not arena then
						--print('return [D1] - Seed of Corruption with Siphon life - Should Stop')
						if _Cast(aff.seedOfCorruption, t, false) then return true end
					end
				end
			end
			--actions+=/vile_taint,if=(soul_shard>1|active_enemies>2)&cooldown.summon_darkglare.remains>12
			if vileTaintEnabled and (shards > 1 or valid_enemies_around(t, 10) > 2) and _spellCooldown(aff.summonDarkglare) > 12 and _spellCooldown(aff.vileTaint) == 0 then
				if should_stop_drain_soul() then
					--print('return [D1] - Vile Taint Enabled - Should Stop')
					if _AeCast(aff.vileTaint, t, 40, 10, true, true) then return true end
				end
			end
			--actions+=/unstable_affliction,if=dot.unstable_affliction.remains<4
			if not _isMoving('player') then
				if (not rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAffliction, 'player') < ua_refresh_time) or (rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time) then
					if _distance('player', t) <= 40 then
						if should_stop_drain_soul() then
							if _Cast(aff.unstableAffliction, t, false) then return true end
						end
					end
				elseif (arena or instanceType == 'pvp') and ua_aoe then
					for i = 1, #Enemies do
						if UnitIsPlayer(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time and _distance('player', Enemies[i]) <= 40 then
							if should_stop_drain_soul() then
								if _Cast(aff.unstableAffliction, Enemies[i], false) then return true end
							end
						end
					end
				end
			end
			--actions+=/siphon_life,if=dot.siphon_life.remains<4
			if siphonLifeEnabled and _debuffRemains(t, aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
				if should_stop_drain_soul() then
					--print('return [D1] - Siphon Life - Should Stop')
					if _Cast(aff.siphonLife, t, false) then return true end
				end
			end

			--actions+=/siphon_life,cycle_targets=1,if=active_enemies>1,target_if=dot.siphon_life.remains<4
			if siphonLifeEnabled and valid_enemies_around('player', 40) > 1 and siphon_life_single_target and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
						if should_stop_drain_soul() then
							--print('return [D2] - Siphon Life Refresh - Should Stop')
							if _Cast(aff.siphonLife, Enemies[i], false) then return true end
						end
					end
				end
				--refresh siphon life on the amount of mobs we want for single target
			elseif siphonLifeEnabled and valid_enemies_around('player', 40) > 1 and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and UnitDebuffID(Enemies[i], aff.debuffs.siphonLife, 'player') and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
						if should_stop_drain_soul() then
							--print('return [D2] - Siphon Life Refresh - Should Stop')
							if _Cast(aff.siphonLife, Enemies[i], false) then return true end
						end
					end
				end
			end
			--actions+=/call_action_list,name=covenant,if=!covenant.necrolord
			if covenantID ~= covenants.ids.necroLord then
				if covenant() then return true end
			end
			--actions+=/corruption,if=active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled)&dot.corruption.remains<2
			if (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and ( _debuffRemains(t, warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(t, warlock.debuffs.corruption, 'player') ~= -1) then
				if should_stop_drain_soul() then
					--print('return [D2] - Corruption - Should Stop')
					if _Cast(warlock.corruption, t, false) then return true end
				end
			end
			--Culprit? Yes it was one.
			--actions+=/corruption,cycle_targets=1,if=active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled),target_if=dot.corruption.remains<2
			if (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and corruption_single_target and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
						if should_stop_drain_soul() then
							--print('return [D2] - Corruption Refresh1 - Should Stop')
							if _Cast(warlock.corruption, Enemies[i], false) then return true end
						end
					end
				end
				--refresh corruption on the amount of mobs we want for single target
			elseif (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], warlock.debuffs.corruption, 'player') and ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
						if should_stop_drain_soul() then
							--print('return [D2] - Corruption Refresh2 - Should Stop')
							if _Cast(warlock.corruption, Enemies[i], false) then return true end
						end
					end
				end
			end
			--[[
			--actions+=/phantom_singularity,if=covenant.necrolord|covenant.night_fae|covenant.kyrian|covenant.none
			if covenantID == covenants.ids.necroLord or covenantID == covenants.ids.nightFae or covenantID == covenants.ids.kyrian or covenants.ids.none then
				if phantomSingularityEnabled and auto_cds and _spellCooldown(aff.phantomSingularity) == 0 then
					if should_stop_drain_soul() then
						--print('return [D2] - Phantom Singularity Off CD - Should Stop')
						if _Cast(aff.phantomSingularity, t) then return true end
					end
				end
			end
			--]]
			--actions+=/malefic_rapture,if=soul_shard>4
			if shards > 4 and _LoS(t) then
				if should_stop_drain_soul() then
					--print('return [D2] - Malefic Rapture - Shards > 4 - Should Stop')
					if _Cast(aff.maleficRapture, t) then return true end
				end
			end
			--actions+=/call_action_list,name=darkglare_prep,if=covenant.venthyr&(cooldown.impending_catastrophe.ready|dot.impending_catastrophe_dot.ticking)&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
			if covenantID == covenants.ids.venthyr and (_spellCooldown(covenants.venthyr.impendingCatastrophe) == 0 or _debuffRemains(covenants.venthyr.impendingCatastrophe) > 0) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
				darkglare_prep()
			end
			--actions+=/call_action_list,name=darkglare_prep,if=(covenant.necrolord|covenant.kyrian|covenant.none)&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
			if (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenants.ids.none) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
				darkglare_prep()
			end
			--actions+=/call_action_list,name=darkglare_prep,if=covenant.night_fae&(cooldown.soul_rot.ready|dot.soul_rot.ticking)&cooldown.summon_darkglare.remains<2&(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
			if covenantID == covenants.ids.nightFae and (_spellCooldown(covenants.nightFae.soulRot) == 0 or _debuffRemains(t, covenants.nightFae.soulRot) > 0 ) and  _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
				darkglare_prep()
			end
			--actions+=/call_action_list,name=item
			if dots_up_t and auto_cds and use_darkmoon_deck then
				if use_items() then return true end
			end
			--actions+=/call_action_list,name=se,if=debuff.shadow_embrace.stack<(2-action.shadow_bolt.in_flight)|debuff.shadow_embrace.remains<3
			if not UnitDebuffID(t, aff.debuffs.shadowEmbrace, 'player') or UnitDebuffID(t, aff.debuffs.shadowEmbrace, 'player') and _debuffStacks(t, aff.debuffs.shadowEmbrace) < 3 then
				if se() then return true end
			end
			--actions+=/malefic_rapture,if=dot.vile_taint.ticking
			if shards >= 1 and _debuffRemains(aff.debuffs.vileTaint) > _castTime(aff.maleficRapture) and _LoS(t) then
				if should_stop_drain_soul() then
					--print('return [D2] - Malefic Rapture - Taint Remains  - Should Stop')
					if _Cast(aff.maleficRapture) then return true end
				end
			end
			--actions+=/malefic_rapture,if=dot.impending_catastrophe_dot.ticking
			if shards >= 1 and covenantID == covenants.ids.venthyr and _debuffRemains(t, ovenants.venthyr.impendingCatastrophe, 'player') > _castTime(aff.maleficRapture) and _LoS(t) then
				if should_stop_drain_soul() then
					--print('return [D2] - Malefic Rapture - Impending Catastrophe Remains - Should Stop')
					if _Cast(aff.maleficRapture) then return true end
				end
			end
			--actions+=/malefic_rapture,if=dot.soul_rot.ticking
			if shards >= 1 and covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot, 'player') > _castTime(aff.maleficRapture) and _LoS(t) then
				if should_stop_drain_soul() then
					--print('return [D2] - Malefic Rapture - Soul Rot Remains - Should Stop')
					if _Cast(aff.maleficRapture) then return true end
				end
			end

			--actions+=/malefic_rapture,if=talent.phantom_singularity.enabled&(dot.phantom_singularity.ticking|soul_shard>3|time_to_die<cooldown.phantom_singularity.remains)
			if shards >= 1 and phantomSingularityEnabled and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > _castTime(aff.maleficRapture) or shards > 3 ) and _LoS(t) then
				if should_stop_drain_soul() then
					--print('return [D3] - Malefic Rapture - Phantom Singularity Remains - Should Stop')
					if _Cast(aff.maleficRapture) then return true end
				end
			end
			--actions+=/malefic_rapture,if=talent.sow_the_seeds.enabled
			if not _isMoving('player') and shards >= 1 and sowTheSeedsEnabled and _LoS(t) then
				if should_stop_drain_soul() then
					--print('return [D3] - Malefic Rapture - Shards >= 1 and Sow the Seeds Enabled - Should Stop')
					if _Cast(aff.maleficRapture) then return true end
				end
			end
			--actions+=/drain_life,if=buff.inevitable_demise.stack>40|buff.inevitable_demise.up&time_to_die<4
			if not _isMoving('player') and inevitableDemiseEnabled and UnitBuffID('player', aff.buffs.inevitableDemise) and _buffStacks('player', aff.buffs.inevitableDemise) >= 40 then
				if should_stop_drain_soul() then
					if _Cast(warlock.drainLife, t, true) then return true end
				end
			end
			--actions+=/call_action_list,name=covenant
			if covenant() then return true end
			--actions+=/agony,if=refreshable
			if _debuffRemains(t, aff.debuffs.agony) < agony_refresh_time then
				if should_stop_drain_soul() then
					--print('return [D3] - Agony Refresh - Should Stop')
					if _Cast(aff.agony, t, false) then return true end
				end
			end
			--actions+=/agony,cycle_targets=1,if=active_enemies>1,target_if=refreshable
			if valid_enemies_around('player', 40) > 1 and agony_single_target and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
						if should_stop_drain_soul() then
							--print('return [D3] - Agony AoE - Should Stop')
							if _Cast(aff.agony, Enemies[i], false) then return true end
						end
					end
				end
				--refresh agony on the amount of mobs we want for single target
			elseif valid_enemies_around('player', 40) > 1 and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], aff.debuffs.agony, 'player') and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
						if should_stop_drain_soul() then
							--print('return [D3] - Agony AoE Refresh - Should Stop')
							if _Cast(aff.agony, Enemies[i], false) then return true end
						end
					end
				end
			end
			--actions+=/corruption,if=refreshable&active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled)
			if (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and ( _debuffRemains(t, warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(t, warlock.debuffs.corruption, 'player') ~= -1) then
				if should_stop_drain_soul() then
					--print('return [D3] - Corruption Refresh - Should Stop')
					if _Cast(warlock.corruption, t, false) then return true end
				end
			end
			--actions+=/unstable_affliction,if=dot.unstable_affliction.remains<4
			if not _isMoving('player') then
				if (not rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAffliction, 'player') < ua_refresh_time) or (rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time) then
					if _distance('player', t) <= 40 then
						if should_stop_drain_soul() then
							if _Cast(aff.unstableAffliction, t, false) then return true end
						end
					end
				elseif (arena or instanceType == 'pvp') and ua_aoe then
					for i = 1, #Enemies do
						if UnitIsPlayer(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time and _distance('player', Enemies[i]) <= 40 then
							if should_stop_drain_soul() then
								if _Cast(aff.unstableAffliction, Enemies[i], false) then return true end
							end
						end
					end
				end
			end
			--actions+=/siphon_life,if=refreshable
			if siphonLifeEnabled and _debuffRemains(t, aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
				if should_stop_drain_soul() then
					--print('return [D3] - Malefic Rapture - Phantom Singularity Remains - Should Stop')
					if _Cast(aff.siphonLife, t, false) then return true end
				end
			end
			--actions+=/siphon_life,cycle_targets=1,if=active_enemies>1,target_if=refreshable
			if siphonLifeEnabled and valid_enemies_around('player', 40) > 1 and siphon_life_single_target and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
						if should_stop_drain_soul() then
							--print('return [D3] - Siphon Life AoE - Should Stop')
							if _Cast(aff.siphonLife, Enemies[i], false) then return true end
						end
					end
				end
				--refresh siphon life on the amount of mobs we want for single target
			elseif siphonLifeEnabled and valid_enemies_around('player', 40) > 1 and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], aff.debuffs.siphonLife, 'player') and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
						if should_stop_drain_soul() then
							--print('return [D3] - Siphon Life Aoe Refresh - Should Stop')
							if _Cast(aff.siphonLife, Enemies[i], false) then return true end
						end
					end
				end
			end
			--actions+=/corruption,cycle_targets=1,if=active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled),target_if=refreshable
			if (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and corruption_single_target and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
						if should_stop_drain_soul() then
							--print('return [D3] - Corruption AoE - Should Stop')
							if _Cast(warlock.corruption, Enemies[i], false) then return true end
						end
					end
				end
				--refresh corruption on the amount of mobs we want for single target
			elseif (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and not single_target_only then
				for i = 1, #Enemies do
					if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], warlock.debuffs.corruption, 'player') and ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
						if should_stop_drain_soul() then
							--print('return [D3] - Corruption AoE Refresh - Should Stop')
							if _Cast(warlock.corruption, Enemies[i], false) then return true end
						end
					end
				end
			end

			if drainSoulEnabled and not SpellRecentlyUsed(aff.maleficRapture, gcd + delay) then
				_Cast(aff.drainSoul, t, true)
			end
		end
		
		if not arena then
			dynamicTargeting(40)
		end

		--Fears
		if arena and dots_up_count() >= 2 then
			--feared target
			local feared_target
			local feared_target_remains = 0
			for i=1,#Enemies do 
				if UnitDebuffID(Enemies[i],118699,"player") then
					feared_target = Enemies[i]
					feared_target_remains = _debuffRemains(Enemies[i],118699,"player")
				end
			end
			
			local their_healer = theirHealer
			local their_healer_cc
			local their_healer_cc_remains = 0
			local their_healer_incapacitate_dr
			local their_healer_incapacitate_dr_remains = 0
			local their_healer_disorient_dr
			local their_healer_disorient_dr_remains = 0
			local their_healer_important_lockout
			if their_healer then
				if not UnitIsDeadOrGhost(their_healer) then
					their_healer_cc_remains = _CCremains(their_healer)
					their_healer_cc = their_healer_cc_remains > 0
					their_healer_incapacitate_dr = _incapacitateDR(their_healer)
					their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
					their_healer_disorient_dr = _disorientDR(their_healer)
					their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

					local class = select(2,UnitClass(their_healer))

					local locked,remaining,school = UnitIsLocked(their_healer)

					if locked and remaining > .25 then
						if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
						or ( class == "SHAMAN" and school == "Nature" )
						or ( class == "PALADIN" and school == "Holy" )
						or ( class == "MONK" and school == "Nature" )
						or ( class == "DRUID" and school == "Nature" )  then
							their_healer_important_lockout = true
						end
					end
				else -- no healer if he dead
					their_healer = nil
				end
			end
			
			local function their_healer_can_dispel(unit,after)
				after = after or 0
				if not UnitIsVisible(their_healer) or not UnitIsVisible(unit) then return false end
				if unit_is_unit(unit,their_healer) then return false end
				local dispels = {
					["DRUID"] = 88423,	--Nature's Cure (Druid)
					["PALADIN"] = 4987,	--Cleanse (Paladin)
					["PRIEST"] = 527,	--Purify (Priest)
					["SHAMAN"] = 77130,	--Purify Spirit (Shaman)
					["MONK"] = 115450,	--Detox (Monk)
				}
				local class = select(2,UnitClass(their_healer))
				local cd = UnitCooldown(their_healer,dispels[class])
				if cd <= after and _distance(unit,their_healer) <= 48 then
					return true
				end
			end

			local fear_range = 30
			
			--5782
			local function cc(unit,player_forced)

				if not arena and not unit_is_player(unit) and not player_forced then return 69 end

				--stop if no unit
				if not unit or not UnitIsVisible(unit) then return 69 end

				--do not sheep? (ext. func)
				-- if DoNotSheep(unit) then return 69 end

				--dist to unit
				local dist = _distance(unit)

				local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit), _buffRemains(unit,48707) )

				--this function should not only cc, but also return the time until cc needs to happen
				--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
				local time_to_cc = 0

				--check cc
				local ccr = _CCremains(unit)
				local cc = ccr > 0 
				
				--incap drs
				local idr = _incapacitateDR(unit)
				local idr_remains = _drRemains(unit,"incapacitate")

				--disorient drs
				local ddr = _disorientDR(unit)
				local ddr_remains = _drRemains(unit,"disorient")

				--banner?
				local banner = UnitBuffID(unit,236321)

				--remaining shep
				local sheep_remains = _debuffRemains(unit,118)

				--remaining fear
				local fear_remains = _debuffRemains(unit,118699)
				local feared = fear_remains > 0 

				--yea dont cc into it...unless
				if banner then return 69 end

				--incap on unit?
				local incap = _incapacitateCheck(unit)

				--healer?
				local is_healer = _isHealer(unit) 

				--lockout? (only important lockout...)
				-- local lockout = IsLocked(unit,true)
				local locked,lockout_remaining,school = UnitIsLocked(unit)

				local important_lockout_remaining = 0
				if locked and lockout_remaining > 0 then
					if ( class == "PRIEST" and school == "Shadow" )
					or ( class == "SHAMAN" and school == "Nature" )
					or ( class == "PALADIN" and school == "Holy" )
					or ( class == "MONK" and school == "Nature" )
					or ( class == "DRUID" and school == "Nature" )
					or ( class == "MAGE" and school == "Arcane" )
					or ( class == "WARLOCK" and school == "Shadowflame" ) then
						important_lockout_remaining = lockout_remaining
					end
				end

				--los?
				local los = _LoS(unit)

				--charmed friend?
				local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

				if friendly then return 69 end

				-- local feared_and_dispellable = fear_remains > 3 + fear_cast_time and their_healer_can_dispel(unit,fear_cast_time - buffer)

				--fear, if drs are available, and the unit is not immune
				local time_til_fear = 69
				local max_overlap = fear_cast_time + (buffer*2)
				if los then
					if (important_lockout_remaining <= fear_cast_time + 1 + (buffer*2.5) or UnitCastingInfo(unit)) then -- need better logic here to determine if the lockout is worth sheeping over, cause it often is.
						
						local fear_dr_ready = ddr == 1 or (ddr >= .25 and ddr_remains > 17.25 - (ccr >= fear_cast_time and 8 * ddr or 0) - (feared and ccr >= fear_cast_time-.2 and 4 * ddr or 0) - ((100-lowestEnemy) * .038) + (ddr == .25 and 1 or 0) ) or ( ddr_remains < fear_cast_time-(buffer/2) and ( ddr_remains ~= 0 or ddr == 1 ) )
						
						-- print(sheep_dr_ready, idr, idr_remains)
						-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
						local no_fears_out = not feared_target or unit_is_unit(unit,feared_target) or _disorientDR(feared_target) < .25 or (is_healer and ddr == 1) or (not _isHealer(feared_target) and _disorientDR(feared_target) <= .25 and _drRemains(feared_target,"disorient") > 3 and _drRemains(feared_target,"disorient") < 16.5)
						if fear_dr_ready and no_fears_out then
							
							if dist < fear_range and ( ccr < max_overlap or feared_and_dispellable ) then
								if immunity_remains <= fear_cast_time+(buffer*.44) then
									--alert when moving
									if _isMoving("player") then Squid_Alert("Stop Moving","(Fear)",nil,nil,5782) end
									if (not fear_cast_delay or time-fear_cast_delay > .2) and _Cast(5782,unit) then
										Squid_Alert_Big("Fearing",UnitClass(unit),nil,3,5782)
									end
									time_to_cc = 0
								end
							else
								time_to_cc = math.max(ccr,time_to_cc)
							end

							local immune_val = 0
							if immunity_remains > 0 then
								immune_val = max ( immunity_remains - fear_cast_time - (buffer * .44), 0 )
							end

							time_til_fear = dist < fear_range + 3 and math.max(ccr-max_overlap,ddr_remains < 17 and ddr_remains or 0,immune_val) or 69 -- "never" if out of range (applied to ring too)

						end
					end
				end
				
				local val = time_til_fear-- math.min(time_til_fear,time_til_poly_ready)

				return val
				
			end
			
			--designate highest prio to cc on healer (returning 69 will fall back to off dps cc)
			local function healer_cc()
				
				local healers = {}

				for i=1,#Enemies do if _isHealer(Enemies[i]) then
					local unit = Enemies[i]
					if _distance(unit) < fear_range then
						-- local friends_attacking = UnitEnemiesAttacking(unit)
						local unit_hp = _HP(unit)
						-- if friends_attacking == 0 and not only_ripped_target(unit) then 
							table.insert(healers,unit)
						-- end
					end
				end end

				local soonest = 69
				for i=1,#healers do
					local val = cc(healers[i])

					if val < soonest then
						soonest = val
					end

				end

				return soonest

			end
			
			--cc off dps while waiting for dr on healer, or to secure cc on healer while they have interrupts available
			local function off_cc()

				if only_cc_healers then return 69 end

				local units = {}

				for i=1,#Enemies do
					local e = Enemies[i]
					if unit_is_player(e) then--or (UnitIsHunterPet(e) and combustion_cd <= 2) then
						if _distance(e) < fear_range and _LoS(e) then
							-- local friends_attacking = UnitEnemiesAttacking(e)
							-- local unit_hp = _HP(e)
							-- if friends_attacking == 0 then
								-- local min_hp = 70
								-- min_hp = min_hp - (our_healer_cc and 20 or 0)
								-- min_hp = min_hp - (_CDcheck(e) and 20 or 0)
								-- min_hp = min_hp - (lowestFriend < 40 and 20 or 0)
								-- if unit_hp > min_hp then
									table.insert(units,e)
								-- end
							-- end
						end
					end
				end

				local soonest = 69
				for i=1,#units do
					local val = cc(units[i])

					if val < soonest then
						soonest = val
					end
				end

				return soonest

			end
			
			--priority cc, and define max cast time here
			local max_cast_time = 69
			max_cast_time = healer_cc()
			if max_cast_time > fear_cast_time * 2 then
				max_cast_time = min ( max_cast_time, off_cc() )
			end

			if max_cast_time < 0 then max_cast_time = 0 end
		end
		--Run
		if not IsMounted() then
			if Squid_Burst then
				_Cast(aff.darkSoulMisery)
				--Use Badge with avatar
				if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
					UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
				end
				if dots_up_t then
					_Cast(aff.summonDarkglare)
				end
			end
			if arena then
				arena_pvp()
			end
			if valid_enemies_around(t, 10) > 3 and not arena then
				aoe()
			elseif _valid(t) then
				default()
			end
		end
	end

	if spec == 2 then
		--Don't cast demonic strength while felguard is bladestorming
		--Talents Row 1
		bilescourgeBombersEnabled = IsPlayerSpell(267211)
		demonicStrengthEnabled = IsPlayerSpell(267171)
		dreadlashEnabled = IsPlayerSpell(264078)
		--Talents Row 2
		demonicCallingEnabled = IsPlayerSpell(205145)
		powerSiphonEnabled = IsPlayerSpell(264130)
		doomEnabled = IsPlayerSpell(603)
		--Talents Row 3
		burningRushEnabled = IsPlayerSpell(111400)
		darkPactEnabled = IsPlayerSpell(108416)
		demonSkinEnabled = IsPlayerSpell(219272)
		--Talents Row 4
		fromTheShadowsEnabled = IsPlayerSpell(267170)
		soulStrikeEnabled = IsPlayerSpell(264057)
		summonVileFiendEnabled = IsPlayerSpell(264119)
		---Talents Row 5
		darkFuryEnabled = IsPlayerSpell(264874)
		mortalCoilEnabled = IsPlayerSpell(6789)
		howlOfTerrorEnabled = IsPlayerSpell(5484)
		--Talents Row 6
		soulConduitEnabled = IsPlayerSpell(215941)
		innerDemonsEnabled = IsPlayerSpell(267216)
		grimoireFelguardEnabled = IsPlayerSpell(111898)
		--Talents Row 7
		sacrificedSoulsEnabled = IsPlayerSpell(267214)
		demonicConsumptionEnabled = IsPlayerSpell(267215)
		netherPortalEnabled = IsPlayerSpell(267217)

		--Player Stuff
		demonic_tyrant_cd = _spellCooldown(demo.summonDemonicTyrant)
		--variable,name=tyrant_ready,value=0
		local tyrant_ready = 0

		local function minion_count(id)
			local count = 0
			--55659 Wild Imp Object ID
			--98035 Dread Stalker Object ID
			--135002 Tyrant Object ID
			--135816 Vile Fiend Object ID
			--17252 Grimoire Felguard Object ID
			for i = 1, #Squid_OM do
				if ObjectID(Squid_OM[i]) == id then
					count = count + 1
				end
			end
			return count
		end
		local function minion_time_left(name)
			local haveTotem, totemName, startTime, duration, icon
			for index = 1, MAX_TOTEMS do
				haveTotem, totemName, startTime, duration, icon = GetTotemInfo(index)
				if totemName == name then
					return startTime + duration - GetTime()
				end
			end
		end

		vileFiendRemains = minion_time_left('Vilefiend') or 0
		gimoireFelguardRemains = minion_time_left('Felguard') or 0

		local function use_items()
			if tContains( equipped_items, 173069 ) and GetItemCD ( ( 173069 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 173069 ) ) )
				Squid_Alert( "Darkmoon Deck: Voracity" )
            end   
		end

		local function precombat()
			--actions.precombat=flask
			--actions.precombat+=/food
			--actions.precombat+=/augmentation
			--actions.precombat+=/summon_pet
			--actions.precombat+=/inner_demons,if=talent.inner_demons.enabled
			--actions.precombat+=/snapshot_stats
			--actions.precombat+=/demonbolt
			--actions.precombat+=/variable,name=tyrant_ready,value=0
		end

		local function covenant()
			--actions.covenant=impending_catastrophe,if=!talent.sacrificed_souls.enabled|active_enemies>1
			if covenantID == covenants.ids.venthyr and _spellCooldown(covenants.venthyr.impendingCatastrophe) <= gcd_remains and not sacrificedSoulsEnabled or valid_enemies_around(t, 10) > 1 then
				_Cast(covenants.venthyr.impendingCatastrophe, t, true)
			end
			--actions.covenant+=/scouring_tithe,if=talent.sacrificed_souls.enabled&active_enemies=1
			if covenantID == covenants.ids.kyrian and _spellCooldown(covenants.kyrian.scouringTithe) <= gcd_remains and sacrificedSoulsEnabled and valid_enemies_around(t, 10) == 1 then
				_Cast(covenants.kyrian.scouringTithe, t, true)
			end
			--actions.covenant+=/scouring_tithe,if=!talent.sacrificed_souls.enabled&active_enemies<4
			if covenantID == covenants.ids.kyrian and _spellCooldown(covenants.kyrian.scouringTithe) <= gcd_remains and not sacrificedSoulsEnabled and valid_enemies_around(t, 10) < 4 then
				_Cast(covenants.kyrian.scouringTithe, t, true)
			end
			--actions.covenant+=/soul_rot
			if covenantID == covenants.ids.nightFae and _spellCooldown(covenants.nightFae.soulRot) <= gcd_remains and auto_cds then
				_Cast(covenants.nightFae.soulRot, t, true)
			end
			--actions.covenant+=/decimating_bolt
			if covenantID == covenants.ids.necroLord and _spellCooldown(covenants.necroLord.decimatingBolt) <= gcd_remains then
				_Cast(covenants.necroLord.decimatingBolt, t, true)
			end
		end
		
		local function off_gcd()
			if auto_cds then
			--actions.off_gcd+=/potion,if=buff.berserking.up|pet.demonic_tyrant.active&!race.troll
			--actions.off_gcd+=/fireblood,if=pet.demonic_tyrant.active
			--actions.off_gcd+=/blood_fury
				if race == 'Orc' and _spellCooldown(racials.bloodFury) == 0 then
					--print('return [DGP] - Racial - Should Stop')
					_Cast(racials.bloodFury)
				end
				--actions.off_gcd+=/berserking
				if race == 'Troll' and _spellCooldown(racials.berserking) == 0 then
					_Cast(racials.berserking)
				end
			end
		end

		local function summon_tyrant()
			--actions.summon_tyrant=hand_of_guldan,if=soul_shard=5,line_cd=20
			if shards == 5 and not SpellRecentlyUsed(demo.handOfGuldan, 20) then
				_Cast(demo.handOfGuldan, t, true)
			end
			--actions.summon_tyrant+=/demonbolt,if=buff.demonic_core.up&(talent.demonic_consumption.enabled|buff.nether_portal.down),line_cd=20
			if UnitBuffID('player', demo.buffs.demonicCore) and (demonicConsumptionEnabled or _buffRemains('player', demo.buffs.netherPortal) == 0) and not SpellRecentlyUsed(demo.demonBolt, 20) then
				_Cast(demo.demonBolt, t, true)
			end
			--actions.summon_tyrant+=/shadow_bolt,if=buff.wild_imps.stack+incoming_imps<4&(talent.demonic_consumption.enabled|buff.nether_portal.down),line_cd=20
			if minion_count(55659) < 4 and (demonicConsumptionEnabled or _buffRemains('player', demo.buffs.netherPortal) == 0) and not SpellRecentlyUsed(warlock.shadowBolt, 20) then
				_Cast(warlock.shadowBolt, t, true)
			end
			--actions.summon_tyrant+=/call_dreadstalkers
			if (shards >= 2 or UnitBuffID('player', demo.buffs.demonicCalling)) and _spellCooldown(demo.callDreadStalkers) <= gcd_remains then
				_Cast(demo.callDreadStalkers, t, true)
			end
			--actions.summon_tyrant+=/hand_of_guldan
			if shards >= 3 then
				_Cast(demo.handOfGuldan, t, true)
			end
			--actions.summon_tyrant+=/demonbolt,if=buff.demonic_core.up&buff.nether_portal.up&((buff.vilefiend.remains>5|!talent.summon_vilefiend.enabled)&(buff.grimoire_felguard.remains>5|buff.grimoire_felguard.down))
			if UnitBuffID('player', demo.buffs.demonicCore) and UnitBuffID('player', demo.buffs.netherPortal) and ( (vileFiendRemains > 5 or not summonVileFiendEnabled) and (gimoireFelguardRemains > 5 or gimoireFelguardRemains <= 0)) then
				_Cast(demo.demonBolt, t, true)
			end
			--actions.summon_tyrant+=/shadow_bolt,if=buff.nether_portal.up&((buff.vilefiend.remains>5|!talent.summon_vilefiend.enabled)&(buff.grimoire_felguard.remains>5|buff.grimoire_felguard.down))
			if UnitBuffID('player', demo.buffs.netherPortal) and ((vileFiendRemains > 5 or not summonVileFiendEnabled) and (gimoireFelguardRemains > 5 or gimoireFelguardRemains <= 0)) then
				_Cast(warlock.shadowBolt, t, true)
			end
			--actions.summon_tyrant+=/variable,name=tyrant_ready,value=!cooldown.summon_demonic_tyrant.ready
			tyrant_ready = (demonic_tyrant_cd ~= 0 and 1 or 0)
			--actions.summon_tyrant+=/summon_demonic_tyrant
			if demonic_tyrant_cd <= gcd_remains and auto_cds then
				_Cast(demo.summonDemonicTyrant)
			end
			--actions.summon_tyrant+=/shadow_bolt
			if shards ~= 5 then
				_Cast(warlock.shadowBolt, t, true)
			end
		end

		local function tyrant_prep()
			--actions.tyrant_prep=doom,line_cd=30
			if doomEnabled and not UnitDebuffID(t, demo.debuffs.doom, 'player') and not SpellRecentlyUsed(demo.doom, 30) then
				_Cast(demo.doom, t, true)
			end
			--actions.tyrant_prep+=/demonic_strength,if=!talent.demonic_consumption.enabled
			if not demonicConsumptionEnabled and _spellCooldown(demo.demonicStrength) <= gcd_remains then
				_Cast(demo.demonicStrength, t, true)
			end
			--actions.tyrant_prep+=/nether_portal
			if netherPortalEnabled and _spellCooldown(demo.netherPortal) <= gcd_remains and shards >= 1 then
				_Cast(demo.netherPortal)
			end
			--actions.tyrant_prep+=/grimoire_felguard
			if grimoireFelguardEnabled and _spellCooldown(demo.grimoireFelguard) <= gcd_remains and shards >= 1 and auto_cds then
				_Cast(demo.grimoireFelguard, t, true)
			end
			--actions.tyrant_prep+=/summon_vilefiend
			if summonVileFiendEnabled and _spellCooldown(demo.summonVilefiend) <= gcd_remains and shards >= 1 then
				_Cast(demo.summonVilefiend)
			end
			--actions.tyrant_prep+=/call_dreadstalkers
			if _spellCooldown(demo.callDreadStalkers) <= gcd_remains and (shards >= 2 or UnitBuffID('player', demo.buffs.demonicCalling)) then
				_Cast(demo.callDreadStalkers, t, false)
			end
			--actions.tyrant_prep+=/demonbolt,if=buff.demonic_core.up&soul_shard<4&(talent.demonic_consumption.enabled|buff.nether_portal.down)
			if UnitBuffID('player', demo.buffs.demonicCore) and shards < 4 and (demonicConsumptionEnabled or _buffRemains('player', demo.buffs.netherPortal) == 0) then
				_Cast(demo.demonBolt, t, true)
			end
			--actions.tyrant_prep+=/shadow_bolt,if=soul_shard<5-4*buff.nether_portal.up
			if shards < 5 - 4 * (UnitBuffID('player', demo.buffs.netherPortal) and 1 or 0) then
				_Cast(demo.shadowBolt, t, true)
			end
			--actions.tyrant_prep+=/variable,name=tyrant_ready,value=1
			tyrant_ready = 1
			--actions.tyrant_prep+=/hand_of_guldan
			if shards >= 3 then
				_Cast(demo.handOfGuldan, t, true)
			end
		end

		local function actor()
			--# Executed every time the actor is available.
			--actions=call_action_list,name=off_gcd
			off_gcd()
			--actions+=/run_action_list,name=tyrant_prep,if=cooldown.summon_demonic_tyrant.remains<4&!variable.tyrant_ready
			if demonic_tyrant_cd < 4 and tyrant_ready then
				tyrant_prep()
			end
			--actions+=/run_action_list,name=summon_tyrant,if=variable.tyrant_ready
			if tyrant_ready then
				summon_tyrant()
			end
			--actions+=/summon_vilefiend,if=cooldown.summon_demonic_tyrant.remains>40|time_to_die<cooldown.summon_demonic_tyrant.remains+25
			if demonic_tyrant_cd > 40 or t_ttd < demonic_tyrant_cd + 25 and shards >= 1 then
				_Cast(demo.summonVilefiend, t, true)
			end
			--actions+=/call_dreadstalkers
			if (shards >= 2 or UnitBuffID('player', demo.buffs.demonicCalling)) and _spellCooldown(demo.callDreadStalkers) <= gcd_remains then
				_Cast(demo.callDreadStalkers, t, true)
			end
			--actions+=/doom,if=refreshable
			if doomEnabled and _debuffRemains(t, demo.debuffs.doom, 'player') == 0 then
				_Cast(demo.doom, t, true)
			end
			--actions+=/demonic_strength
			if demonicStrengthEnabled and _spellCooldown(demo.demonicStrength) <= gcd_remains then
				_Cast(demo.demonicStrength, t, true)
			end
			--actions+=/bilescourge_bombers
			if bilescourgeBombersEnabled and _spellCooldown(demo.bilescourgeBombers) <= gcd_remains and shards >= 2 then
				_Cast(demo.bilescourgeBombers, t, true)
			end
			--actions+=/implosion,if=active_enemies>1&!talent.sacrificed_souls.enabled&buff.wild_imps.stack>=8&buff.tyrant.down&cooldown.summon_demonic_tyrant.remains>5
			if valid_enemies_around(t, 8) > 1 and not sacrificedSoulsEnabled and minion_count(55659) >= 3 and _buffRemains('player', demo.buffs.demonicPower) == 0 and _spellCooldown(demo.summonDemonicTyrant) > 5 then
				_Cast(demo.implosion, t, false)
			end 
			--actions+=/implosion,if=active_enemies>2&buff.wild_imps.stack>=8&buff.tyrant.down
			if valid_enemies_around(t, 8) > 2 and minion_count(55659) >= 3 and _buffRemains('player', demo.buffs.demonicPower) == 0 then
				_Cast(demo.implosion, t, false)
			end
			--actions+=/hand_of_guldan,if=soul_shard=5|buff.nether_portal.up
			if shards == 5 or UnitBuffID('player', demo.buffs.netherPortal) and shards >= 1 then
				_Cast(demo.handOfGuldan, t, true)
			end
			--actions+=/hand_of_guldan,if=soul_shard>=3&cooldown.summon_demonic_tyrant.remains>20&(cooldown.summon_vilefiend.remains>5|!talent.summon_vilefiend.enabled)&cooldown.call_dreadstalkers.remains>2
			if shards >= 3 and _spellCooldown(demo.summonDemonicTyrant) > 20 and (_spellCooldown(demo.summonVilefiend) > 5 or not summonVileFiendEnabled) and _spellCooldown(demo.callDreadStalkers) > 2 then
				_Cast(demo.handOfGuldan, t, true)
			end
			--actions+=/call_action_list,name=covenant,if=(covenant.necrolord|covenant.night_fae)&!talent.nether_portal.enabled
			if covenant() then return true end
			--actions+=/demonbolt,if=buff.demonic_core.react&soul_shard<4
			if UnitBuffID('player', demo.buffs.demonicCore) and shards < 4 then
				_Cast(demo.demonBolt, t, true)
			end
			--actions+=/grimoire_felguard,if=cooldown.summon_demonic_tyrant.remains+cooldown.summon_demonic_tyrant.duration>time_to_die|time_to_die<cooldown.summon_demonic_tyrant.remains+15
			if demonic_tyrant_cd + 90 > t_ttd or t_ttd < demonic_tyrant_cd + 15 and shards >= 1 then
				_Cast(demo.grimoireFelguard)
			end
			--actions+=/use_items
			if use_items() then return true end
			--actions+=/power_siphon,if=buff.wild_imps.stack>1&buff.demonic_core.stack<3
			if powerSiphonEnabled and _spellCooldown(demo.powerSiphon) <= gcd_remains and minion_count(55659) > 1 and _buffStacks('player', demo.buffs.demonicCore) < 3 then
				_Cast(demo.powerSiphon, t, true)
			end
			--actions+=/soul_strike
			if soulStrikeEnabled and _spellCooldown(demo.soulStrike) <= gcd_remains then
				_Cast(demo.soulStrike, t, true)
			end
			--actions+=/call_action_list,name=covenant
			if covenant() then return true end
			--actions+=/shadow_bolt
			if shards ~= 5 then
				if _Cast(warlock.shadowBolt, t, true) then return true end
			end
		end
		if _valid(t) then
			if actor() then return true end
		end
	end

	--destruction
	if spec == 3 then
		--get felhunter if no pet

		-- pool shards when infernals nearly ready, pool to 4 when playing vision
		-- go for cata / maintain immo if not capped on shards
		-- pool 1 conflag charge

		-- stop casting bolt into immune targets
		-- delay on casting same ability twice

		-- add infernal key
		-- add auto cc
		-- add double coil key
		-- prioritzie bolts over immolates when important

		--maybe the best way to perform the rotation is 
		--calculating how much damage we can do in a 'go' then just 
		--unleashing the dick + committing to the best target in LoS
		-- ++ use shadowfury / conflag root to keep this target in LoS -- - - - - - -- 

		--maybe shadowfuries like cata works (if it even works lol)

		--havoc coils (check both targets are LoS before sending it)
		-- get 4x backdraft with conflag during havoc

		--dark soul before infernal good to have gcd avail

		--fear enemy that can kick you before doing a go. better to get kicked on fear.
		--after u cant fear dps with kick any more (or u have a shit ton of pressure / no shards) then fear heals

		--banish pets

		--auto infernal 3 targets when shards + shadowfury are available?z

		local time = GetTime()
		local latency = select(4,GetNetStats())/1000
		local msperframe = (2/GetFramerate())
		local buffer = latency + msperframe + .1
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		local hp = _HP("player")
		local mana = (100 * UnitPower("player") / UnitPowerMax("player"));
		local shards = UnitPower("player",7)
		local groupsize = GetNumGroupMembers()

		local immolate_cast_time = _castTime(destro.immolate)

		if infernal_key then
			RunMacroText("/cast [@cursor] summon infernal")
		end
		if cataclysm_key then
			RunMacroText("/cast [@cursor] cataclysm")
		end

		-- get pet
		if not UnitExists("pet") or UnitIsDeadOrGhost("pet") then
			CastSpellByID(691)
		end

		--buffs & debuffs
		local backdraft = UnitBuff("player",117828)
		local backdraft_stacks = _buffStacks("player",117828)
		local backdraft_remains = _buffRemains("player",117828)

		local dark_soul = UnitBuffID("player",113858)
		local dark_soul_remains = _buffRemains("player",113858)

		--maintain demon armor
		local demon_armor = UnitBuffID("player",285933)
		if not demon_armor and IsPlayerSpell(285933) then
			_Cast(285933)
		end

		local supremacy_stacks = _buffStacks("player",266091)
		local supremacy_effect = supremacy_stacks * 8

		local conflag_charges = GetSpellCharges(17962)

		--chaotic inferno = instant incinerate azerite trait proc on bolt cast
		local chaotic_inferno = UnitBuffID("player",279673)

		--remaining infernal "x s"
		local infernals_remain = 0
		for i=1,4 do
			local totem = _G["TotemFrameTotem"..i]
			if totem:IsShown() then
				local duration_text = totem.duration:GetText()
				duration_text = duration_text:gsub(" s", "")
				local duration = tonumber(duration_text)
				if duration > infernals_remain then
					infernals_remain = duration
				end
			end
		end
		local infernals_up = infernals_remain > 0

		--CATACLYSM SPITBALLING--
		--[[ Once cata is available and two players are within 8 yards of eachother, determine the center point between them, 
		then determine whether or not they will both still be within the radius of that center point after the cast time of cataclysm 
		(based on moving speed & direction, we already created this dynamic prediction with mage) --]]

		local valid_magic = _valid(t,2)

		local function cataclysm()
			if valid_magic and _spellCooldown(152108) <= gcd then

				local cata_targets = {}

				for i=1,#Enemies do if not unit_is_unit(Enemies[i],t) then
					local e = Enemies[i]
					if _distance(e,t) < 15 then
						table.insert(cata_targets,e)
					end
				end end

				table.insert(cata_targets,t)

				--point between all units here
				if #cata_targets >= 2 then
					local x,y,z = point_between_units(cata_targets)

					--determine whether each target will be within cata radius after cast time, otherwise eliminate them from the table
					--note: considering the way our movement prediction works, it may be best to reduce the time of prediction here,
					--maybe even increase the distance check from the centerpoint, which may 'reduce accuracy', but result in more casts.
					local prediction_time = _castTime(152108) / 3.25

					if not x or not y or not z then squid_print("Warlock: Couldn't determine position between units for cataclysm.") return false end

					for i=1,#cata_targets do
						local t = cata_targets[i]
						local tx,ty,tz = PredictUnitPosition(t,prediction_time)
						if GetDistanceBetweenPositions(tx,ty,tz,x,y,z) > 6.5 then table.remove(cata_targets,i) end
					end

					if #cata_targets >= 2 then
						_AeCastPosition(152108,x,y,z,40)
					end

				end

			end
		end

		cataclysm()

		local load_mode = lowestEnemy < 60

		--reflect
		-- if IsPlayerSpell(216890) then
		-- 	local reflect = _shouldReflect()
		-- 	if reflect then
		-- 		if _Cast(216890) then
		-- 			Squid_Alert("Reflect","("..reflect..")",2)
		-- 		end
		-- 	end
		-- end

		--maintain immolate prio
		if not infernals_up and shards <= 4 - (infernals_up and 2 or 0) then
			for i=1,#Pets do
				local e = Pets[i]
				if (UnitIsPet(e) or unit_is_player(e) or _isDummy(e)) and _debuffRemains(e,157736,"player") < 6 and magic_immunity_remains(e) < immolate_cast_time then
					_Cast(348,e,true)
				end
			end
		end

		if valid_magic then
			--priority bolts
			if shards >= 3 or infernals_up or _spellCooldown(1122) > 10 or load_mode then
				--conflag
				-- if (conflag_charges == 2 or shards <= 2) and shards <= 4 then
				-- 	_Cast(17962,t,nil,true)
				-- end
				_Cast(116858,t,true)
			end
		end

		--maintain immolate
		for i=1,#Pets do
			local e = Pets[i]
			if (UnitIsPet(e) or unit_is_player(e) or _isDummy(e)) and _debuffRemains(e,157736,"player") < 6 and magic_immunity_remains(e) < immolate_cast_time then
				_Cast(348,e,true)
			end
		end

		if valid_magic then
			if shards >= 4 then
				_Cast(116858,t,true)
			end
			--conflag
			if (conflag_charges > 1 or inferals_up or shards >= 4) and (shards >= 2 or chaotic_inferno) then
				_Cast(17962,t,nil,true)
			end
			--incinerate
			if chaotic_inferno or shards < 2 or _spellCooldown(116858) >= 1.5 then
				_Cast(29722,t,true)
			end
		end

	end




endfunction Squid_Priest()

    if IsAoEPending() or IsMounted() or IsFlying() or UnitBuffID("player",199483) then return true end

    --General
    local time = GetTime()
    local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
    local gcd_remains = GetGCD()
    local gcdMax = 1.5
    local moving = _isMoving("player")
    local totalHaste = UnitSpellHaste("player") / 100
    local latency = select(4,GetNetStats())/1000
    local inCombat = UnitAffectingCombat("player")
	local groupCheck = select(2, IsInInstance())
	local spec = GetSpecialization()
	local groupsize = GetNumGroupMembers()
	local tinsert = table.insert
	if groupsize == 0 then groupsize = 1 end

	local function healing_immune(unit)
		return UnitDebuffID(unit,33786)
		or UnitDebuffID(unit,221527)
		or UnitDebuffID(unit,217832)
		or UnitCanAttack("player",unit)
	end

    --Target Checks
    local function _valid(unit) 
        if UnitExists(unit) 
        and UnitCanAttack("player",unit) 
        and not UnitIsDeadOrGhost(unit) 
        and not _breakableCC(unit)
        and not _immuneMagic(unit)
        and (arena or UnitAffectingCombat(unit) or UnitName(unit) == "Training Dummy" or UnitIsPlayer(unit)) then
        	return true 
        end
    end

    --Target
    local t = current_target
    local focus = current_focus

    if UnitLevel("player") < 30 then
    	no_combat_debug = true
    	if _HP("player") < 60 and not UnitDebuffID("player",6788) then
    		_Cast(17,"player")
    	end
    	if _HP("player") < 30 then
    		_Cast(2061,"player")
    	end
    	for i=1,#Enemies do if _debuffRemains(Enemies[i],589,"player") < 4 then
    		_Cast(589,Enemies[i])
    	end end
    	for i=1,#Enemies do 
    		_Cast(589,Enemies[i])
    	end
    	return
    end

    ----------------
    -- Discipline ---
    ----------------
	if spec == 1 then

		--talents
		local schism_enabled = IsPlayerSpell(214621)
		local twist_of_fate_enabled = IsPlayerSpell(265259)
		local angelic_feather_enabled = IsPlayerSpell(121536)
		local body_and_soul_enabled = IsPlayerSpell(64129)
		local solace_enabled = IsPlayerSpell(129250)
		local shining_force_enabled = IsPlayerSpell(204263)
		local masochism_enabled = IsPlayerSpell(193063)

		--pvp talents
		local dark_archangel_enabled = IsPlayerSpell(197871)
		local ultimate_radiance_enabled = IsPlayerSpell(236499)
		local trinity_enabled = IsPlayerSpell(214205)
		local searing_light_enabled = IsPlayerSpell(215768)
		local premonition_enabled = IsPlayerSpell(305498)

		--buffs
		local rapture_remains = _buffRemains("player",47536)
		local rapture_up = rapture_remains > 0
		local power_of_the_dark_side_remains = _buffRemains("player",198069)
		local potds_remains = power_of_the_dark_side_remains
		local power_of_the_dark_side = potds_remains > 0
		local potds = power_of_the_dark_side
		local preparation = UnitBuffID("player",32727)
		local masochism_remains = _buffRemains("player",193065)

		--cds
		local purify_cd = _spellCooldown(527)
		local md_cd = _spellCooldown(32375) 
		local shadow_cd = _spellCooldown(605)
		local holy_cd = _spellCooldown(585)

		--cast times
		local md_cast_time = _castTime(32375) 

		--stats, healing spell effects
		local mana = (100 * UnitPower("player") / UnitPowerMax("player"));
		local intellect = UnitStat("player",4)		--pws effect rapture mod
		local pws_effect = (intellect * 1.6282) * (rapture and 3 or 1)
		local sm_effect = intellect * 2.6645

		local holy_locked = _spellCooldown(585) > gcd_remains

		local fr_cast

		local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
		local player_cast_target = UnitSpellTarget("player")
		local player_cast_time_left = _castTimeLeft("player")
		local player_cast_percent_complete = _castPctDone("player")

		--smite, schism
		local facing_required_casts = {585,214621}
		local active_dmg_casts = {585,214621,47540}

		if tContains(facing_required_casts,player_cast_id) then
			fr_cast = true
		end

		--face dest at end of cast
		if player_cast and fr_cast then
			if player_cast_time_left <= latency+.235 then
				local dest = UnitSpellTarget("player")
				--no forced facing if we're already facing
				if dest then
					FaceDirection(GetAnglesBetweenObjects("player",dest),true)
				end
			end
		end

		if player_cast and tContains(active_dmg_casts,player_cast_id) then
			local dest = UnitSpellTarget("player")
			if dest and _breakableCC(dest) then
				Squid_Alert("Stop casting dmg","(Breakable CC)",nil,nil,player_cast_id)
				SpellStopCasting()
			end
		end

		--hpdeficit
		--returns, hp missing from unit
		local function hp_deficit(unit)
			return UnitHealthMax(unit) - UnitHealth(unit)
		end

		--atonement
		--returns, up, whether atonement is up on the unit or not
		--returns, remains, how long atonement remains on the unit
		local function atonement(unit)
			local remains = _buffRemains(unit,194384,"player") 
			return remains > 0 , remains
		end

		--pws
		--returns, up, whether pws is up on the unit or not
		--returns, remains, how long pws remains on the unit
		--returns, absorb, the amount of shield remaining on unit
		local function pws(unit)
			local buff,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID(unit,17,"player")
			local remains = _buffRemains(unit,17,"player")
			return buff, remains, absorb or 0
		end

		--purge the wicked
		--returns, up, whether or not purge the wicked is up or not
		--returns, remains, how long purge the wicked remains on the unit
		local function purge_the_wicked(unit)
			local remains = _debuffRemains(unit,204213,"player")
			return remains > 0 , remains
		end

		--weakened soul
		--returns, up, whether or not the unit has weakened soul
		local function weakened_soul(unit)
			return UnitDebuffID(unit,6788,"player")
		end

		--enemies sorted
		local p_enemies = {}
		local ptw_enemies = {}
		for i=1,#Pets do
			local e = Pets[i]
			if not _breakableCC(e) 
			and not _immuneMagic(e)
			and (UnitIsPlayer(e) or UnitIsPet(e) or _isDummy(e)) then

				local priority = 0

				--general
				priority = priority + (unit_is_unit(e,"target") and 1 or 0)
				priority = priority + (UnitIsPlayer(e) and 1 or 0)
				table.insert(p_enemies,{pointer = e, priority = priority, hp = _HP(e)})

				--ptw
				local up,remains = purge_the_wicked(e)
				priority = priority + (20 - remains)
				table.insert(ptw_enemies,{pointer = e, priority = priority, hp = _HP(e)})

			end
		end
		table.sort(p_enemies,function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)
		table.sort(ptw_enemies,function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)
		
		--friends sorted
		local p_friends = {}
		for i=1,#Friends do if UnitIsPlayer(Friends[i]) then
			local e = Friends[i]
			local hp = _HP(e)
			local prio = 0
			local ea = EnemiesAttacking(Friends[i])

			if hp < 50 then
				prio = hp
			else
				prio = 100 - ea
			end

			--general
			table.insert(p_friends,{pointer = e, prio = prio, hp = hp})
		end end
		table.sort(p_friends,function(x,y) return x.prio < y.prio end)

		local their_healer = theirHealer
		local their_healer_cc_remains = 0
		local their_healer_cc
		if their_healer then
			their_healer_cc_remains = _CCremains(their_healer)
			their_healer_cc = their_healer_cc_remains > 0
		elseif not arena then
			their_healer_cc = true
			their_healer_cc_remains = 3
		end

		--deaths
		if premonition_enabled then
			local death = should_death()
			if death == "wait" then
				Squid_Alert("Holding GCD for Prem",nil,nil,nil,305498)
				return 
			elseif death then
				local spell = GetSpellInfo(death)
				SpellStopCasting()
				SpellStopCasting()
				if _Cast(305498) then
					Squid_Alert_Big("Premonition","("..spell..")",1,3.5,305498)
				end
			end
		end

		--purge mc
		for i=1,#Friends do
			if UnitDebuffID(Friends[i],605) then
				if _Cast(528,Friends[i]) then
					Squid_Alert_Big("Purge","(Mind Control)",1,3.5,528)
					return
				end
			end
		end

		--dispels
		for i=1,#Friends do 
			local f = Friends[i]
			local purify = should_purify(f)
			if purify and _Cast(527,f) then
				Squid_Alert_Big("Dispel " .. UnitClass(f),"("..GetSpellInfo(purify)..")",nil,nil,527)
			end
		end

		--mass dispel enemies
		for i=1,#Enemies do
			local e = Enemies[i]
			if should_md(e) then
				if md_cd <= gcd and mana > 20 then
					if _AeCast(32375,e,30,28) then
						if _isMoving("player") then 
							Squid_Alert_Big("Stop Moving","(Mass Dispel)",2,3,32375)
						else
							Squid_Alert("Mass Dispel " .. UnitClass(e),nil,nil,nil,32375)
						end
						return
					end
				end
			end
		end

		--mc gpy
		for i=1,#Enemies do if UnitCastingInfo(Enemies[i]) == "Greater Pyroblast" then
			if _castTimeLeft(Enemies[i]) > _castTime(605) + .5 then
				if _isMoving("player") then
					Squid_Alert_Big("Stop Moving","(Mind Control)",2,3,605)
				else
					if _Cast(605,Enemies[i],true) then
						Squid_Alert_Big("Mind Control","(Greater Pyroblast)",2,3,605)
					end
				end
			end
		end end

		--mass dispel friends
		if purify_cd > gcd_remains + md_cast_time then
			for i=1,#Friends do
				local f = Friends[i]
				local purify = should_purify(f)
				if purify then
					if md_cd <= gcd_remains and _CCremains(f) > md_cast_time+2 and mana > 20 then
						if _AeCast(32375,f,30,28) then
							if _isMoving("player") then 
								Squid_Alert_Big("Stop Moving","(Mass Dispel)",2,3,32375) 
							else
								Squid_Alert("Mass Dispel " .. UnitClass(f),"("..purify..")",nil,nil,32375)
							end
							return
						end
					end
				end
			end
		end

		--purge
		for i=1,#Enemies do 
			local e = Enemies[i]
			local d = dispel_magic(e)
			if d and _Cast(528,e) then
				Squid_Alert("Purge","("..GetSpellInfo(d)..")",nil,nil,528)
			end
		end

		--atonements out
		local atonements_out = 0
		for i=1,#Friends do if atonement(Friends[i]) then
			atonements_out = atonements_out + 1
		end end

		--group cds with atonement 
		local group_cds_atoned = 0
		for i=1,#Friends do if atonement(Friends[i]) and _CDcheck(Friends[i]) then
			group_cds_atoned = group_cds_atoned + 1
		end end

		--purge the wickeds out
		local ptw_out = 0
		for i=1,#Pets do if purge_the_wicked(Pets[i]) then
			ptw_out = ptw_out + 1
		end end

		--dark arch
		if UnitAffectingCombat("player") then
			if their_healer_cc or group_cds_atoned > 0 or lowestEnemy < 70 then
				if atonements_out == groupsize or group_cds_atoned > 0 then
					if _Cast(197871) then Squid_Alert_Big("Dark Archangel",nil,nil,nil,197871) end
				end
			end
		end

		--totem stomp
		local function Stomp(totem,name)
			local hp = UnitHealth(totem)
			local maxhp = UnitHealthMax(totem)
			if hp <= 1 then return false; end
			--ptw
			if hp <= 2000 then
				if _Cast(204197,totem,nil,true) then
					Squid_Alert_Big(name .. " Stomped","(PTW)",1,4,5221)
					return
				end
			end
		end

		local totems = {
		101398,	--Psyfiend
		119052,	--War Banner
		104818,	--Ancestral Protection Totem
		53006,	--Spirit Link Totem
		2630,	--Earthbind Totem
		60561,	--Earthgrab Totem
		-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
		5925,	--Grounding Totem
		105425,	--Skyfury Totem
		5913,	--Tremor Totem
		105451,	--Counterstrike Totem
		}

		if arena then
			for i=1,#Pets do
				local e = Pets[i]
				local name = UnitName(e);
				local id = UnitCreatureID(e)
				--only kill cap totems when they're casting
				if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
					Stomp(e,name)
				end
			end
		end

		--ultimate radiance pw:radiance
		if ultimate_radiance_enabled then
			if _spellCooldown(194509) <= gcd_remains then
				if lowestFriend < 55 and _distance(lowestFriendName) < 40 and _LoS(lowestFriendName) then
					if _Cast(194509) then return end
				end
			end
		end

		--with trinity, maintain atonement on all party members
		if not preparation and (trinity and groupsize >= 3 or _spellCooldown(197871) < 3) then
			for i=1,#Friends do if not weakened_soul(Friends[i]) and not healing_immune(Friends[i]) then
				local f = Friends[i]
				local up,remains = atonement(f)
				if remains < gcd*groupsize then
					if _Cast(17,f) then return end
				end
			end end
		end


		--crucible (essence)
		-- if IsPlayerSpell(295373) then
			for i=1,#p_enemies do
				local e = p_enemies[i].pointer
				if not schism_enabled or UnitDebuffID(e,214621,"player") or _buffStacks("player",295378) == 0 or _HP(e) < 20 then
					if _Cast(295373,e) then return end
				end
			end
		-- end

		--pws
		if rapture_up then
			for i=1,#p_friends do
				local f = p_friends[i].pointer
				local up,remains,absorb = pws(f)
				if (not weakened_soul(f) or rapture_up) and _HP(f) < 80 and not healing_immune(f) then
					if not up or absorb < 4000 or not atonement(f) then
						if _Cast(17,f) then return end
					end
				end
			end
		end

		--enemy mage or hunter
		local mendComp
		if arena then
		    for i=1,GetNumArenaOpponents() do 
		    	if UnitIsPlayer("arena"..i) then
		    		local class = select(2,UnitClass("arena"..i))
		    		if class == "MAGE" or class == "HUNTER" or class == "ROGUE" or class == "DEMONHUNTER" or class == "DEATHKNIGHT" then
		   	 			mendComp=true
		   	 		end
		   	 	end
			end
		end

		if GetNumGroupMembers() == 3 then
			--shadow mend priority
			local mendhp = 50
			for i=1,#Enemies do if _CDcheck(Enemies[i]) then
				mendhp = mendhp + 30
			end end
			mendhp = mendhp + (mendComp and 25 or 0)
			if mendhp > 92 then mendhp = 92 end

			--shadow mend
			for i=1,#p_friends do
				local f = p_friends[i].pointer
				if _HP(f) < mendhp or holy_locked then
					if _Cast(2061,f) then return end
				end
			end
		end

		--penance to spread ptw
		for i=1,#p_enemies do
			local e = p_enemies[i].pointer
			local up,remains = purge_the_wicked(e)
			if up and Enemies_Around_Unit(e,8) > 0 then
				if _Cast(47540,e,nil,true) then return end
			end
		end

		--pws
		if not preparation then
			for i=1,#p_friends do
				local f = p_friends[i].pointer
				local up,remains,absorb = pws(f)
				if (not weakened_soul(f) or rapture_up) and _HP(f) < 85 and not healing_immune(f) then
					if not atonement(f) or (_HP(f) < 80 and EnemiesAttacking(f) > 0 and absorb < pws_effect / 3) then
						if _Cast(17,f) then return end
					end
				end
			end
		end

		--shadowfiend
		if (their_healer_cc or lowestEnemy < 70 or not arena) and _spellCooldown(34433) <= gcd_remains then
			for i=1,#p_enemies do
				local e = p_enemies[i].pointer
				if UnitEnemiesAttacking(e) > 0 then
					if _Cast(34433,e) then Squid_Alert("Shadowfiend",nil,nil,nil,34433) return end
				end
			end
		end

		--118699

		--schism prio
		if _valid(t) and _spellChargeFrac(295373) >= .88 then
			if _Cast(214621,t,true) then Squid_Alert("Schism",nil,nil,nil,214621) return end
		end

		--masochism shadow mends
		if masochism_enabled and _spellCooldown(605) <= gcd_remains then
			if _HP("player") < 65 or masochism_remains < 3 then
				if EnemiesAttacking("player") > 0 or _HP("player") < 45 then
					if _Cast(2061,"player") then return end
				end
			end
		end	

		--solace on cd
		if solace_enabled then
			for i=1,#p_enemies do
				local e = p_enemies[i].pointer
				if _Cast(129250,e,nil,true) then return end
			end
		end

		--cast shadow when locked in holy
		if holy_cd > gcd_remains then
			--schism
			if _valid(t) then
				if _Cast(214621,t,true) then Squid_Alert("Schism",nil,nil,nil,214621) return end
			end
			--autoschism team's target
			if their_healer_cc then
				for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then
					local e = Enemies[i]

				end end
			end
			--shadow mend
			for i=1,#p_friends do if UnitIsPlayer(p_friends[i]) then
				local f = p_friends[i]
				if _HP(f) < 88 then
					_Cast(2061,f)
				end
			end end
		end

		--cast holy when locked shadow
		if shadow_cd > gcd_remains then
			--penance enemies on cd
			for i=1,#p_enemies do
				local e = p_enemies[i].pointer
				if _Cast(47540,e,nil,true) then return end
			end

			--penance self
			if _HP("player") < 70 then
				if _Cast(47540,"player") then return end
			end

			--smite enemies
			for i=1,#p_enemies do
				local e = p_enemies[i].pointer
				if _Cast(585,e,true) then return end
			end

		end

		--schism
		if _valid(t) then
			if _Cast(214621,t,true) then Squid_Alert("Schism",nil,nil,nil,214621) return end
		end

		--masochism shadow mends
		if masochism_enabled then
			if _HP("player") < 65 or masochism_remains < 3 then
				if EnemiesAttacking("player") > 0 then
					if _Cast(2061,"player") then return end
				end
			end
		end	

		--maintain purge the wicked on all enemies
		if ptw_out < 4 then
			for i=1,#ptw_enemies do
				local e = ptw_enemies[i].pointer
				local up,remains = purge_the_wicked(e)
				if remains < gcd * (4 - ptw_out) then
					if _Cast(204197,e,nil,true) then return end
				end
			end
		end

		--priority penance friends
		for i=1,#p_friends do if not healing_immune(p_friends[i].pointer) then
			local e = p_friends[i].pointer
			if _HP(e) < 60 or unit_is_unit(e,"player") and _HP(e) < 75 then
				if _Cast(47540,e,nil,true) then return end
			end
		end end

		-- shadow mend priority
		if _spellCooldown(585) > gcd_remains or lowestFriend <= 40 then
			for i=1,#p_friends do
				local f = p_friends[i].pointer
				if _HP(f) < 80 then
					if _Cast(2061,f) then return end
				end
			end
		end

		--penance enemies on cd
		for i=1,#p_enemies do
			local e = p_enemies[i].pointer
			if _Cast(47540,e,nil,true) then return end
		end

		--shadow mend
		for i=1,#p_friends do
			local f = p_friends[i].pointer
			if _HP(f) < 82 then
				if _Cast(2061,f) then return end
			end
		end

		--smite enemies
		for i=1,#p_enemies do
			local e = p_enemies[i].pointer
			if _Cast(585,e,true) then return end
		end

		--rebuff / buff
		for i=1,#Friends do if not UnitBuffID(Friends[i],21562,"player") and _distance(Friends[i]) < 40 and not healing_immune(Friends[i]) then
			if _Cast(21562) then
				Squid_Alert("Rebuff",nil,nil,nil,21562)
			end
		end end

	end

end